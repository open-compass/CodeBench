{"Contest id": "378/2983", "text_name": "回文串重新排列查询", "text": "给你一个长度为 偶数 n ，下标从 0 开始的字符串 s 。\n同时给你一个下标从 0 开始的二维整数数组 queries ，其中 queries[i] = [ai, bi, ci, di] 。\n对于每个查询 i ，你需要执行以下操作：\n将下标在范围 0 <= ai <= bi < n / 2 内的 子字符串 s[ai:bi] 中的字符重新排列。\n将下标在范围 n / 2 <= ci <= di < n 内的 子字符串 s[ci:di] 中的字符重新排列。\n对于每个查询，你的任务是判断执行操作后能否让 s 变成一个 回文串 。\n每个查询与其他查询都是 独立的 。\n请你返回一个下标从 0 开始的数组 answer ，如果第 i 个查询执行操作后，可以将 s 变为一个回文串，那么 answer[i] = true，否则为 false 。\n子字符串 指的是一个字符串中一段连续的字符序列。\ns[x:y] 表示 s 中从下标 x 到 y 且两个端点 都包含 的子字符串。", "canonical_solution": "def canMakePalindromeQueries(s, queries):\n        from collections import Counter\n        n = len(s)\n        q = len(queries)\n        s1 = s[:n//2]\n        s2 = s[n//2:][::-1]\n        if Counter(s1) != Counter(s2):\n            return [False] * q       \n        for i, ls in enumerate(queries):\n            queries[i] = [ls[0], ls[1], n - 1 - ls[3], n - 1 - ls[2]]       \n        n //= 2\n        left = [-1] * n\n        l = -1\n        for i in range(n):\n            if s1[i] == s2[i]:\n                if l == -1:\n                    l = i\n            else:\n                if l != -1:\n                    for j in range(l, i):\n                        left[j] = i - 1\n                    l = -1\n        if l != -1:\n            for j in range(l, n):\n                left[j] = n - 1\n        cnt1 = [[0] * 26]\n        curr = [0] * 26\n        for i in range(n):\n            curr[ord(s1[i]) - 97] += 1\n            cnt1.append(curr[:])      \n        cnt2 = [[0] * 26]\n        curr = [0] * 26\n        for i in range(n):\n            curr[ord(s2[i]) - 97] += 1\n            cnt2.append(curr[:])           \n        res = []\n        for a, b, c, d in queries:\n            flag = True\n            if a > c:\n                a, b, c, d = c, d, a, b\n                flag = False\n            if b < c - 1:\n                if left[b + 1] >= c - 1 and left[0] >= a - 1 and (d == n - 1 or left[d + 1] == n - 1):\n                    curr = [0] * 26\n                    total = [0] * 26\n                    for i in range(26):\n                        curr[i] = cnt2[b + 1][i] - cnt2[a][i]\n                        total[i] = cnt1[b + 1][i] - cnt1[a][i]\n                        if total[i] < curr[i]:\n                            res.append(False)\n                            break\n                    else:\n                        res.append(True)\n                else:\n                    res.append(False)\n            elif b >= d:\n                if left[0] >= a - 1 and (b == n - 1 or left[b + 1] == n - 1):\n                    res.append(True)\n                else:\n                    res.append(False)\n            else:\n                if left[0] >= a - 1 and (d == n - 1 or left[d + 1] == n - 1):\n                    curr = [0] * 26\n                    total = [0] * 26\n                    if flag:\n                        for i in range(26):\n                            curr[i] = cnt2[c][i] - cnt2[a][i]\n                            total[i] = cnt1[b + 1][i] - cnt1[a][i]\n                            if total[i] < curr[i]:\n                                res.append(False)\n                                break\n                        else:\n                            res.append(True)\n                    else:\n                        for i in range(26):\n                            curr[i] = cnt1[c][i] - cnt1[a][i]\n                            total[i] = cnt2[b + 1][i] - cnt2[a][i]\n                            if total[i] < curr[i]:\n                                res.append(False)\n                                break\n                        else:\n                            res.append(True)\n                else:\n                    res.append(False)\n        return res", "entry_point": "canMakePalindromeQueries", "test_list": ["assert canMakePalindromeQueries(s = \"abcabc\", queries = [[1,1,3,5],[0,2,5,5]]) == [True,True]", "assert canMakePalindromeQueries(s = \"abbcdecbba\", queries = [[0,2,7,9]]) == [False]", "assert canMakePalindromeQueries(s = \"acbcab\", queries = [[1,2,4,5]]) ==  [True]"]}
{"Contest id": "378/2982", "text_name": "找出出现至少三次的最长特殊子字符串 II", "text": "给你一个仅由小写英文字母组成的字符串 s 。\n如果一个字符串仅由单一字符组成，那么它被称为 特殊 字符串。例如，字符串 \"abc\" 不是特殊字符串，而字符串 \"ddd\"、\"zz\" 和 \"f\" 是特殊字符串。\n返回在 s 中出现 至少三次 的 最长特殊子字符串 的长度，如果不存在出现至少三次的特殊子字符串，则返回 -1 。\n子字符串 是字符串中的一个连续 非空 字符序列。", "canonical_solution": "from collections import defaultdict\ndef maximumLength(s):\n        special_substrings = defaultdict(int)\n        start = 0\n        while start < len(s):\n            curr = start\n            while curr < len(s) - 1 and s[curr] == s[curr + 1]:\n                curr += 1\n            window_size = curr + 1 - start\n            for length in range(1, window_size + 1):\n                special_substrings[(s[start], length)] += window_size + 1 - length  \n            start = curr + 1\n        res = -1\n        for k in special_substrings:\n            if special_substrings[k] >= 3:\n                res = max(res, k[1])   \n        return res", "entry_point": "maximumLength", "test_list": ["assert maximumLength(\"aaaa\") == 2", "assert maximumLength(\"abcdef\") == -1", "assert maximumLength(\"abcaba\") == 1"]}
{"Contest id": "378/2981", "text_name": "找出出现至少三次的最长特殊子字符串 I", "text": "给你一个仅由小写英文字母组成的字符串 s 。\n如果一个字符串仅由单一字符组成，那么它被称为 特殊 字符串。例如，字符串 \"abc\" 不是特殊字符串，而字符串 \"ddd\"、\"zz\" 和 \"f\" 是特殊字符串。\n返回在 s 中出现 至少三次 的 最长特殊子字符串 的长度，如果不存在出现至少三次的特殊子字符串，则返回 -1 。\n子字符串 是字符串中的一个连续 非空 字符序列。", "canonical_solution": "def maximumLength(st):\n        from collections import defaultdict\n        mps = defaultdict(int)\n        count = 0        \n        for i in range(len(st)):\n            count = 1\n            mps[(st[i], count)] += 1\n            for j in range(i, len(st)):\n                if j + 1 < len(st) and st[j] == st[j + 1]:\n                    count += 1\n                    mps[(st[i], count)] += 1\n                else:\n                    break        \n        ans1 = 0\n        for key, value in mps.items():\n            if value >= 3:\n                ans1 = max(ans1, key[1])       \n        return ans1 if ans1 != 0 else -1", "entry_point": "maximumLength", "test_list": ["assert maximumLength(\"aaaa\") == 2", "assert maximumLength(\"abcdef\") == -1", "assert maximumLength(\"abcaba\") == 1"]}
{"Contest id": "378/2980", "text_name": "检查按位或是否存在尾随零", "text": "给你一个 正整数 数组 nums 。\n你需要检查是否可以从数组中选出 两个或更多 元素，满足这些元素的按位或运算（ OR）结果的二进制表示中 至少 存在一个尾随零。\n例如，数字 5 的二进制表示是 \"101\"，不存在尾随零，而数字 4 的二进制表示是 \"100\"，存在两个尾随零。\n如果可以选择两个或更多元素，其按位或运算结果存在尾随零，返回 true；否则，返回 false 。", "canonical_solution": "def hasTrailingZeros(nums):\n        n = len(nums)       \n        for i in range(n):\n            for j in range(n):\n                if i != j and (nums[i] | nums[j]) % 2 == 0:\n                    return True        \n        return False", "entry_point": "hasTrailingZeros", "test_list": ["assert hasTrailingZeros([1,2,3,4,5]) == True", "assert hasTrailingZeros([2,4,8,16]) == True", "assert hasTrailingZeros([1,3,5,7,9]) == False"]}
{"Contest id": "377/2977", "text_name": "转换字符串的最小成本 II", "text": "给你两个下标从 0 开始的字符串 source 和 target ，它们的长度均为 n 并且由 小写 英文字母组成。\n另给你两个下标从 0 开始的字符串数组 original 和 changed ，以及一个整数数组 cost ，其中 cost[i] 代表将字符串 original[i] 更改为字符串 changed[i] 的成本。\n你从字符串 source 开始。在一次操作中，如果 存在 任意 下标 j 满足 cost[j] == z  、original[j] == x 以及 changed[j] == y ，你就可以选择字符串中的 子串 x 并以 z 的成本将其更改为 y 。 你可以执行 任意数量 的操作，但是任两次操作必须满足 以下两个 条件 之一 ：\n在两次操作中选择的子串分别是 source[a..b] 和 source[c..d] ，满足 b < c  或 d < a 。换句话说，两次操作中选择的下标 不相交 。\n在两次操作中选择的子串分别是 source[a..b] 和 source[c..d] ，满足 a == c 且 b == d 。换句话说，两次操作中选择的下标 相同 。\n返回将字符串 source 转换为字符串 target 所需的 最小 成本。如果不可能完成转换，则返回 -1 。\n注意，可能存在下标 i 、j 使得 original[j] == original[i] 且 changed[j] == changed[i] 。", "canonical_solution": "def minimumCost(source, target, original, changed, cost):\n        index = {}\n        for o in original:\n            if o not in index:\n                index[o] = len(index)\n        for c in changed:\n            if c not in index:\n                index[c] = len(index)\n        n = len(index)\n        dis = [[float('inf')] * n for _ in range(n)]\n        for i in range(len(cost)):\n            dis[index[original[i]]][index[changed[i]]] = min(dis[index[original[i]]][index[changed[i]]], cost[i])\n        for k in range(n):\n            for i in range(n):\n                if dis[i][k] < float('inf'):\n                    for j in range(n):\n                        if dis[k][j] < float('inf'):\n                            dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])\n        substr_lengths = set(len(o) for o in original)\n        dp = [float('inf')] * (len(target) + 1)\n        dp[0] = 0\n        for i in range(len(target)):\n            if dp[i] == float('inf'):\n                continue\n            if target[i] == source[i]:\n                dp[i + 1] = min(dp[i + 1], dp[i])\n            for t in substr_lengths:\n                if i + t >= len(dp):\n                    continue\n                sub_source = source[i:i + t]\n                sub_target = target[i:i + t]\n                c1 = index[sub_source] if sub_source in index else -1\n                c2 = index[sub_target] if sub_target in index else -1\n                if c1 >= 0 and c2 >= 0 and dis[c1][c2] < float('inf'):\n                    dp[i + t] = min(dp[i + t], dp[i] + dis[c1][c2])\n        return dp[-1] if dp[-1] != float('inf') else -1", "entry_point": "minimumCost", "test_list": ["assert minimumCost(source = \"abcd\", target = \"acbe\", original = [\"a\",\"b\",\"c\",\"c\",\"e\",\"d\"], changed = [\"b\",\"c\",\"b\",\"e\",\"b\",\"e\"], cost = [2,5,5,1,2,20]) == 28", "assert minimumCost(source = \"abcdefgh\", target = \"acdeeghh\", original = [\"bcd\",\"fgh\",\"thh\"], changed = [\"cde\",\"thh\",\"ghh\"], cost = [1,3,5]) == 9", "assert minimumCost(source = \"abcdefgh\", target = \"addddddd\", original = [\"bcd\",\"defgh\"], changed = [\"ddd\",\"ddddd\"], cost = [100,1578]) == -1"]}
{"Contest id": "377/2976", "text_name": "转换字符串的最小成本 I", "text": "给你两个下标从 0 开始的字符串 source 和 target ，它们的长度均为 n 并且由 小写 英文字母组成。\n另给你两个下标从 0 开始的字符数组 original 和 changed ，以及一个整数数组 cost ，其中 cost[i] 代表将字符 original[i] 更改为字符 changed[i] 的成本。\n你从字符串 source 开始。在一次操作中，如果 存在 任意 下标 j 满足 cost[j] == z  、original[j] == x 以及 changed[j] == y 。你就可以选择字符串中的一个字符 x 并以 z 的成本将其更改为字符 y 。\n返回将字符串 source 转换为字符串 target 所需的 最小 成本。如果不可能完成转换，则返回 -1 。\n注意，可能存在下标 i 、j 使得 original[j] == original[i] 且 changed[j] == changed[i] 。", "canonical_solution": "def minimumCost(source, target, original, changed, cost):\n        inf = 10 ** 18\n        c = [[inf] * 26 for _ in range(26)]\n        m = len(original)\n        for i in range(26):\n            c[i][i] = 0\n        for i in range(m):\n            c[ord(original[i]) - ord('a')][ord(changed[i]) - ord('a')] = min(c[ord(original[i]) - ord('a')][ord(changed[i]) - ord('a')], cost[i])\n        for k in range(26):\n            for i in range(26):\n                for j in range(26):\n                    c[i][j] = min(c[i][j], c[i][k] + c[k][j])\n        ans = 0\n        n = len(source)\n        for i in range(n):\n            ans += c[ord(source[i]) - ord('a')][ord(target[i]) - ord('a')]\n            if ans >= inf:\n                return -1\n        return ans", "entry_point": "minimumCost", "test_list": ["assert minimumCost(source = \"abcd\", target = \"acbe\", original = [\"a\",\"b\",\"c\",\"c\",\"e\",\"d\"], changed = [\"b\",\"c\",\"b\",\"e\",\"b\",\"e\"], cost = [2,5,5,1,2,20]) == 28", "assert minimumCost(source = \"aaaa\", target = \"bbbb\", original = [\"a\",\"c\"], changed = [\"c\",\"b\"], cost = [1,2]) == 12", "assert minimumCost(source = \"abcd\", target = \"abce\", original = [\"a\"], changed = [\"e\"], cost = [10000]) == -1"]}
{"Contest id": "377/2975", "text_name": "移除栅栏得到的正方形田地的最大面积", "text": "有一个大型的 (m - 1) x (n - 1) 矩形田地，其两个对角分别是 (1, 1) 和 (m, n) ，田地内部有一些水平栅栏和垂直栅栏，分别由数组 hFences 和 vFences 给出。\n水平栅栏为坐标 (hFences[i], 1) 到 (hFences[i], n)，垂直栅栏为坐标 (1, vFences[i]) 到 (m, vFences[i]) 。\n返回通过 移除 一些栅栏（可能不移除）所能形成的最大面积的 正方形 田地的面积，或者如果无法形成正方形田地则返回 -1。\n由于答案可能很大，所以请返回结果对 109 + 7 取余 后的值。\n注意：田地外围两个水平栅栏（坐标 (1, 1) 到 (1, n) 和坐标 (m, 1) 到 (m, n) ）以及两个垂直栅栏（坐标 (1, 1) 到 (m, 1) 和坐标 (1, n) 到 (m, n) ）所包围。这些栅栏 不能 被移除。", "canonical_solution": "def maximizeSquareArea(m, n, hFences, vFences):\n        hFences.sort()\n        vFences.sort()\n        hFences = [1] + hFences + [m]\n        vFences = [1] + vFences + [n]\n        ans = -1\n        cnt = {}\n        for i in range(len(hFences)):\n            for j in range(i + 1, len(hFences)):\n                cnt[hFences[j] - hFences[i]] = 1\n        for i in range(len(vFences)):\n            for j in range(i + 1, len(vFences)):\n                if (vFences[j] - vFences[i]) in cnt:\n                    ans = max(ans, vFences[j] - vFences[i])\n        if ans == -1:\n            return ans\n        mod = 10**9 + 7\n        return (ans * ans) % mod", "entry_point": "maximizeSquareArea", "test_list": ["assert maximizeSquareArea(m = 4, n = 3, hFences = [2,3], vFences = [2]) == 4", "assert maximizeSquareArea(m = 6, n = 7, hFences = [2], vFences = [4]) == -1"]}
{"Contest id": "377/2974", "text_name": "最小数字游戏", "text": "你有一个下标从 0 开始、长度为 偶数 的整数数组 nums ，同时还有一个空数组 arr 。Alice 和 Bob 决定玩一个游戏，游戏中每一轮 Alice 和 Bob 都会各自执行一次操作。游戏规则如下：\n每一轮，Alice 先从 nums 中移除一个 最小 元素，然后 Bob 执行同样的操作。\n接着，Bob 会将移除的元素添加到数组 arr 中，然后 Alice 也执行同样的操作。\n游戏持续进行，直到 nums 变为空。\n返回结果数组 arr 。", "canonical_solution": "def numberGame(nums):\n        nums.sort()\n        for i in range (0,len(nums),2):\n            nums[i] , nums[i+1] = nums[i+1] ,nums[i]\n        return nums", "entry_point": "numberGame", "test_list": ["assert numberGame([5,4,2,3]) == [3,2,5,4]", "assert numberGame([2,5]) == [5,2]"]}
{"Contest id": "Bi120/2973", "text_name": "树中每个节点放置的金币数目", "text": "给你一棵 n 个节点的 无向 树，节点编号为 0 到 n - 1 ，树的根节点在节点 0 处。同时给你一个长度为 n - 1 的二维整数数组 edges ，其中 edges[i] = [ai, bi] 表示树中节点 ai 和 bi 之间有一条边。\n给你一个长度为 n 下标从 0 开始的整数数组 cost ，其中 cost[i] 是第 i 个节点的 开销 。\n你需要在树中每个节点都放置金币，在节点 i 处的金币数目计算方法如下：\n如果节点 i 对应的子树中的节点数目小于 3 ，那么放 1 个金币。\n否则，计算节点 i 对应的子树内 3 个不同节点的开销乘积的 最大值 ，并在节点 i 处放置对应数目的金币。如果最大乘积是 负数 ，那么放置 0 个金币。\n请你返回一个长度为 n 的数组 coin ，coin[i]是节点 i 处的金币数目。", "canonical_solution": "def placedCoins(edges, cost):\n        res, al = [0] * len(cost), [[] for _ in range(len(cost))]\n        for  a, b in edges:\n                al[a].append(b)\n                al[b].append(a)\n        def dfs(i, p):\n            c = [cost[i]]\n            for j in al[i]:\n                if j != p:\n                    c.extend(dfs(j, i))\n            c.sort()\n            res[i] = 1 if len(c) < 3 else max(0, c[0] * c[1] * c[-1], c[-3] * c[-2] * c[-1])\n            return c if len(c) < 5 else [c[0], c[1], c[-3], c[-2], c[-1]]\n        dfs(0, 0)\n        return res", "entry_point": "placedCoins", "test_list": ["assert placedCoins(edges = [[0,1],[0,2],[1,3],[1,4],[1,5],[2,6],[2,7],[2,8]], cost = [1,4,2,3,5,7,8,-4,2]) == [280,140,32,1,1,1,1,1,1]", "assert placedCoins(edges = [[0,1],[0,2]], cost = [1,2,-2]) == [0,1,1]", "assert placedCoins(edges = [[0,1],[0,2],[0,3],[0,4],[0,5]], cost = [1,2,3,4,5,6]) == [120,1,1,1,1,1]"]}
{"Contest id": "Bi120/2972", "text_name": "统计移除递增子数组的数目 II", "text": "给你一个下标从 0 开始的 正 整数数组 nums 。\n如果 nums 的一个子数组满足：移除这个子数组后剩余元素 严格递增 ，那么我们称这个子数组为 移除递增 子数组。比方说，[5, 3, 4, 6, 7] 中的 [3, 4] 是一个移除递增子数组，因为移除该子数组后，[5, 3, 4, 6, 7] 变为 [5, 6, 7] ，是严格递增的。\n请你返回 nums 中 移除递增 子数组的总数目。\n注意 ，剩余元素为空的数组也视为是递增的。\n子数组 指的是一个数组中一段连续的元素序列。", "canonical_solution": "def incremovableSubarrayCount(A):\n        n = len(A)\n        i = 0\n        while i + 1 < n and A[i] < A[i + 1]:\n            i += 1\n        if i == n - 1:\n            return n * (n + 1) // 2\n        res = i + 2\n        for j in range(n - 1, -1, -1):\n            if j < n - 1 and A[j] >= A[j + 1]:\n                break\n            while i >= 0 and A[i] >= A[j]:\n                i -= 1\n            res += i + 2\n        return res", "entry_point": "incremovableSubarrayCount", "test_list": ["assert incremovableSubarrayCount([1,2,3,4]) == 10", "assert incremovableSubarrayCount([6,5,7,8]) == 7", "assert incremovableSubarrayCount([8,7,6,6]) == 3"]}
{"Contest id": "Bi120/2971", "text_name": "找到最大周长的多边形", "text": "给你一个长度为 n 的 正 整数数组 nums 。\n多边形 指的是一个至少有 3 条边的封闭二维图形。多边形的 最长边 一定 小于 所有其他边长度之和。\n如果你有 k （k >= 3）个 正 数 a1，a2，a3, ...，ak 满足 a1 <= a2 <= a3 <= ... <= ak 且 a1 + a2 + a3 + ... + ak-1 > ak ，那么 一定 存在一个 k 条边的多边形，每条边的长度分别为 a1 ，a2 ，a3 ， ...，ak 。\n一个多边形的 周长 指的是它所有边之和。\n请你返回从 nums 中可以构造的 多边形 的 最大周长 。如果不能构造出任何多边形，请你返回 -1 。", "canonical_solution": "def largestPerimeter(A):\n        A.sort()\n        cur = sum(A)\n        while A and cur <= A[-1] * 2:\n            cur -= A.pop()\n        return sum(A) if len(A) > 2 else -1", "entry_point": "largestPerimeter", "test_list": ["assert largestPerimeter([5,5,5]) == 15", "assert largestPerimeter([1,12,1,2,5,50,3]) == 12", "assert largestPerimeter([5,5,50]) == -1"]}
{"Contest id": "Bi120/2970", "text_name": "统计移除递增子数组的数目 I", "text": "给你一个下标从 0 开始的 正 整数数组 nums 。\n如果 nums 的一个子数组满足：移除这个子数组后剩余元素 严格递增 ，那么我们称这个子数组为 移除递增 子数组。比方说，[5, 3, 4, 6, 7] 中的 [3, 4] 是一个移除递增子数组，因为移除该子数组后，[5, 3, 4, 6, 7] 变为 [5, 6, 7] ，是严格递增的。\n请你返回 nums 中 移除递增 子数组的总数目。\n注意 ，剩余元素为空的数组也视为是递增的。\n子数组 指的是一个数组中一段连续的元素序列。", "canonical_solution": "def incremovableSubarrayCount(nums):\n    def ss(arr):\n        for i in range(len(arr)-1):\n            if(arr[i]>=arr[i+1]):\n                return 0\n        return 1\n    p=0\n    for i in range(len(nums)):\n        for j in range(i+1,len(nums)+1):\n            temp=nums[:]\n            del temp[i:j]\n            if ss(temp)==1:\n                p+=1\n    return p", "entry_point": "incremovableSubarrayCount", "test_list": ["assert incremovableSubarrayCount([1,2,3,4]) == 10", "assert incremovableSubarrayCount([6,5,7,8]) == 7", "assert incremovableSubarrayCount([8,7,6,6]) == 3"]}
{"Contest id": "376/2968", "text_name": "执行操作使频率分数最大", "text": "给你一个下标从 0 开始的整数数组 nums 和一个整数 k 。\n你可以对数组执行 至多 k 次操作：\n从数组中选择一个下标 i ，将 nums[i] 增加 或者 减少 1 。\n最终数组的频率分数定义为数组中众数的 频率 。\n请你返回你可以得到的 最大 频率分数。\n众数指的是数组中出现次数最多的数。一个元素的频率指的是数组中这个元素的出现次数。", "canonical_solution": "def maxFrequencyScore(nums, k):\n    nums.sort()\n    n = len(nums)\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + nums[i]\n    start = 0\n    end = 1\n    max_score = 1\n    while end < n:\n        end += 1\n        mid = (start + end) // 2\n        target = nums[mid]       \n        cost = (target * (mid - start) - (prefix_sum[mid] - prefix_sum[start])) + (prefix_sum[end] - prefix_sum[mid] - target * (end - mid))\n        while start < end and cost > k:\n            start += 1\n            mid = (start + end) // 2\n            target = nums[mid]\n            cost = (target * (mid - start) - (prefix_sum[mid] - prefix_sum[start])) +(prefix_sum[end] - prefix_sum[mid] - target * (end - mid))\n        max_score = max(max_score, end - start)\n    return max_score", "entry_point": "maxFrequencyScore", "test_list": ["assert maxFrequencyScore(nums = [1,2,6,4], k = 3) == 3", "assert maxFrequencyScore(nums = [1,4,4,2,4], k = 0) == 3"]}
{"Contest id": "376/2967", "text_name": "使数组成为等数数组的最小代价", "text": "给你一个长度为 n 下标从 0 开始的整数数组 nums 。\n你可以对 nums 执行特殊操作 任意次 （也可以 0 次）。每一次特殊操作中，你需要 按顺序 执行以下步骤：\n从范围 [0, n - 1] 里选择一个下标 i 和一个 正 整数 x 。\n将 |nums[i] - x| 添加到总代价里。\n将 nums[i] 变为 x 。\n如果一个正整数正着读和反着读都相同，那么我们称这个数是 回文数 。比方说，121 ，2552 和 65756 都是回文数，但是 24 ，46 ，235 都不是回文数。\n如果一个数组中的所有元素都等于一个整数 y ，且 y 是一个小于 109 的 回文数 ，那么我们称这个数组是一个 等数数组 。\n请你返回一个整数，表示执行任意次特殊操作后使 nums 成为 等数数组 的 最小 总代价。", "canonical_solution": "def minimumCost(nums):\n        nums.sort()\n        midIndex = len(nums) // 2\n        def check_palindrome(x):\n            x = str(x)\n            return x == x[::-1]       \n        def add(nums, target):\n            result = 0\n            for elem in nums:\n                result += abs(elem - target)\n            return result\n        if len(nums) % 2 == 1:\n            mid = nums[midIndex]\n            if check_palindrome(mid):\n                return add(nums, mid)\n        else:\n            mid = (nums[midIndex] + nums[midIndex - 1]) // 2\n            if check_palindrome(mid):\n                return add(nums, mid)\n        p_1 = mid + 1\n        p_2 = mid - 1\n        while not (check_palindrome(p_1) and check_palindrome(p_2)):\n            if not check_palindrome(p_1):\n                p_1 += 1\n            if not check_palindrome(p_2):\n                p_2 -= 1\n        return min(add(nums, p_1), add(nums, p_2))", "entry_point": "minimumCost", "test_list": ["assert minimumCost([1,2,3,4,5]) == 6", "assert minimumCost([10,12,13,14,15]) == 11", "assert minimumCost([22,33,22,33,22]) == 22"]}
{"Contest id": "376/2966", "text_name": "划分数组并满足最大差限制", "text": "给你一个长度为 n 的整数数组 nums，以及一个正整数 k 。\n将这个数组划分为一个或多个长度为 3 的子数组，并满足以下条件：\nnums 中的 每个 元素都必须 恰好 存在于某个子数组中。\n子数组中 任意 两个元素的差必须小于或等于 k 。\n返回一个 二维数组 ，包含所有的子数组。如果不可能满足条件，就返回一个空数组。如果有多个答案，返回 任意一个 即可。", "canonical_solution": "def divideArray(nums, k):\n    nums.sort()\n    flag = True\n    ans = []\n    count = 0\n    s = []\n    for i in range(0, len(nums) - 2, 3):\n        if (\n            nums[i + 2] - nums[i + 1] <= k\n            and nums[i + 1] - nums[i] <= k\n            and nums[i + 2] - nums[i] <= k\n        ):\n            s.extend([nums[i], nums[i + 1], nums[i + 2]])\n            count += len(s)\n            ans.append(s[:])\n            s.clear()\n        else:\n            flag = False\n            break\n    if len(nums) != count:\n        flag = False\n    if not flag:\n        ans.clear()\n    return ans", "entry_point": "divideArray", "test_list": ["assert divideArray(nums = [1,3,4,8,7,9,3,5,1], k = 2) == [[1,1,3],[3,4,5],[7,8,9]]", "assert divideArray(nums = [1,3,3,2,7,3], k = 3) == []"]}
{"Contest id": "376/2965", "text_name": "找出缺失和重复的数字", "text": "给你一个下标从 0 开始的二维整数矩阵 grid，大小为 n * n ，其中的值在 [1, n2] 范围内。除了 a 出现 两次，b 缺失 之外，每个整数都 恰好出现一次 。\n任务是找出重复的数字a 和缺失的数字 b 。\n返回一个下标从 0 开始、长度为 2 的整数数组 ans ，其中 ans[0] 等于 a ，ans[1] 等于 b 。", "canonical_solution": "def findMissingAndRepeatedValues(grid):\n    arr=[element for sublist in grid for element in sublist]\n    arr.sort()\n    n=[]\n    for i in range(len(arr)-1):\n        if arr[i]==arr[i+1]:\n            n.append(arr[i])\n            arr.remove(arr[i])\n            break\n    arr.append(1000000)\n    for i in range(len(arr)):\n        if i+1!=arr[i]:\n            n.append(i+1)\n            break\n    return n", "entry_point": "findMissingAndRepeatedValues", "test_list": ["assert findMissingAndRepeatedValues([[1,3],[2,2]]) == [2,4]", "assert findMissingAndRepeatedValues([[9,1,7],[8,9,2],[3,4,6]]) == [9,5]"]}
{"Contest id": "375/2963", "text_name": "统计好分割方案的数目", "text": "给你一个下标从 0 开始、由 正整数 组成的数组 nums。\n将数组分割成一个或多个 连续 子数组，如果不存在包含了相同数字的两个子数组，则认为是一种 好分割方案 。\n返回 nums 的 好分割方案 的 数目。\n由于答案可能很大，请返回答案对 109 + 7 取余 的结果。", "canonical_solution": "def numberOfGoodPartitions(A):\n        last = {a: i for i,a in enumerate(A)}\n        res = 1\n        mod = 10 ** 9 + 7\n        j = 0\n        for i,a in enumerate(A):\n            if i > j:\n                res = res * 2 % mod\n            j = max(j, last[a])\n        return res", "entry_point": "numberOfGoodPartitions", "test_list": ["assert numberOfGoodPartitions([1,2,3,4]) == 8", "assert numberOfGoodPartitions([1,1,1,1]) == 1", "assert numberOfGoodPartitions([1,2,1,3]) == 2"]}
{"Contest id": "375/2962", "text_name": "统计最大元素出现至少 K 次的子数组", "text": "给你一个整数数组 nums 和一个 正整数 k 。\n请你统计有多少满足 「 nums 中的 最大 元素」至少出现 k 次的子数组，并返回满足这一条件的子数组的数目。\n子数组是数组中的一个连续元素序列。", "canonical_solution": "def countSubarrays(A, k):\n        ma = max(A)\n        res = cur = i = 0\n        for j in range(len(A)):\n            cur += A[j] == ma\n            while cur >= k:\n                cur -= A[i] == ma\n                i += 1\n            res += i\n        return res", "entry_point": "countSubarrays", "test_list": ["assert countSubarrays([1,3,2,3,3],2) == 6", "assert countSubarrays([1,4,2,1],3) == 0"]}
{"Contest id": "375/2961", "text_name": "双模幂运算", "text": "给你一个下标从 0 开始的二维数组 variables ，其中 variables[i] = [ai, bi, ci, mi]，以及一个整数 target 。\n如果满足以下公式，则下标 i 是 好下标：\n0 <= i < variables.length\n((aibi % 10)ci) % mi == target\n返回一个由 好下标 组成的数组，顺序不限 。", "canonical_solution": "def getGoodIndices(A, target):\n        return [i for i,(a,b,c,m) in enumerate(A) if pow(pow(a, b, 10), c, m) == target]", "entry_point": "getGoodIndices", "test_list": ["assert getGoodIndices([[2,3,3,10],[3,3,3,1],[6,1,1,4]],2) == [0,2]", "assert getGoodIndices([[39,3,1000,1000]],17) == []"]}
{"Contest id": "375/2960", "text_name": "统计已测试设备", "text": "给你一个长度为 n 、下标从 0 开始的整数数组 batteryPercentages ，表示 n 个设备的电池百分比。\n你的任务是按照顺序测试每个设备 i，执行以下测试操作：\n如果 batteryPercentages[i] 大于 0：\n增加 已测试设备的计数。\n将下标在 [i + 1, n - 1] 的所有设备的电池百分比减少 1，确保它们的电池百分比 不会低于 0 ，即 batteryPercentages[j] = max(0, batteryPercentages[j] - 1)。\n移动到下一个设备。\n否则，移动到下一个设备而不执行任何测试。\n返回一个整数，表示按顺序执行测试操作后 已测试设备 的数量。\n", "canonical_solution": "def countTestedDevices(A):\n    k = 0\n    for a in A:\n        k += a > k\n    return k", "entry_point": "countTestedDevices", "test_list": ["assert countTestedDevices([1,1,2,1,3]) == 3", "assert countTestedDevices([0,1,2]) == 2"]}
{"Contest id": "Bi119/2958", "text_name": "最多 K 个重复元素的最长子数组", "text": "给你一个整数数组 nums 和一个整数 k 。\n一个元素 x 在数组中的 频率 指的是它在数组中的出现次数。\n如果一个数组中所有元素的频率都 小于等于 k ，那么我们称这个数组是 好 数组。\n请你返回 nums 中 最长好 子数组的长度。\n子数组 指的是一个数组中一段连续非空的元素序列。", "canonical_solution": "def maxSubarrayLength(nums, k):\n    n = len(nums)\n    l, r, ans = 0, 0, 0\n    freq = {}\n    while r < n:\n        freq[nums[r]] = freq.get(nums[r], 0) + 1\n        while l <= r and freq[nums[r]] > k:\n            freq[nums[l]] -= 1\n            if freq[nums[l]] == 0:\n                del freq[nums[l]]\n            l += 1\n        ans = max(ans, r - l + 1)\n        r += 1\n    return ans", "entry_point": "maxSubarrayLength", "test_list": ["assert maxSubarrayLength(nums = [1,2,3,1,2,3,1,2], k = 2) == 6", "assert maxSubarrayLength(nums = [1,2,1,2,1,2,1,2], k = 1) == 2", "assert maxSubarrayLength(nums = [5,5,5,5,5,5,5], k = 4) == 4"]}
{"Contest id": "Bi119/2957", "text_name": "消除相邻近似相等字符", "text": "给你一个下标从 0 开始的字符串 word 。\n一次操作中，你可以选择 word 中任意一个下标 i ，将 word[i] 修改成任意一个小写英文字母。\n请你返回消除 word 中所有相邻 近似相等 字符的 最少 操作次数。\n两个字符 a 和 b 如果满足 a == b 或者 a 和 b 在字母表中是相邻的，那么我们称它们是 近似相等 字符。", "canonical_solution": "def removeAlmostEqualCharacters(s):\n    i, k = 1, 0\n    while i + k < len(s):\n        k += abs(ord(s[i + k]) - ord(s[i + k - 1])) < 2\n        i += 1\n    return k", "entry_point": "removeAlmostEqualCharacters", "test_list": ["assert removeAlmostEqualCharacters(\"aaaaa\") == 2", "assert removeAlmostEqualCharacters(\"abddez\") == 2", "assert removeAlmostEqualCharacters(\"zyxyxyz\") == 3"]}
{"Contest id": "Bi119/2956", "text_name": "找到两个数组中的公共元素", "text": "给你两个下标从 0 开始的整数数组 nums1 和 nums2 ，它们分别含有 n 和 m 个元素。\n请你计算以下两个数值：\n统计 0 <= i < n 中的下标 i ，满足 nums1[i] 在 nums2 中 至少 出现了一次。\n统计 0 <= i < m 中的下标 i ，满足 nums2[i] 在 nums1 中 至少 出现了一次。\n请你返回一个长度为 2 的整数数组 answer ，按顺序 分别为以上两个数值。", "canonical_solution": "def findIntersectionValues(nums1, nums2):\n    set1 = set(nums1)\n    set2 = set(nums2)\n\n    count1 = sum(1 for num in nums1 if num in set2)\n    count2 = sum(1 for num in nums2 if num in set1)\n\n    return [count1, count2]", "entry_point": "findIntersectionValues", "test_list": ["assert findIntersectionValues(nums1 = [4,3,2,3,1], nums2 = [2,2,5,2,3,6]) == [3,4]", "assert findIntersectionValues(nums1 = [3,4,2,3], nums2 = [1,5]) == [0,0]"]}
{"Contest id": "374/2954", "text_name": "统计感冒序列的数目", "text": "给你一个整数 n 和一个下标从 0 开始的整数数组 sick ，数组按 升序 排序。\n有 n 位小朋友站成一排，按顺序编号为 0 到 n - 1 。数组 sick 包含一开始得了感冒的小朋友的位置。如果位置为 i 的小朋友得了感冒，他会传染给下标为 i - 1 或者 i + 1 的小朋友，前提 是被传染的小朋友存在且还没有得感冒。每一秒中， 至多一位 还没感冒的小朋友会被传染。\n经过有限的秒数后，队列中所有小朋友都会感冒。感冒序列 指的是 所有 一开始没有感冒的小朋友最后得感冒的顺序序列。请你返回所有感冒序列的数目。\n由于答案可能很大，请你将答案对 109 + 7 取余后返回。\n注意，感冒序列 不 包含一开始就得了感冒的小朋友的下标。", "canonical_solution": "def numberOfSequence(n, sick):\n    M = 10 ** 9 + 7\n    f = [1] * (n + 1)\n    for i in range(1, n + 1):\n        f[i] = i * f[i - 1]\n        f[i] %= M\n    count = lambda m, n: (f[m + n] * pow(f[m], M - 2, M) * pow(f[n], M - 2, M)) % M\n    gaps = []\n    if sick[0] > 0:\n        gaps.append((sick[0], True))\n    for i in range(len(sick) - 1):\n        if sick[i + 1] - sick[i] > 1:\n            gaps.append((sick[i + 1] - sick[i] - 1, False))\n    if sick[-1] < n - 1:\n        gaps.append((n - sick[-1] - 1, True))\n    res = 1\n    l = 0\n    for g, once in gaps:\n        res *= (pow(2, g - 1, M) if not once else 1) * count(l, g)\n        res %= M\n        l += g\n    return res", "entry_point": "numberOfSequence", "test_list": ["assert numberOfSequence(n = 5, sick = [0,4]) == 4", "assert numberOfSequence(n = 4, sick = [1]) == 3"]}
{"Contest id": "374/2953", "text_name": "统计完全子字符串", "text": "给你一个字符串 word 和一个整数 k 。\n如果 word 的一个子字符串 s 满足以下条件，我们称它是 完全字符串：\ns 中每个字符 恰好 出现 k 次。\n相邻字符在字母表中的顺序 至多 相差 2 。也就是说，s 中两个相邻字符 c1 和 c2 ，它们在字母表中的位置相差 至多 为 2 。\n请你返回 word 中 完全 子字符串的数目。\n子字符串 指的是一个字符串中一段连续 非空 的字符序列。", "canonical_solution": "def countCompleteSubstrings(word, k):\n    def calc(left, right):\n        sub = 0\n        for m in range(1, 27):\n            if m * k > right - left: break\n            cnt = [0] * 26\n            meet = 0\n            for r in range(left, right):\n                x = ord(word[r]) - ord('a')\n                cnt[x] += 1\n                if cnt[x] == k: meet += 1\n                L = r - m * k + 1\n                if L >= left:\n                    if meet == m: sub += 1\n                    if cnt[ord(word[L]) - ord('a')] == k: meet -= 1\n                    cnt[ord(word[L]) - ord('a')] -= 1\n        return sub\n    n = len(word)\n    i = 0\n    ans = 0\n    while i < n:\n        start = i\n        i += 1\n        while i < n and abs(ord(word[i]) - ord(word[i-1])) <= 2: i+=1\n        ans += calc(start, i)\n    return ans", "entry_point": "countCompleteSubstrings", "test_list": ["assert countCompleteSubstrings(word = \"igigee\", k = 2) == 3", "assert countCompleteSubstrings(word = \"aaabbbccc\", k = 3) == 6"]}
{"Contest id": "374/2952", "text_name": "需要添加的硬币的最小数量", "text": "给你一个下标从 0 开始的整数数组 coins，表示可用的硬币的面值，以及一个整数 target 。\n如果存在某个 coins 的子序列总和为 x，那么整数 x 就是一个 可取得的金额 。\n返回需要添加到数组中的 任意面值 硬币的 最小数量 ，使范围 [1, target] 内的每个整数都属于 可取得的金额 。\n数组的 子序列 是通过删除原始数组的一些（可能不删除）元素而形成的新的 非空 数组，删除过程不会改变剩余元素的相对位置。\n", "canonical_solution": "def minimumAddedCoins(coins, target):\n    ans = 0\n    coins = sorted(coins)\n    tmpp= 1  \n    for i in coins:\n        while i > tmpp:\n            ans += 1\n            tmpp *= 2    \n        tmpp += i\n        if tmpp > target:\n            break  \n    while tmpp <= target:\n        ans += 1\n        tmpp *= 2\n    return ans", "entry_point": "minimumAddedCoins", "test_list": ["assert minimumAddedCoins(coins = [1,4,10], target = 19) == 2", "assert minimumAddedCoins(coins = [1,4,10,5,7,19], target = 19) == 1", "assert minimumAddedCoins(coins = [1,1,1], target = 20) == 3"]}
{"Contest id": "374/2951", "text_name": "找出峰值", "text": "给你一个下标从 0 开始的数组 mountain 。你的任务是找出数组 mountain 中的所有 峰值。\n以数组形式返回给定数组中 峰值 的下标，顺序不限 。\n注意：\n峰值 是指一个严格大于其相邻元素的元素。\n数组的第一个和最后一个元素 不 是峰值。", "canonical_solution": "def findPeaks(mountain):\n    peaks = []\n    n = len(mountain)\n    for i in range(1, n - 1):\n        if mountain[i] > mountain[i - 1] and mountain[i] > mountain[i + 1]:\n            peaks.append(i)\n    return peaks", "entry_point": "findPeaks", "test_list": ["assert findPeaks([2,4,4]) == []", "assert findPeaks([1,4,3,8,5]) == [1,3]"]}
{"Contest id": "373/2949", "text_name": "统计美丽子字符串 II", "text": "给你一个字符串 s 和一个正整数 k 。\n用 vowels 和 consonants 分别表示字符串中元音字母和辅音字母的数量。\n如果某个字符串满足以下条件，则称其为 美丽字符串 ：\nvowels == consonants，即元音字母和辅音字母的数量相等。\n(vowels * consonants) % k == 0，即元音字母和辅音字母的数量的乘积能被 k 整除。\n返回字符串 s 中 非空美丽子字符串 的数量。\n子字符串是字符串中的一个连续字符序列。\n英语中的 元音字母 为 'a'、'e'、'i'、'o' 和 'u' 。\n英语中的 辅音字母 为除了元音字母之外的所有字母。", "canonical_solution": "from collections import Counter\nfrom itertools import count\ndef beautifulSubstrings(s, k):\n    n = len(s)\n    l = next(i for i in count(1) if i * i % k == 0) * 2\n    vowels = set(list('aeiou'))\n    seen = [Counter() for i in range(l)]\n    seen[-1][0] = 1\n    res = 0\n    v = 0\n    for i,c in enumerate(s):\n        v += 1 if s[i] in vowels else -1\n        res += seen[i % l][v]\n        seen[i % l][v] += 1\n    return res", "entry_point": "beautifulSubstrings", "test_list": ["assert beautifulSubstrings(s = \"baeyh\", k = 2) == 2", "assert beautifulSubstrings(s = \"abba\", k = 1) == 3", "assert beautifulSubstrings(s = \"bcdf\", k = 1) == 0"]}
{"Contest id": "373/2948", "text_name": "交换得到字典序最小的数组", "text": "给你一个下标从 0 开始的 正整数 数组 nums 和一个 正整数 limit 。\n在一次操作中，你可以选择任意两个下标 i 和 j，如果 满足 |nums[i] - nums[j]| <= limit ，则交换 nums[i] 和 nums[j] 。\n返回执行任意次操作后能得到的 字典序最小的数组 。\n如果在数组 a 和数组 b 第一个不同的位置上，数组 a 中的对应元素比数组 b 中的对应元素的字典序更小，则认为数组 a 就比数组 b 字典序更小。例如，数组 [2,10,3] 比数组 [10,2,3] 字典序更小，下标 0 处是两个数组第一个不同的位置，且 2 < 10 。", "canonical_solution": "def lexicographicallySmallestArray(nums, limit):\n    size = len(nums)\n    pair = [[nums[i], i] for i in range(0, size)]\n    pair = sorted(pair, key=lambda x : x[0])\n    result = [0] * size\n    start = 0\n    for end in range(0, size):\n        if (end + 1 >= size or pair[end + 1][0] - pair[end][0] > limit):\n            temp = [pair[i][1] for i in range(start, end + 1)]\n            temp = sorted(temp)\n            j = start\n            for idx in temp:\n                result[idx] = pair[j][0]\n                j += 1\n            start = end + 1\n    return result", "entry_point": "lexicographicallySmallestArray", "test_list": ["assert lexicographicallySmallestArray(nums = [1,5,3,9,8], limit = 2) == [1,3,5,8,9]", "assert lexicographicallySmallestArray(nums = [1,7,6,18,2,1], limit = 3) == [1,6,7,18,1,2]", "assert lexicographicallySmallestArray(nums = [1,7,28,19,10], limit = 3) == [1,7,28,19,10]"]}
{"Contest id": "373/2947", "text_name": "统计美丽子字符串 I", "text": "给你一个字符串 s 和一个正整数 k 。\n用 vowels 和 consonants 分别表示字符串中元音字母和辅音字母的数量。\n如果某个字符串满足以下条件，则称其为 美丽字符串 ：\nvowels == consonants，即元音字母和辅音字母的数量相等。\n(vowels * consonants) % k == 0，即元音字母和辅音字母的数量的乘积能被 k 整除。\n返回字符串 s 中 非空美丽子字符串 的数量。\n子字符串是字符串中的一个连续字符序列。\n英语中的 元音字母 为 'a'、'e'、'i'、'o' 和 'u' 。\n英语中的 辅音字母 为除了元音字母之外的所有字母。", "canonical_solution": "def beautifulSubstrings(s, k):\n    n = len(s)\n    res = 0\n    cc = ['a','e','i','o','u']\n    for j in range(n):\n        c,v=0,0\n        for i in range(j,n):\n            if s[i] in cc:\n                v += 1\n            else:\n                c += 1\n            if c==v and (c*v)%k==0:\n                res += 1\n    return res", "entry_point": "beautifulSubstrings", "test_list": ["assert beautifulSubstrings(s = \"baeyh\", k = 2) == 2", "assert beautifulSubstrings(s = \"abba\", k = 1) == 3", "assert beautifulSubstrings(s = \"bcdf\", k = 1) == 0"]}
{"Contest id": "373/2946", "text_name": "循环移位后的矩阵相似检查", "text": "给你一个下标从 0 开始且大小为 m x n 的整数矩阵 mat 和一个整数 k 。请你将矩阵中的奇数行循环右移 k 次，偶数行循环左移 k 次。\n如果初始矩阵和最终矩阵完全相同，则返回 true ，否则返回 false 。", "canonical_solution": "def areSimilar(mat, k):\n    for l in mat:\n        n = len(l)\n    for i in range(n):\n        if l[i] != l[(i + k) % n]:\n            return False\n    return True", "entry_point": "areSimilar", "test_list": ["assert areSimilar(mat = [[1,2,1,2],[5,5,5,5],[6,3,6,3]], k = 2) == True", "assert areSimilar(mat = [[2,2],[2,2]], k = 3) == True", "assert areSimilar(mat = [[1,2]], k = 1) == False"]}
{"Contest id": "Bi118/2945", "text_name": "找到最大非递减数组的长度", "text": "给你一个下标从 0 开始的整数数组 nums 。\n你可以执行任意次操作。每次操作中，你需要选择一个 子数组 ，并将这个子数组用它所包含元素的和替换。比方说，给定数组是 [1,3,5,6] ，你可以选择子数组 [3,5] ，用子数组的和 8 替换掉子数组，然后数组会变为 [1,8,6] 。\n请你返回执行任意次操作以后，可以得到的最长非递减数组的长度。\n子数组指的是一个数组中一段连续非空的元素序列。", "canonical_solution": "from math import inf\ndef findMaximumLength(A):\n    n = len(A)\n    last = [0] + [inf] * n\n    acc = [0]\n    dp = [0] + [0] * n\n    for j in range(n):\n        a = A[j]\n        acc.append(a + acc[-1])\n        i = j\n        while last[i] > acc[-1] - acc[i]:\n            i -= 1\n        last[j + 1] = acc[-1] - acc[i]\n        dp[j + 1] = dp[i] + 1\n    return dp[-1]", "entry_point": "findMaximumLength", "test_list": ["assert findMaximumLength([5,2,2]) == 1", "assert findMaximumLength([1,2,3,4]) == 4", "assert findMaximumLength([4,3,2,6]) == 3"]}
{"Contest id": "Bi118/2944", "text_name": "购买水果需要的最少金币数", "text": "你在一个水果超市里，货架上摆满了玲琅满目的奇珍异果。\n给你一个下标从 1 开始的数组 prices ，其中 prices[i] 表示你购买第 i 个水果需要花费的金币数目。\n水果超市有如下促销活动：\n如果你花费 price[i] 购买了水果 i ，那么接下来的 i 个水果你都可以免费获得。\n注意 ，即使你 可以 免费获得水果 j ，你仍然可以花费 prices[j] 个金币去购买它以便能免费获得接下来的 j 个水果。\n请你返回获得所有水果所需要的最少金币数。", "canonical_solution": "def minimumCoins(prices):\n    def dp(i, f):\n        if i >= len(prices):\n            return 0\n        m = dp(i + 1, i + 1) + prices[i]  # buy\n        for j in range(f):\n            m = min(m, dp(i + j + 1, 0))  # get free\n        return m\n    return dp(0, 0)", "entry_point": " minimumCoins", "test_list": ["assert  minimumCoins([3,1,2]) == 4", "assert  minimumCoins([1,10,1,1]) == 2"]}
{"Contest id": "Bi118/2943", "text_name": "最大化网格图中正方形空洞的面积", "text": "给你一个网格图，由 n + 2 条 横线段 和 m + 2 条 竖线段 组成，一开始所有区域均为 1 x 1 的单元格。\n所有线段的编号从 1 开始。\n给你两个整数 n 和 m 。\n同时给你两个整数数组 hBars 和 vBars 。\nhBars 包含区间 [2, n + 1] 内 互不相同 的横线段编号。\nvBars 包含 [2, m + 1] 内 互不相同的 竖线段编号。\n如果满足以下条件之一，你可以 移除 两个数组中的部分线段：\n如果移除的是横线段，它必须是 hBars 中的值。\n如果移除的是竖线段，它必须是 vBars 中的值。\n请你返回移除一些线段后（可能不移除任何线段），剩余网格图中 最大正方形 空洞的面积，正方形空洞的意思是正方形 内部 不含有任何线段。", "canonical_solution": "def maximizeSquareHoleArea(n, m, hBars, vBars):\n    hBars.sort()\n    vBars.sort()\n    mh, mv, c = 1, 1, 1       \n    for i in range(1, len(hBars)):\n        if hBars[i] == hBars[i - 1] + 1:\n            c += 1\n        else:\n            c = 1\n        mh = max(mh, c)       \n    c = 1\n    for i in range(1, len(vBars)):\n        if vBars[i] == vBars[i - 1] + 1:\n            c += 1\n        else:\n            c = 1\n        mv = max(mv, c)       \n    x = min(mh + 1, mv + 1)\n    return x * x", "entry_point": "maximizeSquareHoleArea", "test_list": ["assert maximizeSquareHoleArea(n = 2, m = 1, hBars = [2,3], vBars = [2]) == 4", "assert maximizeSquareHoleArea(n = 1, m = 1, hBars = [2], vBars = [2]) == 4", "assert maximizeSquareHoleArea(n = 2, m = 3, hBars = [2,3], vBars = [2,3,4]) == 9"]}
{"Contest id": "Bi118/2942", "text_name": "查找包含给定字符的单词", "text": "给你一个下标从 0 开始的字符串数组 words 和一个字符 x 。\n请你返回一个下标数组 ，表示下标在数组中对应的单词包含字符 x 。\n注意 ，返回的数组可以是任意顺序。", "canonical_solution": "def findWordsContaining(words, x):\n    ans = []\n    for i, word in enumerate(words):\n        if x in word:\n            ans.append(i)\n    return ans", "entry_point": "findWordsContaining", "test_list": ["assert findWordsContaining(words = [\"leet\",\"code\"], x = \"e\") == [0,1]", "assert findWordsContaining([\"abc\",\"bcd\",\"aaaa\",\"cbc\"], x = \"a\") == [0,2]", "assert findWordsContaining(words = [\"abc\",\"bcd\",\"aaaa\",\"cbc\"], x = \"z\") == []"]}
{"Contest id": "372/2940", "text_name": "找到 Alice 和 Bob 可以相遇的建筑", "text": "给你一个下标从 0 开始的正整数数组 heights ，其中 heights[i] 表示第 i 栋建筑的高度。\n如果一个人在建筑 i ，且存在 i < j 的建筑 j 满足 heights[i] < heights[j] ，那么这个人可以移动到建筑 j 。\n给你另外一个数组 queries ，其中 queries[i] = [ai, bi] 。第 i 个查询中，Alice 在建筑 ai ，Bob 在建筑 bi 。\n请你能返回一个数组 ans ，其中 ans[i] 是第 i 个查询中，Alice 和 Bob 可以相遇的 最左边的建筑 。如果对于查询 i ，Alice 和 Bob 不能相遇，令 ans[i] 为 -1 。", "canonical_solution": "from bisect import bisect_right\nfrom collections import deque\nfrom operator import itemgetter\ndef leftmostBuildingQueries(heights, queries):\n    res, idx = [0] * len(queries), []\n    for i, q in enumerate(queries):\n        a, b = sorted(q)\n        if a == b or heights[a] < heights[b]:\n            res[i] = b\n        else:\n            idx.append((a, b, i))\n    j, mono = len(heights) - 1, deque()\n    for a, b, i in sorted(idx, key=itemgetter(1), reverse=True):\n        while j > b:\n            while mono and heights[mono[0]] < heights[j]:\n                mono.popleft()\n            mono.appendleft(j)\n            j -= 1\n        k = bisect_right(mono, heights[a], key=lambda x: heights[x])\n        res[i] = -1 if k == len(mono) else mono[k]\n    return res", "entry_point": "leftmostBuildingQueries", "test_list": ["assert leftmostBuildingQueries([6,4,8,5,2,7], [[0,1],[0,3],[2,4],[3,4],[2,2]]) == [2,5,-1,5,2]", "assert leftmostBuildingQueries([5,3,8,2,6,1,4,6],[[0,7],[3,5],[5,2],[3,0],[1,6]]) == [7,6,-1,4,6]"]}
{"Contest id": "372/2939", "text_name": "最大异或乘积", "text": "给你三个整数 a ，b 和 n ，请你返回 (a XOR x) * (b XOR x) 的 最大值 且 x 需要满足 0 <= x < 2n。\n由于答案可能会很大，返回它对 109 + 7 取余 后的结果。\n注意，XOR 是按位异或操作。", "canonical_solution": "def maximumXorProduct(a, b, n):\n        mask = (1 << n) - 1\n        d = (a ^ b) & mask\n        mod = 10 ** 9 + 7\n        a = (a | mask) & ~d\n        b = (b | mask) & ~d\n        if d == 0:\n            return a * b % mod\n        h = 1 << (d.bit_length() - 1)\n        return max((a ^ d) * b, a * (b ^ d), (a ^ d ^ h) * (b ^ h), (a  ^ h) * (b ^ d ^ h)) % mod", "entry_point": "maximumXorProduct", "test_list": ["assert maximumXorProduct(a = 12, b = 5, n = 4) == 98", "assert maximumXorProduct(a = 6, b = 7 , n = 5) == 930", "assert maximumXorProduct(a = 1, b = 6, n = 3) == 12"]}
{"Contest id": "372/2938", "text_name": "区分黑球与白球", "text": "桌子上有 n 个球，每个球的颜色不是黑色，就是白色。\n给你一个长度为 n 、下标从 0 开始的二进制字符串 s，其中 1 和 0 分别代表黑色和白色的球。\n在每一步中，你可以选择两个相邻的球并交换它们。\n返回「将所有黑色球都移到右侧，所有白色球都移到左侧所需的 最小步数。", "canonical_solution": "def minimumSteps(s):\n    cnt = 0\n    ans = 0\n    for i in range(len(s) - 1, -1, -1):\n        if s[i] == '1':\n            ans += cnt\n        else:\n            cnt += 1\n    return ans", "entry_point": "minimumSteps", "test_list": ["assert minimumSteps(\"101\") == 1", "assert minimumSteps(\"100\") == 2", "assert minimumSteps(\"0111\") == 0"]}
{"Contest id": "372/2937", "text_name": "使三个字符串相等", "text": "给你三个字符串 s1、s2 和 s3。 你可以根据需要对这三个字符串执行以下操作 任意次数 。\n在每次操作中，你可以选择其中一个长度至少为 2 的字符串 并删除其 最右位置上 的字符。\n如果存在某种方法能够使这三个字符串相等，请返回使它们相等所需的 最小 操作次数；否则，返回 -1。", "canonical_solution": "def findMinimumOperations(s1, s2, s3):\n    size, l1, l2, l3 = 0, len(s1), len(s2), len(s3)\n    for a, b, c in zip(s1, s2, s3):\n        if a == b == c:\n            size += 1\n        else: break       \n    return (l1 + l2 + l3) - 3 * size if size > 0 else -1", "entry_point": "findMinimumOperations", "test_list": ["assert findMinimumOperations(s1 = \"abc\", s2 = \"abb\", s3 = \"ab\") == 2", "assert findMinimumOperations(s1 = \"dac\", s2 = \"bac\", s3 = \"cac\") == -1"]}
{"Contest id": "371/2935", "text_name": "找出强数对的最大异或值 II", "text": "给你一个下标从 0 开始的整数数组 nums 。如果一对整数 x 和 y 满足以下条件，则称其为 强数对 ：\n|x - y| <= min(x, y)\n你需要从 nums 中选出两个整数，且满足：这两个整数可以形成一个强数对，并且它们的按位异或（XOR）值是在该数组所有强数对中的 最大值 。\n返回数组 nums 所有可能的强数对中的 最大 异或值。\n注意，你可以选择同一个整数两次来形成一个强数对。", "canonical_solution": "def maximumStrongPairXor(A):\n    res = 0\n    for i in range(20, -1, -1):\n        res <<= 1\n        pref, pref2 = {}, {}\n        for a in A:\n            p = a >> i\n            if p not in pref:\n                pref[p] = pref2[p] = a\n            pref[p] = min(pref[p], a)\n            pref2[p] = max(pref2[p], a)\n        for x in pref:\n            y = res ^ 1 ^ x\n            if x >= y and y in pref and pref[x] <= pref2[y] * 2:\n                res |= 1\n                break\n    return res", "entry_point": "maximumStrongPairXor", "test_list": ["assert maximumStrongPairXor([1,2,3,4,5]) == 7", "assert maximumStrongPairXor([10,100]) == 0", "assert maximumStrongPairXor([500,520,2500,3000]) == 1020"]}
{"Contest id": "371/2934", "text_name": "最大化数组末位元素的最少操作次数", "text": "给你两个下标从 0 开始的整数数组 nums1 和 nums2 ，这两个数组的长度都是 n 。\n你可以执行一系列 操作（可能不执行）。\n在每次操作中，你可以选择一个在范围 [0, n - 1] 内的下标 i ，并交换 nums1[i] 和 nums2[i] 的值。\n你的任务是找到满足以下条件所需的 最小 操作次数：\nnums1[n - 1] 等于 nums1 中所有元素的 最大值 ，即 nums1[n - 1] = max(nums1[0], nums1[1], ..., nums1[n - 1]) 。\nnums2[n - 1] 等于 nums2 中所有元素的 最大值 ，即 nums2[n - 1] = max(nums2[0], nums2[1], ..., nums2[n - 1]) 。\n以整数形式，表示并返回满足上述 全部 条件所需的 最小 操作次数，如果无法同时满足两个条件，则返回 -1 。", "canonical_solution": "def minOperations(nums1, nums2):\n    swaps = 0\n    n = len(nums1)\n    nums1Last, nums2Last = nums1[-1], nums2[-1]\n    for i in range(n-2,-1,-1):\n        if nums1[i] > nums1Last or nums2[i] > nums2Last:\n            if not nums2[i] > nums1Last and not nums1[i] > nums2Last:\n                swaps += 1\n            else:\n                swaps = -1\n                break\n    swapsSECOND = 1\n    nums1Last, nums2Last = nums2[-1], nums1[-1]\n    for i in range(n-2,-1,-1):\n        if nums1[i] > nums1Last or nums2[i] > nums2Last:\n            if not nums2[i] > nums1Last and not nums1[i] > nums2Last:\n                swapsSECOND += 1\n            else:\n                swapsSECOND = -1\n                break\n    return min(swaps, swapsSECOND)", "entry_point": "minOperations", "test_list": ["assert minOperations(nums1 = [1,2,7], nums2 = [4,5,3]) == 1", "assert minOperations(nums1 = [2,3,4,5,9], nums2 = [8,8,4,4,4]) == 2", "assert minOperations(nums1 = [1,5,4], nums2 = [2,5,3]) == -1"]}
{"Contest id": "371/2933", "text_name": "高访问员工", "text": "给你一个长度为 n 、下标从 0 开始的二维字符串数组 access_times 。对于每个 i（0 <= i <= n - 1 ），access_times[i][0] 表示某位员工的姓名，access_times[i][1] 表示该员工的访问时间。access_times 中的所有条目都发生在同一天内。\n访问时间用 四位 数字表示， 符合 24 小时制 ，例如 \"0800\" 或 \"2250\" 。\n如果员工在 同一小时内 访问系统 三次或更多 ，则称其为 高访问 员工。\n时间间隔正好相差一小时的时间 不 被视为同一小时内。例如，\"0815\" 和 \"0915\" 不属于同一小时内。\n一天开始和结束时的访问时间不被计算为同一小时内。例如，\"0005\" 和 \"2350\" 不属于同一小时内。\n以列表形式，按任意顺序，返回所有 高访问 员工的姓名。\n", "canonical_solution": "from collections import defaultdict\ndef findHighAccessEmployees(access_times):\n        when = defaultdict(list)\n\n        for v in access_times:\n            a, b = v\n            when[a].append(int(b))\n\n        ret = []\n\n        for x, lst in when.items():\n            lst.sort()\n\n            k = len(lst)\n\n            flag = False\n\n            for i in range(k - 2):\n                flag |= lst[i + 2] < lst[i] + 100\n\n            if flag:\n                ret.append(x)\n\n        return ret", "entry_point": "findHighAccessEmployees", "test_list": ["assert findHighAccessEmployees([[\"a\",\"0549\"],[\"b\",\"0457\"],[\"a\",\"0532\"],[\"a\",\"0621\"],[\"b\",\"0540\"]]) == [\"a\"]", "assert findHighAccessEmployees([[\"d\",\"0002\"],[\"c\",\"0808\"],[\"c\",\"0829\"],[\"e\",\"0215\"],[\"d\",\"1508\"],[\"d\",\"1444\"],[\"d\",\"1410\"],[\"c\",\"0809\"]]) == [\"c\",\"d\"]", "assert findHighAccessEmployees([[\"cd\",\"1025\"],[\"ab\",\"1025\"],[\"cd\",\"1046\"],[\"cd\",\"1055\"],[\"ab\",\"1124\"],[\"ab\",\"1120\"]]) == [\"ab\",\"cd\"]"]}
{"Contest id": "371/2932", "text_name": "找出强数对的最大异或值 I", "text": "给你一个下标从 0 开始的整数数组 nums 。如果一对整数 x 和 y 满足以下条件，则称其为强数对 ：\n|x - y| <= min(x, y)\n你需要从 nums 中选出两个整数，且满足：这两个整数可以形成一个强数对，并且它们的按位异或（XOR）值是在该数组所有强数对中的最大值 。\n返回数组 nums 所有可能的强数对中的 最大异或值。\n注意，你可以选择同一个整数两次来形成一个强数对。", "canonical_solution": "def maximumStrongPairXor(nums):\n    top = 0\n    for i in range(len(nums)):\n        for j in range(i, len(nums)):\n            if abs(nums[i] - nums[j]) <= min(nums[i], nums[j]):\n                top = max(top, nums[i] ^ nums[j])\n    return top", "entry_point": "maximumStrongPairXor", "test_list": ["assert maximumStrongPairXor([1,2,3,4,5]) == 7", "assert maximumStrongPairXor([10,100]) == 0", "assert maximumStrongPairXor([5,6,25,30]) == 7"]}
{"Contest id": "Bi117/2931", "text_name": "购买物品的最大开销", "text": "给你一个下标从 0 开始大小为 m * n 的整数矩阵 values ，表示 m 个不同商店里 m * n 件不同的物品。每个商店有 n 件物品，第 i 个商店的第 j 件物品的价值为 values[i][j] 。除此以外，第 i 个商店的物品已经按照价值非递增排好序了，也就是说对于所有 0 <= j < n - 1 都有 values[i][j] >= values[i][j + 1] 。\n每一天，你可以在一个商店里购买一件物品。具体来说，在第 d 天，你可以：\n选择商店 i 。\n购买数组中最右边的物品 j ，开销为 values[i][j] * d 。换句话说，选择该商店中还没购买过的物品中最大的下标 j ，并且花费 values[i][j] * d 去购买。\n注意，所有物品都视为不同的物品。比方说如果你已经从商店 1 购买了物品 0 ，你还可以在别的商店里购买其他商店的物品 0 。\n请你返回购买所有 m * n 件物品需要的 最大开销 。", "canonical_solution": "def maxSpending(values):\n    a = sorted([n for row in values for n in row])\n    t = 0\n    for d, v in enumerate(a, start=1):\n        t += d*v\n    return t", "entry_point": "maxSpending", "test_list": ["assert maxSpending([[8,5,2],[6,4,1],[9,7,3]]) == 285", "assert maxSpending([[10,8,6,4,2],[9,7,5,3,2]]) == 386"]}
{"Contest id": "Bi117/2930", "text_name": "重新排列后包含指定子字符串的字符串数目", "text": "给你一个整数 n 。\n如果一个字符串 s 只包含小写英文字母，且 将 s 的字符重新排列后，新字符串包含 子字符串 \"leet\" ，那么我们称字符串 s 是一个 好 字符串。\n比方说：\n字符串 \"lteer\" 是好字符串，因为重新排列后可以得到 \"leetr\" 。\n\"letl\" 不是好字符串，因为无法重新排列并得到子字符串 \"leet\" 。\n请你返回长度为 n 的好字符串 总 数目。\n由于答案可能很大，将答案对 109 + 7 取余 后返回。\n子字符串 是一个字符串中一段连续的字符序列。\n", "canonical_solution": "def stringCount(n):\n        l_0 = 25 ** n\n        e_0 = 25 ** n\n        t_0 = 25 ** n\n        e_1 = n * 25 ** (n-1)\n        e_2 = e_0 + e_1\n        l_0_t_0 = 24 ** n\n        l_0_e_2 = 24 ** n + n * 24 ** (n-1)\n        t_0_e_2 = 24 ** n + n * 24 ** (n-1)\n        l_0_t_0_e_2 = 23 ** n + n * 23 ** (n-1)\n        return (26 ** n - (l_0 + e_2 + t_0 - l_0_t_0 - l_0_e_2 - t_0_e_2 + l_0_t_0_e_2)) % (10 ** 9 + 7)", "entry_point": "stringCount", "test_list": ["assert stringCount(4) == 12", "assert stringCount(10) == 83943898"]}
{"Contest id": "Bi117/2929", "text_name": "给小朋友们分糖果 II", "text": "给你两个正整数 n 和 limit 。\n请你将 n 颗糖果分给 3 位小朋友，确保没有任何小朋友得到超过 limit 颗糖果，请你返回满足此条件下的 总方案数 。", "canonical_solution": "def distributeCandies(n, limit):\n    res = 0\n    for f in range(min(n, limit) + 1):\n        rem = n - f\n        a = max(rem - limit, 0)\n        b = min(rem, limit)\n        if a <= b:\n            res += b - a + 1\n    return res", "entry_point": "distributeCandies", "test_list": ["assert distributeCandies(n = 5, limit = 2) == 3", "assert distributeCandies(n = 3, limit = 3) == 10"]}
{"Contest id": "Bi117/2928", "text_name": "给小朋友们分糖果 I", "text": "给你两个正整数 n 和 limit 。\n请你将 n 颗糖果分给 3 位小朋友，确保没有任何小朋友得到超过 limit 颗糖果，请你返回满足此条件下的 总方案数 。", "canonical_solution": "def distributeCandies(n, limit):\n    res=[]\n    for i in range(0,limit+1):\n        for j in range(0,limit+1):\n            for k in range(0,limit+1):\n                if i+j+k==n and (i,j,k) not in res:\n                    res.append((i,j,k))\n    return len(res)", "entry_point": "distributeCandies", "test_list": ["assert distributeCandies(n = 5, limit = 2) == 3", "assert distributeCandies(n = 3, limit = 3) == 10"]}
{"Contest id": "370/2925", "text_name": "在树上执行操作以后得到的最大分数", "text": "有一棵 n 个节点的无向树，节点编号为 0 到 n - 1 ，根节点编号为 0 。给你一个长度为 n - 1 的二维整数数组 edges 表示这棵树，其中 edges[i] = [ai, bi] 表示树中节点 ai 和 bi 有一条边。\n同时给你一个长度为 n 下标从 0 开始的整数数组 values ，其中 values[i] 表示第 i 个节点的值。\n一开始你的分数为 0 ，每次操作中，你将执行：\n选择节点 i 。\n将 values[i] 加入你的分数。\n将 values[i] 变为 0 。\n如果从根节点出发，到任意叶子节点经过的路径上的节点值之和都不等于 0 ，那么我们称这棵树是 健康的 。\n你可以对这棵树执行任意次操作，但要求执行完所有操作以后树是 健康的 ，请你返回你可以获得的 最大分数 。\n", "canonical_solution": "def maximumScoreAfterOperations(edges, values):\n    def dfs(i, adj, v, vis):\n        if len(adj[i]) == 1 and i != 0:\n            return v[i]\n        s = 0\n        vis[i] = 1\n        for j in adj[i]:\n            if vis[j] == 1:\n                continue\n            s += dfs(j, adj, v, vis)\n        return min(v[i], s)\n    n = len(values)\n    adj = [[] for _ in range(n)]\n    for t in range(n - 1):\n        adj[edges[t][0]].append(edges[t][1])\n        adj[edges[t][1]].append(edges[t][0])\n    s = 0\n    for t in values:\n        s += t\n    vis = [0] * n\n    k = dfs(0, adj, values, vis)\n    return s - k", "entry_point": "maximumScoreAfterOperations", "test_list": ["assert maximumScoreAfterOperations(edges = [[0,1],[0,2],[0,3],[2,4],[4,5]], values = [5,2,5,2,1,1]) == 11", "assert maximumScoreAfterOperations(edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]], values = [20,10,9,7,4,3,5]) == 40"]}
{"Contest id": "370/2924", "text_name": " 找到冠军 II", "text": "一场比赛中共有 n 支队伍，按从 0 到  n - 1 编号。每支队伍也是 有向无环图（DAG） 上的一个节点。\n给你一个整数 n 和一个下标从 0 开始、长度为 m 的二维整数数组 edges 表示这个有向无环图，其中 edges[i] = [ui, vi] 表示图中存在一条从 ui 队到 vi 队的有向边。\n从 a 队到 b 队的有向边意味着 a 队比 b 队 强 ，也就是 b 队比 a 队 弱 。\n在这场比赛中，如果不存在某支强于 a 队的队伍，则认为 a 队将会是 冠军 。\n如果这场比赛存在 唯一 一个冠军，则返回将会成为冠军的队伍。否则，返回 -1 。\n注意\n环 是形如 a1, a2, ..., an, an+1 的一个序列，且满足：节点 a1 与节点 an+1 是同一个节点；节点 a1, a2, ..., an 互不相同；对于范围 [1, n] 中的每个 i ，均存在一条从节点 ai 到节点 ai+1 的有向边。\n有向无环图 是不存在任何环的有向图。", "canonical_solution": "def findChampion(n, edges):\n    m = len(edges)\n    in_count = [0] * n\n    for i in range(m):\n        in_count[edges[i][1]] += 1\n    ans = []\n    for i in range(n):\n        if in_count[i] == 0:\n            ans.append(i)\n    if len(ans) > 1:\n        return -1\n    return ans[0]", "entry_point": " findChampion", "test_list": ["assert findChampion(n = 4, edges = [[0,2],[1,3],[1,2]]) == -1", "assert findChampion(n = 3, edges = [[0,1],[1,2]]) == 0"]}
{"Contest id": "370/2923", "text_name": "找到冠军 I", "text": "一场比赛中共有 n 支队伍，按从 0 到  n - 1 编号。\n给你一个下标从 0 开始、大小为 n * n 的二维布尔矩阵 grid 。对于满足 0 <= i, j <= n - 1 且 i != j 的所有 i, j ：如果 grid[i][j] == 1，那么 i 队比 j 队 强 ；否则，j 队比 i 队 强 。\n在这场比赛中，如果不存在某支强于 a 队的队伍，则认为 a 队将会是 冠军 。\n返回这场比赛中将会成为冠军的队伍。", "canonical_solution": "def findChampion(grid):\n    n = len(grid)\n    for i in range(n):\n        if sum(grid[i]) == n - 1:\n            return i", "entry_point": "findChampion", "test_list": ["assert findChampion([[0,1],[0,0]]) == 0", "assert findChampion([[0,0,1],[1,0,1],[0,0,0]]) == 1\n\n\n\n\n\n\n\n\n\n\n\n\n"]}
{"Contest id": "369/2920", "text_name": "收集所有金币可获得的最大积分", "text": "有一棵由 n 个节点组成的无向树，以 0  为根节点，节点编号从 0 到 n - 1 。给你一个长度为 n - 1 的二维 整数 数组 edges ，其中 edges[i] = [ai, bi] 表示在树上的节点 ai 和 bi 之间存在一条边。另给你一个下标从 0 开始、长度为 n 的数组 coins 和一个整数 k ，其中 coins[i] 表示节点 i 处的金币数量。\n从根节点开始，你必须收集所有金币。要想收集节点上的金币，必须先收集该节点的祖先节点上的金币。\n节点 i 上的金币可以用下述方法之一进行收集：\n收集所有金币，得到共计 coins[i] - k 点积分。如果 coins[i] - k 是负数，你将会失去 abs(coins[i] - k) 点积分。\n收集所有金币，得到共计 floor(coins[i] / 2) 点积分。如果采用这种方法，节点 i 子树中所有节点 j 的金币数 coins[j] 将会减少至 floor(coins[j] / 2) 。\n返回收集 所有 树节点的金币之后可以获得的最大积分。", "canonical_solution": "def maximumPoints(edges, coins, k):\n    n = len(edges) + 1\n    G = [set() for i in range(n)]\n    for i,j in edges:\n        G[i].add(j)\n        G[j].add(i)\n    def dp(i, pre, v):\n        if v > 13:\n            return 0\n        a = coins[i] >> v\n        op1 = a - k + sum(dp(j, i, v) for j in G[i] if j != pre)\n        if a >= k + k:\n            return op1\n        op2 = (a >> 1) + sum(dp(j, i, v + 1) for j in G[i] if j != pre)\n        return max(op1, op2)\n    return dp(0, -1, 0)", "entry_point": "maximumPoints", "test_list": ["assert maximumPoints([[0,1],[1,2],[2,3]],[10,10,3,3],5)==11", "assert maximumPoints([[0,1],[0,2]],[8,4,4],0)==16"]}
{"Contest id": "369/2919", "text_name": "使数组变美的最小增量运算数", "text": "给你一个下标从 0 开始、长度为 n 的整数数组 nums ，和一个整数 k 。\n你可以执行下述 递增 运算 任意 次（可以是 0 次）：\n从范围 [0, n - 1] 中选择一个下标 i ，并将 nums[i] 的值加 1 。\n如果数组中任何长度 大于或等于 3 的子数组，其 最大 元素都大于或等于 k ，则认为数组是一个 美丽数组 。\n以整数形式返回使数组变为 美丽数组 需要执行的 最小 递增运算数。\n子数组是数组中的一个连续 非空 元素序列。", "canonical_solution": "def minIncrementOperations(nums, k):\n    dp1, dp2, dp3 = 0,0,0\n    for a in nums:\n        dp1, dp2, dp3 = dp2, dp3, min(dp1, dp2, dp3) + max(k - a, 0)\n    return min(dp1, dp2, dp3)", "entry_point": "minIncrementOperations", "test_list": ["assert minIncrementOperations([2,3,0,0,2],4)==3", "assert minIncrementOperations([0,1,3,3],5)==2", "assert minIncrementOperations([1,1,2],1)==0"]}
{"Contest id": "369/2918", "text_name": "数组的最小相等和", "text": "给你两个由正整数和 0 组成的数组 nums1 和 nums2 。\n你必须将两个数组中的 所有 0 替换为 严格 正整数，并且满足两个数组中所有元素的和 相等 。\n返回 最小 相等和 ，如果无法使两数组相等，则返回 -1 。", "canonical_solution": "def minSum(nums1, nums2):\n    sa = sum(max(a, 1) for a in nums1)\n    sb = sum(max(b, 1) for b in nums2)\n    if sa < sb and nums1.count(0) == 0: return -1\n    if sa > sb and nums2.count(0) == 0: return -1\n    return max(sa, sb)", "entry_point": "minSum", "test_list": ["assert minSum([3,2,0,1,0],[6,5,0])==12", "assert minSum([2,0,2,0],[1,4])==-1"]}
{"Contest id": "369/2917", "text_name": "找出数组中的 K-or 值", "text": "给你一个下标从 0 开始的整数数组 nums 和一个整数 k 。\nnums 中的 K-or 是一个满足以下条件的非负整数：\n只有在 nums 中，至少存在 k 个元素的第 i 位值为 1 ，那么 K-or 中的第 i 位的值才是 1 。\n返回 nums 的 K-or 值。\n注意 ：对于整数 x ，如果 (2i AND x) == 2i ，则 x 中的第 i 位值为 1 ，其中 AND 为按位与运算符。", "canonical_solution": "def findKOr(nums, k):\n    ans = 0\n    for i in range(32):\n        count = 0\n        for num in nums:\n            if 2 ** i & num == 2 ** i:\n                count += 1\n        if count >= k:\n            ans |= 2 ** i\n    return ans", "entry_point": "findKOr", "test_list": ["assert findKOr([7,12,9,8,9,15],4)==9", "assert findKOr([2,12,1,11,4,5],6)==0", "assert findKOr([10,8,5,9,11,6,8],1)==15"]}
{"Contest id": "Bi116/2916", "text_name": "子数组不同元素数目的平方和 II", "text": "给你一个下标从 0 开始的整数数组 nums 。\n定义 nums 一个子数组的 不同计数 值如下：\n令 nums[i..j] 表示 nums 中所有下标在 i 到 j 范围内的元素构成的子数组（满足 0 <= i <= j < nums.length ），那么我们称子数组 nums[i..j] 中不同值的数目为 nums[i..j] 的不同计数。\n请你返回 nums 中所有子数组的 不同计数 的 平方 和。\n由于答案可能会很大，请你将它对 109 + 7 取余 后返回。\n子数组指的是一个数组里面一段连续 非空 的元素序列。", "canonical_solution": "def sumCounts(nums):\n    import collections\n    n = len(nums)\n    tree = [0]*(4*n)\n    lazy = [0]*(4*n)\n    def build(tree, arr, v, lo, hi):\n        if lo == hi:\n            tree[v] = arr[lo]\n            return\n        m = (lo + hi)//2\n        build(tree, arr, 2*v + 1, lo, m)\n        build(tree, arr, 2*v + 2, m + 1, hi)\n        tree[v] = tree[2*v + 1] + tree[2*v + 2]\n    def update(tree, v, lo, hi, i, j, val):\n        if lazy[v]:\n            tree[v] += (hi - lo + 1) * lazy[v]\n            if lo < hi:\n                lazy[2*v + 1] += lazy[v]\n                lazy[2*v + 2] += lazy[v]\n            lazy[v] = 0\n        if lo > j or hi < i: \n            return \n        if i <= lo and hi <= j:\n            tree[v] += (hi - lo + 1)*val\n            if lo < hi:\n                lazy[2*v + 1] += val \n                lazy[2*v + 2] += val\n            return\n        m = (lo + hi)//2\n        update(tree, 2*v + 1, lo, m, i, j, val) \n        update(tree, 2*v + 2, m+1, hi, i, j, val)\n        tree[v] = tree[2*v + 1] + tree[2*v + 2]\n    def query(tree, v, lo, hi, i, j):\n        if j < lo or hi < i:\n            return 0\n        if lazy[v]:\n            tree[v] += (hi - lo + 1)*lazy[v]\n            if lo < hi:\n                lazy[2*v + 1] += lazy[v]\n                lazy[2*v + 2] += lazy[v]\n            lazy[v] = 0\n        if i <= lo and hi <= j:\n            return tree[v]\n        m = (lo + hi)//2\n        if i > m:\n            return query(tree, 2*v + 2, m + 1, hi, i, j)\n        elif j <= m:\n            return query(tree, 2*v + 1, lo, m, i, j)\n        return query(tree, 2*v + 1, lo, m, i, m) + query(tree, 2*v + 2, m+1, hi, m+1, j)\n    squares = 1\n    update(tree, 0, 0, n-1, n-1, n-1, 1)\n    index = collections.defaultdict(lambda:n)\n    index[nums[-1]] = n - 1\n    res = 1\n    for i in range(n-2,-1,-1):\n        j = index[nums[i]]\n        squares += (j-i) + 2*query(tree,0,0,n-1,i+1,j-1)\n        res += squares\n        update(tree, 0, 0, n-1, i, j-1, 1)\n        index[nums[i]] = i\n    return res%(10**9 + 7)", "entry_point": "sumCounts", "test_list": ["assert sumCounts([1,2,1])==15", "assert sumCounts([2,2])==3"]}
{"Contest id": "Bi116/2915", "text_name": "和为目标值的最长子序列的长度", "text": "给你一个下标从 0 开始的整数数组 nums 和一个整数 target 。\n返回和为 target 的 nums 子序列中，子序列 长度的最大值 。如果不存在和为 target 的子序列，返回 -1 。\n子序列 指的是从原数组中删除一些或者不删除任何元素后，剩余元素保持原来的顺序构成的数组。", "canonical_solution": "def lengthOfLongestSubsequence(nums, sum):\n    n = len(nums)\n    dp = [[-1] * (sum + 1) for _ in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = 0\n    for i in range(1, n + 1):\n        for j in range(1, sum + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j >= nums[i - 1] and dp[i - 1][j - nums[i - 1]] != -1:\n                dp[i][j] = max(1 + dp[i - 1][j - nums[i - 1]], dp[i][j])\n    return dp[n][sum]", "entry_point": "lengthOfLongestSubsequence", "test_list": ["assert lengthOfLongestSubsequence([1,2,3,4,5],9)==3", "assert lengthOfLongestSubsequence([4,1,3,2,1,5],7)==4", "assert lengthOfLongestSubsequence([1,1,5,4,5],3)==-1"]}
{"Contest id": "Bi116/2914", "text_name": "使二进制字符串变美丽的最少修改次数", "text": "给你一个长度为偶数下标从 0 开始的二进制字符串 s 。\n如果可以将一个字符串分割成一个或者更多满足以下条件的子字符串，那么我们称这个字符串是 美丽的 ：\n每个子字符串的长度都是 偶数 。\n每个子字符串都 只 包含 1 或 只 包含 0 。\n你可以将 s 中任一字符改成 0 或者 1 。\n请你返回让字符串 s 美丽的 最少 字符修改次数。", "canonical_solution": "def minChanges(s):\n    n = len(s)\n    ans = 0\n    for i in range(0, n, 2):\n        if s[i] != s[i + 1]:\n            ans += 1\n    return ans", "entry_point": "minChanges", "test_list": ["assert minChanges(\"1001\")==2", "assert minChanges(\"10\")==1", "assert minChanges(\"0000\")==0"]}
{"Contest id": "Bi116/2913", "text_name": "子数组不同元素数目的平方和 I", "text": "给你一个下标从 0 开始的整数数组 nums 。\n定义 nums 一个子数组的 不同计数 值如下：\n令 nums[i..j] 表示 nums 中所有下标在 i 到 j 范围内的元素构成的子数组（满足 0 <= i <= j < nums.length ），那么我们称子数组 nums[i..j] 中不同值的数目为 nums[i..j] 的不同计数。\n请你返回 nums 中所有子数组的 不同计数 的 平方 和。\n由于答案可能会很大，请你将它对 109 + 7 取余 后返回。\n子数组指的是一个数组里面一段连续 非空 的元素序列。", "canonical_solution": "def sumCounts(nums):\n    ans=[]\n    for i in range(len(nums)):\n        for j in range(i,len(nums)+1):\n            ans.append(len(set(nums[i:j]))**2)\n    return sum(ans)", "entry_point": "sumCounts", "test_list": ["assert sumCounts([1,2,1])==15", "assert sumCounts([1,1])==3"]}
{"Contest id": "368/2911", "text_name": "得到 K 个半回文串的最少修改次数", "text": "给你一个字符串 s 和一个整数 k ，请你将 s 分成 k 个 子字符串 ，使得每个 子字符串 变成 半回文串 需要修改的字符数目最少。\n请你返回一个整数，表示需要修改的 最少 字符数目。\n注意：\n如果一个字符串从左往右和从右往左读是一样的，那么它是一个 回文串 。\n如果长度为 len 的字符串存在一个满足 1 <= d < len 的正整数 d ，len % d == 0 成立且所有对 d 做除法余数相同的下标对应的字符连起来得到的字符串都是 回文串 ，那么我们说这个字符串是 半回文串 。比方说 \"aa\" ，\"aba\" ，\"adbgad\" 和 \"abab\" 都是 半回文串 ，而 \"a\" ，\"ab\" 和 \"abca\" 不是。\n子字符串 指的是一个字符串中一段连续的字符序列。", "canonical_solution": "def minimumChanges(s, k):\n    import collections\n    div = collections.defaultdict(lambda: [1])\n    n = len(s)\n    for d in range(2, n):\n            for v in range(d + d, n + 1, d):\n                div[v].append(d)\n    def change(i, j):\n        return min(semi(i, j, d) for d in div[j - i])\n    def semi(i, j, d):\n        if i >= j: return 0\n        return semi(i + d, j - d, d) + sum(s[i + ii] != s[j - d + ii] for ii in range(d))\n    def dp(i, k):\n        if k == 1:\n            return change(0, i)\n        return min(dp(j, k - 1) + change(j, i) for j in range((k - 1) * 2, i - 1))\n    return dp(n, k)", "entry_point": "minimumChanges", "test_list": ["assert minimumChanges(\"abcac\",2)==1", "assert minimumChanges(\"abcdef\",2)==2", "assert minimumChanges(\"aabbaa\",3)==0"]}
{"Contest id": "368/2910", "text_name": "合法分组的最少组数", "text": "给你一个长度为 n 下标从 0 开始的整数数组 nums 。\n我们想将下标进行分组，使得 [0, n - 1] 内所有下标 i 都 恰好 被分到其中一组。\n如果以下条件成立，我们说这个分组方案是合法的：\n对于每个组 g ，同一组内所有下标在 nums 中对应的数值都相等。\n对于任意两个组 g1 和 g2 ，两个组中 下标数量 的 差值不超过 1 。\n请你返回一个整数，表示得到一个合法分组方案的 最少 组数。", "canonical_solution": "def minGroupsForValidAssignment(nums):\n    import math\n    def partition(guessed_partition_size, frequencies):\n        result = 0\n        for frequency in frequencies:\n            num_groups = frequency // guessed_partition_size\n            remainder = frequency % guessed_partition_size\n            if remainder > num_groups:\n                return float(\"inf\")\n            result += math.ceil(frequency / (guessed_partition_size + 1))\n        return result\n    counts = {}\n    for num in nums:\n        counts[num] = counts.get(num, 0) + 1\n    frequencies = counts.values()\n    if len(frequencies) == 1:\n        return 1\n    result = len(nums)\n    least_frequent = min(frequencies)\n    for partition_size in range(1, least_frequent + 1):\n        result = min(result, partition(partition_size, frequencies))\n    return int(result)", "entry_point": "minGroupsForValidAssignment", "test_list": ["assert minGroupsForValidAssignment([3,2,3,2,3])==2", "assert minGroupsForValidAssignment([10,10,10,3,1,1])==4"]}
{"Contest id": "368/2909", "text_name": "元素和最小的山形三元组 II", "text": "给你一个下标从 0 开始的整数数组 nums 。\n如果下标三元组 (i, j, k) 满足下述全部条件，则认为它是一个 山形三元组 ：\ni < j < k\nnums[i] < nums[j] 且 nums[k] < nums[j]\n请你找出 nums 中 元素和最小 的山形三元组，并返回其 元素和 。如果不存在满足条件的三元组，返回 -1 。", "canonical_solution": "def minimumSum(nums):\n    n = len(nums)\n    prefix, suffix = [float('inf')] * n, [float('inf')] * n\n    result = float('inf')\n    for i in range(1, n - 1):\n        prefix[i] = min(nums[i - 1], prefix[i - 1])\n    for i in range(n - 2, 0, -1):\n        suffix[i] = min(nums[i + 1], suffix[i + 1])\n    for i in range(1, n - 1):\n        if prefix[i] < nums[i] and suffix[i] < nums[i]:\n            result = min(result, prefix[i] + nums[i] + suffix[i])\n    return -1 if result == float('inf') else result", "entry_point": "minimumSum", "test_list": ["assert minimumSum([8,6,1,5,3])==9", "assert minimumSum([5,4,8,7,10,2])==13", "assert minimumSum([6,5,4,3,4,5])==-1"]}
{"Contest id": "368/2908", "text_name": "元素和最小的山形三元组 I", "text": "给你一个下标从 0 开始的整数数组 nums 。\n如果下标三元组 (i, j, k) 满足下述全部条件，则认为它是一个 山形三元组 ：\ni < j < k\nnums[i] < nums[j] 且 nums[k] < nums[j]\n请你找出 nums 中 元素和最小 的山形三元组，并返回其 元素和 。如果不存在满足条件的三元组，返回 -1 。", "canonical_solution": "def minimumSum(nums):\n    ans=float('inf')\n    for i in range(len(nums)):\n        for j in range(i+1,len(nums)):\n            for k in range(j+1,len(nums)):\n                if nums[i]<nums[j] and nums[k]<nums[j]:\n                    ans=min(ans,nums[i]+nums[j]+nums[k])\n    return ans if ans!=float('inf') else -1", "entry_point": "minimumSum", "test_list": ["assert minimumSum([8,6,1,5,3])==9", "assert minimumSum([5,4,8,7,10,2])==13", "assert minimumSum([6,5,4,3,4,5])==-1"]}
{"Contest id": "367/2906", "text_name": "构造乘积矩阵", "text": "给你一个下标从 0 开始、大小为 n * m 的二维整数矩阵 grid ，定义一个下标从 0 开始、大小为 n * m 的的二维矩阵 p。如果满足以下条件，则称 p 为 grid 的 乘积矩阵 ：\n对于每个元素 p[i][j] ，它的值等于除了 grid[i][j] 外所有元素的乘积。乘积对 12345 取余数。\n返回 grid 的乘积矩阵。", "canonical_solution": "def constructProductMatrix(grid):\n    n, m = len(grid), len(grid[0])\n    A = [[1] * m for r in grid]\n    pre, suf, mod = 1, 1, 12345\n    for i in range(n):\n        for j in range(m):\n            A[i][j] = A[i][j] * pre % mod\n            A[~i][~j] = A[~i][~j] * suf % mod\n            pre = pre * grid[i][j] % mod\n            suf = suf * grid[~i][~j] % mod\n    return A", "entry_point": "constructProductMatrix", "test_list": ["assert constructProductMatrix([[1,2],[3,4]])==[[24,12],[8,6]]", "assert constructProductMatrix([[12345],[2],[1]])==[[2],[0],[0]]"]}
{"Contest id": "367/2905", "text_name": "找出满足差值条件的下标 II", "text": "给你一个下标从 0 开始、长度为 n 的整数数组 nums ，以及整数 indexDifference 和整数 valueDifference 。\n你的任务是从范围 [0, n - 1] 内找出  2 个满足下述所有条件的下标 i 和 j ：\nabs(i - j) >= indexDifference 且\nabs(nums[i] - nums[j]) >= valueDifference\n返回整数数组 answer。如果存在满足题目要求的两个下标，则 answer = [i, j] ；否则，answer = [-1, -1] 。如果存在多组可供选择的下标对，只需要返回其中任意一组即可。\n注意：i 和 j 可能 相等 。", "canonical_solution": "def findIndices(nums, indexDifference, valueDifference):\n    min_index = 0\n    max_index = 0\n    for i in range(indexDifference, len(nums)):\n        if nums[i - indexDifference] < nums[min_index]:\n            min_index = i - indexDifference\n        if nums[i - indexDifference] > nums[max_index]:\n            max_index = i - indexDifference\n        if abs(nums[i] - nums[min_index]) >= valueDifference:\n            return [min_index, i]\n        if abs(nums[i] - nums[max_index]) >= valueDifference:\n            return [max_index, i]\n    return [-1, -1]", "entry_point": "findIndices", "test_list": ["assert findIndices([5,1,4,1],2,4)==[0,3]", "assert findIndices([2,1],0,0)==[0,0]", "assert findIndices([1,2,3],2,4)==[-1,-1]"]}
{"Contest id": "367/2904", "text_name": "最短且字典序最小的美丽子字符串", "text": "给你一个二进制字符串 s 和一个正整数 k 。\n如果 s 的某个子字符串中 1 的个数恰好等于 k ，则称这个子字符串是一个 美丽子字符串 。\n令 len 等于 最短 美丽子字符串的长度。\n返回长度等于 len 且字典序 最小 的美丽子字符串。如果 s 中不含美丽子字符串，则返回一个 空 字符串。\n对于相同长度的两个字符串 a 和 b ，如果在 a 和 b 出现不同的第一个位置上，a 中该位置上的字符严格大于 b 中的对应字符，则认为字符串 a 字典序 大于 字符串 b 。\n例如，\"abcd\" 的字典序大于 \"abcc\" ，因为两个字符串出现不同的第一个位置对应第四个字符，而 d 大于 c 。\n ", "canonical_solution": "def shortestBeautifulSubstring(s, k):\n    n = len(s)\n    ans = \"\"\n    i = 0\n    j = 0\n    c = 0\n    while j < n:\n        if s[j] == '1':\n            c += 1\n        if c == k:\n            while i < n and c == k:\n                s1 = s[i:j + 1]\n                if not ans or len(s1) < len(ans):\n                    ans = s1\n                elif len(s1) == len(ans):\n                    ans = min(ans, s1)\n                if s[i] == '1':\n                    c -= 1\n                i += 1\n        j += 1\n    return ans", "entry_point": "shortestBeautifulSubstring", "test_list": ["assert shortestBeautifulSubstring(\"100011001\",3)==\"11001\"", "assert shortestBeautifulSubstring(\"1011\",2)==\"11\"", "assert shortestBeautifulSubstring(\"000\",1)==\"\""]}
{"Contest id": "367/2903", "text_name": "找出满足差值条件的下标 I", "text": "给你一个下标从 0 开始、长度为 n 的整数数组 nums ，以及整数 indexDifference 和整数 valueDifference 。\n你的任务是从范围 [0, n - 1] 内找出  2 个满足下述所有条件的下标 i 和 j ：\nabs(i - j) >= indexDifference 且\nabs(nums[i] - nums[j]) >= valueDifference\n返回整数数组 answer。如果存在满足题目要求的两个下标，则 answer = [i, j] ；否则，answer = [-1, -1] 。如果存在多组可供选择的下标对，只需要返回其中任意一组即可。\n注意：i 和 j 可能 相等 。", "canonical_solution": "def findIndices(nums, indexDifference, valueDifference):\n    mini = maxi = 0\n    for i in range(indexDifference, len(nums)):\n        if nums[i - indexDifference] < nums[mini]: mini = i - indexDifference\n        if nums[i - indexDifference] > nums[maxi]: maxi = i - indexDifference\n        if nums[i] - nums[mini] >= valueDifference: return [mini, i]\n        if nums[maxi] - nums[i] >= valueDifference: return [maxi, i]\n    return [-1, -1]", "entry_point": "findIndices", "test_list": ["assert findIndices([5,1,4,1],2,4)==[0,3]", "assert findIndices([2,1],0,0)==[0,0]", "assert findIndices([1,2,3],2,4)==[-1,-1]"]}
{"Contest id": "Bi115/2902", "text_name": "和带限制的子多重集合的数目", "text": "给你一个下标从 0 开始的非负整数数组 nums 和两个整数 l 和 r 。\n请你返回 nums 中子多重集合的和在闭区间 [l, r] 之间的 子多重集合的数目 。\n由于答案可能很大，请你将答案对 109 + 7 取余后返回。\n子多重集合 指的是从数组中选出一些元素构成的 无序 集合，每个元素 x 出现的次数可以是 0, 1, ..., occ[x] 次，其中 occ[x] 是元素 x 在数组中的出现次数。\n注意：\n如果两个子多重集合中的元素排序后一模一样，那么它们两个是相同的 子多重集合 。\n空 集合的和是 0 。", "canonical_solution": "def countSubMultisets(nums, l, r):\n    import collections\n    dp = [1] + [0] * r\n    counts = collections.Counter(nums)\n    zeros = counts.pop(0, 0) + 1\n    for a, c in counts.items():\n        stride_sums = dp[:]\n        for i in range(a, r + 1):\n            stride_sums[i] += stride_sums[i - a]\n        for k in range(r, 0, -1):\n            dp[k] = stride_sums[k] - stride_sums[k - a * c - a] if k >= a * c + a else stride_sums[k]\n    return zeros * sum(dp[l:r+1]) % (10 ** 9 + 7)", "entry_point": "countSubMultisets", "test_list": ["assert countSubMultisets([1,2,2,3],6,6)==1", "assert countSubMultisets([2,1,4,2,7],1,5)==7", "assert countSubMultisets([1,2,1,3,5,2],3,5)==9"]}
{"Contest id": "Bi115/2901", "text_name": "最长相邻不相等子序列 II", "text": "给你一个整数 n 和一个下标从 0 开始的字符串数组 words ，和一个下标从 0 开始的数组 groups ，两个数组长度都是 n 。\n两个长度相等字符串的 汉明距离 定义为对应位置字符 不同 的数目。\n你需要从下标 [0, 1, ..., n - 1] 中选出一个 最长子序列 ，将这个子序列记作长度为 k 的 [i0, i1, ..., ik - 1] ，它需要满足以下条件：\n相邻 下标对应的 groups 值 不同。即，对于所有满足 0 < j + 1 < k 的 j 都有 groups[ij] != groups[ij + 1] 。\n对于所有 0 < j + 1 < k 的下标 j ，都满足 words[ij] 和 words[ij + 1] 的长度 相等 ，且两个字符串之间的 汉明距离 为 1 。\n请你返回一个字符串数组，它是下标子序列 依次 对应 words 数组中的字符串连接形成的字符串数组。如果有多个答案，返回任意一个。\n子序列 指的是从原数组中删掉一些（也可能一个也不删掉）元素，剩余元素不改变相对位置得到的新的数组。\n注意：words 中的字符串长度可能 不相等 。", "canonical_solution": "def getWordsInLongestSubsequence(n, words, groups):\n        dp = [1] * len(groups)\n        pv = [-1] * len(groups)\n\n        for i in range(1, len(groups)):\n            for j in range(i):\n                if groups[i] == groups[j]:\n                    continue\n                if len(words[i]) != len(words[j]):\n                    continue\n\n                diff = sum(1 for k in range(len(words[i])) if words[i][k] != words[j][k])\n\n                if diff != 1:\n                    continue\n\n                if dp[j] + 1 > dp[i]:\n                    dp[i] = dp[j] + 1\n                    pv[i] = j\n\n        wi = dp.index(max(dp))\n        ans = []\n\n        while wi != -1:\n            ans.append(words[wi])\n            wi = pv[wi]\n\n        ans.reverse()\n        return ans\n", "entry_point": "getWordsInLongestSubsequence", "test_list": ["assert getWordsInLongestSubsequence(3,[\"bab\",\"dab\",\"cab\"],[1,2,2])==[\"bab\",\"cab\"]", "assert getWordsInLongestSubsequence(4,[\"a\",\"b\",\"c\",\"d\"],[1,2,3,4])==[\"a\",\"b\",\"c\",\"d\"]"]}
{"Contest id": "Bi115/2900", "text_name": "最长相邻不相等子序列 I", "text": "给你一个整数 n 和一个下标从 0 开始的字符串数组 words ，和一个下标从 0 开始的 二进制 数组 groups ，两个数组长度都是 n 。\n你需要从下标 [0, 1, ..., n - 1] 中选出一个 最长子序列 ，将这个子序列记作长度为 k 的 [i0, i1, ..., ik - 1] ，对于所有满足 0 < j + 1 < k 的 j 都有 groups[ij] != groups[ij + 1] 。\n请你返回一个字符串数组，它是下标子序列 依次 对应 words 数组中的字符串连接形成的字符串数组。如果有多个答案，返回任意一个。\n子序列 指的是从原数组中删掉一些（也可能一个也不删掉）元素，剩余元素不改变相对位置得到的新的数组。\n注意：words 中的字符串长度可能 不相等 。", "canonical_solution": "def getWordsInLongestSubsequence(n, words, groups):\n    from typing import List\n    ls,c_g,sl=0,-1,[]\n    for i in range(n):\n        if groups[i]!=c_g:\n            c_g=groups[i]\n            sl.append(words[i])\n            ls+=1\n    return sl", "entry_point": "getWordsInLongestSubsequence", "test_list": ["assert getWordsInLongestSubsequence(3,[\"e\",\"a\",\"b\"],[0,0,1])==[\"e\",\"b\"]", "assert getWordsInLongestSubsequence(4, [\"a\",\"b\",\"c\",\"d\"],[1,0,1,1])==[\"a\",\"b\",\"c\"]"]}
{"Contest id": "Bi115/2899", "text_name": "上一个遍历的整数", "text": "给你一个下标从 0 开始的字符串数组 words ，其中 words[i] 要么是一个字符串形式的正整数，要么是字符串 \"prev\" 。\n我们从数组的开头开始遍历，对于 words 中的每个 \"prev\" 字符串，找到 words 中的 上一个遍历的整数 ，定义如下：\nk 表示到当前位置为止的连续 \"prev\" 字符串数目（包含当前字符串），令下标从 0 开始的 整数 数组 nums 表示目前为止遍历过的所有整数，同时用 nums_reverse 表示 nums 反转得到的数组，那么当前 \"prev\" 对应的 上一个遍历的整数 是 nums_reverse 数组中下标为 (k - 1) 的整数。\n如果 k 比目前为止遍历过的整数数目 更多 ，那么上一个遍历的整数为 -1 。\n请你返回一个整数数组，包含所有上一个遍历的整数。", "canonical_solution": "def lastVisitedIntegers(words):\n    k,li,ans=0,[],[]\n    for i in words:\n        if i=='prev':\n            k+=1\n            if k>len(li):\n                ans.append(-1)\n            else:\n                ans.append(li[-k])\n        else:\n            k=0\n            li.append(int(i))\n    return ans", "entry_point": "lastVisitedIntegers", "test_list": ["assert lastVisitedIntegers([\"1\",\"2\",\"prev\",\"prev\",\"prev\"])==[2,1,-1]", "assert lastVisitedIntegers([\"1\",\"prev\",\"2\",\"prev\",\"prev\"])==[1,2,1]"]}
{"Contest id": "366/2897", "text_name": "对数组执行操作使平方和最大", "text": "给你一个下标从 0 开始的整数数组 nums 和一个 正 整数 k 。\n你可以对数组执行以下操作 任意次 ：\n选择两个互不相同的下标 i 和 j ，同时 将 nums[i] 更新为 (nums[i] AND nums[j]) 且将 nums[j] 更新为 (nums[i] OR nums[j]) ，OR 表示按位 或 运算，AND 表示按位 与 运算。\n你需要从最终的数组里选择 k 个元素，并计算它们的 平方 之和。\n请你返回你可以得到的 最大 平方和。\n由于答案可能会很大，将答案对 109 + 7 取余 后返回。", "canonical_solution": "def maxSum(nums, k):\n    count = [0] * 35\n    for a in nums:\n        for i in range(35):\n            if a & (1 << i):\n                count[i] += 1\n    res = 0\n    mod = 10 ** 9 + 7\n    for j in range(k):\n        cur = 0\n        for i in range(35):\n            if count[i]:\n                count[i] -= 1\n                cur += 1 << i\n        res += cur * cur % mod\n    return res % mod", "entry_point": "maxSum", "test_list": ["assert maxSum([2,6,5,8],2)==261", "assert maxSum([4,5,4,7],3)==90"]}
{"Contest id": "366/2896", "text_name": "执行操作使两个字符串相等", "text": "给你两个下标从 0 开始的二进制字符串 s1 和 s2 ，两个字符串的长度都是 n ，再给你一个正整数 x 。\n你可以对字符串 s1 执行以下操作 任意次 ：\n选择两个下标 i 和 j ，将 s1[i] 和 s1[j] 都反转，操作的代价为 x 。\n选择满足 i < n - 1 的下标 i ，反转 s1[i] 和 s1[i + 1] ，操作的代价为 1 。\n请你返回使字符串 s1 和 s2 相等的 最小 操作代价之和，如果无法让二者相等，返回 -1 。\n注意 ，反转字符的意思是将 0 变成 1 ，或者 1 变成 0 。", "canonical_solution": "def minOperations(s1, s2, x):\n    diffs = [i for i in range(len(s1)) if s1[i] != s2[i]]\n    if len(diffs) % 2 == 1:\n        return -1\n    if len(diffs) == 0:\n        return 0\n    dp = [float(\"inf\") for _ in range(len(diffs) + 1)]\n    dp[-1] = 0\n    dp[-2] = x / 2\n    for idx in reversed(range(len(diffs) - 1)):\n        dp[idx] = min(\n                dp[idx + 1] + x / 2,\n                dp[idx + 2] + diffs[idx + 1] - diffs[idx]\n            )\n    return int(dp[0])", "entry_point": "minOperations", "test_list": ["assert minOperations(\"1100011000\",\"0101001010\",2)==4", "assert minOperations(\"10110\",\"00011\",4)==-1"]}
{"Contest id": "366/2895", "text_name": "最小处理时间", "text": "你有 n 颗处理器，每颗处理器都有 4 个核心。现有 n * 4 个待执行任务，每个核心只执行 一个 任务。\n给你一个下标从 0 开始的整数数组 processorTime ，表示每颗处理器最早空闲时间。另给你一个下标从 0 开始的整数数组 tasks ，表示执行每个任务所需的时间。返回所有任务都执行完毕需要的 最小时间 。\n注意：每个核心独立执行任务。", "canonical_solution": "def minProcessingTime(processorTime, tasks):\n    n = len(tasks)\n    processorTime.sort()\n    tasks.sort()\n    j = n - 1\n    m = len(processorTime)\n    ans = 0\n    for i in range(m):\n        c = 0\n        while c < 4:\n            ans = max(ans, processorTime[i] + tasks[j])\n            c += 1\n            j -= 1\n    return ans", "entry_point": "minProcessingTime", "test_list": ["assert minProcessingTime([8,10],[2,2,3,1,8,7,4,5])==16", "assert minProcessingTime([10,20],[2,3,1,2,5,8,4,3])==23"]}
{"Contest id": "366/2894", "text_name": "分类求和并作差", "text": "给你两个正整数 n 和 m 。\n现定义两个整数 num1 和 num2 ，如下所示：\nnum1：范围 [1, n] 内所有 无法被 m 整除 的整数之和。\nnum2：范围 [1, n] 内所有 能够被 m 整除 的整数之和。\n返回整数 num1 - num2 。", "canonical_solution": "def differenceOfSums(n, m):\n    return (1 + n) * n // 2 - (1 + n // m) * (n // m) * m", "entry_point": "differenceOfSums", "test_list": ["assert differenceOfSums(10,3)==19", "assert differenceOfSums(5,6)==15", "assert differenceOfSums(5,1)==-15"]}
{"Contest id": "365/2876", "text_name": "有向图访问计数", "text": "现有一个有向图，其中包含 n 个节点，节点编号从 0 到 n - 1 。此外，该图还包含了 n 条有向边。\n给你一个下标从 0 开始的数组 edges ，其中 edges[i] 表示存在一条从节点 i 到节点 edges[i] 的边。\n想象在图上发生以下过程：\n你从节点 x 开始，通过边访问其他节点，直到你在 此过程 中再次访问到之前已经访问过的节点。\n返回数组 answer 作为答案，其中 answer[i] 表示如果从节点 i 开始执行该过程，你可以访问到的不同节点数。", "canonical_solution": "def countVisitedNodes(edges):\n    import collections\n    n = len(edges)\n    res = [0] * n\n    for i in range(n):\n        seen = collections.OrderedDict()\n        j = i\n        while (j not in seen) and (res[j] == 0):\n            seen[j] = len(seen)\n            j = edges[j]\n        if j in seen:\n            k = len(seen) - seen[j]\n            for _ in range(k):\n                res[seen.popitem()[0]] = k\n        while seen:\n            j = seen.popitem()[0]\n            res[j] = res[edges[j]] + 1\n    return res", "entry_point": "countVisitedNodes", "test_list": ["assert countVisitedNodes([1,2,0,0])==[3,3,3,4]", "assert countVisitedNodes([1,2,3,4,0])==[5,5,5,5,5]"]}
{"Contest id": "365/2875", "text_name": "无限数组的最短子数组", "text": "给你一个下标从 0 开始的数组 nums 和一个整数 target 。\n下标从 0 开始的数组 infinite_nums 是通过无限地将 nums 的元素追加到自己之后生成的。\n请你从 infinite_nums 中找出满足 元素和 等于 target 的 最短 子数组，并返回该子数组的长度。如果不存在满足条件的子数组，返回 -1 。", "canonical_solution": "def minSizeSubarray(A,target):\n    from numpy import inf\n    sumA = sum(A)\n    n = len(A)\n    k = target // sumA\n    target %= sumA\n    if target == 0:\n        return k * n\n    dp = {0: -1}\n    su = 0\n    res = inf\n    for i,a in enumerate(A + A):\n        su += a\n        if su - target in dp:\n            res = min(res, i - dp.get(su - target))\n        dp[su] = i\n    return res + k * n if res < inf else -1", "entry_point": "minSizeSubarray", "test_list": ["assert minSizeSubarray([1,2,3],5)==2", "assert minSizeSubarray([1,1,1,2,3],4)==2", "assert minSizeSubarray([2,4,6,8],3)==-1"]}
{"Contest id": "365/2874", "text_name": "有序三元组中的最大值 II", "text": "给你一个下标从 0 开始的整数数组 nums 。\n请你从所有满足 i < j < k 的下标三元组 (i, j, k) 中，找出并返回下标三元组的最大值。如果所有满足条件的三元组的值都是负数，则返回 0 。\n下标三元组 (i, j, k) 的值等于 (nums[i] - nums[j]) * nums[k] 。", "canonical_solution": "def maximumTripletValue(nums):\n    res = maxa = maxab = 0\n    for a in nums:\n        res = max(res, maxab * a)\n        maxab = max(maxab, maxa - a)\n        maxa = max(maxa, a)\n    return res", "entry_point": "maximumTripletValue", "test_list": ["assert maximumTripletValue([12,6,1,2,7])==77", "assert maximumTripletValue([1,10,3,4,19])==133", "assert maximumTripletValue([1,2,3])==0"]}
{"Contest id": "365/2873", "text_name": "有序三元组中的最大值 I", "text": "给你一个下标从 0 开始的整数数组 nums 。\n请你从所有满足 i < j < k 的下标三元组 (i, j, k) 中，找出并返回下标三元组的最大值。如果所有满足条件的三元组的值都是负数，则返回 0 。\n下标三元组 (i, j, k) 的值等于 (nums[i] - nums[j]) * nums[k] 。", "canonical_solution": "def maximumTripletValue(nums):\n    res = maxa = maxab = 0\n    for a in nums:\n        res = max(res, maxab * a)\n        maxab = max(maxab, maxa - a)\n        maxa = max(maxa, a)\n    return res", "entry_point": "maximumTripletValue", "test_list": ["assert maximumTripletValue([12,6,1,2,7])==77", "assert maximumTripletValue([1,10,3,4,19])==133", "assert maximumTripletValue([1,2,3])==0"]}
{"Contest id": "Bi114/2872", "text_name": "可以被 K 整除连通块的最大数目", "text": "给你一棵 n 个节点的无向树，节点编号为 0 到 n - 1 。给你整数 n 和一个长度为 n - 1 的二维整数数组 edges ，其中 edges[i] = [ai, bi] 表示树中节点 ai 和 bi 有一条边。\n同时给你一个下标从 0 开始长度为 n 的整数数组 values ，其中 values[i] 是第 i 个节点的 值 。再给你一个整数 k 。\n你可以从树中删除一些边，也可以一条边也不删，得到若干连通块。一个 连通块的值 定义为连通块中所有节点值之和。如果所有连通块的值都可以被 k 整除，那么我们说这是一个 合法分割 。\n请你返回所有合法分割中，连通块数目的最大值 。", "canonical_solution": "def maxKDivisibleComponents(n, edges, values, k):\n    adj = [[] for _ in range(n + 1)]\n    for edge in edges:\n        adj[edge[0]].append(edge[1])\n        adj[edge[1]].append(edge[0])\n    res = [0]  \n    vis = [0] * n\n    vis[0] = 1\n    def dfs(node):\n        leaf = values[node]\n        vis[node] = 1\n        for it in adj[node]:\n            if vis[it] == 0:\n                leaf += dfs(it)\n        if leaf % k == 0:\n            res[0] += 1\n            leaf = 0\n        return leaf\n    dfs(0)\n    if res[0] == 0:\n        return 1\n    return res[0]", "entry_point": "maxKDivisibleComponents", "test_list": ["assert maxKDivisibleComponents(5,[[0,2],[1,2],[1,3],[2,4]],[1,8,1,4,4],6)==2", "assert maxKDivisibleComponents(7,[[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]],[3,0,6,1,5,2,1],3)==3"]}
{"Contest id": "Bi114/2871", "text_name": "将数组分割成最多数目的子数组", "text": "给你一个只包含 非负 整数的数组 nums 。\n我们定义满足 l <= r 的子数组 nums[l..r] 的分数为 nums[l] AND nums[l + 1] AND ... AND nums[r] ，其中 AND 是按位与运算。\n请你将数组分割成一个或者更多子数组，满足：\n每个 元素都 只 属于一个子数组。\n子数组分数之和尽可能 小 。\n请你在满足以上要求的条件下，返回 最多 可以得到多少个子数组。\n一个 子数组 是一个数组中一段连续的元素。", "canonical_solution": "def maxSubarrays(nums):\n    v = -1\n    res = 0\n    for a in nums:\n        v &= a\n        if v == 0:\n            v = -1\n            res += 1\n    return max(1, res)", "entry_point": "maxSubarrays", "test_list": ["assert maxSubarrays([1,0,2,0,1,2])==3", "assert maxSubarrays([5,7,1,3])==1"]}
{"Contest id": "Bi114/2870", "text_name": "使数组为空的最少操作次数", "text": "给你一个下标从 0 开始的正整数数组 nums 。\n你可以对数组执行以下两种操作 任意次 ：\n从数组中选择 两个 值 相等 的元素，并将它们从数组中 删除 。\n从数组中选择 三个 值 相等 的元素，并将它们从数组中 删除 。\n请你返回使数组为空的 最少 操作次数，如果无法达成，请返回 -1 。", "canonical_solution": "def minOperations(nums):\n    from collections import Counter\n    mp = Counter(nums)\n    count = 0\n    for t in mp.values():\n        if t == 1:\n            return -1\n        count += t // 3\n        if t % 3:\n            count += 1  \n    return count", "entry_point": "minOperations", "test_list": ["assert minOperations([2,3,3,2,2,4,2,3,4])==4", "assert minOperations([2,1,2,2,3,3])==-1"]}
{"Contest id": "Bi114/2869", "text_name": "收集元素的最少操作次数", "text": "给你一个正整数数组 nums 和一个整数 k 。\n一次操作中，你可以将数组的最后一个元素删除，将该元素添加到一个集合中。\n请你返回收集元素 1, 2, ..., k 需要的 最少操作次数 。", "canonical_solution": "def minOperations(nums, k):\n    l = []\n    for i in range(1,k+1):\n        l.append(i)\n    c = 0\n    i = len(nums) - 1\n    while l:\n        if nums[i] in l:\n            l.remove(nums[i])\n        i -= 1\n        c += 1\n    return c", "entry_point": "minOperations", "test_list": ["assert minOperations([3,1,5,4,2],2)==4", "assert minOperations([3,1,5,4,2],5)==5", "assert minOperations([3,2,5,3,1],3)==4"]}
{"Contest id": "364/2867", "text_name": "统计树中的合法路径数目", "text": "给你一棵 n 个节点的无向树，节点编号为 1 到 n 。给你一个整数 n 和一个长度为 n - 1 的二维整数数组 edges ，其中 edges[i] = [ui, vi] 表示节点 ui 和 vi 在树中有一条边。\n请你返回树中的 合法路径数目 。\n如果在节点 a 到节点 b 之间 恰好有一个 节点的编号是质数，那么我们称路径 (a, b) 是 合法的 。\n注意：\n路径 (a, b) 指的是一条从节点 a 开始到节点 b 结束的一个节点序列，序列中的节点 互不相同 ，且相邻节点之间在树上有一条边。\n路径 (a, b) 和路径 (b, a) 视为 同一条 路径，且只计入答案 一次 。", "canonical_solution": "def countPaths(n, edges):\n    def mul(x, y):\n        return x * y\n    def dfs(x, f, con, prime, r):\n        v = [1 - prime[x], prime[x]]\n        for y in con[x]:\n            if y == f:\n                continue\n            p = dfs(y, x, con, prime, r)\n            r[0] += mul(p[0], v[1]) + mul(p[1], v[0])\n            if prime[x]:\n                v[1] += p[0]\n            else:\n                v[0] += p[0]\n                v[1] += p[1]\n        return v\n    prime = [True] * (n + 1)\n    prime[1] = False\n    all_primes = []\n    for i in range(2, n + 1):\n        if prime[i]:\n            all_primes.append(i)\n        for x in all_primes:\n            temp = i * x\n            if temp > n:\n                break\n            prime[temp] = False\n            if i % x == 0:\n                break\n    con = [[] for _ in range(n + 1)]\n    for e in edges:\n        con[e[0]].append(e[1])\n        con[e[1]].append(e[0])\n    r = [0]\n    dfs(1, 0, con, prime, r)\n    return r[0]", "entry_point": "countPaths", "test_list": ["assert countPaths(5,[[1,2],[1,3],[2,4],[2,5]])==4", "assert countPaths(6,[[1,2],[1,3],[2,4],[3,5],[3,6]])==6"]}
{"Contest id": "364/2866", "text_name": "美丽塔 II", "text": "给你一个长度为 n 下标从 0 开始的整数数组 maxHeights 。\n你的任务是在坐标轴上建 n 座塔。第 i 座塔的下标为 i ，高度为 heights[i] 。\n如果以下条件满足，我们称这些塔是 美丽 的：\n1 <= heights[i] <= maxHeights[i]\nheights 是一个 山脉 数组。\n如果存在下标 i 满足以下条件，那么我们称数组 heights 是一个 山脉 数组：\n对于所有 0 < j <= i ，都有 heights[j - 1] <= heights[j]\n对于所有 i <= k < n - 1 ，都有 heights[k + 1] <= heights[k]\n请你返回满足 美丽塔 要求的方案中，高度和的最大值 。", "canonical_solution": "def maximumSumOfHeights(maxHeights):\n    n = len(maxHeights)\n    left = [0] * n\n    stack = [-1]\n    cur = 0\n    for i in range(n):\n        while len(stack) > 1 and maxHeights[stack[-1]] > maxHeights[i]:\n            j = stack.pop()\n            cur -= (j - stack[-1]) * maxHeights[j]\n        cur += (i - stack[-1]) * maxHeights[i]\n        stack.append(i)\n        left[i] = cur\n    stack = [n]\n    res = cur = 0\n    for i in range(n - 1, -1, -1):\n        while len(stack) > 1 and maxHeights[stack[-1]] > maxHeights[i]:\n            j = stack.pop()\n            cur -= -(j - stack[-1]) * maxHeights[j]\n        cur += -(i - stack[-1]) * maxHeights[i]\n        stack.append(i)\n        res = max(res, left[i] + cur - maxHeights[i])\n    return res", "entry_point": "maximumSumOfHeights", "test_list": ["assert maximumSumOfHeights([5,3,4,1,1])==13", "assert maximumSumOfHeights([6,5,3,9,2,7])==22", "assert maximumSumOfHeights([3,2,5,5,2,3])==18"]}
{"Contest id": "364/2865", "text_name": "美丽塔 I", "text": "给你一个长度为 n 下标从 0 开始的整数数组 maxHeights 。\n你的任务是在坐标轴上建 n 座塔。第 i 座塔的下标为 i ，高度为 heights[i] 。\n如果以下条件满足，我们称这些塔是 美丽 的：\n1 <= heights[i] <= maxHeights[i]\nheights 是一个 山脉 数组。\n如果存在下标 i 满足以下条件，那么我们称数组 heights 是一个 山脉 数组：\n对于所有 0 < j <= i ，都有 heights[j - 1] <= heights[j]\n对于所有 i <= k < n - 1 ，都有 heights[k + 1] <= heights[k]\n请你返回满足 美丽塔 要求的方案中，高度和的最大值 。", "canonical_solution": "def maximumSumOfHeights(maxHeights):\n    res = 0\n    n = len(maxHeights)\n    for i in range(n):\n        cur = v = maxHeights[i]\n        for j in range(i - 1, -1, -1):\n            v = min(v, maxHeights[j])\n            cur += v\n        v = maxHeights[i]\n        for j in range(i + 1, n):\n            v = min(v, maxHeights[j])\n            cur += v\n        res = max(res, cur)\n    return res", "entry_point": "maximumSumOfHeights", "test_list": ["assert maximumSumOfHeights([5,3,4,1,1])==13", "assert maximumSumOfHeights([6,5,3,9,2,7])==22", "assert maximumSumOfHeights([3,2,5,5,2,3])==18"]}
{"Contest id": "364/2864", "text_name": "最大二进制奇数", "text": "给你一个 二进制 字符串 s ，其中至少包含一个 '1' 。\n你必须按某种方式 重新排列 字符串中的位，使得到的二进制数字是可以由该组合生成的 最大二进制奇数 。\n以字符串形式，表示并返回可以由给定组合生成的最大二进制奇数。\n注意 返回的结果字符串 可以 含前导零。", "canonical_solution": "def maximumOddBinaryNumber(s):\n    ones = s.count('1')\n    return '1' * (ones - 1) + '0' * (len(s) - ones) + '1'", "entry_point": "maximumOddBinaryNumber", "test_list": ["assert maximumOddBinaryNumber(\"010\")==\"001\"", "assert maximumOddBinaryNumber(\"0101\")==\"1001\""]}
{"Contest id": "363/2862", "text_name": "完全子集的最大元素和", "text": "给你一个下标从 1 开始、由 n 个整数组成的数组。\n如果一组数字中每对元素的乘积都是一个完全平方数，则称这组数字是一个 完全集 。\n下标集 {1, 2, ..., n} 的子集可以表示为 {i1, i2, ..., ik}，我们定义对应该子集的 元素和 为 nums[i1] + nums[i2] + ... + nums[ik] 。\n返回下标集 {1, 2, ..., n} 的 完全子集 所能取到的 最大元素和 。\n完全平方数是指可以表示为一个整数和其自身相乘的数。", "canonical_solution": "def maximumSum(nums):\n    import collections\n    count = collections.Counter()\n    for i in range(len(nums)):\n        x, v = i + 1, 2\n        while x >= v * v:\n            while x % (v * v) == 0:\n                x //= v * v\n            v += 1\n        count[x] += nums[i]\n    return max(count.values())", "entry_point": "maximumSum", "test_list": ["assert maximumSum([8,7,3,5,7,2,4,9])==16", "assert maximumSum([5,10,3,10,1,13,7,9,4])==19"]}
{"Contest id": "363/2861", "text_name": "最大合金数", "text": "假设你是一家合金制造公司的老板，你的公司使用多种金属来制造合金。现在共有 n 种不同类型的金属可以使用，并且你可以使用 k 台机器来制造合金。每台机器都需要特定数量的每种金属来创建合金。\n对于第 i 台机器而言，创建合金需要 composition[i][j] 份 j 类型金属。最初，你拥有 stock[i] 份 i 类型金属，而每购入一份 i 类型金属需要花费 cost[i] 的金钱。\n给你整数 n、k、budget，下标从 1 开始的二维数组 composition，两个下标从 1 开始的数组 stock 和 cost，请你在预算不超过 budget 金钱的前提下，最大化 公司制造合金的数量。\n所有合金都需要由同一台机器制造。\n返回公司可以制造的最大合金数。", "canonical_solution": "def maxNumberOfAlloys(n, k, budget, composition, stock, cost):\n    def func(mid, budget, composition, stock, cost):\n        minCost = float('inf')\n        for i in range(len(composition)):\n            currCost = 0\n            for j in range(len(composition[i])):\n                curr = mid * composition[i][j]\n                if stock[j] >= curr:\n                    continue\n                else:\n                    extra = (curr - stock[j]) * cost[j]\n                    currCost += extra\n            minCost = min(currCost, minCost)\n        return minCost <= budget\n    low = 0\n    high = int(1e9)\n    ans = 0\n    while low <= high:\n        mid = low + (high - low) // 2\n        if func(mid, budget, composition, stock, cost):\n            ans = mid\n            low = mid + 1\n        else:\n            high = mid - 1\n    return ans", "entry_point": "maxNumberOfAlloys", "test_list": ["assert maxNumberOfAlloys(3,2,15,[[1,1,1],[1,1,10]],[0,0,0],[1,2,3])==2", "assert maxNumberOfAlloys(3,2,15,[[1,1,1],[1,1,10]],[0,0,100],[1,2,3])==5", "assert maxNumberOfAlloys(2,3,10,[[2,1],[1,2],[1,1]],[1,1],[5,5])==2"]}
{"Contest id": "363/2860", "text_name": "让所有学生保持开心的分组方法数", "text": "给你一个下标从 0 开始、长度为 n 的整数数组 nums ，其中 n 是班级中学生的总数。班主任希望能够在让所有学生保持开心的情况下选出一组学生：\n如果能够满足下述两个条件之一，则认为第 i 位学生将会保持开心：\n这位学生被选中，并且被选中的学生人数 严格大于 nums[i] 。\n这位学生没有被选中，并且被选中的学生人数 严格小于 nums[i] 。\n返回能够满足让所有学生保持开心的分组方法的数目。", "canonical_solution": "def countWays(nums):\n        nums.sort()\n        res = int(nums[0] != 0)\n        nums.append(float('inf'))\n        for i in range(len(nums) - 1):\n            if nums[i] < i + 1 < nums[i + 1]:\n                res += 1\n        return res", "entry_point": "countWays", "test_list": ["assert countWays([1,1])==2", "assert countWays([6,0,3,3,6,7,2,7])==3"]}
{"Contest id": "363/2859", "text_name": "计算 K 置位下标对应元素的和", "text": "给你一个下标从 0 开始的整数数组 nums 和一个整数 k 。\n请你用整数形式返回 nums 中的特定元素之 和 ，这些特定元素满足：其对应下标的二进制表示中恰存在 k 个置位。\n整数的二进制表示中的 1 就是这个整数的 置位 。\n例如，21 的二进制表示为 10101 ，其中有 3 个置位。", "canonical_solution": "def sumIndicesWithKSetBits(nums, k):\n    return sum(x for i, x in enumerate(nums) if bin(i).count('1') == k)", "entry_point": "sumIndicesWithKSetBits", "test_list": ["assert sumIndicesWithKSetBits([5,10,1,5,2],1)==13", "assert sumIndicesWithKSetBits([4,3,2,1],2)==1"]}
{"Contest id": "Bi113/2858", "text_name": "可以到达每一个节点的最少边反转次数", "text": "给你一个 n 个点的 简单有向图 （没有重复边的有向图），节点编号为 0 到 n - 1 。如果这些边是双向边，那么这个图形成一棵 树 。\n给你一个整数 n 和一个 二维 整数数组 edges ，其中 edges[i] = [ui, vi] 表示从节点 ui 到节点 vi 有一条 有向边 。\n边反转 指的是将一条边的方向反转，也就是说一条从节点 ui 到节点 vi 的边会变为一条从节点 vi 到节点 ui 的边。\n对于范围 [0, n - 1] 中的每一个节点 i ，你的任务是分别 独立 计算 最少 需要多少次 边反转 ，从节点 i 出发经过 一系列有向边 ，可以到达所有的节点。\n请你返回一个长度为 n 的整数数组 answer ，其中 answer[i]表示从节点 i 出发，可以到达所有节点的 最少边反转 次数。", "canonical_solution": "def minEdgeReversals(n, edges):\n        G = defaultdict(dict)\n        for i,j in edges:\n            G[i][j], G[j][i] = 0, 1\n        def dp(i, j):\n            return sum(dp(j, k) + G[j][k] for k in G[j] if k != i)\n        return [dp(-1, i) for i in range(n)]", "entry_point": "minEdgeReversals", "test_list": ["assert minEdgeReversals(4, [[2,0],[2,1],[1,3]])==[1,1,0,2]", "assert minEdgeReversals(3,[[1,2],[2,0]])==[2,0,1]"]}
{"Contest id": "Bi113/2857", "text_name": "统计距离为 k 的点对", "text": "给你一个 二维 整数数组 coordinates 和一个整数 k ，其中 coordinates[i] = [xi, yi] 是第 i 个点在二维平面里的坐标。\n我们定义两个点 (x1, y1) 和 (x2, y2) 的 距离 为 (x1 XOR x2) + (y1 XOR y2) ，XOR 指的是按位异或运算。\n请你返回满足 i < j 且点 i 和点 j之间距离为 k 的点对数目。", "canonical_solution": "from collections import Counter\ndef countPairs(coordinates, k):\n        count = Counter()\n        res = 0\n        for x1, y1 in coordinates:\n            for x in range(k + 1):\n                res += count[x1 ^ x, y1 ^ (k - x)]\n            count[x1, y1] += 1\n        return res", "entry_point": "countPairs", "test_list": ["assert countPairs([[1,2],[4,2],[1,3],[5,2]],5)==2", "assert countPairs([[1,3],[1,3],[1,3],[1,3],[1,3]],0)==10"]}
{"Contest id": "Bi113/2856", "text_name": "删除数对后的最小数组长度", "text": "给你一个下标从 0 开始的 非递减 整数数组 nums 。\n你可以执行以下操作任意次：\n选择 两个 下标 i 和 j ，满足 i < j 且 nums[i] < nums[j] 。\n将 nums 中下标在 i 和 j 处的元素删除。剩余元素按照原来的顺序组成新的数组，下标也重新从 0 开始编号。\n请你返回一个整数，表示执行以上操作任意次后（可以执行 0 次），nums 数组的 最小 数组长度。\n请注意，nums 数组是按 非降序 排序的。", "canonical_solution": "import heapq\nfrom collections import Counter\ndef minLengthAfterRemovals(nums):\n        counts = [-x for x in Counter(nums).values()]\n        heapq.heapify(counts)\n        while len(counts) > 1:\n            a = -heapq.heappop(counts)\n            b = -heapq.heappop(counts)\n            if a > 1:\n                heapq.heappush(counts, -a + 1)\n            if b > 1:\n                heapq.heappush(counts, -b + 1)\n        return -sum(counts)", "entry_point": "minLengthAfterRemovals", "test_list": ["assert minLengthAfterRemovals([1,3,4,9])==0", "assert minLengthAfterRemovals([2,3,6,9])==0", "assert minLengthAfterRemovals([1,1,2])==1"]}
{"Contest id": "Bi113/2855", "text_name": "使数组成为递增数组的最少右移次数", "text": "给你一个长度为 n 下标从 0 开始的数组 nums ，数组中的元素为 互不相同 的正整数。请你返回让 nums 成为递增数组的 最少右移 次数，如果无法得到递增数组，返回 -1 。\n一次 右移 指的是同时对所有下标进行操作，将下标为 i 的元素移动到下标 (i + 1) % n 处。", "canonical_solution": "def minimumRightShifts(nums):\n    sorted_nums = sorted(nums)\n    result = 0\n    while result < len(nums):\n        if nums == sorted_nums:\n            return result\n        result = result + 1\n        last_element = nums.pop()\n        nums.insert(0, last_element)\n        return -1", "entry_point": "minimumRightShifts", "test_list": ["assert minimumRightShifts([3,4,5,1,2])==2", "assert minimumRightShifts([1,3,5])==0", "assert minimumRightShifts([2,1,4])==-1"]}
{"Contest id": "362/2850", "text_name": "将石头分散到网格图的最少移动次数", "text": "给你一个大小为 3 * 3 ，下标从 0 开始的二维整数矩阵 grid ，分别表示每一个格子里石头的数目。网格图中总共恰好有 9 个石头，一个格子里可能会有 多个 石头。\n每一次操作中，你可以将一个石头从它当前所在格子移动到一个至少有一条公共边的相邻格子。\n请你返回每个格子恰好有一个石头的 最少移动次数 。", "canonical_solution": "def minimumMoves(grid):\n        def f(z, o, ind):\n            n = len(z)\n            if ind == n:\n                return 0\n            ans = float('inf')\n            for j in range(len(o)):\n                curZ = z[ind]\n                curO = o[j]\n                cur = abs(curZ[0] - curO[0]) + abs(curZ[1] - curO[1])\n                o[j] = (-1, -1)\n                ans = min(ans, cur + f(z, o, ind + 1))\n                o[j] = curO\n            return ans\n        if grid[0][0] == 9 or grid[0][2] == 9 or grid[2][0] == 9 or grid[2][2] == 9:\n            return 18\n        if grid[0][1] == 9 or grid[1][0] == 9 or grid[1][2] == 9 or grid[2][1] == 9:\n            return 15\n        if grid[1][1] == 9:\n            return 12\n        z = []\n        o = []\n        for i in range(3):\n            for j in range(3):\n                if grid[i][j] == 0:\n                    z.append((i, j))\n                while grid[i][j] > 1:\n                    grid[i][j] -= 1\n                    o.append((i, j))\n        return f(z, o, 0)", "entry_point": "minimumMoves", "test_list": ["assert minimumMoves([[1,1,0],[1,1,1],[1,2,1]])==3", "assert minimumMoves([[1,3,0],[1,0,0],[1,0,3]])==4"]}
{"Contest id": "362/2849", "text_name": "判断能否在给定时间到达单元格", "text": "给你四个整数 sx、sy、fx、fy  以及一个 非负整数 t 。\n在一个无限的二维网格中，你从单元格 (sx, sy) 开始出发。每一秒，你 必须 移动到任一与之前所处单元格相邻的单元格中。\n如果你能在 恰好 t 秒 后到达单元格 (fx, fy) ，返回 true ；否则，返回  false 。\n单元格的 相邻单元格 是指该单元格周围与其至少共享一个角的 8 个单元格。你可以多次访问同一个单元格。", "canonical_solution": "def isReachableAtTime(sx, sy, fx, fy, t):\n        if sx == fx and sy == fy:\n            return t > 1 or t == 0\n        height_difference = abs(sy - fy)\n        width_difference = abs(sx - fx)\n        extra_time = abs(height_difference - width_difference)\n        return (min(height_difference, width_difference) + extra_time) <= t", "entry_point": "isReachableAtTime", "test_list": ["assert isReachableAtTime(2,4,7,7,6)==True", "assert isReachableAtTime(3,1,7,3,3)==False"]}
{"Contest id": "362/2848", "text_name": "与车相交的点", "text": "给你一个下标从 0 开始的二维整数数组 nums 表示汽车停放在数轴上的坐标。对于任意下标 i，nums[i] = [starti, endi] ，其中 starti 是第 i 辆车的起点，endi 是第 i 辆车的终点。\n返回数轴上被车 任意部分 覆盖的整数点的数目。", "canonical_solution": "def numberOfPoints(nums):\n        return len(set(j for i in nums for j in range(i[0], i[1] + 1)))", "entry_point": "numberOfPoints", "test_list": ["assert numberOfPoints([[3,6],[1,5],[4,7]])==7", "assert numberOfPoints([[1,3],[5,8]])==7"]}
{"Contest id": "361/2846", "text_name": "边权重均等查询", "text": "现有一棵由 n 个节点组成的无向树，节点按从 0 到 n - 1 编号。给你一个整数 n 和一个长度为 n - 1 的二维整数数组 edges ，其中 edges[i] = [ui, vi, wi] 表示树中存在一条位于节点 ui 和节点 vi 之间、权重为 wi 的边。\n另给你一个长度为 m 的二维整数数组 queries ，其中 queries[i] = [ai, bi] 。对于每条查询，请你找出使从 ai 到 bi 路径上每条边的权重相等所需的 最小操作次数 。在一次操作中，你可以选择树上的任意一条边，并将其权重更改为任意值。\n注意：\n查询之间 相互独立 的，这意味着每条新的查询时，树都会回到 初始状态 。\n从 ai 到 bi的路径是一个由 不同 节点组成的序列，从节点 ai 开始，到节点 bi 结束，且序列中相邻的两个节点在树中共享一条边。\n返回一个长度为 m 的数组 answer ，其中 answer[i] 是第 i 条查询的答案。", "canonical_solution": "def minOperationsQueries(n, edges, queries):\n        def dfs(x, p, b, e, f, t, all, w):\n            all[x] = w[:]\n            f[x][0] = p\n            b[x] = t[0] = t[0] + 1\n            for v in con[x]:\n                if v[0] != p:\n                    w[v[1]] += 1\n                    dfs(v[0], x, b, e, f, t, all, w)\n                    w[v[1]] -= 1\n            e[x] = t[0]\n        def isAncestor(b, e, x, y):\n            return b[x] <= b[y] and e[x] >= e[y]\n        def lca(f, b, e, x, y):\n            if isAncestor(b, e, x, y):\n                return x\n            if isAncestor(b, e, y, x):\n                return y\n            r = 0\n            for i in range(19, -1, -1):\n                temp = f[x][i]\n                if isAncestor(b, e, temp, y):\n                    r = temp\n                else:\n                    x = temp\n            return r\n        con = [[] for _ in range(n)]\n        for e in edges:\n            con[e[0]].append((e[1], e[2] - 1))\n            con[e[1]].append((e[0], e[2] - 1))\n        all = [[0] * 26 for _ in range(n)]\n        f = [[0] * 20 for _ in range(n)]\n        b = [0] * n\n        e = [0] * n\n        w = [0] * 26\n        t = [0]\n        dfs(0, -1, b, e, f, t, all, w)\n        f[0][0] = 0\n        for i in range(1, 20):\n            for j in range(n):\n                f[j][i] = f[f[j][i - 1]][i - 1]\n        result = []\n        for q in queries:\n            if q[0] == q[1]:\n                result.append(0)\n                continue\n            tLca = lca(f, b, e, q[0], q[1])\n            _sum, m = 0, 0\n            for i in range(26):\n                temp = all[q[0]][i] + all[q[1]][i] - (all[tLca][i] << 1)\n                _sum += temp\n                m = max(m, temp)\n            result.append(_sum - m)\n        return result", "entry_point": "minOperationsQueries", "test_list": ["assert minOperationsQueries(7,[[0,1,1],[1,2,1],[2,3,1],[3,4,2],[4,5,2],[5,6,2]],[[0,3],[3,6],[2,6],[0,6]])==[0,0,1,3]", "assert minOperationsQueries(8,[[1,2,6],[1,3,4],[2,4,6],[2,5,3],[3,6,6],[3,0,8],[7,0,2]],[[4,6],[0,4],[6,5],[7,4]])==[1,2,2,3]"]}
{"Contest id": "361/2845", "text_name": "统计趣味子数组的数目", "text": "给你一个下标从 0 开始的整数数组 nums ，以及整数 modulo 和整数 k 。\n请你找出并统计数组中 趣味子数组 的数目。\n如果 子数组 nums[l..r] 满足下述条件，则称其为 趣味子数组 ：\n在范围 [l, r] 内，设 cnt 为满足 nums[i] % modulo == k 的索引 i 的数量。并且 cnt % modulo == k 。\n以整数形式表示并返回趣味子数组的数目。\n注意：子数组是数组中的一个连续非空的元素序列。", "canonical_solution": "def countInterestingSubarrays(nums, mod, k):\n        res = acc = 0\n        count = Counter({0: 1})\n        for a in nums:\n            acc = (acc + (1 if a % mod == k else 0)) % mod\n            res += count[(acc - k) % mod]\n            count[acc] += 1\n        return res", "entry_point": "countInterestingSubarrays", "test_list": ["assert countInterestingSubarrays([3,2,4],2,1)==3", "assert countInterestingSubarrays([3,1,9,6],3,0)==2"]}
{"Contest id": "361/2844", "text_name": "生成特殊数字的最少操作", "text": "给你一个下标从 0 开始的字符串 num ，表示一个非负整数。\n在一次操作中，您可以选择 num 的任意一位数字并将其删除。请注意，如果你删除 num 中的所有数字，则 num 变为 0。\n返回最少需要多少次操作可以使 num 变成特殊数字。\n如果整数 x 能被 25 整除，则该整数 x 被认为是特殊数字。", "canonical_solution": "def minimumOperations(num):\n        min_count, count = len(num), 0\n        if num.endswith(('00', '25', '50', '75')):\n            return 0\n        for i in range(len(num) - 1, -1, -1):\n            if num[i] == '0':\n                if len(num) == 2:\n                    return 1\n                five_idx = [match.start() for match in re.finditer('5', num[:i][::-1])]\n                zero_idx = [match.start() for match in re.finditer('0', num[:i][::-1])]\n                count = min(min(five_idx) if five_idx else len(num), min(zero_idx) if zero_idx else len(num))\n                min_count = min(min_count, len(num) - 1 - i + count)  \n            elif num[i] == '5':\n                two_idx = [match.start() for match in re.finditer('2', num[:i][::-1])]\n                seven_idx = [match.start() for match in re.finditer('7', num[:i][::-1])]\n                \n                count = min(min(two_idx) if two_idx else len(num), min(seven_idx) if seven_idx else len(num))\n                min_count = min(min_count, len(num) - 1 - i + count)\n        return min_count - num.count('0') if min_count == len(num) and '0' in num else min_count", "entry_point": "minimumOperations", "test_list": ["assert minimumOperations(\"2245047\")==2", "assert minimumOperations(\"2908305\")==3", "assert minimumOperations(\"10\")==1"]}
{"Contest id": "361/2843", "text_name": "统计对称整数的数目", "text": "给你两个正整数 low 和 high 。\n对于一个由 2 * n 位数字组成的整数 x ，如果其前 n 位数字之和与后 n 位数字之和相等，则认为这个数字是一个对称整数。\n返回在 [low, high] 范围内的 对称整数的数目 。", "canonical_solution": "def countSymmetricIntegers(l, h):\n        ans = 0\n        for i in range(l, h + 1):\n            c = 0\n            j = i\n            while j > 0:\n                c += 1\n                j = j // 10\n            if c % 2 != 0:\n                continue\n            j = i\n            s = 0\n            a = 0\n            b = 0\n            while s < (c // 2):\n                a += j % 10\n                j = j // 10\n                s += 1\n            while s < c:\n                b += j % 10\n                j = j // 10\n                s += 1\n            if a == b:\n                ans += 1\n        return ans", "entry_point": "countSymmetricIntegers", "test_list": ["assert countSymmetricIntegers(1,100)==9", "assert countSymmetricIntegers(1200,1230)==4"]}
{"Contest id": "Bi112/2842", "text_name": "统计一个字符串的 k 子序列美丽值最大的数目", "text": "给你一个字符串 s 和一个整数 k 。\nk 子序列指的是 s 的一个长度为 k 的 子序列 ，且所有字符都是 唯一 的，也就是说每个字符在子序列里只出现过一次。\n定义 f(c) 为字符 c 在 s 中出现的次数。\nk 子序列的 美丽值 定义为这个子序列中每一个字符 c 的 f(c) 之 和 。\n比方说，s = \"abbbdd\" 和 k = 2 ，我们有：\nf('a') = 1, f('b') = 3, f('d') = 2\ns 的部分 k 子序列为：\n\"abbbdd\" -> \"ab\" ，美丽值为 f('a') + f('b') = 4\n\"abbbdd\" -> \"ad\" ，美丽值为 f('a') + f('d') = 3\n\"abbbdd\" -> \"bd\" ，美丽值为 f('b') + f('d') = 5\n请你返回一个整数，表示所有 k 子序列 里面 美丽值 是 最大值 的子序列数目。由于答案可能很大，将结果对 109 + 7 取余后返回。\n一个字符串的子序列指的是从原字符串里面删除一些字符（也可能一个字符也不删除），不改变剩下字符顺序连接得到的新字符串。\n注意：\nf(c) 指的是字符 c 在字符串 s 的出现次数，不是在 k 子序列里的出现次数。\n两个 k 子序列如果有任何一个字符在原字符串中的下标不同，则它们是两个不同的子序列。所以两个不同的 k 子序列可能产生相同的字符串。", "canonical_solution": "def countKSubsequencesWithMaxBeauty(s, k):\n        from scipy.special import comb\n        from collections import Counter\n        mod = 10**9 + 7\n        counter = Counter(s)\n        if len(counter) < k: return 0\n        freq = Counter(counter.values())\n        pairs = list(sorted(freq.items(), reverse=True))\n        res = 1\n        for fc, occ in pairs:\n            if occ <= k:\n                res = (res * pow(fc, occ, mod)) % mod\n                k -= occ\n            else:\n                res = (res * comb(occ, k) * pow(fc, k, mod)) % mod\n                break\n        return res % mod", "entry_point": "countKSubsequencesWithMaxBeauty", "test_list": ["assert countKSubsequencesWithMaxBeauty(\"bcca\",2)==4", "assert countKSubsequencesWithMaxBeauty(\"abbcd\",4)==2"]}
{"Contest id": "Bi112/2841", "text_name": "几乎唯一子数组的最大和", "text": "给你一个整数数组 nums 和两个正整数 m 和 k 。\n请你返回 nums 中长度为 k 的 几乎唯一 子数组的 最大和 ，如果不存在几乎唯一子数组，请你返回 0 。\n如果 nums 的一个子数组有至少 m 个互不相同的元素，我们称它是 几乎唯一 子数组。\n子数组指的是一个数组中一段连续 非空 的元素序列。", "canonical_solution": "def maxSum(nums, m, k):\n                result = 0\n                sub_array = nums[:k-1]\n                for index in range(k-1 , len(nums)):\n                        sub_array.append(nums[index])\n                        if len(set(sub_array)) >= m:\n                                result = max(result , sum(sub_array))\n                        sub_array.pop(0)\n                return result", "entry_point": "maxSum", "test_list": ["assert maxSum([2,6,7,3,1,7],3,4)==18", "assert maxSum([5,9,9,2,4,5,4],1,3)==23", "assert maxSum([1,2,1,2,1,2,1],3,3)==0"]}
{"Contest id": "Bi112/2840", "text_name": "判断通过操作能否让字符串相等 II", "text": "给你两个字符串 s1 和 s2 ，两个字符串长度都为 n ，且只包含 小写 英文字母。\n你可以对两个字符串中的 任意一个 执行以下操作 任意 次：\n选择两个下标 i 和 j ，满足 i < j 且 j - i 是 偶数，然后 交换 这个字符串中两个下标对应的字符。\n如果你可以让字符串 s1 和 s2 相等，那么返回 true ，否则返回 false 。", "canonical_solution": "def checkStrings(s1, s2):\n        n = len(s1)\n        if len(s2) != n:\n            return False\n        d2 = {}\n        for i in range(n):\n            if s2[i] in d2:\n                d2[s2[i]][i&1] += 1\n            else:\n                d2[s2[i]] = [0, 0]\n                d2[s2[i]][i&1] += 1\n        for i in range(n):\n            if s1[i] not in d2:\n                return False\n            d2[s1[i]][i&1] -= 1\n            if d2[s1[i]][i&1] < 0:\n                return False\n            elif d2[s1[i]] == [0, 0]:\n                del d2[s1[i]]\n        return True", "entry_point": "checkStrings", "test_list": ["assert checkStrings(\"abcdba\",\"cabdab\")==True", "assert checkStrings(\"abe\",\"bea\")==False"]}
{"Contest id": "Bi112/2839", "text_name": "判断通过操作能否让字符串相等 I", "text": "给你两个字符串 s1 和 s2 ，两个字符串的长度都为 4 ，且只包含 小写 英文字母。\n你可以对两个字符串中的 任意一个 执行以下操作 任意 次：\n选择两个下标 i 和 j 且满足 j - i = 2 ，然后 交换 这个字符串中两个下标对应的字符。\n如果你可以让字符串 s1 和 s2 相等，那么返回 true ，否则返回 false 。", "canonical_solution": "def canBeEqual(s1, s2):\n                if s1 == s2:\n                        return True\n                s3 = list(s1)\n                s3[0] , s3[2] = s3[2], s3[0]\n                s5 = s3\n                s3 = ''.join(s3)\n                if s3 == s2:\n                        return True\n                s4 = list(s1)\n                s4[1] , s4[3] = s4[3], s4[1]\n                s4 = ''.join(s4)\n                if s4 == s2:\n                        return True\n                s5[1] , s5[3] = s5[3], s5[1]\n                s5 = ''.join(s5)\n                if s5 == s2:\n                        return True\n                return False", "entry_point": "canBeEqual", "test_list": ["assert canBeEqual(\"abcd\",\"cdab\")==True", "assert canBeEqual(\"abcd\",\"dacb\")==False"]}
{"Contest id": "360/2836", "text_name": "在传球游戏中最大化函数值", "text": "给你一个长度为 n 下标从 0 开始的整数数组 receiver 和一个整数 k 。\n总共有 n 名玩家，玩家 编号 互不相同，且为 [0, n - 1] 中的整数。这些玩家玩一个传球游戏，receiver[i] 表示编号为 i 的玩家会传球给编号为 receiver[i] 的玩家。玩家可以传球给自己，也就是说 receiver[i] 可能等于 i 。\n你需要从 n 名玩家中选择一名玩家作为游戏开始时唯一手中有球的玩家，球会被传 恰好 k 次。\n如果选择编号为 x 的玩家作为开始玩家，定义函数 f(x) 表示从编号为 x 的玩家开始，k 次传球内所有接触过球玩家的编号之 和 ，如果有玩家多次触球，则 累加多次 。换句话说， f(x) = x + receiver[x] + receiver[receiver[x]] + ... + receiver(k)[x] 。\n你的任务时选择开始玩家 x ，目的是 最大化 f(x) 。\n请你返回函数的 最大值 。\n注意：receiver 可能含有重复元素。", "canonical_solution": "def getMaxFunctionValue(receiver, k):\n        n = len(receiver)\n        parent, pathSum = [[0] * 35 for _ in range(n)], [[0] * 35 for _ in range(n)]\n        for start in range(n):\n            parent[start][0] = pathSum[start][0] = receiver[start]\n        for power in range(1, 35):\n            for start in range(n):\n                parent[start][power] = parent[parent[start][power - 1]][power - 1]\n                pathSum[start][power] = pathSum[start][power - 1] + pathSum[parent[start][power - 1]][power - 1]\n        res = 0\n        for start in range(n):\n            i = start\n            runningSum = 0\n            for power in range(35):\n                if k & (1 << power) != 0:\n                    runningSum += pathSum[i][power]\n                    i = parent[i][power]\n            res = max(start + runningSum, res)\n        return res", "entry_point": "getMaxFunctionValue", "test_list": ["assert getMaxFunctionValue([2,0,1],4)==6", "assert getMaxFunctionValue([1,1,1,2,3],3)==10"]}
{"Contest id": "360/2835", "text_name": "使子序列的和等于目标的最少操作次数", "text": "给你一个下标从 0 开始的数组 nums ，它包含 非负 整数，且全部为 2 的幂，同时给你一个整数 target 。\n一次操作中，你必须对数组做以下修改：\n选择数组中一个元素 nums[i] ，满足 nums[i] > 1 。\n将 nums[i] 从数组中删除。\n在 nums 的 末尾 添加 两个 数，值都为 nums[i] / 2 。\n你的目标是让 nums 的一个 子序列 的元素和等于 target ，请你返回达成这一目标的 最少操作次数 。如果无法得到这样的子序列，请你返回 -1 。\n数组中一个 子序列 是通过删除原数组中一些元素，并且不改变剩余元素顺序得到的剩余数组。", "canonical_solution": "def minOperations(nums, target):\n        tot = sum(nums)\n        if tot < target:\n            return -1\n        nums.sort()\n        res = 0\n        while target:\n            a = nums.pop()\n            if tot - a >= target:\n                tot -= a\n            elif a <= target:\n                tot -= a\n                target -= a\n            else:\n                nums.append(a // 2)\n                nums.append(a // 2)\n                res += 1\n        return res", "entry_point": "minOperations", "test_list": ["assert minOperations([1,2,8],7)==1", "assert minOperations([1,32,1,2],12)==2", "assert minOperations([1,32,1],35)==-1"]}
{"Contest id": "360/2834", "text_name": "找出美丽数组的最小和", "text": "给你两个正整数：n 和 target 。\n如果数组 nums 满足下述条件，则称其为 美丽数组 。\nnums.length == n.\nnums 由两两互不相同的正整数组成。\n在范围 [0, n-1] 内，不存在 两个 不同 下标 i 和 j ，使得 nums[i] + nums[j] == target 。\n返回符合条件的美丽数组所可能具备的 最小 和，并对结果进行取模 10^9 + 7。", "canonical_solution": "def minimumPossibleSum(n, target):\n        k = target // 2\n        if n <= k:\n            return n * (n + 1) // 2\n        return k * (k + 1) // 2 + (target + target + n - k - 1) * (n - k) // 2", "entry_point": "minimumPossibleSum", "test_list": ["assert minimumPossibleSum(2,3)==4", "assert minimumPossibleSum(3,3)==8", "assert minimumPossibleSum(1,1)==1"]}
{"Contest id": "360/2833", "text_name": "距离原点最远的点", "text": "给你一个长度为 n 的字符串 moves ，该字符串仅由字符 'L'、'R' 和 '_' 组成。字符串表示你在一条原点为 0 的数轴上的若干次移动。\n你的初始位置就在原点（0），第 i 次移动过程中，你可以根据对应字符选择移动方向：\n如果 moves[i] = 'L' 或 moves[i] = '_' ，可以选择向左移动一个单位距离\n如果 moves[i] = 'R' 或 moves[i] = '_' ，可以选择向右移动一个单位距离\n移动 n 次之后，请你找出可以到达的距离原点 最远 的点，并返回 从原点到这一点的距离 。", "canonical_solution": "def furthestDistanceFromOrigin(moves):\n        return abs(moves.count('R') - moves.count('L')) + moves.count('_')", "entry_point": "furthestDistanceFromOrigin", "test_list": ["assert furthestDistanceFromOrigin(\"L_RL__R\")==3", "assert furthestDistanceFromOrigin(\"_R__LL_\")==5", "assert furthestDistanceFromOrigin(\"_______\")==7"]}
{"Contest id": "359/2831", "text_name": "找出最长等值子数组", "text": "给你一个下标从 0 开始的整数数组 nums 和一个整数 k 。\n如果子数组中所有元素都相等，则认为子数组是一个 等值子数组 。注意，空数组是 等值子数组 。\n从 nums 中删除最多 k 个元素后，返回可能的最长等值子数组的长度。\n子数组 是数组中一个连续且可能为空的元素序列。", "canonical_solution": "def longestEqualSubarray(nums, k):\n        maxf = i = 0\n        count = Counter()\n        for j in range(len(nums)):\n            count[nums[j]] += 1\n            maxf = max(maxf, count[nums[j]])\n            if j - i + 1 - maxf > k:\n                count[nums[i]] -= 1\n                i += 1\n        return maxf", "entry_point": "longestEqualSubarray", "test_list": ["assert longestEqualSubarray([1,3,2,3,1,3],3)==3", "assert longestEqualSubarray([1,1,2,2,1,1],2)==4"]}
{"Contest id": "359/2830", "text_name": "销售利润最大化", "text": "给你一个整数 n 表示数轴上的房屋数量，编号从 0 到 n - 1 。\n另给你一个二维整数数组 offers ，其中 offers[i] = [starti, endi, goldi] 表示第 i 个买家想要以 goldi 枚金币的价格购买从 starti 到 endi 的所有房屋。\n作为一名销售，你需要有策略地选择并销售房屋使自己的收入最大化。\n返回你可以赚取的金币的最大数目。\n注意 同一所房屋不能卖给不同的买家，并且允许保留一些房屋不进行出售。", "canonical_solution": "def maximizeTheProfit(n, offers):\n        dp = [0] * (n + 1)\n        m = [[] for _ in range(n)]\n        for s,e,g in offers:\n            m[e].append([s,g])\n        for e in range(1, n + 1):\n            dp[e] = dp[e - 1]\n            for s, g in m[e - 1]:\n                dp[e] = max(dp[e], dp[s] + g)\n        return dp[-1]", "entry_point": "maximizeTheProfit", "test_list": ["assert maximizeTheProfit(5,[[0,0,1],[0,2,2],[1,3,2]])==3", "assert maximizeTheProfit(5,[[0,0,1],[0,2,10],[1,3,2]])==10"]}
{"Contest id": "359/2829", "text_name": "k-avoiding 数组的最小总和", "text": "给你两个整数 n 和 k 。\n对于一个由 不同 正整数组成的数组，如果其中不存在任何求和等于 k 的不同元素对，则称其为 k-avoiding 数组。\n返回长度为 n 的 k-avoiding 数组的可能的最小总和。", "canonical_solution": "def minimumSum(n, k):\n        a = min(k // 2, n)\n        b = n - a\n        return (1 + a) * a // 2 + (k + k + b - 1) * b // 2", "entry_point": "minimumSum", "test_list": ["assert minimumSum(5,4)==18", "assert minimumSum(2,6)==3"]}
{"Contest id": "359/2828", "text_name": "判别首字母缩略词", "text": "给你一个字符串数组 words 和一个字符串 s ，请你判断 s 是不是 words 的 首字母缩略词 。\n如果可以按顺序串联 words 中每个字符串的第一个字符形成字符串 s ，则认为 s 是 words 的首字母缩略词。例如，\"ab\" 可以由 [\"apple\", \"banana\"] 形成，但是无法从 [\"bear\", \"aardvark\"] 形成。\n如果 s 是 words 的首字母缩略词，返回 true ；否则，返回 false 。", "canonical_solution": "def isAcronym(words, s):\n        ans=\"\"\n        for word in words:\n            ans+=word[0]\n        return ans==s  \n        ", "entry_point": "isAcronym", "test_list": ["assert isAcronym([\"alice\",\"bob\",\"charlie\"],\"abc\")==True", "assert isAcronym([\"an\",\"apple\"],\"a\")==False", "assert isAcronym([\"never\",\"gonna\",\"give\",\"up\",\"on\",\"you\"],\"ngguoy\")==True"]}
{"Contest id": "Bi111/2827", "text_name": "范围中美丽整数的数目", "text": "给你正整数 low ，high 和 k 。\n如果一个数满足以下两个条件，那么它是 美丽的 ：\n偶数数位的数目与奇数数位的数目相同。\n这个整数可以被 k 整除。\n请你返回范围 [low, high] 中美丽整数的数目。", "canonical_solution": "def numberOfBeautifulIntegers(low, high, k):\n        def dp(i, diff, is_limit, is_zero, s, m):\n            if i == len(s):\n                return int(is_zero) & (diff == 0) & (m == 0)\n            res = 0\n            if not is_zero:\n                res = dp(i + 1, diff, False, False, s, m)\n            bound = int(s[i]) if is_limit else 9\n            for d in range(1 - int(is_zero), bound + 1):\n                if d & 1:\n                    res += dp(i + 1, diff + 1, is_limit and d == bound, True, s, (m + d * 10 ** (len(s) - i - 1)) % k)\n                else:\n                    res += dp(i + 1, diff - 1, is_limit and d == bound, True, s, (m + d * 10 ** (len(s) - i - 1)) % k)\n            return res\n        return dp(0, 0, True, False, str(high), 0) - dp(0, 0, True, False, str(low - 1), 0)", "entry_point": "numberOfBeautifulIntegers", "test_list": ["assert numberOfBeautifulIntegers(10,20,3)==2", "assert numberOfBeautifulIntegers(1,10,1)==1", "assert numberOfBeautifulIntegers(5,5,2)==0"]}
{"Contest id": "Bi111/2826", "text_name": "将三个组排序", "text": "给你一个下标从 0 开始长度为 n 的整数数组 nums 。\n从 0 到 n - 1 的数字被分为编号从 1 到 3 的三个组，数字 i 属于组 nums[i] 。注意，有的组可能是 空的 。\n你可以执行以下操作任意次：\n选择数字 x 并改变它的组。更正式的，你可以将 nums[x] 改为数字 1 到 3 中的任意一个。\n你将按照以下过程构建一个新的数组 res ：\n将每个组中的数字分别排序。\n将组 1 ，2 和 3 中的元素 依次 连接以得到 res 。\n如果得到的 res 是 非递减顺序的，那么我们称数组 nums 是 美丽数组 。\n请你返回将 nums 变为 美丽数组 需要的最少步数。", "canonical_solution": "def minimumOperations(nums):\n        a, b, c = 0, 0, 0\n        for x in nums:\n            a += x != 1\n            b = min(a, b + (x != 2))\n            c = min(b, c + (x != 3))\n        return c", "entry_point": "minimumOperations", "test_list": ["assert minimumOperations([2,1,3,2,1])==3", "assert minimumOperations([1,3,2,1,3,3])==2", "assert minimumOperations([2,2,2,2,3,3])==0"]}
{"Contest id": "Bi111/2825", "text_name": "循环增长使字符串子序列等于另一个字符串", "text": "给你一个下标从 0 开始的字符串 str1 和 str2 。\n一次操作中，你选择 str1 中的若干下标。对于选中的每一个下标 i ，你将 str1[i] 循环 递增，变成下一个字符。也就是说 'a' 变成 'b' ，'b' 变成 'c' ，以此类推，'z' 变成 'a' 。\n如果执行以上操作 至多一次 ，可以让 str2 成为 str1 的子序列，请你返回 true ，否则返回 false 。\n注意：一个字符串的子序列指的是从原字符串中删除一些（可以一个字符也不删）字符后，剩下字符按照原本先后顺序组成的新字符串。", "canonical_solution": "def canMakeSubsequence(str1, str2):\n        j, n, m = 0, len(str1), len(str2)\n        for i in range(n):\n            if j < m and (ord(str2[j]) - ord(str1[i])) % 26 <= 1:\n                j += 1\n        return j == m", "entry_point": "canMakeSubsequence", "test_list": ["assert canMakeSubsequence(\"abc\",\"ad\")==True", "assert canMakeSubsequence(\"zc\",\"ad\")==True", "assert canMakeSubsequence(\"ab\",\"d\")==False"]}
{"Contest id": "Bi111/2824", "text_name": "统计和小于目标的下标对数目", "text": "给你一个下标从 0 开始长度为 n 的整数数组 nums 和一个整数 target ，请你返回满足 0 <= i < j < n 且 nums[i] + nums[j] < target 的下标对 (i, j) 的数目。", "canonical_solution": "def countPairs(nums, target):\n        nums.sort()\n        count = 0\n        left = 0\n        right = len(nums)-1\n        while(left < right):\n            if(nums[left] + nums[right] < target):\n                count += right-left\n                left += 1\n            else:\n                right -= 1\n        return count", "entry_point": "countPairs", "test_list": ["assert countPairs([-1,1,2,3,1],2)==3", "assert countPairs([-6,2,5,-2,-7,-1,3],-2)==10"]}
{"Contest id": "358/2818", "text_name": "操作使得分最大", "text": "给你一个长度为 n 的正整数数组 nums 和一个整数 k 。\n一开始，你的分数为 1 。你可以进行以下操作至多 k 次，目标是使你的分数最大：\n选择一个之前没有选过的 非空 子数组 nums[l, ..., r] 。\n从 nums[l, ..., r] 里面选择一个 质数分数 最高的元素 x 。如果多个元素质数分数相同且最高，选择下标最小的一个。\n将你的分数乘以 x 。\nnums[l, ..., r] 表示 nums 中起始下标为 l ，结束下标为 r 的子数组，两个端点都包含。\n一个整数的 质数分数 等于 x 不同质因子的数目。比方说， 300 的质数分数为 3 ，因为 300 = 2 * 2 * 3 * 5 * 5 。\n请你返回进行至多 k 次操作后，可以得到的 最大分数 。\n由于答案可能很大，请你将结果对 109 + 7 取余后返回。", "canonical_solution": "def maximumScore(nums, k):\n        def isqrt(n):\n            x = n\n            y = (x + 1) // 2\n            while y < x:\n                x = y\n                y = (x + n // x) // 2\n            return x\n        def getPrimeFactors(n):\n            res = set()\n            for i in range(2, isqrt(n) + 1):\n                while n % i == 0:\n                    res.add(i)\n                    n //= i\n            if n > 1: res.add(n)\n            return len(res)\n        arr = [getPrimeFactors(i) for i in nums]\n        f = [len(arr) - i - 1 for i in range(len(arr))]\n        st = []\n        for i in range(len(arr)):\n            while st and arr[st[-1]] < arr[i]:\n                t = st.pop()\n                f[t] = i - t - 1\n            st.append(i)\n        b = [len(arr) - i - 1 for i in range(len(arr) - 1, -1, -1)]\n        st = []\n        for i in range(len(arr) - 1, -1, -1):\n            while st and arr[st[-1]] <= arr[i]:\n                t = st.pop()\n                b[t] = t - i - 1\n            st.append(i)\n        hp = []\n        for i in range(len(arr)):\n            t1 = f[i] + 1\n            t2 = b[i] + 1\n            hp.append( (t1 * t2, nums[i]) )\n        hp.sort(key = lambda x: (-x[1], -x[0]))\n        res = 1\n        mod = pow(10, 9) + 7\n        for i, j in hp:\n            t = min(i, k)\n            k -= t\n            res = (res * pow(j, t, mod)) % mod\n            if k == 0:\n                break \n        return res", "entry_point": "maximumScore", "test_list": ["assert maximumScore([8,3,9,3,8],2)==81", "assert maximumScore([19,12,14,6,10,18],3)==4788"]}
{"Contest id": "358/2817", "text_name": "限制条件下元素之间的最小绝对差", "text": "给你一个下标从 0 开始的整数数组 nums 和一个整数 x 。\n请你找到数组中下标距离至少为 x 的两个元素的 差值绝对值 的 最小值 。\n换言之，请你找到两个下标 i 和 j ，满足 abs(i - j) >= x 且 abs(nums[i] - nums[j]) 的值最小。\n请你返回一个整数，表示下标距离至少为 x 的两个元素之间的差值绝对值的 最小值 。", "canonical_solution": "import heapq\ndef minAbsoluteDifference(nums, x):\n        sortedNums = sorted((nums[i], i) for i in range(len(nums)))\n        heapLeft, heapRight = [], []\n        minDiff = float('inf')\n\n        for i in range(len(sortedNums)):\n            val, index = sortedNums[i]\n            heapq.heappush(heapLeft, (index, val)) \n            heapq.heappush(heapRight, (-index, val)) \n \n            while heapLeft and heapLeft[0][0] + x <= index:\n                minDiff = min(minDiff, val - heapq.heappop(heapLeft)[1])\n            while heapRight and heapRight[0][0] + x <= -index: \n                minDiff = min(minDiff, val - heapq.heappop(heapRight)[1])\n         \n        return minDiff", "entry_point": "minAbsoluteDifference", "test_list": ["assert minAbsoluteDifference([4,3,2,4],2)==0", "assert minAbsoluteDifference([5,3,2,10,15],1)==1", "assert minAbsoluteDifference([1,2,3,4],3)==3"]}
{"Contest id": "358/2815", "text_name": "数组中的最大数对和", "text": "给你一个下标从 0 开始的整数数组 nums 。请你从 nums 中找出和 最大 的一对数，且这两个数数位上最大的数字相等。\n返回最大和，如果不存在满足题意的数字对，返回 -1 。", "canonical_solution": "def maxSum(nums):\n        max_by_digit = defaultdict(int)\n        max_sum = -1\n        for num in nums:\n            digit = max(str(num))\n            if digit in max_by_digit:\n                max_sum = max(max_sum, max_by_digit[digit] + num)\n            max_by_digit[digit] = max(max_by_digit[digit], num)\n        return max_sum", "entry_point": "maxSum", "test_list": ["assert maxSum([51,71,17,24,42])==88", "assert maxSum([1,2,3,4])==-1"]}
{"Contest id": "357/2813", "text_name": "子序列最大优雅度\n", "text": "给你一个长度为 n 的二维整数数组 items 和一个整数 k 。\nitems[i] = [profiti, categoryi]，其中 profiti 和 categoryi 分别表示第 i 个项目的利润和类别。\n现定义 items 的 子序列 的 优雅度 可以用 total_profit + distinct_categories2 计算，其中 total_profit 是子序列中所有项目的利润总和，distinct_categories 是所选子序列所含的所有类别中不同类别的数量。\n你的任务是从 items 所有长度为 k 的子序列中，找出 最大优雅度 。\n用整数形式表示并返回 items 中所有长度恰好为 k 的子序列的最大优雅度。\n注意：数组的子序列是经由原数组删除一些元素（可能不删除）而产生的新数组，且删除不改变其余元素相对顺序。", "canonical_solution": "def findMaximumElegance(items, k):\n        items = sorted(items, key=lambda v: -v[0])\n        res = cur = 0\n        A = []\n        seen = set()\n        for i, (p, c) in enumerate(items):\n            if i < k:\n                if c in seen:\n                    A.append(p)\n                cur += p\n            elif c not in seen:\n                if not A:\n                    break\n                cur += p - A.pop()\n            seen.add(c)\n            res = max(res, cur + len(seen) * len(seen))\n        return res", "entry_point": "findMaximumElegance", "test_list": ["assert findMaximumElegance(items = [[3,2],[5,1],[10,1]], k = 2) == 17", "assert findMaximumElegance(items = [[3,1],[3,1],[2,2],[5,3]], k = 3) == 19", "assert findMaximumElegance(items = [[1,1],[2,1],[3,1]], k = 3) == 7"]}
{"Contest id": "357/2812", "text_name": "找出最安全路径", "text": "给你一个下标从 0 开始、大小为 n x n 的二维矩阵 grid ，其中 (r, c) 表示：\n如果 grid[r][c] = 1 ，则表示一个存在小偷的单元格\n如果 grid[r][c] = 0 ，则表示一个空单元格\n你最开始位于单元格 (0, 0) 。在一步移动中，你可以移动到矩阵中的任一相邻单元格，包括存在小偷的单元格。\n矩阵中路径的 安全系数 定义为：从路径中任一单元格到矩阵中任一小偷所在单元格的 最小曼哈顿距离。\n返回所有通向单元格 (n - 1, n - 1) 的路径中的 最大安全系数 。\n单元格 (r, c) 的某个 相邻 单元格，是指在矩阵中存在的 (r, c + 1)、(r, c - 1)、(r + 1, c) 和 (r - 1, c) 之一。\n两个单元格 (a, b) 和 (x, y) 之间的 曼哈顿距离 等于 | a - x | + | b - y | ，其中 |val| 表示 val 的绝对值。", "canonical_solution": "def maximumSafenessFactor(grid):\n    n = len(grid)\n    q = []\n    dis = [[-1] * n for _ in range(n)]\n    for i, row in enumerate(grid):\n        for j, x in enumerate(row):\n            if x:\n                q.append((i, j))\n                dis[i][j] = 0\n    groups = [q]\n    while q:\n        tmp = q\n        q = []\n        for i, j in tmp:\n            for x, y in (i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1):\n                if 0 <= x < n and 0 <= y < n and dis[x][y] < 0:\n                    q.append((x, y))\n                    dis[x][y] = len(groups)\n        groups.append(q) \n    fa = list(range(n * n))\n    def find(x: int) -> int:\n        if fa[x] != x:\n            fa[x] = find(fa[x])\n        return fa[x]\n    for d in range(len(groups) - 2, 0, -1):\n        for i, j in groups[d]:\n            for x, y in (i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1):\n                if 0 <= x < n and 0 <= y < n and dis[x][y] >= dis[i][j]:\n                    fa[find(x * n + y)] = find(i * n + j)\n        if find(0) == find(n * n - 1):\n            return d\n    return 0", "entry_point": "maximumSafenessFactor", "test_list": ["assert maximumSafenessFactor([[1,0,0],[0,0,0],[0,0,1]]) == 0", "assert maximumSafenessFactor([[0,0,1],[0,0,0],[0,0,0]]) == 2", "assert maximumSafenessFactor([[0,0,0,1],[0,0,0,0],[0,0,0,0],[1,0,0,0]]) == 2"]}
{"Contest id": "357/2811", "text_name": "判断是否能拆分数组", "text": "给你一个长度为 n 的数组 nums 和一个整数 m 。请你判断能否执行一系列操作，将数组拆分成 n 个非空数组。\n在每一步操作中，你可以选择一个长度至少为 2 的现有数组（之前步骤的结果） 并将其拆分成 2 个子数组，而得到的每个子数组，至少需要满足以下条件之一：\n子数组的长度为 1 ，或者子数组元素之和 大于或等于 m 。\n如果你可以将给定数组拆分成 n 个满足要求的数组，返回 true ；否则，返回 false 。\n注意：子数组是数组中的一个连续非空元素序列。", "canonical_solution": "def canSplitArray(nums, m):\n    n = len(nums)\n    if n <= 2:\n        return True\n    if nums[0] + nums[1] >= m or nums[n - 1] + nums[n - 2] >= m:\n        return True\n    for i in range(1, n - 1):\n        if nums[i] + nums[i + 1] >= m:\n            return True\n    return False", "entry_point": "canSplitArray", "test_list": ["assert canSplitArray(nums = [2, 2, 1], m = 4) == True", "assert canSplitArray(nums = [2, 1, 3], m = 5) == False", "assert canSplitArray(nums = [2, 3, 3, 2, 3], m = 6) == True"]}
{"Contest id": "357/2810", "text_name": "故障键盘", "text": "你的笔记本键盘存在故障，每当你在上面输入字符 'i' 时，它会反转你所写的字符串。而输入其他字符则可以正常工作。\n给你一个下标从 0 开始的字符串 s ，请你用故障键盘依次输入每个字符。\n返回最终笔记本屏幕上输出的字符串。", "canonical_solution": "def finalString(s):\n    import collections\n    d = collections.deque()\n    cnt = s.count('i') % 2\n    for c in s:\n        if c == 'i':\n            cnt ^= 1\n        else:\n            d.appendleft(c) if cnt else d.append(c)\n    return \"\".join(d)", "entry_point": "finalString", "test_list": ["assert finalString(\"string\") == \"rtsng\"", "assert finalString(\"poiinter\") == \"ponter\""]}
{"Contest id": "Bi110/2809", "text_name": "使数组和小于等于 x 的最少时间\n", "text": "给你两个长度相等下标从 0 开始的整数数组 nums1 和 nums2 。每一秒，对于所有下标 0 <= i < nums1.length ，nums1[i] 的值都增加 nums2[i] 。操作 完成后 ，你可以进行如下操作：\n选择任一满足 0 <= i < nums1.length 的下标 i ，并使 nums1[i] = 0 。\n同时给你一个整数 x 。\n请你返回使 nums1 中所有元素之和 小于等于 x 所需要的 最少 时间，如果无法实现，那么返回 -1 。", "canonical_solution": "def minimumTime(A, B, x):\n    n = len(A)\n    dp = [0] * (n + 1)\n    for j, (b, a) in enumerate(sorted(zip(B, A)), 1):\n        for i in range(j, 0, -1):\n            dp[i] = max(dp[i], dp[i - 1] + i * b + a)\n    sa, sb = sum(A), sum(B)\n    for i in range(0, n + 1):\n        if sb * i + sa - dp[i] <= x:\n            return i\n    return -1", "entry_point": "minimumTime", "test_list": ["assert minimumTime([1,2,3], [1,2,3], 4) == 3", "assert minimumTime([1,2,3], [3,3,3], 4) == -1"]}
{"Contest id": "Bi110/2808", "text_name": "使循环数组所有元素相等的最少秒数\n", "text": "给你一个下标从 0 开始长度为 n 的数组 nums 。\n每一秒，你可以对数组执行以下操作：\n对于范围在 [0, n - 1] 内的每一个下标 i ，将 nums[i] 替换成 nums[i] ，nums[(i - 1 + n) % n] 或者 nums[(i + 1) % n] 三者之一。\n注意，所有元素会被同时替换。\n请你返回将数组 nums 中所有元素变成相等元素所需要的最少秒数。", "canonical_solution": "def minimumSeconds(nums):\n   data = defaultdict(list)\n   for i, v in enumerate(nums):\n       data[v].append(i)\n   res = len(nums) + 1\n   for k, v in data.items():\n       curr_max = (v[0] + len(nums) - v[-1]) // 2;\n       for i in range(1, len(v)):\n           curr_max = max(curr_max, (v[i] - v[i - 1]) // 2)\n       res = min(res, curr_max)\n   return res", "entry_point": "minimumSeconds", "test_list": ["assert minimumSeconds([1,2,1,2]) == 1", "assert minimumSeconds([2,1,3,3,2]) == 2", "assert minimumSeconds([5,5,5,5]) == 0"]}
{"Contest id": "Bi110/2806", "text_name": "取整购买后的账户余额\n", "text": "一开始，你的银行账户里有 100 块钱。\n给你一个整数purchaseAmount ，它表示你在一次购买中愿意支出的金额。\n在一个商店里，你进行一次购买，实际支出的金额会向 最近 的 10 的 倍数 取整。换句话说，你实际会支付一个 非负 金额 roundedAmount ，满足 roundedAmount 是 10 的倍数且 abs(roundedAmount - purchaseAmount) 的值最小 。\n如果存在多于一个最接近的 10 的倍数，较大的倍数 是你的实际支出金额。\n请你返回一个整数，表示你在愿意支出金额为 purchaseAmount 块钱的前提下，购买之后剩下的余额。\n注意： 0 也是 10 的倍数。", "canonical_solution": "def accountBalanceAfterPurchase(purchaseAmount):\n    purchaseAmount = ((purchaseAmount - 5) // 10 ) * 10 + 10\n    result = 100 - purchaseAmount\n    return result", "entry_point": "accountBalanceAfterPurchase", "test_list": ["assert accountBalanceAfterPurchase(9) == 90", "assert accountBalanceAfterPurchase(15) == 80"]}
{"Contest id": "356/2801", "text_name": "统计范围内的步进数字数目", "text": "给你两个正整数 low 和 high ，都用字符串表示，请你统计闭区间 [low, high] 内的 步进数字数目。\n如果一个整数相邻数位之间差的绝对值都 恰好 是 1 ，那么这个数字被称为步进数字 。\n请你返回一个整数，表示闭区间 [low, high] 之间步进数字的数目。\n由于答案可能很大，请你将它对 109 + 7 取余后返回。\n注意：步进数字不能有前导 0 。", "canonical_solution": "def countSteppingNumbers(low, high):\n   mod = 10**9 + 7\n   def solve(high):\n       def dp(idx, tight, last, nz):\n           if idx == len(high): return 1\n           ans = 0\n           h = 10 if not tight else int(high[idx]) + 1\n           for i in range(h):\n               if not nz or abs(i - last) == 1:\n                  ans += dp(idx + 1, 1 if (tight and i == int(high[idx])) else 0, i, nz | (i != 0))\n                  ans %= mod\n               ans %= mod\n           return ans\n       return dp(0, 1, 0, 0)\n   return (solve(high) - solve(str(int(low) - 1))) % mod", "entry_point": "countSteppingNumbers", "test_list": ["assert countSteppingNumbers(low = \"1\", high = \"11\") == 10", "assert countSteppingNumbers(low = \"90\", high = \"101\") == 2"]}
{"Contest id": "356/2800", "text_name": "包含三个字符串的最短字符串\n", "text": "给你三个字符串 a ，b 和 c ， 你的任务是找到长度最短的字符串，且这三个字符串都是它的子字符串 。\n如果有多个这样的字符串，请你返回字典序最小的一个。\n请你返回满足题目要求的字符串。\n注意：\n两个长度相同的字符串 a 和 b ，如果在第一个不相同的字符处，a 的字母在字母表中比 b 的字母靠前 ，那么字符串 a 比字符串 b 字典序小 。\n子字符串是一个字符串中一段连续的字符序列。\n", "canonical_solution": "def minimumString(a, b, c):\n   from itertools import permutations\n   def f(a, b):\n       if b in a: return a\n       for k in range(len(a), -1, -1):\n           if a.endswith(b[:k]):\n               return a + b[k:]\n   return min((f(f(a,b), c) for a,b,c in permutations((a,b,c))), key=lambda a: (len(a), a))", "entry_point": "minimumString", "test_list": ["assert minimumString(a = \"abc\", b = \"bca\", c = \"aaa\") == \"aaabca\"", "assert minimumString(a = \"ab\", b = \"ba\", c = \"aba\") == \"aba\""]}
{"Contest id": "356/2799", "text_name": "统计完全子数组的数目", "text": "给你一个由正整数组成的数组 nums 。\n如果数组中的某个子数组满足下述条件，则称之为完全子数组 ：\n子数组中不同元素的数目等于整个数组不同元素的数目。\n返回数组中完全子数组的数目。\n子数组是数组中的一个连续非空序列。", "canonical_solution": "def countCompleteSubarrays(A):\n   from collections import Counter\n   n, k = len(A), len(set(A))\n   res = i = 0\n   count = Counter()\n   for j in range(n):\n       count[A[j]] += 1\n       while len(count) == k:\n           count[A[i]] -= 1\n           if count[A[i]] == 0:\n               del count[A[i]]\n           i += 1\n       res += i\n   return res", "entry_point": "countCompleteSubarrays", "test_list": ["assert countCompleteSubarrays([1,3,1,2,2]) == 4", "assert countCompleteSubarrays([5,5,5,5]) == 10"]}
{"Contest id": "356/2798", "text_name": "满足目标工作时长的员工数目", "text": "公司里共有 n 名员工，按从 0 到 n - 1 编号。每个员工 i 已经在公司工作了 hours[i] 小时。\n公司要求每位员工工作 至少 target 小时。\n给你一个下标从 0 开始、长度为 n 的非负整数数组 hours 和一个非负整数 target 。\n请你用整数表示并返回工作至少 target 小时的员工数。", "canonical_solution": "def numberOfEmployeesWhoMetTarget(hours, target):\n  ans = 0\n  for h in hours:\n      if h >= target:\n          ans += 1\n  return ans", "entry_point": "numberOfEmployeesWhoMetTarget", "test_list": ["assert numberOfEmployeesWhoMetTarget(hours = [0,1,2,3,4], target = 2) == 3", "assert numberOfEmployeesWhoMetTarget(hours = [5,1,4,2,2], target = 6) == 0"]}
{"Contest id": "355/2791", "text_name": "树中可以形成回文的路径数", "text": "给你一棵树（即一个连通、无向且无环的图），根节点为 0 ，由编号从 0 到 n - 1 的 n 个节点组成。这棵树用一个长度为 n 、下标从 0 开始的数组 parent 表示，其中 parent[i] 为节点 i 的父节点，由于节点 0 为根节点，所以 parent[0] == -1 。\n另给你一个长度为 n 的字符串 s ，其中 s[i] 是分配给 i 和 parent[i] 之间的边的字符。s[0] 可以忽略。\n找出满足 u < v ，且从 u 到 v 的路径上分配的字符可以重新排列形成回文的所有节点对 (u, v) ，并返回节点对的数目。\n如果一个字符串正着读和反着读都相同，那么这个字符串就是一个回文 。", "canonical_solution": "def countPalindromePaths(parent, s):\n   from collections import Counter\n   def f(i):\n       return f(parent[i]) ^ (1 << (ord(s[i]) - ord('a'))) if i else 0\n   count = Counter()\n   res = 0\n   for i in range(len(parent)):\n       v = f(i)\n       res += count[v] + sum(count[v ^ (1 << j)] for j in range(26))\n       count[v] += 1\n   return res", "entry_point": "countPalindromePaths", "test_list": ["assert countPalindromePaths(parent = [-1,0,0,1,1,2], s = \"acaabc\") == 8", "assert countPalindromePaths(parent = [-1,0,0,0,0], s = \"aaaaa\") == 10"]}
{"Contest id": "355/2790", "text_name": "长度递增组的最大数目", "text": "给你一个下标从 0 开始、长度为 n 的数组 usageLimits 。\n你的任务是使用从 0 到 n - 1 的数字创建若干组，并确保每个数字 i 在 所有组中使用的次数总共不超过 usageLimits[i] 次。此外，还必须满足以下条件：\n每个组必须由不同的数字组成，也就是说，单个组内不能存在重复的数字。\n每个组（除了第一个）的长度必须严格大于前一个组。\n在满足所有条件的情况下，以整数形式返回可以创建的最大组数。\n", "canonical_solution": "def maxIncreasingGroups(A):\n   A.sort()\n   total = k = 0\n   for a in A:\n       total += a\n       if total >= (k + 1) * (k + 2) // 2:\n           k += 1\n   return k", "entry_point": "maxIncreasingGroups", "test_list": ["assert maxIncreasingGroups([1,2,5]) == 3", "assert maxIncreasingGroups([2,1,2]) == 2", "assert maxIncreasingGroups([1,1]) == 1"]}
{"Contest id": "355/2789", "text_name": "合并后数组中的最大元素", "text": "给你一个下标从 0 开始、由正整数组成的数组 nums 。\n你可以在数组上执行下述操作任意次：\n选中一个同时满足 0 <= i < nums.length - 1 和 nums[i] <= nums[i + 1] 的整数 i 。将元素 nums[i + 1] 替换为 nums[i] + nums[i + 1] ，并从数组中删除元素 nums[i] 。\n返回你可以从最终数组中获得的最大元素的值。", "canonical_solution": "def maxArrayValue(nums):\n   stack = []\n   for n in reversed(nums):\n       while stack and stack[-1] >= n:\n           n += stack.pop()\n       stack.append(n)\n   return stack[-1]", "entry_point": "maxArrayValue", "test_list": ["assert maxArrayValue([2,3,7,9,3]) == 21", "assert maxArrayValue([5,3,3]) == 11"]}
{"Contest id": "355/2788", "text_name": "按分隔符拆分字符串", "text": "给你一个字符串数组 words 和一个字符 separator ，请你按 separator 拆分 words 中的每个字符串。\n返回一个由拆分后的新字符串组成的字符串数组，不包括空字符串 。\n注意separator 用于决定拆分发生的位置，但它不包含在结果字符串中。\n拆分可能形成两个以上的字符串。\n结果字符串必须保持初始相同的先后顺序。\n", "canonical_solution": "def splitWordsBySeparator(words, separator):\n   ans = []\n   for word in words:\n       for i in word.split(separator):\n           if i:\n               ans.append(i)\n   return ans", "entry_point": "splitWordsBySeparator", "test_list": ["assert splitWordsBySeparator(words = [\"one.two.three\",\"four.five\",\"six\"], separator = \".\") == [\"one\",\"two\",\"three\",\"four\",\"five\",\"six\"]", "assert splitWordsBySeparator(words = [\"$easy$\",\"$problem$\"], separator = \"$\") == [\"easy\",\"problem\"]", "assert splitWordsBySeparator(words = [\"|||\"], separator = \"|\") == []"]}
{"Contest id": "Bi109/2787", "text_name": "将一个数字表示成幂的和的方案数", "text": "给你两个正整数 n 和 x 。\n请你返回将 n 表示成一些互不相同正整数的 x 次幂之和的方案数。换句话说，你需要返回互不相同整数 [n1, n2, ..., nk] 的集合数目，满足 n = n1x + n2x + ... + nkx 。\n由于答案可能非常大，请你将它对 109 + 7 取余后返回。\n比方说，n = 160 且 x = 3 ，一个表示 n 的方法是 n = 23 + 33 + 53 。", "canonical_solution": "def numberOfWays(n, x):\n   nums = []\n   n1, num = 1, 1\n   while num <= n:\n       nums.append(num)\n       n1 += 1\n       num = n1 ** x\n   def findSum(i, currentSum, memo):\n       if (i, currentSum) in memo:\n           return memo[(i, currentSum)]\n       if currentSum == n:\n           return 1\n       if currentSum > n or i >= len(nums):\n           return 0\n       take = findSum(i+1, currentSum + nums[i], memo)\n       dontTake = findSum(i+1, currentSum, memo)\n       memo[(i, currentSum)] = take + dontTake\n       return memo[(i, currentSum)]\n   return findSum(0, 0, {}) % (10 ** 9 + 7)", "entry_point": "numberOfWays", "test_list": ["assert numberOfWays(n = 10, x = 2) == 1", "assert numberOfWays(n = 4, x = 1) == 2"]}
{"Contest id": "Bi109/2786", "text_name": "访问数组中的位置使分数最大", "text": "给你一个下标从 0 开始的整数数组 nums 和一个正整数 x 。\n你一开始 在数组的位置 0 处，你可以按照下述规则访问数组中的其他位置：\n如果你当前在位置 i ，那么你可以移动到满足 i < j 的任意位置 j 。\n对于你访问的位置 i ，你可以获得分数 nums[i] 。\n如果你从位置 i 移动到位置 j 且 nums[i] 和 nums[j] 的奇偶性不同，那么你将失去分数 x 。\n请你返回你能得到的最大得分之和。\n注意，你一开始的分数为 nums[0] 。", "canonical_solution": "def maxScore(nums, x):\n  dp = [-x, -x]\n  dp[nums[0] & 1] = nums[0]\n  for i in range(1, len(nums)):\n      dp[nums[i] & 1] = max(dp[nums[i] & 1], dp[nums[i] & 1 ^ 1] - x) + nums[i]\n  return max(dp)", "entry_point": "maxScore", "test_list": ["assert maxScore(nums = [2,3,6,1,9,2], x = 5) == 13", "assert maxScore(nums = [2,4,6,8], x = 3) == 20"]}
{"Contest id": "Bi109/2785", "text_name": "将字符串中的元音字母排序", "text": "给你一个下标从 0 开始的字符串 s ，将 s 中的元素重新排列得到新的字符串 t ，它满足：\n所有辅音字母都在原来的位置上。更正式的，如果满足 0 <= i < s.length 的下标 i 处的 s[i] 是个辅音字母，那么 t[i] = s[i] 。\n元音字母都必须以他们的 ASCII 值按非递减顺序排列。更正式的，对于满足 0 <= i < j < s.length 的下标 i 和 j  ，如果 s[i] 和 s[j] 都是元音字母，那么 t[i] 的 ASCII 值不能大于 t[j] 的 ASCII 值。\n请你返回结果字母串。\n元音字母为 'a' ，'e' ，'i' ，'o' 和 'u' ，它们可能是小写字母也可能是大写字母，辅音字母是除了这 5 个字母以外的所有字母。", "canonical_solution": "def sortVowels(s):\n   vow = []\n   pos = []\n   for i, ch in enumerate(s):\n       if ch.lower() in {'a', 'e', 'i', 'o', 'u'}:\n           vow.append(ch)\n           pos.append(i)\n   vow.sort()\n   answer = list(s)\n   for i, v in zip(pos, vow):\n       answer[i] = v\n   return ''.join(answer)", "entry_point": "sortVowels", "test_list": ["assert sortVowels(\"lEetcOde\") == \"lEOtcede\"", "assert sortVowels(\"lYmpH\") == \"lYmpH\""]}
{"Contest id": "Bi109/2784", "text_name": "检查数组是否是好的", "text": "给你一个整数数组 nums ，如果它是数组 base[n] 的一个排列，我们称它是个好数组。\nbase[n] = [1, 2, ..., n - 1, n, n] （换句话说，它是一个长度为 n + 1 且包含 1 到 n - 1 恰好各一次，包含 n  两次的一个数组）。比方说，base[1] = [1, 1] ，base[3] = [1, 2, 3, 3] 。\n如果数组是一个好数组，请你返回 true ，否则返回 false 。\n注意：数组的排列是这些数字按任意顺序排布后重新得到的数组。", "canonical_solution": "def isGood(v):\n  n = len(v)\n  mx = max(v)\n  s = set(v)\n  flag = True\n  k = 1\n  for x in s:\n      if x == k:\n          k += 1\n      else:\n          flag = False\n          break\n  ct = v.count(mx)\n  if n == mx + 1 and ct == 2 and flag:\n      return True\n  else:\n      return False", "entry_point": "isGood", "test_list": ["assert isGood([2, 1, 3]) == False", "assert isGood([1, 3, 3, 2]) == True", "assert isGood([1, 1]) == True", "assert isGood([3, 4, 4, 1, 2, 1]) == False"]}
{"Contest id": "354/2781", "text_name": "最长合法子字符串的长度", "text": "给你一个字符串 word 和一个字符串数组 forbidden 。\n如果一个字符串不包含 forbidden 中的任何字符串，我们称这个字符串是合法的。\n请你返回字符串 word 的一个最长合法子字符串的长度。\n子字符串指的是一个字符串中一段连续的字符，它可以为空。", "canonical_solution": "def longestValidSubstring(word, forbidden):\n   length = 0\n   all = set()\n   for s in forbidden:\n       all.add(s)\n       length = max(length, len(s))\n   n = len(word)\n   r = 0\n   right = n\n   for i in range(n - 1, -1, -1):\n       if right <= r:\n           break\n       now = 0\n       temp = ''\n       for j in range(i, min(right, i + length)):\n           temp += word[j]\n           if temp in all:\n               right = j\n               break\n       r = max(r, right - i)\n   return r", "entry_point": "longestValidSubstring", "test_list": ["assert longestValidSubstring(word = \"cbaaaabc\", forbidden = [\"aaa\",\"cb\"]) == 4", "assert longestValidSubstring(word = \"leetcode\", forbidden = [\"de\",\"le\",\"e\"]) == 4"]}
{"Contest id": "354/2780", "text_name": "合法分割的最小下标", "text": "如果元素 x 在长度为 m 的整数数组 arr 中满足 freq(x) * 2 > m ，那么我们称 x 是支配元素 。其中 freq(x) 是 x 在数组 arr 中出现的次数。注意，根据这个定义，数组 arr 最多只会有一个支配元素。\n给你一个下标从 0 开始长度为 n 的整数数组 nums ，数据保证它含有一个支配元素。\n你需要在下标 i 处将 nums 分割成两个数组 nums[0, ..., i] 和 nums[i + 1, ..., n - 1] ，如果一个分割满足以下条件，我们称它是合法的：\n0 <= i < n - 1\nnums[0, ..., i] 和 nums[i + 1, ..., n - 1] 的支配元素相同。\n这里， nums[i, ..., j] 表示 nums 的一个子数组，它开始于下标 i ，结束于下标 j ，两个端点都包含在子数组内。特别地，如果 j < i ，那么 nums[i, ..., j] 表示一个空数组。\n请你返回一个合法分割的最小下标。如果合法分割不存在，返回 -1 。", "canonical_solution": "def minimumIndex(nums):\n   l = dict()\n   r = dict()\n   n = len(nums)\n   for i in range(n):\n       r[nums[i]] = r.get(nums[i], 0) + 1\n   ans = -1\n   for i in range(n-1):\n       l[nums[i]] = l.get(nums[i], 0) + 1\n       r[nums[i]] = r[nums[i]] - 1\n       if l[nums[i]]*2>(i+1) and r[nums[i]]*2>(n-(i+1)):\n           ans = i\n           break\n   return ans", "entry_point": "minimumIndex", "test_list": ["assert minimumIndex([1,2,2,2]) == 2", "assert minimumIndex([2,1,3,1,1,1,7,1,2,1]) == 4", "assert minimumIndex([3,3,3,3,7,2,2]) == -1"]}
{"Contest id": "354/2779", "text_name": "数组的最大美丽值", "text": "给你一个下标从 0 开始的整数数组 nums 和一个非负整数 k 。\n在一步操作中，你可以执行下述指令：\n在范围 [0, nums.length - 1] 中选择一个此前没有选过 的下标 i 。\n将 nums[i] 替换为范围 [nums[i] - k, nums[i] + k] 内的任一整数。\n数组的美丽值定义为数组中由相等元素组成的最长子序列的长度。\n对数组 nums 执行上述操作任意次后，返回数组可能取得的 最大 美丽值。\n注意：你只能对每个下标执行 一次此操作。\n数组的子序列定义是：经由原数组删除一些元素（也可能不删除）得到的一个新数组，且在此过程中剩余元素的顺序不发生改变。\n ", "canonical_solution": "def maximumBeauty(A, k):\n  A.sort()\n  i = 0\n  for j in range(len(A)):\n      if A[j] - A[i] > k * 2:\n          i += 1\n  return j - i + 1", "entry_point": "maximumBeauty", "test_list": ["assert maximumBeauty([4,6,1,2], 2) == 3", "assert maximumBeauty([1,1,1,1], 10) == 4"]}
{"Contest id": "354/2778", "text_name": "特殊元素平方和", "text": "给你一个下标从 1 开始、长度为 n 的整数数组 nums 。\n对 nums 中的元素 nums[i] 而言，如果 n 能够被 i 整除，即 n % i == 0 ，则认为 num[i] 是一个特殊元素 。\n返回 nums 中所有特殊元素的平方和 。", "canonical_solution": "def sumOfSquares(nums):\n   n = len(nums)\n   cound = []\n   for l  in range(2): \n       for i in range(1, n + 1):\n           if n % i == 0: \n               cound.append(nums[i-1])\n   sorted_list = sorted(cound) \n   return sum([sorted_list[i] * sorted_list[i+1] for i in range(0, len(sorted_list)-1, 2)])", "entry_point": "sumOfSquares", "test_list": ["assert sumOfSquares([1,2,3,4]) == 21", "assert sumOfSquares([2,7,1,19,18,3]) == 63"]}
{"Contest id": "353/2772", "text_name": "使数组中的所有元素都等于零", "text": "给你一个下标从 0 开始的整数数组 nums 和一个正整数 k 。\n你可以对数组执行下述操作任意次 ：\n从数组中选出长度为 k 的 任一子数组，并将子数组中每个元素都减去1 。\n如果你可以使数组中的所有元素都等于 0 ，返回 true ；否则，返回 false 。\n子数组是数组中的一个非空连续元素序列。\n", "canonical_solution": "def checkArray(A, k):\n   cur = 0\n   for i, a in enumerate(A):\n       if cur > a:\n           return False\n       A[i], cur = a - cur, a\n       if i >= k - 1:\n           cur -= A[i - k + 1]\n   return cur == 0", "entry_point": "checkArray", "test_list": ["assert checkArray(A = [2,2,3,1,1,0], k = 3) == True", "assert checkArray(A = [1,3,1,1], k = 2) == False"]}
{"Contest id": "353/2771", "text_name": "构造最长非递减子数组", "text": "给你两个下标从 0 开始的整数数组 nums1 和 nums2 ，长度均为 n 。\n让我们定义另一个下标从 0 开始、长度为 n 的整数数组，nums3 。对于范围 [0, n - 1] 的每个下标 i ，你可以将 nums1[i] 或 nums2[i] 的值赋给 nums3[i] 。\n你的任务是使用最优策略为 nums3 赋值，以最大化 nums3 中最长非递减子数组的长度。\n以整数形式表示并返回 nums3 中 最长非递减子数组的长度。\n注意：子数组是数组中的一个连续非空元素序列。", "canonical_solution": "def maxNonDecreasingLength(A, B):\n   res = dp1 = dp2 = 1\n   for i in range(1, len(A)):\n       t11 = dp1 + 1 if A[i - 1] <= A[i] else 1\n       t12 = dp1 + 1 if A[i - 1] <= B[i] else 1\n       t21 = dp2 + 1 if B[i - 1] <= A[i] else 1\n       t22 = dp2 + 1 if B[i - 1] <= B[i] else 1\n       dp1 = max(t11, t21)\n       dp2 = max(t12, t22)\n       res = max(res, dp1, dp2)\n   return res", "entry_point": "maxNonDecreasingLength", "test_list": ["assert maxNonDecreasingLength([2,3,1], [1,2,1]) == 2", "assert maxNonDecreasingLength([1,3,2,1], [2,2,3,4]) == 4", "assert maxNonDecreasingLength([1,1], [2,2]) == 2"]}
{"Contest id": "353/2770", "text_name": "达到末尾下标所需的最大跳跃次数", "text": "给你一个下标从 0 开始、由 n 个整数组成的数组 nums 和一个整数 target 。\n你的初始位置在下标 0 。在一步操作中，你可以从下标 i 跳跃到任意满足下述条件的下标 j ：\n0 <= i < j < n\n-target <= nums[j] - nums[i] <= target\n返回到达下标 n - 1 处所需的最大跳跃次数 。\n如果无法到达下标 n - 1 ，返回 -1 。", "canonical_solution": "def maximumJumps(nums, target):\n   n = len(nums)\n   dp = [-1] * n\n   dp[-1] = 0\n   for i in range(n-2, -1, -1):\n       for j in range(i+1, n):\n           if abs(nums[i]-nums[j]) <= target and dp[j] != -1:\n               dp[i] = max(dp[i], 1+dp[j])\n   return dp[0]", "entry_point": "maximumJumps", "test_list": ["assert maximumJumps(nums = [1,3,6,4,1,2], target = 2) == 3", "assert maximumJumps(nums = [1,3,6,4,1,2], target = 3) == 5", "assert maximumJumps(nums = [1,3,6,4,1,2], target = 0) == -1"]}
{"Contest id": "353/2769", "text_name": "找出最大的可达成数字\n", "text": "给你两个整数 num 和 t 。\n如果整数 x 可以在执行下述操作不超过 t 次的情况下变为与 num 相等，则称其为可达成数字 ：\n每次操作将 x 的值增加或减少 1 ，同时可以选择将 num 的值增加或减少 1 。\n返回所有可达成数字中的最大值。可以证明至少存在一个可达成数字。", "canonical_solution": "def theMaximumAchievableX(num, t):\n    return num+2*t", "entry_point": "theMaximumAchievableX", "test_list": ["assert theMaximumAchievableX(num = 4, t = 1) == 6", "assert theMaximumAchievableX(num = 3, t = 2) == 7"]}
{"Contest id": "Bi108/2768", "text_name": "黑格子的数目", "text": "给你两个整数 m 和 n ，表示一个下标从 0 开始的 m x n 的网格图。\n给你一个下标从 0 开始的二维整数矩阵 coordinates ，其中 coordinates[i] = [x, y] 表示坐标为 [x, y] 的格子是黑色的 ，所有没出现在 coordinates 中的格子都是白色的。\n一个块定义为网格图中 2 x 2 的一个子矩阵。更正式的，对于左上角格子为 [x, y] 的块，其中 0 <= x < m - 1 且 0 <= y < n - 1 ，包含坐标为 [x, y] ，[x + 1, y] ，[x, y + 1] 和 [x + 1, y + 1] 的格子。\n请你返回一个下标从 0 开始长度为 5 的整数数组 arr ，arr[i] 表示恰好包含 i 个黑色 格子的块的数目。\n \n", "canonical_solution": "def countBlackBlocks(m, n, coordinates):\n   from collections import Counter\n   from itertools import product\n   cnt = Counter()\n   res = [(n - 1) * (m - 1), 0, 0, 0, 0]\n   for i, j in coordinates:\n       for i, j in product([i, i + 1], [j, j + 1]):\n           res[cnt[i, j]] -= 1\n           cnt[i, j] += 0 < i < m and 0 < j < n\n           res[cnt[i, j]] += 1\n   return res", "entry_point": "countBlackBlocks", "test_list": ["assert countBlackBlocks(m = 3, n = 3, coordinates = [[0,0]]) == [3,1,0,0,0]", "assert countBlackBlocks(m = 3, n = 3, coordinates = [[0,0],[1,1],[0,2]]) == [0,2,2,0,0]"]}
{"Contest id": "Bi108/2767", "text_name": "将字符串分割为最少的美丽子字符串", "text": "给你一个二进制字符串 s ，你需要将字符串分割成一个或者多个子字符串 ，使每个子字符串都是美丽的。\n如果一个字符串满足以下条件，我们称它是美丽的：\n它不包含前导 0 。\n它是 5 的幂的二进制表示。\n请你返回分割后的子字符串的最少数目。如果无法将字符串 s 分割成美丽子字符串，请你返回 -1 。\n子字符串是一个字符串中一段连续的字符序列。\n", "canonical_solution": "def minimumBeautifulSubstrings(s):\n  n = len(s)\n  dp = [0] + [float('inf')] * n\n  for i in range(n):\n      if s[i] == '1':\n          cur = 0\n          for j in range(i, n):\n              cur = cur * 2 + int(s[j])\n              if 15625 % cur == 0:\n                 dp[j + 1] = min(dp[j + 1], dp[i] + 1)\n  return dp[n] if dp[n] < float('inf') else -1", "entry_point": "minimumBeautifulSubstrings", "test_list": ["assert minimumBeautifulSubstrings(\"1011\") == 2", "assert minimumBeautifulSubstrings(\"111\") == 3", "assert minimumBeautifulSubstrings(\"0\") == -1"]}
{"Contest id": "Bi108/2766", "text_name": "重新放置石块", "text": "给你一个下标从 0 开始的整数数组 nums ，表示一些石块的初始位置。再给你两个长度相等下标从 0 开始的整数数组 moveFrom 和 moveTo 。\n在 moveFrom.length 次操作内，你可以改变石块的位置。在第 i 次操作中，你将位置在 moveFrom[i] 的所有石块移到位置 moveTo[i] 。\n完成这些操作后，请你按升序返回所有有石块的位置。\n注意：\n如果一个位置至少有一个石块，我们称这个位置有石块。一个位置可能会有多个石块。", "canonical_solution": "def relocateMarbles(nums, moveFrom, moveTo):\n   nums = set(nums)\n   for start, end in zip(moveFrom, moveTo):\n       nums.discard(start)\n       nums.add(end)\n   return sorted(nums)", "entry_point": "relocateMarbles", "test_list": ["assert relocateMarbles(nums = [1,6,7,8], moveFrom = [1,7,2], moveTo = [2,9,5]) == [5,6,8,9]", "assert relocateMarbles(nums = [1,1,3,3], moveFrom = [1,3], moveTo = [2,2]) == [2]"]}
{"Contest id": "Bi108/2765", "text_name": "最长交替子数组", "text": "给你一个下标从 0 开始的整数数组 nums 。如果 nums 中长度为 m 的子数组 s 满足以下条件，我们称它是一个交替子数组 ：\nm 大于 1 。\ns1 = s0 + 1 。\n下标从 0 开始的子数组 s 与数组 [s0, s1, s0, s1,...,s(m-1) % 2] 一样。也就是说，s1 - s0 = 1 ，s2 - s1 = -1 ，s3 - s2 = 1 ，s4 - s3 = -1 ，以此类推，直到 s[m - 1] - s[m - 2] = (-1)m 。\n请你返回 nums 中所有交替子数组中，最长的长度，如果不存在交替子数组，请你返回 -1 。\n子数组是一个数组中一段连续非空的元素序列。", "canonical_solution": "def alternatingSubarray(A):\n  n = len(A)\n  res = dp = -1\n  for i in range(1, n):\n      if dp > 0 and A[i] == A[i - 2]:\n          dp += 1\n      else:\n          dp = 2 if A[i] == A[i - 1] + 1 else -1\n      res = max(res, dp)\n  return res", "entry_point": "alternatingSubarray", "test_list": ["assert alternatingSubarray([2,3,4,3,4]) == 4", "assert alternatingSubarray([4,5,6]) == 2"]}
{"Contest id": "352/2763", "text_name": "所有子数组中不平衡数字之和", "text": "一个长度为 n 下标从 0 开始的整数数组 arr 的 不平衡数字 定义为，在 sarr = sorted(arr) 数组中，满足以下条件的下标数目：\n0 <= i < n - 1 ，和\nsarr[i+1] - sarr[i] > 1\n这里，sorted(arr) 表示将数组 arr 排序后得到的数组。\n给你一个下标从 0 开始的整数数组 nums ，请你返回它所有子数组的不平衡数字之和。\n子数组指的是一个数组中连续一段非空的元素序列。\n", "canonical_solution": "def sumImbalanceNumbers(nums):\n   n = len(nums)\n   res = 0\n   for i in range(n):\n       s = set()\n       cur = -1\n       for j in range(i, n):\n           cur += 0 if nums[j] in s else 1 - (nums[j] + 1 in s) - (nums[j] - 1 in s)\n           s.add(nums[j])\n           res += cur\n   return res", "entry_point": "sumImbalanceNumbers", "test_list": ["assert sumImbalanceNumbers([2,3,1,4]) == 3", "assert sumImbalanceNumbers([1,3,3,3,5]) == 8"]}
{"Contest id": "352/2762", "text_name": "不间断子数组", "text": "给你一个下标从 0 开始的整数数组 nums 。nums 的一个子数组如果满足以下条件，那么它是不间断的：\ni，i + 1 ，...，j  表示子数组中的下标。对于所有满足 i <= i1, i2 <= j 的下标对，都有 0 <= |nums[i1] - nums[i2]| <= 2 。\n请你返回不间断子数组的总数目。\n子数组是一个数组中一段连续非空的元素序列。", "canonical_solution": "def continuousSubarrays(nums):\n   from collections import deque\n   maxQ = deque()\n   minQ = deque()\n   left = 0\n   res = 0\n   for right in range(len(nums)):\n       while maxQ and nums[maxQ[-1]] < nums[right]:\n           maxQ.pop()\n       maxQ.append(right)\n       while minQ and nums[minQ[-1]] > nums[right]:\n           minQ.pop()\n       minQ.append(right)\n       while nums[maxQ[0]] - nums[minQ[0]] > 2:\n           if maxQ[0] < minQ[0]:\n               left = maxQ[0] + 1\n               maxQ.popleft()\n           else:\n               left = minQ[0] + 1\n               minQ.popleft()\n       res += right - left + 1\n   return res", "entry_point": "continuousSubarrays", "test_list": ["assert continuousSubarrays([5,4,2,4]) == 8", "assert continuousSubarrays([1,2,3]) == 6"]}
{"Contest id": "352/2761", "text_name": "和等于目标值的质数对", "text": "给你一个整数 n 。如果两个整数 x 和 y 满足下述条件，则认为二者形成一个质数对：\n1 <= x <= y <= n\nx + y == n\nx 和 y 都是质数\n请你以二维有序列表的形式返回符合题目要求的所有 [xi, yi] ，列表需要按 xi 的非递减顺序排序。如果不存在符合要求的质数对，则返回一个空数组。\n注意：质数是大于 1 的自然数，并且只有两个因子，即它本身和 1 。", "canonical_solution": "def findPrimePairs(n):\n        prime = [True] * (n + 1) \n        ans = []\n        \n        for i in range(2, n + 1):\n            prime[i] = True\n        \n        prime[1] = False \n        prime[0] = False\n        \n        p = 2\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p * p, n + 1, p):\n                    prime[i] = False\n            p += 1\n        \n        for i in range(2, n):\n            j = n - i \n            if prime[i] and prime[j] and i <= j:\n                temp = [i, j]  \n                ans.append(temp) \n        return ans\n", "entry_point": "findPrimePairs", "test_list": ["assert findPrimePairs(10) == [[3,7],[5,5]]", "assert findPrimePairs(2) == []"]}
{"Contest id": "351/2751", "text_name": "机器人碰撞", "text": "现有 n 个机器人，编号从 1 开始，每个机器人包含在路线上的位置、健康度和移动方向。\n给你下标从 0 开始的两个整数数组 positions、healths 和一个字符串 directions（directions[i] 为 'L' 表示 向左 或 'R' 表示 向右）。positions 中的所有整数 互不相同 。\n所有机器人以相同速度同时沿给定方向在路线上移动。如果两个机器人移动到相同位置，则会发生 碰撞 。\n如果两个机器人发生碰撞，则将健康度较低的机器人从路线中移除 ，并且另一个机器人的健康度减少1 。幸存下来的机器人将会继续沿着与之前相同的方向前进。如果两个机器人的健康度相同，则将二者都从路线中移除。\n请你确定全部碰撞后幸存下的所有机器人的健康度 ，并按照原来机器人编号的顺序排列。即机器人 1 （如果幸存）的最终健康度，机器人 2 （如果幸存）的最终健康度等。 如果不存在幸存的机器人，则返回空数组。\n在不再发生任何碰撞后，请你以数组形式，返回所有剩余机器人的健康度（按机器人输入中的编号顺序）。\n注意：位置  positions 可能是乱序的。", "canonical_solution": "def survivedRobotsHealths(positions, h, directions):\n  n = len(positions)\n  ind = sorted(range(n), key=positions.__getitem__)\n  stack = []\n  for i in ind:\n     if directions[i] == 'R':\n         stack.append(i)\n         continue\n     while stack and h[i] > 0:\n         if h[stack[-1]] < h[i]:\n             h[stack.pop()] = 0\n             h[i] -= 1\n         elif h[stack[-1]] > h[i]:\n             h[stack[-1]] -= 1\n             h[i] = 0\n         else:\n             h[stack.pop()] = 0\n             h[i] = 0\n  return [v for v in h if v > 0]", "entry_point": "survivedRobotsHealths", "test_list": ["assert survivedRobotsHealths([5,4,3,2,1], [2,17,9,15,10], \"RRRRR\") == [2,17,9,15,10]", "assert survivedRobotsHealths([3,5,2,6], [10,10,15,12], \"RLRL\") == [14]", "assert survivedRobotsHealths([1,2,5,6],  [10,10,11,11], \"RLRL\") == []"]}
{"Contest id": "351/2750", "text_name": "将数组划分成若干好子数组的方式", "text": "给你一个二元数组 nums 。\n如果数组中的某个子数组恰好只存在 一 个值为 1 的元素，则认为该子数组是一个好子数组 。\n请你统计将数组 nums 划分成若干 好子数组 的方法数，并以整数形式返回。由于数字可能很大，返回其对 109 + 7 取余之后的结果。\n子数组是数组中的一个连续非空元素序列。", "canonical_solution": "def numberOfGoodSubarraySplits(nums):\n  prev = count = 0\n  for i, num in enumerate(nums):\n      if num == 1:\n          count = max((count * (i - prev)), 1) % (10 ** 9 + 7)\n          prev = i\n  return count", "entry_point": "numberOfGoodSubarraySplits", "test_list": ["assert numberOfGoodSubarraySplits([0,1,0,0,1]) == 3", "assert numberOfGoodSubarraySplits([0,1,0]) == 1"]}
{"Contest id": "351/2749", "text_name": "得到整数零需要执行的最少操作数", "text": "给你两个整数：num1 和 num2 。\n在一步操作中，你需要从范围 [0, 60] 中选出一个整数 i ，并从 num1 减去 2i + num2 。\n请你计算，要想使 num1 等于 0 需要执行的最少操作数，并以整数形式返回。\n如果无法使 num1 等于 0 ，返回 -1 。", "canonical_solution": "def makeTheIntegerZero(num1, num2):\n   for x in range(1, 101):\n       tmp = num1 - x * num2\n       if tmp < 0:\n           continue\n       arr = []\n       for i in range(62):\n           if (1 << i) & tmp != 0:\n               arr.append(1 << i)\n       if len(arr) <= x and sum(arr) >= x:\n           return x\n   return -1", "entry_point": "makeTheIntegerZero", "test_list": ["assert makeTheIntegerZero(num1 = 3, num2 = -2) == 3", "assert makeTheIntegerZero(num1 = 5, num2 = 7) == -1"]}
{"Contest id": "Bi107/2747", "text_name": "统计没有收到请求的服务器数目", "text": "给你一个整数 n ，表示服务器的总数目，再给你一个下标从 0 开始的二维整数数组 logs ，其中 logs[i] = [server_id, time] 表示 id 为 server_id 的服务器在 time 时收到了一个请求。\n同时给你一个整数 x 和一个下标从 0 开始的整数数组 queries  。\n请你返回一个长度等于 queries.length 的数组 arr ，其中 arr[i] 表示在时间区间 [queries[i] - x, queries[i]] 内没有收到请求的服务器数目。\n注意时间区间是个闭区间。", "canonical_solution": "def countServers(n, logs, x, queries):\n  from collections import Counter\n  res, cnt = [0] * len(queries), Counter()\n  i, j, used = 0, 0, 0\n  logs.sort(key=lambda l: l[1])\n  for [t, id] in sorted([t, id] for id, t in enumerate(queries)):\n      while i < len(logs) and logs[i][1] <= t:\n          cnt[logs[i][0]] += 1\n          used += cnt[logs[i][0]] == 1\n          i += 1\n      while j < i and logs[j][1] < t - x:\n          cnt[logs[j][0]] -= 1\n          used -= cnt[logs[j][0]] == 0\n          j += 1\n      res[id] = n - used\n  return res", "entry_point": "countServers", "test_list": ["assert countServers(n = 3, logs = [[1,3],[2,6],[1,5]], x = 5, queries = [10,11]) == [1,2]", "assert countServers(n = 3, logs = [[2,4],[2,1],[1,2],[3,1]], x = 2, queries = [3,4]) == [0,1]"]}
{"Contest id": "Bi107/2746", "text_name": "字符串连接删减字母", "text": "给你一个下标从 0 开始的数组 words ，它包含 n 个字符串。\n定义连接操作 join(x, y) 表示将字符串 x 和 y 连在一起，得到 xy 。如果 x 的最后一个字符与 y 的第一个字符相等，连接后两个字符中的一个会被删除 。\n比方说 join(\"ab\", \"ba\") = \"aba\" ， join(\"ab\", \"cde\") = \"abcde\" 。\n你需要执行 n - 1 次 连接操作。令 str0 = words[0] ，从 i = 1 直到 i = n - 1 ，对于第 i 个操作，你可以执行以下操作之一：\n令 stri = join(stri - 1, words[i])\n令 stri = join(words[i], stri - 1)\n你的任务是使 strn - 1 的长度最小。\n请你返回一个整数，表示 strn - 1 的最小长度。", "canonical_solution": "def minimizeConcatenatedLength(words):\n   n = len(words)\n   def dp(i, last1, first2):\n       if i == n:\n           return 0\n       len1 = len(words[i]) - (last1 == words[i][0])\n       res1 = len1 + dp(i + 1, words[i][-1], first2)\n       len2 = len(words[i]) - (first2 == words[i][-1])\n       res2 = len2 + dp(i + 1, last1, words[i][0])\n       return min(res1, res2)\n   return len(words[0]) + dp(1, words[0][-1], words[0][0])", "entry_point": "minimizeConcatenatedLength", "test_list": ["assert minimizeConcatenatedLength([\"aa\",\"ab\",\"bc\"]) == 4", "assert minimizeConcatenatedLength([\"ab\",\"b\"]) == 2", "assert minimizeConcatenatedLength([\"aaa\",\"c\",\"aba\"]) == 6"]}
{"Contest id": "Bi107/2745", "text_name": "构造最长的新字符串", "text": "给你三个整数 x ，y 和 z 。\n这三个整数表示你有 x 个 \"AA\" 字符串，y 个 \"BB\" 字符串，和 z 个 \"AB\" 字符串。你需要选择这些字符串中的部分字符串（可以全部选择也可以一个都不选择），将它们按顺序连接得到一个新的字符串。新字符串不能包含子字符串 \"AAA\" 或者 \"BBB\" 。\n请你返回新字符串的最大可能长度。\n子字符串是一个字符串中一段连续非空的字符序列。", "canonical_solution": "def longestString(x, y, z):\n   mn = min(x, y)\n   if x == y:\n       return 4 * x + 2 * z\n   else:\n       return 2 * mn + (mn + 1) * 2 + 2 * z", "entry_point": "longestString", "test_list": ["assert longestString(x = 2, y = 5, z = 1) == 12", "assert longestString(x = 3, y = 2, z = 2)  == 14"]}
{"Contest id": "Bi107/2744", "text_name": "最大字符串配对数目", "text": "给你一个下标从 0 开始的数组 words ，数组中包含互不相同的字符串。\n如果字符串 words[i] 与字符串 words[j] 满足以下条件，我们称它们可以匹配：\n字符串 words[i] 等于 words[j] 的反转字符串。\n0 <= i < j < words.length\n请你返回数组 words 中的 最大匹配数目。\n注意，每个字符串最多匹配一次。\n ", "canonical_solution": "def maximumNumberOfStringPairs(words):\n  pairs = 0\n  reverse_dict = {}\n  for word in words:\n      reverse_word = word[::-1]\n      if reverse_word in reverse_dict:\n          pairs += reverse_dict[reverse_word]\n          reverse_dict[reverse_word] += 1\n      else:\n          reverse_dict[word] = 1\n  return pairs", "entry_point": "maximumNumberOfStringPairs", "test_list": ["assert maximumNumberOfStringPairs([\"cd\",\"ac\",\"dc\",\"ca\",\"zz\"]) == 2", "assert maximumNumberOfStringPairs([\"ab\",\"ba\",\"cc\"]) == 1", "assert maximumNumberOfStringPairs([\"aa\",\"ab\"]) == 0"]}
{"Contest id": "350/2742", "text_name": "给墙壁刷油漆", "text": "给你两个长度为 n 下标从 0 开始的整数数组 cost 和 time ，分别表示给 n 堵不同的墙刷油漆需要的开销和时间。你有两名油漆匠：\n一位需要付费的油漆匠，刷第 i 堵墙需要花费 time[i] 单位的时间，开销为 cost[i] 单位的钱。\n一位免费的油漆匠，刷任意 一堵墙的时间为 1 单位，开销为 0 。但是必须在付费油漆匠工作时，免费油漆匠才会工作。\n请你返回刷完 n 堵墙最少开销为多少。", "canonical_solution": "def paintWalls(cost, time):\n   from math import inf\n   n = len(cost)\n   dp = [0] + [inf] * n\n   for c, t in zip(cost, time):\n       for j in range(n, 0, -1):\n           dp[j] = min(dp[j], dp[max(j - t - 1, 0)] + c)\n   return dp[n]", "entry_point": "paintWalls", "test_list": ["assert paintWalls(cost = [1,2,3,2], time = [1,2,3,2]) == 3", "assert paintWalls(cost = [2,3,4,2], time = [1,1,1,1]) == 4"]}
{"Contest id": "350/2741", "text_name": "特别的排列", "text": "给你一个下标从 0 开始的整数数组 nums ，它包含 n 个互不相同的正整数。如果 nums 的一个排列满足以下条件，我们称它是一个特别的排列：\n对于 0 <= i < n - 1 的下标 i ，要么 nums[i] % nums[i+1] == 0 ，要么 nums[i+1] % nums[i] == 0 。\n请你返回特别排列的总数目，由于答案可能很大，请将它对 109 + 7取余后返回。\n", "canonical_solution": "def specialPerm(nums):\n    n, MOD = len(nums), 10**9 + 7\n    def dfs(prev, mask):\n        if mask == (1 << n) - 1: return 1\n        count = 0\n        for i in range(n):\n            if not (mask & (1 << i)) and (nums[i] % prev == 0 or prev % nums[i] == 0):\n                count += dfs(nums[i], mask | (1 << i))\n        return count % MOD\n    return dfs(1, 0)", "entry_point": "specialPerm", "test_list": ["assert specialPerm([2,3,6]) == 2", "assert specialPerm([1,4,3]) == 2"]}
{"Contest id": "350/2740", "text_name": "找出分区值", "text": "给你一个正整数数组 nums 。\n将 nums 分成两个数组：nums1 和 nums2 ，并满足下述条件：\n数组 nums 中的每个元素都属于数组 nums1 或数组 nums2 。\n两个数组都非空 。\n分区值最小 。\n分区值的计算方法是 |max(nums1) - min(nums2)| 。\n其中，max(nums1) 表示数组 nums1 中的最大元素，min(nums2) 表示数组 nums2 中的最小元素。\n返回表示分区值的整数。", "canonical_solution": "def findValueOfPartition(A):\n    A.sort()\n    return min(A[i] - A[i - 1] for i in range(1, len(A)))", "entry_point": "findValueOfPartition", "test_list": ["assert findValueOfPartition([1,3,2,4]) == 1", "assert findValueOfPartition([100,1,10]) == 9"]}
{"Contest id": "350/2739", "text_name": "总行驶距离", "text": "卡车有两个油箱。给你两个整数，mainTank 表示主油箱中的燃料（以升为单位），additionalTank 表示副油箱中的燃料（以升为单位）。\n该卡车每耗费 1 升燃料都可以行驶 10 km。每当主油箱使用了 5 升燃料时，如果副油箱至少有 1 升燃料，则会将 1 升燃料从副油箱转移到主油箱。\n返回卡车可以行驶的最大距离。\n注意：从副油箱向主油箱注入燃料不是连续行为。这一事件会在每消耗 5 升燃料时突然且立即发生。", "canonical_solution": "def distanceTraveled(a, b):\n    return (a + min((a - 1) // 4, b)) * 10", "entry_point": "distanceTraveled", "test_list": ["assert distanceTraveled(a = 5, b = 10) == 60", "assert distanceTraveled(a = 1, b = 2) == 10"]}
{"Contest id": "349/2735", "text_name": "收集巧克力", "text": "给你一个长度为 n、下标从 0 开始的整数数组 nums，nums[i] 表示收集位于下标 i 处的巧克力成本。每个巧克力都对应一个不同的类型，最初，位于下标 i 的巧克力就对应第 i 个类型。\n在一步操作中，你可以用成本 x 执行下述行为：\n同时修改所有巧克力的类型，将巧克力的类型 ith 修改为类型 ((i + 1) mod n)th。\n假设你可以执行任意次操作，请返回收集所有类型巧克力所需的最小成本。", "canonical_solution": "def minCost(A, x):\n  n = len(A)\n  res = [x * k for k in range(n)]\n  for i in range(n):\n      cur = A[i]\n      for k in range(n):\n          cur = min(cur, A[i - k])\n          res[k] += cur\n  return min(res)", "entry_point": "minCost", "test_list": ["assert minCost(A = [20,1,15], x = 5) == 13", "assert minCost(A = [1,2,3], x = 4) == 6"]}
{"Contest id": "349/2734", "text_name": "执行子串操作后的字典序最小字符串", "text": "给你一个仅由小写英文字母组成的字符串 s 。在一步操作中，你可以完成以下行为：\n选择 s 的任一非空子字符串，可能是整个字符串，接着将字符串中的每一个字符替换为英文字母表中的前一个字符。例如，'b' 用 'a' 替换，'a' 用 'z' 替换。\n返回执行上述操作恰好一次后可以获得的字典序最小的字符串。\n子字符串是字符串中的一个连续字符序列。\n现有长度相同的两个字符串 x 和 字符串 y ，在满足 x[i] != y[i] 的第一个位置 i 上，如果  x[i] 在字母表中先于 y[i] 出现，则认为字符串 x 比字符串 y 字典序更小 。", "canonical_solution": "def smallestString(s):\n   i = 0\n   n = len(s)\n   s = list(s)\n   while i < n and s[i] == 'a':\n       i += 1\n   if i == n:\n       s[-1] = 'z'\n   while i < n and s[i] != 'a':\n       s[i] = chr(ord(s[i]) - 1)\n       i += 1\n   return ''.join(s)", "entry_point": "smallestString", "test_list": ["assert smallestString(\"cbabc\") == \"baabc\"", "assert smallestString(\"acbbc\") == \"abaab\"", "assert smallestString(\"leetcode\") == \"kddsbncd\""]}
{"Contest id": "349/2733", "text_name": "既不是最小值也不是最大值", "text": "给你一个整数数组 nums ，数组由不同正整数组成，请你找出并返回数组中任一 既不是最小值也不是最大值的数字，如果不存在这样的数字，返回 -1 。\n返回所选整数。", "canonical_solution": "def findNonMinOrMax(A):\n    return -1 if len(A) < 3 else sum(A[:3]) - min(A[:3]) - max(A[:3])", "entry_point": "findNonMinOrMax", "test_list": ["assert findNonMinOrMax([3,2,1,4]) == 2", "assert findNonMinOrMax([1,2]) == -1", "assert findNonMinOrMax([2,1,3]) == 2"]}
{"Contest id": "Bi106/2732", "text_name": "找到矩阵中的好子集", "text": "给你一个下标从 0 开始大小为 m x n 的二进制矩阵 grid 。\n从原矩阵中选出若干行构成一个行的非空子集，如果子集中任何一列的和至多为子集大小的一半，那么我们称这个子集是好子集。\n更正式的，如果选出来的行子集大小（即行的数量）为 k，那么每一列的和至多为 floor(k / 2) 。\n请你返回一个整数数组，它包含好子集的行下标，请你将子集中的元素升序返回。\n如果有多个好子集，你可以返回任意一个。如果没有好子集，请你返回一个空数组。\n一个矩阵 grid 的行 子集 ，是删除 grid 中某些（也可能不删除）行后，剩余行构成的元素集合。", "canonical_solution": "def goodSubsetofBinaryMatrix(grid):\n    idx = {}\n    for i, row in enumerate(grid):\n        mask = 0\n        for j, x in enumerate(row):\n            mask |= x << j\n        idx[mask] = i\n    if 0 in idx:\n        return [idx[0]]\n    for x, i in idx.items():\n        for y, j in idx.items():\n            if (x & y) == 0:\n                return sorted((i, j))\n    return []", "entry_point": "goodSubsetofBinaryMatrix", "test_list": ["assert goodSubsetofBinaryMatrix([[0,1,1,0],[0,0,0,1],[1,1,1,1]]) == [0,1]", "assert goodSubsetofBinaryMatrix([[0]]) == [0]"]}
{"Contest id": "Bi106/2731", "text_name": "移动机器人", "text": "有一些机器人分布在一条无限长的数轴上，他们初始坐标用一个下标从 0 开始的整数数组 nums 表示。当你给机器人下达命令时，它们以每秒钟一单位的速度开始移动。\n给你一个字符串 s ，每个字符按顺序分别表示每个机器人移动的方向。'L' 表示机器人往左或者数轴的负方向移动，'R' 表示机器人往右或者数轴的正方向移动。\n当两个机器人相撞时，它们开始沿着原本相反的方向移动。\n请你返回指令重复执行 d 秒后，所有机器人之间两两距离之和。由于答案可能很大，请你将答案对 109 + 7 取余后返回。", "canonical_solution": "def sumDistance(A, s, d):\n    n = len(A)\n    B = sorted(A[i] + (d if s[i] == 'R' else -d) for i in range(n))\n    return sum((i + i + 1 - n) * a for i,a in enumerate(B)) % (10 ** 9 + 7)", "entry_point": "sumDistance", "test_list": ["assert sumDistance(A = [-2,0,2], s = \"RLL\", d = 3) == 8", "assert sumDistance(A = [1,0], s = \"RL\", d = 2) == 5"]}
{"Contest id": "Bi106/2730", "text_name": "找到最长的半重复子字符串", "text": "给你一个下标从 0 开始的字符串 s ，这个字符串只包含 0 到 9 的数字字符。\n如果一个字符串 t 中至多有一对相邻字符是相等的，那么称这个字符串 t 是 半重复的 。例如，0010 、002020 、0123 、2002 和 54944 是半重复字符串，而 00101022 和 1101234883 不是。\n请你返回 s 中最长半重复子字符串的长度。\n一个子字符串是一个字符串中一段连续非空的字符。", "canonical_solution": "def longestSemiRepetitiveSubstring(s):\n  i = cur = 0\n  for j in range(1, len(s)):\n      cur += s[j] == s[j - 1]\n      if cur > 1:\n          i += 1\n          cur -= s[i] == s[i - 1]\n  return len(s) - i", "entry_point": "longestSemiRepetitiveSubstring", "test_list": ["assert longestSemiRepetitiveSubstring(\"52233\") == 4", "assert longestSemiRepetitiveSubstring(\"5494\") == 4", "assert longestSemiRepetitiveSubstring(\"1111111\") == 2"]}
{"Contest id": "Bi106/2729", "text_name": "判断一个数是否迷人", "text": "给你一个三位数整数 n 。\n如果经过以下修改得到的数字恰好包含数字 1 到 9 各一次且不包含任何 0 ，那么我们称数字 n 是 迷人的 ：\n将 n 与数字 2 * n 和 3 * n 连接 。\n如果 n 是迷人的，返回 true，否则返回 false 。\n连接两个数字表示把它们首尾相接连在一起。比方说 121 和 371 连接得到 121371 。", "canonical_solution": "def isFascinating(n):\n    from collections import Counter\n    DIGITS = Counter('123456789')\n    return Counter(str(n) + str(2 * n) + str(3 * n)) == DIGITS", "entry_point": "isFascinating", "test_list": ["assert isFascinating(192) == True", "assert isFascinating(100) == False"]}
{"Contest id": "348/2719", "text_name": "统计整数数目", "text": "给你两个数字字符串 num1 和 num2 ，以及两个整数 max_sum 和 min_sum 。如果一个整数 x 满足以下条件，我们称它是一个好整数：\nnum1 <= x <= num2\nmin_sum <= digit_sum(x) <= max_sum.\n请你返回好整数的数目。答案可能很大，请返回答案对 109 + 7 取余后的结果。\n注意，digit_sum(x) 表示 x 各位数字之和。", "canonical_solution": "def count(num1, num2, min_sum, max_sum):\n   def f(size, sm):\n       def dp(i, curr, lower):\n           if curr > sm:\n               return 0\n           if i == len(size):\n               return 1\n           ans = 0\n           if lower:\n               for num in range(10):\n                  ans += dp(i + 1, curr + num, lower)\n           else:\n               for num in range(1 + int(size[i])):\n                  ans += dp(i + 1, curr + num, num < int(size[i]))\n           return ans % (10**9+7)\n       size = str(size)\n       return dp(0, 0, False)\n   num1 = int(num1)\n   num2 = int(num2)\n   return (f(num2, max_sum) - f(num1 - 1, max_sum) - f(num2, min_sum - 1) + f(num1 - 1, min_sum - 1)) % (10**9+7)", "entry_point": "count", "test_list": ["assert count(num1 = \"1\", num2 = \"12\", min_sum = 1, max_sum = 8) == 11", "assert count(num1 = \"1\", num2 = \"5\", min_sum = 1, max_sum = 5) == 5"]}
{"Contest id": "348/2718", "text_name": "查询后矩阵的和", "text": "给你一个整数 n 和一个下标从 0 开始的 二维数组 queries ，其中 queries[i] = [typei, indexi, vali] 。\n一开始，给你一个下标从 0 开始的 n x n 矩阵，所有元素均为 0 。每一个查询，你需要执行以下操作之一：\n如果 typei == 0 ，将第 indexi 行的元素全部修改为 vali ，覆盖任何之前的值。\n如果 typei == 1 ，将第 indexi 列的元素全部修改为 vali ，覆盖任何之前的值。\n请你执行完所有查询以后，返回矩阵中所有整数的和。", "canonical_solution": "def matrixSumQueries(n, queries):\n   col, row = {}, {}\n   res = 0\n   for t, i, v in queries[::-1]:\n       if t == 0 and i not in row:\n           row[i] = v\n           res += v * (n - len(col))\n       if t == 1 and i not in col:\n           col[i] = v\n           res += v * (n - len(row))\n   return res", "entry_point": "matrixSumQueries", "test_list": ["assert matrixSumQueries(n = 3, queries = [[0,0,1],[1,2,2],[0,2,3],[1,0,4]]) == 23", "assert matrixSumQueries(n = 3, queries = [[0,0,4],[0,1,2],[1,0,1],[0,2,3],[1,2,1]]) == 17"]}
{"Contest id": "348/2717", "text_name": "2717. 半有序排列", "text": "给你一个下标从 0 开始、长度为 n 的整数排列 nums 。\n如果排列的第一个数字等于 1 且最后一个数字等于 n ，则称其为半有序排列。你可以执行多次下述操作，直到将 nums 变成一个半有序排列：\n选择 nums 中相邻的两个元素，然后交换它们。\n返回使 nums 变成半有序排列所需的最小操作次数。\n排列是一个长度为 n 的整数序列，其中包含从 1 到 n 的每个数字恰好一次。", "canonical_solution": "def semiOrderedPermutation(A):\n    n = len(A)\n    i, j = A.index(1), A.index(n)\n    return i + n - 1 - j - (i > j)", "entry_point": "semiOrderedPermutation", "test_list": ["assert semiOrderedPermutation([2,1,4,3]) == 2", "assert semiOrderedPermutation([2,4,1,3]) == 3", "assert semiOrderedPermutation([1,3,4,2,5]) == 0"]}
{"Contest id": "348/2716", "text_name": "最小化字符串长度", "text": "给你一个下标从 0 开始的字符串 s ，重复执行下述操作任意次：\n在字符串中选出一个下标 i ，并使 c 为字符串下标 i 处的字符。并在 i 左侧（如果有）和右侧（如果有）各删除一个距离 i 最近 的字符 c 。\n请你通过执行上述操作任意次，使 s 的长度最小化。\n返回一个表示最小化字符串的长度的整数。", "canonical_solution": "def minimizedStringLength(s):\n    return len(set(s))", "entry_point": "minimizedStringLength", "test_list": ["assert minimizedStringLength(\"aaabc\") == 3", "assert minimizedStringLength(\"cbbd\") == 3", "assert minimizedStringLength(\"dddaaa\") == 2"]}
{"Contest id": "347/2713", "text_name": "矩阵中严格递增的单元格数", "text": "给你一个下标从 1 开始、大小为 m x n 的整数矩阵 mat，你可以选择任一单元格作为 起始单元格 。\n从起始单元格出发，你可以移动到同一行或同一列中的任何其他单元格，但前提是目标单元格的值严格大于 当前单元格的值。\n你可以多次重复这一过程，从一个单元格移动到另一个单元格，直到无法再进行任何移动。\n请你找出从某个单元开始访问矩阵所能访问的单元格的最大数量 。\n返回一个表示可访问单元格最大数量的整数。", "canonical_solution": "def maxIncreasingCells(M):\n   m, n = len(M), len(M[0])\n   A = defaultdict(list)\n   for i in range(m):\n       for j in range(n):\n           A[M[i][j]].append([i, j])\n   dp = [[0] * n for i in range(m)]\n   res = [0] * (n + m)\n   for a in sorted(A):\n       for i, j in A[a]:\n           dp[i][j] = max(res[i], res[~j]) + 1\n       for i, j in A[a]:\n           res[~j] = max(res[~j], dp[i][j])\n           res[i] = max(res[i], dp[i][j])\n   return max(res)", "entry_point": "maxIncreasingCells", "test_list": ["assert maxIncreasingCells([[3,1],[3,4]]) == 2", "assert maxIncreasingCells([[1,1],[1,1]]) == 1", "assert maxIncreasingCells([[3,1,6],[-9,5,7]]) == 4"]}
{"Contest id": "347/2712", "text_name": "使所有字符相等的最小成本", "text": "给你一个下标从 0 开始、长度为 n 的二进制字符串 s ，你可以对其执行两种操作：\n选中一个下标 i 并且反转从下标 0 到下标 i（包括下标 0 和下标 i ）的所有字符，成本为 i + 1 。\n选中一个下标 i 并且反转从下标 i 到下标 n - 1（包括下标 i 和下标 n - 1 ）的所有字符，成本为 n - i 。\n返回使字符串内所有字符相等需要的最小成本 。\n反转 字符意味着：如果原来的值是 '0' ，则反转后值变为 '1' ，反之亦然。", "canonical_solution": "def minimumCost(s):\n    n = len(s)\n    return sum(min(i, n - i) for i in range(1, n) if s[i] != s[i - 1])", "entry_point": "minimumCost", "test_list": ["assert minimumCost(\"0011\") == 2", "assert minimumCost(\"010101\") == 9"]}
{"Contest id": "347/2711", "text_name": "对角线上不同值的数量差", "text": "给你一个下标从 0 开始、大小为 m x n 的二维矩阵 grid ，请你求解大小同样为 m x n 的答案矩阵 answer 。\n矩阵 answer 中每个单元格 (r, c) 的值可以按下述方式进行计算：\n令 topLeft[r][c] 为矩阵 grid 中单元格 (r, c) 左上角对角线上不同值的数量。\n令 bottomRight[r][c] 为矩阵 grid 中单元格 (r, c) 右下角对角线上不同值的数量。\n然后 answer[r][c] = |topLeft[r][c] - bottomRight[r][c]| 。\n返回矩阵 answer 。\n矩阵对角线是从最顶行或最左列的某个单元格开始，向右下方向走到矩阵末尾的对角线。\n如果单元格 (r1, c1) 和单元格 (r, c) 属于同一条对角线且 r1 < r ，则单元格 (r1, c1) 属于单元格 (r, c) 的左上对角线。类似地，可以定义右下对角线。", "canonical_solution": "def differenceOfDistinctValues(grid):\n   ar = []\n   ro = len(grid)\n   co = len(grid[0])\n   for i in range(len(grid)):\n       ls = []\n       for j in range(len(grid[i])):\n           le = set()\n           re = set()\n           x = i - 1\n           y = j - 1\n           while x >= 0 and y >= 0:\n               le.add(grid[x][y])\n               x -= 1\n               y -= 1\n           x = i + 1\n           y = j + 1\n           while x < ro and y < co:\n               re.add(grid[x][y])\n               x += 1\n               y += 1\n           ls.append(abs(len(le) - len(re)))\n       ar.append(ls)\n   return ar", "entry_point": "differenceOfDistinctValues", "test_list": ["assert differenceOfDistinctValues([[1,2,3],[3,1,5],[3,2,1]]) == [[1,1,0],[1,0,1],[0,1,1]]", "assert differenceOfDistinctValues([[1]]) == [[0]]"]}
{"Contest id": "347/2710", "text_name": "移除字符串中的尾随零", "text": "给你一个用字符串表示的正整数 num ，请你以字符串形式返回不含尾随零的整数 num 。", "canonical_solution": "def removeTrailingZeros(num):\n    return num.rstrip('0')", "entry_point": "removeTrailingZeros", "test_list": ["assert removeTrailingZeros(\"51230100\") == \"512301\"", "assert removeTrailingZeros(\"123\") == \"123\""]}
{"Contest id": "Bi105/2709", "text_name": "最大公约数遍历", "text": "给你一个下标从 0 开始的整数数组 nums ，你可以在一些下标之间遍历。对于两个下标 i 和 j（i != j），当且仅当 gcd(nums[i], nums[j]) > 1 时，我们可以在两个下标之间通行，其中 gcd 是两个数的最大公约数 。\n你需要判断 nums 数组中任意两个满足 i < j 的下标 i 和 j ，是否存在若干次通行可以从 i 遍历到 j 。\n如果任意满足条件的下标对都可以遍历，那么返回 true ，否则返回 false 。", "canonical_solution": "def canTraverseAllPairs(nums):\n   n = len(nums)\n   if n == 1:\n       return True\n   f = [_ for _ in range(0, n)]\n   num = [1] * n    \n   def getf(x):\n       if f[x] == x:\n           return x\n       f[x] = getf(f[x])\n       return f[x]\n   def merge(x, y):\n       x, y = getf(x), getf(y)\n       if x == y:\n           return\n       if num[x] < num[y]:\n           x, y = y, x\n       f[y] = x\n       num[x] += num[y]\n   have = {}\n   for i in range(0, n):\n       x = nums[i]\n       if x == 1:\n           return False\n       d = 2\n       while d * d <= x:\n           if x % d == 0:\n               if d in have:\n                  merge(i, have[d])\n               else:\n                  have[d] = i\n               while x % d == 0:\n                  x //= d\n           d += 1\n       if x > 1:\n           if x in have:\n               merge(i, have[x])\n           else:\n               have[x] = i\n   return num[getf(0)] == n", "entry_point": "canTraverseAllPairs", "test_list": ["assert canTraverseAllPairs([2,3,6]) == True", "assert canTraverseAllPairs([3,9,5]) == False", "assert canTraverseAllPairs([4,3,12,8]) == True"]}
{"Contest id": "Bi105/2708", "text_name": "一个小组的最大实力值", "text": "给你一个下标从 0 开始的整数数组 nums ，它表示一个班级中所有学生在一次考试中的成绩。老师想选出一部分同学组成一个非空小组，且这个小组的实力值最大，如果这个小组里的学生下标为 i0, i1, i2, ... , ik ，那么这个小组的实力值定义为 nums[i0] * nums[i1] * nums[i2] * ... * nums[ik] 。\n请你返回老师创建的小组能得到的最大实力值为多少。", "canonical_solution": "import math\ndef maxStrength(nums):\n    negs = []\n    pos = []   \n    for num in nums:\n        if num < 0:\n            negs.append(num)\n        elif num > 0:\n            pos.append(num)\n    prod = 1\n    x = nums.count(0)\n    negs.sort()\n    if len(negs) <= 1 and len(pos) == 0:\n        return max(nums)\n    if len(negs) % 2 == 0:\n        for num in negs:\n            prod *= num\n        for num in pos:\n            prod *= num\n        return prod\n    else:\n        for i in range(len(negs) - 1):\n            prod *= negs[i]\n        for num in pos:\n            prod *= num\n        return prod", "entry_point": "maxStrength", "test_list": ["assert maxStrength([3,-1,-5,2,5,-9]) == 1350", "assert maxStrength([-4,-5,-4]) == 20"]}
{"Contest id": "Bi105/2707", "text_name": "字符串中的额外字符", "text": "给你一个下标从 0 开始的字符串 s 和一个单词字典 dictionary 。你需要将 s 分割成若干个互不重叠的子字符串，每个子字符串都在 dictionary 中出现过。s 中可能会有一些额外的字符不在任何子字符串中。\n请你采取最优策略分割 s ，使剩下的字符最少。", "canonical_solution": "from collections import defaultdict\ndef minExtraChar(s, dictionary):\n    n = len(s)\n    word_dict = defaultdict(list)\n    for word in dictionary:\n        word_dict[word[0]].append(word)\n    result = [0] * (n + 1)\n    for i in range(n - 1, -1, -1):\n        result[i] = result[i + 1] + 1\n        if s[i] in word_dict:\n            for word in word_dict[s[i]]:\n                if s[i:i + len(word)] == word:\n                    result[i] = min(result[i], result[i + len(word)])\n    return result[0]\n", "entry_point": "minExtraChar", "test_list": ["assert minExtraChar(s = \"leetscode\", dictionary = [\"leet\",\"code\",\"leetcode\"]) == 1", "assert minExtraChar(s = \"sayhelloworld\", dictionary = [\"hello\",\"world\"]) == 3"]}
{"Contest id": "Bi105/2706", "text_name": "购买两块巧克力", "text": "给你一个整数数组 prices ，它表示一个商店里若干巧克力的价格。同时给你一个整数 money，表示你一开始拥有的钱数。\n你必须购买恰好两块巧克力，而且剩余的钱数必须是非负数。同时你想最小化购买两块巧克力的总花费。\n请你返回在购买两块巧克力后，最多能剩下多少钱。如果购买任意两块巧克力都超过了你拥有的钱，请你返回 money 。注意剩余钱数必须是非负数。", "canonical_solution": "def buyChoco(arr, key):\n    ans = float('inf')\n    for i in range(len(arr)):\n        for j in range(len(arr)):\n            if i != j:\n                total = arr[i] + arr[j]\n                ans = min(ans, total)\n    fin = key - ans\n    if(fin>=0):\n        return fin\n    else:\n        return key\n        ", "entry_point": "buyChoco", "test_list": ["assert buyChoco( [1,2,2], 3) == 0", "assert buyChoco([3,2,3], 3) == 3"]}
{"Contest id": "346/2699", "text_name": "修改图中的边权", "text": "给你一个 n 个节点的 无向带权连通 图，节点编号为 0 到 n - 1 ，再给你一个整数数组 edges ，其中 edges[i] = [ai, bi, wi] 表示节点 ai 和 bi 之间有一条边权为 wi 的边。\n部分边的边权为 -1（wi = -1），其他边的边权都为正数（wi > 0）。\n你需要将所有边权为 -1 的边都修改为范围 [1, 2 * 109] 中的正整数 ，使得从节点 source 到节点 destination 的最短距离为整数 target 。如果有多种修改方案可以使 source 和 destination 之间的最短距离等于 target ，你可以返回任意一种方案。\n如果存在使 source 到 destination 最短距离为 target 的方案，请你按任意顺序返回包含所有边的数组（包括未修改边权的边）。如果不存在这样的方案，请你返回一个空数组 。\n注意：你不能修改一开始边权为正数的边。", "canonical_solution": "def modifiedGraphEdges(n, edges, source, destination, target):\n    def dijkstra(adj_matrix):\n        dist = [float(\"inf\")] * n\n        used = set()\n        dist[source] = 0\n        for round in range(n - 1):\n            u = -1\n            for i in range(n):\n                if i not in used and (u == -1 or dist[i] < dist[u]):\n                    u = i\n            used.add(u)\n            for v in range(n):\n                if v not in used and adj_matrix[u][v] != -1:\n                    dist[v] = min(dist[v], dist[u] + adj_matrix[u][v])\n        return dist[destination]\n    def construct(idx) :\n        adj_matrix = [[-1] * n for _ in range(n)]\n        for u, v, w in edges:\n            if w != -1:\n                adj_matrix[u][v] = adj_matrix[v][u] = w\n            else:\n                if idx >= target - 1:\n                    adj_matrix[u][v] = adj_matrix[v][u] = target\n                    idx -= (target - 1)\n                else:\n                    adj_matrix[u][v] = adj_matrix[v][u] = 1 + idx\n                    idx = 0\n        return adj_matrix\n    k = sum(1 for e in edges if e[2] == -1)\n    if dijkstra(construct(0)) > target:\n        return []\n    if dijkstra(construct(k * (target - 1))) < target:\n        return []\n    left, right, ans = 0, k * (target - 1), 0\n    while left <= right:\n        mid = (left + right) // 2\n        if dijkstra(construct(mid)) >= target:\n            ans = mid\n            right = mid - 1\n        else:\n            left = mid + 1\n    for i, e in enumerate(edges):\n        if e[2] == -1:\n            if ans >= target - 1:\n                edges[i][2] = target\n                ans -= (target - 1)\n            else:\n                edges[i][2] = 1 + ans\n                ans = 0\n    return edges", "entry_point": "modifiedGraphEdges", "test_list": ["assert modifiedGraphEdges(n = 5, edges = [[4,1,-1],[2,0,-1],[0,3,-1],[4,3,-1]], source = 0, destination = 1, target = 5) == [[4,1,3],[2,0,1],[0,3,1],[4,3,1]]", "assert modifiedGraphEdges(n = 3, edges = [[0,1,-1],[0,2,5]], source = 0, destination = 2, target = 6) == []", "assert modifiedGraphEdges(n = 4, edges = [[1,0,4],[1,2,3],[2,3,5],[0,3,-1]], source = 0, destination = 2, target = 6) == [[1,0,4],[1,2,3],[2,3,5],[0,3,1]]"]}
{"Contest id": "346/2698", "text_name": "求一个整数的惩罚数", "text": "给你一个正整数 n ，请你返回 n 的 惩罚数 。\nn 的惩罚数定义为所有满足以下条件 i 的数的平方和：\n1 <= i <= n\ni * i 的十进制表示的字符串可以分割成若干连续子字符串，且这些子字符串对应的整数值之和等于 i 。", "canonical_solution": "def punishmentNumber(n):\n    def possible(sum_added,cache_sum, n, target):    \n        if not n:\n            return target == sum_added+cache_sum\n        num = int(n[0])\n        cas = cache_sum\n        return possible(sum_added,cas*10+num, n[1:], target) or possible(sum_added+cas,num, n[1:], target)\n    ans = 0\n    for i in range(1, n+1):\n           \n        if possible(0,0,str(i*i), i):\n            ans += i*i\n    return ans", "entry_point": "punishmentNumber", "test_list": ["assert punishmentNumber(10) == 182", "assert punishmentNumber(37) == 1478"]}
{"Contest id": "346/2697", "text_name": "字典序最小回文串", "text": "给你一个由小写英文字母 组成的字符串 s ，你可以对其执行一些操作。在一步操作中，你可以用其他小写英文字母替换 s 中的一个字符。\n请你执行尽可能少的操作，使 s 变成一个 回文串 。如果执行最少操作次数的方案不止一种，则只需选取字典序最小的方案。\n对于两个长度相同的字符串 a 和 b ，在 a 和 b 出现不同的第一个位置，如果该位置上 a 中对应字母比 b 中对应字母在字母表中出现顺序更早，则认为 a 的字典序比 b 的字典序要小。\n返回最终的回文字符串。", "canonical_solution": "def makeSmallestPalindrome(s):\n    return ''.join(map(min, zip(s, s[::-1])))", "entry_point": "makeSmallestPalindrome", "test_list": ["assert makeSmallestPalindrome(\"egcfe\") == \"efcfe\"", "assert makeSmallestPalindrome(\"abcd\") == \"abba\"", "assert makeSmallestPalindrome(\"seven\") == \"neven\""]}
{"Contest id": "346/2696", "text_name": "删除子串后的字符串最小长度", "text": "给你一个仅由大写英文字符组成的字符串 s 。\n你可以对此字符串执行一些操作，在每一步操作中，你可以从 s 中删除 任一个 \"AB\" 或 \"CD\" 子字符串。\n通过执行操作，删除所有 \"AB\" 和 \"CD\" 子串，返回可获得的最终字符串的最小可能长度。\n注意，删除子串后，重新连接出的字符串可能会产生新的 \"AB\" 或 \"CD\" 子串。\n", "canonical_solution": "def minLength(s):\n    stack = []\n    for c in s:\n        if stack and stack[-1] + c in ('AB', 'CD'):\n            stack.pop()\n        else:\n            stack.append(c)\n\n    return len(stack)", "entry_point": "minLength", "test_list": ["assert minLength(\"ABFCACDB\") == 2", "assert minLength(\"ACBBD\") == 5"]}
{"Contest id": "345/2685", "text_name": "统计完全连通分量的数量", "text": "给你一个整数 n 。现有一个包含 n 个顶点的 无向 图，顶点按从 0 到 n - 1 编号。给你一个二维整数数组 edges 其中 edges[i] = [ai, bi] 表示顶点 ai 和 bi 之间存在一条 无向 边。\n返回图中完全连通分量的数量。\n如果在子图中任意两个顶点之间都存在路径，并且子图中没有任何一个顶点与子图外部的顶点共享边，则称其为连通分量 。\n如果连通分量中每对节点之间都存在一条边，则称其为完全连通分量 。", "canonical_solution": "def countCompleteComponents(n,edges):\n        adj=defaultdict(list)\n        for a,b in edges:\n            adj[a].append(b)\n            adj[b].append(a)   \n        def dfs(i):\n            component.add(i)\n            for child in adj[i]:\n                if child not in visited:\n                    visited.add(child)\n                    dfs(child)\n        ans=0\n        visited=set()\n        for i in range(n):\n            if i not in visited:\n                component=set()\n                visited.add(i)\n                dfs(i)\n                if all(len(adj[node]) == len(component)-1 for node in component):\n                    ans+=1\n        return ans", "entry_point": "countCompleteComponents", "test_list": ["assert countCompleteComponents(6,[[0,1],[0,2],[1,2],[3,4]])==3", "assert countCompleteComponents(6,[[0,1],[0,2],[1,2],[3,4],[3,5]])==1"]}
{"Contest id": "345/2684", "text_name": "矩阵中移动的最大次数", "text": "给你一个下标从0开始、大小为 m x n 的矩阵 grid ，矩阵由若干正整数组成。\n你可以从矩阵第一列中的 任一 单元格出发，按以下方式遍历 grid ：\n从单元格 (row, col) 可以移动到 (row - 1, col + 1)、(row, col + 1) 和 (row + 1, col + 1) 三个单元格中任一满足值 严格 大于当前单元格的单元格。\n返回你在矩阵中能够移动的最大次数。", "canonical_solution": "def maxMoves(grid):\n        def helper(row,col) :\n            if row < 0 or row >= m or col >= n:\n                return 0\n            if dp[row][col] != -1:\n                return dp[row][col]\n            directions = [(row - 1, col + 1), (row, col + 1), (row + 1, col + 1)]\n            max_moves = 0\n            for x,y in directions :\n                if x>=0 and x < m and (y < n) and grid[x][y] > grid[row][col] :\n                    if dp[x][y] != -1:\n                        max_moves = max(max_moves , 1+dp[x][y])\n                    else :\n                        max_moves = max(max_moves , 1+helper(x,y)) \n            dp[row][col] = max_moves\n            return dp[row][col]         \n        m = len(grid)\n        n = len(grid[0])  \n        ans = 0\n        dp = [[-1 for i in range(n)]for j in range(m)]\n        dp[m-1][n-1] = 0\n        for i in range(m):\n            ans = max(ans , helper(i,0))   \n        return ans", "entry_point": "maxMoves", "test_list": ["assert maxMoves([[2,4,3,5],[5,4,9,3],[3,4,2,11],[10,9,13,15]])==3", "assert maxMoves([[3,2,4],[2,1,9],[1,1,7]])==0"]}
{"Contest id": "345/2683", "text_name": "相邻值的按位异或", "text": "下标从 0 开始、长度为 n 的数组 derived 是由同样长度为 n 的原始 二进制数组 original 通过计算相邻值的 按位异或（⊕）派生而来。\n特别地，对于范围 [0, n - 1] 内的每个下标 i ：\n如果 i = n - 1 ，那么 derived[i] = original[i] ⊕ original[0]\n否则 derived[i] = original[i] ⊕ original[i + 1]\n给你一个数组 derived ，请判断是否存在一个能够派生得到 derived 的 有效原始二进制数组 original 。\n如果存在满足要求的原始二进制数组，返回 true ；否则，返回 false 。\n二进制数组是仅由 0 和 1 组成的数组。", "canonical_solution": "def doesValidArrayExist(derived):\n    n = len(derived)\n    A = [0] * n\n    for i in range(n - 1):\n        A[i + 1] = A[i] ^ derived[i]\n    for i in range(n):\n        ni = (i + 1) % n\n        if (A[i] ^ A[ni]) != derived[i]:\n            return False\n    return True", "entry_point": "doesValidArrayExist", "test_list": ["assert doesValidArrayExist([1,1,0])==True", "assert doesValidArrayExist([1,1])==True", "assert doesValidArrayExist([1,0])==False"]}
{"Contest id": "345/2682", "text_name": "找出转圈游戏输家", "text": "n 个朋友在玩游戏。这些朋友坐成一个圈，按 顺时针方向 从 1 到 n 编号。准确的说，从第 i 个朋友的位置开始顺时针移动 1 步会到达第 (i + 1) 个朋友的位置（1 <= i < n），而从第 n 个朋友的位置开始顺时针移动 1 步会回到第 1 个朋友的位置。\n游戏规则如下：\n第 1 个朋友接球。\n接着，第 1 个朋友将球传给距离他顺时针方向 k 步的朋友。\n然后，接球的朋友应该把球传给距离他顺时针方向 2 * k 步的朋友。\n接着，接球的朋友应该把球传给距离他顺时针方向 3 * k 步的朋友，以此类推。\n换句话说，在第 i 轮中持有球的那位朋友需要将球传递给距离他顺时针方向 i * k 步的朋友。\n当某个朋友第 2 次接到球时，游戏结束。\n在整场游戏中没有接到过球的朋友是 输家 。\n给你参与游戏的朋友数量 n 和一个整数 k ，请按升序排列返回包含所有输家编号的数组 answer 作为答案。", "canonical_solution": "def circularGameLosers(n,k):\n    visited = [0] * n\n    count = 1\n    pos = 0\n    visited[pos] = 1\n    while (visited[pos]!=2):\n        pos = (pos+(count*k))%n\n        visited[pos]+=1\n        count+=1\n    res = []\n    for i in range(n):\n        if not visited[i]:\n            res.append(i+1)\n    return res", "entry_point": "circularGameLosers", "test_list": ["assert circularGameLosers(5,2)==[4,5]", "assert circularGameLosers(4,4)==[2,3,4]"]}
{"Contest id": "Bi104/2681", "text_name": "英雄的力量", "text": "给你一个下标从0开始的整数数组nums，它表示英雄的能力值。如果我们选出一部分英雄，这组英雄的力量定义为：\ni0，i1，... ik表示这组英雄在数组中的下标。那么这组英雄的力量为 max(nums[i0],nums[i1] ... nums[ik])2 * min(nums[i0],nums[i1] ... nums[ik]) 。\n请你返回所有可能的非空英雄组的力量之和。由于答案可能非常大，请你将结果对 10^9 + 7 取余。", "canonical_solution": "def sumOfPower(nums):\n        M = 10 ** 9 + 7\n        nums.sort()\n        res, s = 0, 0\n        for x in nums:\n            res += (x + s) * (x * x) \n            res %= M\n            s = (s * 2 + x) % M\n        return res", "entry_point": "sumOfPower", "test_list": ["assert sumOfPower([2,1,4])==141", "assert sumOfPower([1,1,1])==7"]}
{"Contest id": "Bi104/2680", "text_name": "最大或值", "text": "给你一个下标从0开始长度为n的整数数组nums和一个整数k。每一次操作中，你可以选择一个数并将它乘2。\n你最多可以进行k次操作，请你返回 nums[0] | nums[1] | ... | nums[n - 1] 的最大值。\na | b 表示两个整数 a 和 b 的按位或运算。", "canonical_solution": "def maximumOr(nums, k):\n        res, left, n = 0, 0, len(nums)\n        right = [0] * n\n        for i in range(n - 2, -1, -1):\n            right[i] = right[i + 1] | nums[i + 1]\n        for i in range(n):\n            res = max(res, left | nums[i] << k | right[i])\n            left |= nums[i]\n        return res", "entry_point": "maximumOr", "test_list": ["assert maximumOr([12,9],1)==30", "assert maximumOr([8,1,2],2)==35"]}
{"Contest id": "Bi104/2679", "text_name": "矩阵中的和", "text": "给你一个下标从0开始的二维整数数组nums。一开始你的分数为0。你需要执行以下操作直到矩阵变为空：\n矩阵中每一行选取最大的一个数，并删除它。如果一行中有多个最大的数，选择任意一个并删除。\n在步骤1删除的所有数字中找到最大的一个数字，将它添加到你的分数中。\n请你返回最后的分数。", "canonical_solution": "def matrixSum(nums):\n        m, n = len(nums), len(nums[0])\n        res = 0\n        for num in nums: num.sort()\n        for j in range(n):\n            mx = 0\n            for i in range(m): mx = max(mx, nums[i][j])\n            res += mx\n        return res", "entry_point": "matrixSum", "test_list": ["assert matrixSum([[7,2,1],[6,4,2],[6,5,3],[3,2,1]])==15", "assert matrixSum([[1]])==1"]}
{"Contest id": "Bi104/2678", "text_name": "老人的数目", "text": "给你一个下标从 0 开始的字符串 details 。details 中每个元素都是一位乘客的信息，信息用长度为 15 的字符串表示，表示方式如下：\n前十个字符是乘客的手机号码。\n接下来的一个字符是乘客的性别。\n接下来两个字符是乘客的年龄。\n最后两个字符是乘客的座位号。\n请你返回乘客中年龄严格大于60岁的人数。", "canonical_solution": "def countSeniors(details):\n        count = 0\n        for item in details:\n            age = int(item[11]+item[12])\n            if age > 60:\n                count +=1\n        return count", "entry_point": "countSeniors", "test_list": ["assert countSeniors([\"7868190130M7522\",\"5303914400F9211\",\"9273338290F4010\"])==2", "assert countSeniors([\"1313579440F2036\",\"2921522980M5644\"])==0"]}
{"Contest id": "344/2673", "text_name": "使二叉树所有路径值相等的最小代价", "text": "给你一个整数 n 表示一棵 满二叉树 里面节点的数目，节点编号从 1 到 n 。根节点编号为 1 ，树中每个非叶子节点 i 都有两个孩子，分别是左孩子 2 * i 和右孩子 2 * i + 1 。\n树中每个节点都有一个值，用下标从 0 开始、长度为 n 的整数数组 cost 表示，其中 cost[i] 是第 i + 1 个节点的值。每次操作，你可以将树中 任意 节点的值 增加 1 。你可以执行操作任意次。\n你的目标是让根到每一个 叶子结点 的路径值相等。请你返回 最少 需要执行增加操作多少次。\n注意：\n满二叉树 指的是一棵树，它满足树中除了叶子节点外每个节点都恰好有 2 个节点，且所有叶子节点距离根节点距离相同。\n路径值 指的是路径上所有节点的值之和。", "canonical_solution": "def minIncrements(n, cost):\n        res = 0\n        for i in range(n // 2 - 1, -1, -1):\n            l, r = i * 2 + 1, i * 2 + 2\n            res += abs(cost[l] - cost[r])\n            cost[i] += max(cost[l], cost[r])\n        return res", "entry_point": "minIncrements", "test_list": ["assert minIncrements(7,[1,5,2,2,3,3,1])==6", "assert minIncrements(3,[5,3,3])==0"]}
{"Contest id": "344/2672", "text_name": "有相同颜色的相邻元素数目", "text": "给你一个下标从 0 开始、长度为 n 的数组 nums 。一开始，所有元素都是 未染色 （值为 0 ）的。\n给你一个二维整数数组 queries ，其中 queries[i] = [indexi, colori] 。\n对于每个操作，你需要将数组 nums 中下标为 indexi 的格子染色为 colori 。\n请你返回一个长度与 queries 相等的数组 answer ，其中 answer[i]是前 i 个操作 之后 ，相邻元素颜色相同的数目。\n更正式的，answer[i] 是执行完前 i 个操作后，0 <= j < n - 1 的下标 j 中，满足 nums[j] == nums[j + 1] 且 nums[j] != 0 的数目。", "canonical_solution": "def colorTheArray(n, queries):\n        count = 0\n        nums = [0] * n\n        result = []\n        for q in queries:\n            idx, val = q\n            \n            if idx > 0:\n                if nums[idx-1] == 0:\n                    pass\n                elif nums[idx] == nums[idx-1]:\n                    if nums[idx] != val and count > 0:\n                        count -= 1\n                else:\n                    if val == nums[idx-1]:\n                        count += 1\n            if idx+1 < n:\n                if nums[idx+1] == 0:\n                    pass\n                elif nums[idx] == nums[idx+1]:\n                    if nums[idx] != val and count > 0:\n                        count -= 1\n                else:\n                    if val == nums[idx+1]:\n                        count += 1\n            nums[idx] = val\n            result.append(count)\n        return result", "entry_point": "colorTheArray", "test_list": ["assert colorTheArray(4,[[0,2],[1,2],[3,1],[1,1],[2,1]])==[0,1,1,0,2]", "assert colorTheArray(1,[[0,100000]])==[0]"]}
{"Contest id": "344/2670", "text_name": "找出不同元素数目差数组", "text": "给你一个下标从 0 开始的数组 nums ，数组长度为 n 。\nnums 的 不同元素数目差 数组可以用一个长度为 n 的数组 diff 表示，其中 diff[i] 等于前缀 nums[0, ..., i] 中不同元素的数目 减去 后缀 nums[i + 1, ..., n - 1] 中不同元素的数目。\n返回 nums 的 不同元素数目差 数组。\n注意 nums[i, ..., j] 表示 nums 的一个从下标 i 开始到下标 j 结束的子数组（包含下标 i 和 j 对应元素）。特别需要说明的是，如果 i > j ，则 nums[i, ..., j] 表示一个空子数组。", "canonical_solution": "def distinctDifferenceArray(nums):\n        pre, suf = [], []\n        ps, ss = set(), set()\n        n = len(nums)\n        for i in range(n):\n            ps.add(nums[i])\n            pre.append(len(ps))\n        for i in range(n - 1, -1, -1):\n            suf.insert(0, len(ss))\n            ss.add(nums[i])\n        return [pre[i] - suf[i] for i in range(n)]", "entry_point": "distinctDifferenceArray", "test_list": ["assert distinctDifferenceArray([1,2,3,4,5])==[-3,-1,1,3,5]", "assert distinctDifferenceArray([3,2,3,4,2])==[-2,-1,0,2,3]"]}
{"Contest id": "343/2663", "text_name": "字典序最小的美丽字符串", "text": "如果一个字符串满足以下条件，则称其为 美丽字符串 ：\n它由英语小写字母表的前 k 个字母组成。\n它不包含任何长度为 2 或更长的回文子字符串。\n给你一个长度为 n 的美丽字符串 s 和一个正整数 k 。\n请你找出并返回一个长度为 n 的美丽字符串，该字符串还满足：在字典序大于 s 的所有美丽字符串中字典序最小。如果不存在这样的字符串，则返回一个空字符串。\n对于长度相同的两个字符串 a 和 b ，如果字符串 a 在与字符串 b 不同的第一个位置上的字符字典序更大，则字符串 a 的字典序大于字符串 b 。\n例如，\"abcd\" 的字典序比 \"abcc\" 更大，因为在不同的第一个位置（第四个字符）上 d 的字典序大于 c 。", "canonical_solution": "def smallestBeautifulString(s, k):\n        i, n = len(s) - 1, len(s)\n        s = s[:i] + chr(ord(s[i]) + 1)\n        while i >= 0 and i < n:\n            if ord(s[i]) >= ord('a') + k:\n                s = s[:i] + 'a' + s[i + 1:]\n                i -= 1\n                if i >= 0:\n                    s = s[:i] + chr(ord(s[i]) + 1) + s[i + 1:]\n                else:\n                    break\n            elif (i - 1 >= 0 and s[i] == s[i - 1]) or (i - 2 >= 0 and s[i] == s[i - 2]):\n                s = s[:i] + chr(ord(s[i]) + 1) + s[i + 1:]\n            else:\n                i += 1\n        if i == -1:\n            s = \"\"\n        return s", "entry_point": "smallestBeautifulString", "test_list": ["assert smallestBeautifulString(\"abcz\",26)==\"abda\"", "assert smallestBeautifulString(\"dc\",4)==\"\""]}
{"Contest id": "343/2662", "text_name": "前往目标的最小代价", "text": "给你一个数组 start ，其中 start = [startX, startY] 表示你的初始位置位于二维空间上的 (startX, startY) 。另给你一个数组 target ，其中 target = [targetX, targetY] 表示你的目标位置 (targetX, targetY) 。\n从位置 (x1, y1) 到空间中任一其他位置 (x2, y2) 的代价是 |x2 - x1| + |y2 - y1| 。\n给你一个二维数组 specialRoads ，表示空间中存在的一些特殊路径。其中 specialRoads[i] = [x1i, y1i, x2i, y2i, costi] 表示第 i 条特殊路径可以从 (x1i, y1i) 到 (x2i, y2i) ，但成本等于 costi 。你可以使用每条特殊路径任意次数。\n返回从 (startX, startY) 到 (targetX, targetY) 所需的最小代价。", "canonical_solution": "def minimumCost(start, target, specialRoads):\n        specialRoads = [[a, b, c, d, x] for a, b, c, d, x in specialRoads if x < abs(a - c) + abs(b - d)]\n        dist = {(start[0], start[1]): 0}\n        heap = [(0, start[0], start[1])]\n        while len(heap) > 0:\n            currdist, x, y = heapq.heappop(heap)\n            for a, b, c, d, cost in specialRoads:\n                if dist.get((c, d), float('inf')) > currdist + abs(x - a) + abs(y - b) + cost:\n                    dist[(c, d)] = currdist + abs(x - a) + abs(y - b) + cost\n                    heapq.heappush(heap, (dist[(c, d)], c, d))\n        res = abs(target[0] - start[0]) + abs(target[1] - start[1])\n        for a, b, c, d, cost in specialRoads:\n            res = min(res, dist.get((c, d), float('inf')) + abs(target[0] - c) + abs(target[1] - d))\n        return res", "entry_point": "minimumCost", "test_list": ["assert minimumCost([1,1],[4,5],[[1,2,3,3,2],[3,4,4,5,1]])==5", "assert minimumCost([3,2],[5,7],[[3,2,3,4,4],[3,3,5,5,5],[3,4,5,6,6]])==7"]}
{"Contest id": "343/2661", "text_name": "找出叠涂元素", "text": "给你一个下标从 0 开始的整数数组 arr 和一个 m x n 的整数 矩阵 mat 。arr 和 mat 都包含范围 [1，m * n] 内的 所有 整数。\n从下标 0 开始遍历 arr 中的每个下标 i ，并将包含整数 arr[i] 的 mat 单元格涂色。\n请你找出 arr 中第一个使得 mat 的某一行或某一列都被涂色的元素，并返回其下标 i 。", "canonical_solution": "def firstCompleteIndex(arr, mat):\n        m = len(mat)\n        n = len(mat[0])\n        map = {}\n        for i in range(m):\n            for j in range(n):\n                map[mat[i][j]] = [i, j]\n        row = [0] * m\n        col = [0] * n\n        for i in range(len(arr)):\n            x = map[arr[i]]\n            row[x[0]] += 1\n            col[x[1]] += 1\n            if row[x[0]] == n or col[x[1]] == m:\n                return i\n        return -1", "entry_point": "firstCompleteIndex", "test_list": ["assert firstCompleteIndex([1,3,4,2],[[1,4],[2,3]])==2", "assert firstCompleteIndex([2,8,7,4,1,3,5,6,9],[[3,2,5],[1,4,6],[8,7,9]])==3"]}
{"Contest id": "343/2660", "text_name": "保龄球游戏的获胜者", "text": "给你两个下标从 0 开始的整数数组 player1 和 player2 ，分别表示玩家 1 和玩家 2 击中的瓶数。\n保龄球比赛由 n 轮组成，每轮的瓶数恰好为 10 。\n假设玩家在第 i 轮中击中 xi 个瓶子。玩家第 i 轮的价值为：\n如果玩家在该轮的前两轮的任何一轮中击中了 10 个瓶子，则为 2xi 。\n否则，为 xi 。\n玩家的得分是其 n 轮价值的总和。\n返回\n如果玩家 1 的得分高于玩家 2 的得分，则为 1 ；\n如果玩家 2 的得分高于玩家 1 的得分，则为 2 ；\n如果平局，则为 0 。", "canonical_solution": "def isWinner(p1, p2):\n        ans, s1, s2 = 0, 0, 0\n        n = len(p1)\n        for i in range(n):\n            s1 += p1[i]\n            s2 += p2[i]\n        if n > 1:\n            for i in range(1, n):\n                if p1[i - 1] == 10 or ((i >= 2) and p1[i - 2] == 10):\n                    s1 += p1[i]\n                if p2[i - 1] == 10 or ((i >= 2) and p2[i - 2] == 10):\n                    s2 += p2[i]\n        if s1 == s2:\n            ans = 0\n        elif s1 > s2:\n            ans = 1\n        else:\n            ans = 2\n        return ans", "entry_point": "isWinner", "test_list": ["assert isWinner([4,10,7,9],[6,5,2,3])==1", "assert isWinner([3,5,7,6],[8,10,10,2])==2", "assert isWinner([2,3],[4,1])==0"]}
{"Contest id": "Bi103/2659", "text_name": "将数组清空", "text": "给你一个包含若干互不相同整数的数组 nums ，你需要执行以下操作直到数组为空：\n如果数组中第一个元素是当前数组中的最小值，则删除它。\n否则，将第一个元素移动到数组的末尾。\n请你返回需要多少个操作使 nums 为空。", "canonical_solution": "def countOperationsToEmptyArray(A):\n        pos = {a: i for i, a in enumerate(A)}\n        res = n = len(A)\n        A.sort()\n        for i in range(1, n):\n            if pos[A[i]] < pos[A[i - 1]]:\n                res += n - i\n        return res", "entry_point": "countOperationsToEmptyArray", "test_list": ["assert countOperationsToEmptyArray([3,4,-1])==5", "assert countOperationsToEmptyArray([1,2,4,3])==5", "assert countOperationsToEmptyArray([1,2,3])==3"]}
{"Contest id": "Bi103/2658", "text_name": "网格图中鱼的最大数目", "text": "给你一个下标从 0 开始大小为 m x n 的二维整数数组 grid ，其中下标在 (r, c) 处的整数表示：\n如果 grid[r][c] = 0 ，那么它是一块 陆地 。\n如果 grid[r][c] > 0 ，那么它是一块 水域 ，且包含 grid[r][c] 条鱼。\n一位渔夫可以从任意 水域 格子 (r, c) 出发，然后执行以下操作任意次：\n捕捞格子 (r, c) 处所有的鱼，或者移动到相邻的水域格子。\n请你返回渔夫最优策略下， 最多可以捕捞多少条鱼。如果没有水域格子，请你返回 0 。\n格子 (r, c) 相邻的格子为 (r, c + 1) ，(r, c - 1) ，(r + 1, c) 和 (r - 1, c) ，前提是相邻格子在网格图内。", "canonical_solution": "def findMaxFish(grid):\n        def dfs(i,j,grid,n,m):\n            f = grid[i][j]\n            grid[i][j] = 0\n            dr = [0, 1, 0, -1, 0]\n            for k in range(4):\n                nr = i + dr[k]\n                nc = j + dr[k + 1]\n                if nr >= 0 and nr < n and nc >= 0 and nc < m and grid[nr][nc] > 0:\n                    f += dfs(nr, nc, grid, n, m)\n            return f\n        n = len(grid)\n        m = len(grid[0])\n        ans = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > 0:\n                    ans = max(ans, dfs(i, j, grid, n, m))\n        return ans", "entry_point": "findMaxFish", "test_list": ["assert findMaxFish([[0,2,1,0],[4,0,0,3],[1,0,0,4],[0,3,2,0]])==7", "assert findMaxFish([[1,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,1]])==1"]}
{"Contest id": "Bi103/2657", "text_name": "找到两个数组的前缀公共数组", "text": "给你两个下标从 0 开始长度为 n 的整数排列 A 和 B 。\nA 和 B 的 前缀公共数组 定义为数组 C ，其中 C[i] 是数组 A 和 B 到下标为 i 之前公共元素的数目。\n请你返回 A 和 B 的 前缀公共数组 。\n如果一个长度为 n 的数组包含 1 到 n 的元素恰好一次，我们称这个数组是一个长度为 n 的 排列 。", "canonical_solution": "def findThePrefixCommonArray(A, B):\n        n = len(A)\n        m1, m2 = {}, {}\n        for i in range(n):\n            m1[A[i]] = i\n            m2[B[i]] = i\n        c = [0] * n\n        for i in range(n):\n            cnt = 0\n            for j in range(i + 1):\n                if m1[A[j]] <= i and m2[A[j]] <= i:\n                    cnt += 1\n            c[i] = cnt\n        return c", "entry_point": "findThePrefixCommonArray", "test_list": ["assert findThePrefixCommonArray([1,3,2,4],[3,1,2,4])==[0,2,3,4]", "assert findThePrefixCommonArray([2,3,1],[3,1,2])==[0,1,3]"]}
{"Contest id": "Bi103/2656", "text_name": "K个元素的最大和", "text": "给你一个下标从 0 开始的整数数组 nums 和一个整数 k 。你需要执行以下操作 恰好 k 次，最大化你的得分：\n从 nums 中选择一个元素 m 。\n将选中的元素 m 从数组中删除。\n将新元素 m + 1 添加到数组中。\n你的得分增加 m 。\n请你返回执行以上操作恰好 k 次后的最大得分。", "canonical_solution": "def maximizeSum(nums, k):\n        return (max(nums))*k + (k-1)*k/2", "entry_point": "maximizeSum", "test_list": ["assert maximizeSum([1,2,3,4,5],3)==18", "assert maximizeSum([5,5,5],2)==11"]}
{"Contest id": "342/2654", "text_name": "使数组所有元素变成1的最少操作次数", "text": "给你一个下标从 0 开始的 正 整数数组 nums 。你可以对数组执行以下操作任意次：\n选择一个满足 0 <= i < n - 1 的下标 i ，将 nums[i] 或者 nums[i+1] 两者之一替换成它们的最大公约数。\n请你返回使数组 nums 中所有元素都等于 1 的 最少 操作次数。如果无法让数组全部变成 1 ，请你返回 -1 。\n两个正整数的最大公约数指的是能整除这两个数的最大正整数。", "canonical_solution": "from math import inf, gcd\ndef minOperations(nums):\n        n = len(nums)\n        ones = nums.count(1)\n        if ones: return n - ones\n        res = inf\n        for i in range(n):\n            g = nums[i]\n            for j in range(i + 1, n):\n                g = gcd(g, nums[j])\n                if g == 1:\n                    res = min(res, j - i)\n        if res == inf: return -1\n        return res + n - 1", "entry_point": "minOperations", "test_list": ["assert minOperations([2,6,3,4])==4", "assert minOperations([2,10,6,14])==-1"]}
{"Contest id": "342/2652", "text_name": "倍数求和", "text": "给你一个正整数 n ，请你计算在 [1，n] 范围内能被 3、5、7 整除的所有整数之和。\n返回一个整数，用于表示给定范围内所有满足约束条件的数字之和。", "canonical_solution": "def sumOfMultiples(n):\n        mul = 0\n        for i in range(1, n+1):\n            if i%3==0 or i%5==0 or i%7==0:\n                mul+=i\n        return mul", "entry_point": "sumOfMultiples", "test_list": ["assert sumOfMultiples(7)==21", "assert sumOfMultiples(10)==40", "assert sumOfMultiples(9)==30"]}
{"Contest id": "342/2651", "text_name": "计算列车到站时间", "text": "给你一个正整数 arrivalTime 表示列车正点到站的时间（单位：小时），另给你一个正整数 delayedTime 表示列车延误的小时数。\n返回列车实际到站的时间。\n注意，该问题中的时间采用 24 小时制。", "canonical_solution": "def findDelayedArrivalTime(at,dt):\n        arrive = at + dt\n        if arrive >= 24:\n            return arrive - 24\n        return arrive", "entry_point": "findDelayedArrivalTime", "test_list": ["assert findDelayedArrivalTime(15,5)==20", "assert findDelayedArrivalTime(13,11)==0"]}
{"Contest id": "341/2646", "text_name": "最小化旅行的价格总和", "text": "现有一棵无向、无根的树，树中有 n 个节点，按从 0 到 n - 1 编号。给你一个整数 n 和一个长度为 n - 1 的二维整数数组 edges ，其中 edges[i] = [ai, bi] 表示树中节点 ai 和 bi 之间存在一条边。\n每个节点都关联一个价格。给你一个整数数组 price ，其中 price[i] 是第 i 个节点的价格。\n给定路径的 价格总和 是该路径上所有节点的价格之和。\n另给你一个二维整数数组 trips ，其中 trips[i] = [starti, endi] 表示您从节点 starti 开始第 i 次旅行，并通过任何你喜欢的路径前往节点 endi 。\n在执行第一次旅行之前，你可以选择一些 非相邻节点 并将价格减半。\n返回执行所有旅行的最小价格总和。", "canonical_solution": "from collections import deque\ndef minimumTotalPrice(n, edges, price, trips):\n    tree = [[] for _ in range(n)]\n    for u, v in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    freq = [0] * n\n    for s, e in trips:\n        queue = deque([(s, -1)])\n        parent = {s: -1}\n        while queue:\n            u, p = queue.popleft()\n            if u == e: break\n            for v in tree[u]:\n                if v != p:\n                    queue.append((v, u))\n                    parent[v] = u\n        u = e\n        while u >= 0:\n            freq[u] += 1\n            u = parent[u]\n\n    def dfs(u, p):\n        full = half = 0\n        for v in tree[u]:\n            if v != p:\n                ff, hh = dfs(v, u)\n                full += ff\n                half += min(ff, hh)\n        return price[u] * freq[u] + half, price[u] * freq[u] // 2 + full\n\n    return min(dfs(0, -1))", "entry_point": "minimumTotalPrice", "test_list": ["assert minimumTotalPrice(4,[[0,1],[1,2],[1,3]],[2,2,10,6],[[0,3],[2,1],[2,3]])==23", "assert minimumTotalPrice(2,[[0,1]],[2,2],[[0,0]])==1"]}
{"Contest id": "341/2645", "text_name": "构造有效字符串的最少插入数", "text": "给你一个字符串 word ，你可以向其中任何位置插入 \"a\"、\"b\" 或 \"c\" 任意次，返回使 word 有效 需要插入的最少字母数。\n如果字符串可以由 \"abc\" 串联多次得到，则认为该字符串 有效 。", "canonical_solution": "def addMinimum(word):\n        k, prev = 0, 'z'\n        for c in word:\n            k += c <= prev\n            prev = c\n        return k * 3 - len(word)", "entry_point": "addMinimum", "test_list": ["assert addMinimum(\"b\")==2", "assert addMinimum(\"aaa\")==6", "assert addMinimum(\"abc\")==0"]}
{"Contest id": "341/2644", "text_name": "找出可整除性得分最大的整数", "text": "给你两个下标从 0 开始的整数数组 nums 和 divisors 。\ndivisors[i] 的 可整除性得分 等于满足 nums[j] 能被 divisors[i] 整除的下标 j 的数量。\n返回 可整除性得分 最大的整数 divisors[i] 。如果有多个整数具有最大得分，则返回数值最小的一个。", "canonical_solution": "def maxDivScore(nums, divisors):\n        res = -1\n        mx_cnt = -1\n        for d in divisors:\n            cnt = 0\n            for x in nums:\n                if x % d == 0:\n                    cnt += 1\n            if cnt > mx_cnt:\n                mx_cnt = cnt\n                res = d\n            elif cnt == mx_cnt:\n                res = min(res, d)\n        return res", "entry_point": "maxDivScore", "test_list": ["assert maxDivScore([4,7,9,3,9],[5,2,3])==3", "assert maxDivScore([20,14,21,10],[5,7,5])==5", "assert maxDivScore([12],[10,16])==10"]}
{"Contest id": "341/2643", "text_name": "一最多的行", "text": "给你一个大小为 m x n 的二进制矩阵 mat ，请你找出包含最多 1 的行的下标（从 0 开始）以及这一行中 1 的数目。\n如果有多行包含最多的 1 ，只需要选择 行下标最小 的那一行。\n返回一个由行下标和该行中 1 的数量组成的数组。", "canonical_solution": "def rowAndMaximumOnes(mat):\n        output = [0,0]\n        for index, item in enumerate(mat):\n            one_count = item.count(1)\n            if one_count > output[1]:\n                output[0] = index\n                output[1] = one_count\n        return output", "entry_point": "rowAndMaximumOnes", "test_list": ["assert rowAndMaximumOnes([[0,1],[1,0]])==[0,1]", "assert rowAndMaximumOnes([[0,0,0],[0,1,1]])==[1,2]", "assert rowAndMaximumOnes([[0,0],[1,1],[0,0]])==[1,2]"]}
{"Contest id": "Bi102/2640", "text_name": "一个数组所有前缀的分数", "text": "定义一个数组 arr 的 转换数组 conver 为：\nconver[i] = arr[i] + max(arr[0..i])，其中 max(arr[0..i]) 是满足 0 <= j <= i 的所有 arr[j] 中的最大值。\n定义一个数组 arr 的 分数 为 arr 转换数组中所有元素的和。\n给你一个下标从 0 开始长度为 n 的整数数组 nums ，请你返回一个长度为 n 的数组 ans ，其中 ans[i]是前缀 nums[0..i] 的分数。", "canonical_solution": "import heapq\nfrom heapq import heappush\ndef findPrefixScore(nums):\n    heap = [-nums[0]]\n    result = []\n    runningSum = 0\n    for num in nums:\n        maxSum = max(num, -1 * heapq.heappop(heap))\n        result.append(runningSum + num + maxSum)\n        runningSum += maxSum + num\n        heappush(heap, -maxSum)\n    return result", "entry_point": "findPrefixScore", "test_list": ["assert findPrefixScore([2,3,7,5,10])==[4,10,24,36,56]", "assert findPrefixScore([1,1,2,4,8,16])==[2,4,8,16,32,64]"]}
{"Contest id": "Bi102/2639", "text_name": "查询网格图中每一列的宽度", "text": "给你一个下标从 0 开始的 m x n 整数矩阵 grid 。矩阵中某一列的宽度是这一列数字的最大字符串长度 。\n比方说，如果 grid = [[-10], [3], [12]] ，那么唯一一列的宽度是 3 ，因为 -10 的字符串长度为 3 。\n请你返回一个大小为 n 的整数数组 ans ，其中 ans[i] 是第 i 列的宽度。\n一个有 len 个数位的整数 x ，如果是非负数，那么 字符串长度 为 len ，否则为 len + 1 。", "canonical_solution": "def findColumnWidth(grid):\n        def cal(x):\n            res = 0\n            if x == 0:\n                res += 1\n            if x < 0:\n                res += 1\n                x = -x\n            while x > 0:\n                x //= 10\n                res += 1\n            return res\n        return [max(cal(y) for y in x) for x in zip(*grid)]", "entry_point": "findColumnWidth", "test_list": ["assert findColumnWidth([[1],[22],[333]])==[3]", "assert findColumnWidth([[-15,1,3],[15,7,12],[5,6,-2]])==[3,1,2]"]}
{"Contest id": "340/2617", "text_name": "网格图中最少访问的格子数", "text": "给你一个下标从 0 开始的 m x n 整数矩阵 grid 。你一开始的位置在 左上角 格子 (0, 0) 。\n当你在格子 (i, j) 的时候，你可以移动到以下格子之一：\n满足 j < k <= grid[i][j] + j 的格子 (i, k) （向右移动），或者\n满足 i < k <= grid[i][j] + i 的格子 (k, j) （向下移动）。\n请你返回到达 右下角 格子 (m - 1, n - 1) 需要经过的最少移动格子数，如果无法到达右下角格子，请你返回 -1 。", "canonical_solution": "def minimumVisitedCells(grid):\n        from collections import deque\n        from sortedcontainers import SortedList\n        m, n = len(grid), len(grid[0])\n        s0 = [SortedList(range(n)) for _ in range(m)]\n        s1 = [SortedList(range(m)) for _ in range(n)]\n        q = deque([(0, 0, 1)])\n        while q:\n            i, j, d = q.popleft()\n            if (i, j) == (m-1, n-1):\n                return d\n            for k in list(s0[i].irange(j+1, min(j+1+grid[i][j], n) - 1)):\n                q.append((i, k, d+1))\n                s0[i].remove(k)\n                s1[k].remove(i)\n            for k in list(s1[j].irange(i+1, min(i+1+grid[i][j], m) - 1)):\n                q.append((k, j, d+1))\n                s1[j].remove(k)\n                s0[k].remove(j)\n        return -1", "entry_point": "minimumVisitedCells", "test_list": ["assert minimumVisitedCells([[3,4,2,1],[4,2,3,1],[2,1,0,0],[2,4,0,0]])==4", "assert minimumVisitedCells([[3,4,2,1],[4,2,1,1],[2,1,1,0],[3,4,1,0]])==3", "assert minimumVisitedCells([[2,1,0],[1,0,0]])==-1"]}
{"Contest id": "340/2616", "text_name": "最小化数对的最大差值", "text": "给你一个下标从 0 开始的整数数组 nums 和一个整数 p 。请你从 nums 中找到 p 个下标对，每个下标对对应数值取差值，你需要使得这 p 个差值的 最大值 最小。同时，你需要确保每个下标在这 p 个下标对中最多出现一次。\n对于一个下标对 i 和 j ，这一对的差值为 |nums[i] - nums[j]| ，其中 |x| 表示 x 的 绝对值 。\n请你返回 p 个下标对对应数值 最大差值 的 最小值 。", "canonical_solution": "def minimizeMax(nums, p):\n    def can_form_pairs(mid):\n        count = 0\n        i = 0\n        while i < len(nums) - 1 and count < p:\n            if nums[i + 1] - nums[i] <= mid:\n                count += 1\n                i += 2\n            else:\n                i += 1\n        return count >= p\n\n    nums.sort()\n    left, right = 0, nums[-1] - nums[0]\n\n    while left < right:\n        mid = (left + right) // 2\n        if can_form_pairs(mid):\n            right = mid\n        else:\n            left = mid + 1\n\n    return left", "entry_point": "minimizeMax", "test_list": ["assert minimizeMax([10,1,2,7,1,3],2)==1", "assert minimizeMax([4,2,1,2],1)==0"]}
{"Contest id": "340/2615", "text_name": "等值距离和", "text": "给你一个下标从 0 开始的整数数组 nums 。现有一个长度等于 nums.length 的数组 arr 。对于满足 nums[j] == nums[i] 且 j != i 的所有 j ，arr[i] 等于所有 |i - j| 之和。如果不存在这样的 j ，则令 arr[i] 等于 0 。\n返回数组 arr 。", "canonical_solution": "def distance(nums):\n        vals = defaultdict(lambda: [0])\n        for i, x in enumerate(nums):\n            vals[x].append(vals[x][-1] + i)\n        cnts = defaultdict(int)\n        ans = []\n        for i, x in enumerate(nums):\n            c = cnts[x]\n            sz = len(vals[x]) - 1\n            cur = c * i - vals[x][c] + (vals[x][-1] - vals[x][c]) - i * (sz - c)\n            cnts[x] += 1\n            ans.append(cur)\n        return ans", "entry_point": "distance", "test_list": ["assert distance([1,3,1,1,2])==[5,0,3,4,0]", "assert distance([0,5,3])==[0,0,0]"]}
{"Contest id": "340/2614", "text_name": "对角线上的质数", "text": "给你一个下标从 0 开始的二维整数数组 nums 。\n返回位于 nums 至少一条 对角线 上的最大 质数 。如果任一对角线上均不存在质数，返回 0 。\n注意：\n如果某个整数大于 1 ，且不存在除 1 和自身之外的正整数因子，则认为该整数是一个质数。\n如果存在整数 i ，使得 nums[i][i] = val 或者 nums[i][nums.length - i - 1]= val ，则认为整数 val 位于 nums 的一条对角线上。", "canonical_solution": "def diagonalPrime(nums):\n        def is_prime(num):\n            if num <= 1:\n                return False\n            for i in range(2, int(num ** 0.5) + 1):\n                if num % i == 0:\n                    return False\n            return True\n        largest_prime = 0\n        n = len(nums)\n        for i in range(n):\n            if is_prime(nums[i][i]):\n                largest_prime = max(largest_prime, nums[i][i])\n            if is_prime(nums[i][n-i-1]):\n                largest_prime = max(largest_prime, nums[i][n-i-1])\n        return largest_prime", "entry_point": "diagonalPrime", "test_list": ["assert diagonalPrime([[1,2,3],[5,6,7],[9,10,11]])==11", "assert diagonalPrime([[1,2,3],[5,17,7],[9,11,10]])==17"]}
{"Contest id": "339/2612", "text_name": "最少翻转操作数", "text": "给你一个整数 n 和一个在范围 [0, n - 1] 以内的整数 p ，它们表示一个长度为 n 且下标从 0 开始的数组 arr ，数组中除了下标为 p 处是 1 以外，其他所有数都是 0 。\n同时给你一个整数数组 banned ，它包含数组中的一些位置。banned 中第 i 个位置表示 arr[banned[i]] = 0 ，题目保证 banned[i] != p 。\n你可以对 arr 进行 若干次 操作。一次操作中，你选择大小为 k 的一个 子数组 ，并将它 翻转 。在任何一次翻转操作后，你都需要确保 arr 中唯一的 1 不会到达任何 banned 中的位置。换句话说，arr[banned[i]] 始终 保持 0 。\n请你返回一个数组 ans ，对于 [0, n - 1] 之间的任意下标 i ，ans[i] 是将 1 放到位置 i 处的 最少 翻转操作次数，如果无法放到位置 i 处，此数为 -1 。\n子数组 指的是一个数组里一段连续 非空 的元素序列。\n对于所有的 i ，ans[i] 相互之间独立计算。\n将一个数组中的元素 翻转 指的是将数组中的值变成 相反顺序 。", "canonical_solution": "def minReverseOperations(n, p, banned, k):\n    from bisect import bisect_left\n    s = set(banned) | {p}\n    not_banned = [[], []]\n    for i in range(n):\n        if i not in s:\n            not_banned[i % 2].append(i)\n    not_banned[0].append(n)\n    not_banned[1].append(n)  # 哨兵\n    fa = [list(range(len(not_banned[0]))), list(range(len(not_banned[1])))]\n    def find(i, x) :\n        f = fa[i]\n        if f[x] != x:\n            f[x] = find(i, f[x])\n        return f[x]\n    def merge(i, from_, to) :\n        x, y = find(i, from_), find(i, to)\n        fa[i][x] = y\n    ans = [-1] * n\n    q = [p]\n    step = 0\n    while q:\n        tmp = q\n        q = []\n        for i in tmp:\n            ans[i] = step\n            mn = max(i - k + 1, k - i - 1)\n            mx = min(i + k - 1, n * 2 - k - i - 1)\n            a = not_banned[mn % 2]\n            j = find(mn % 2, bisect_left(a, mn))\n            while a[j] <= mx:\n                q.append(a[j])\n                merge(mn % 2, j, j + 1)  # 删除 j\n                j = find(mn % 2, j + 1)\n        step += 1\n    return ans", "entry_point": "minReverseOperations", "test_list": ["assert minReverseOperations(4,0,[1,2],4)==[0,-1,-1,1]", "assert minReverseOperations(5,0,[2,4],3)==[0,-1,-1,-1,-1]", "assert minReverseOperations(4,2,[0,1,3],1)==[-1,-1,0,-1]"]}
{"Contest id": "339/2611", "text_name": "老鼠和奶酪", "text": "有两只老鼠和 n 块不同类型的奶酪，每块奶酪都只能被其中一只老鼠吃掉。\n下标为 i 处的奶酪被吃掉的得分为：\n如果第一只老鼠吃掉，则得分为 reward1[i] 。\n如果第二只老鼠吃掉，则得分为 reward2[i] 。\n给你一个正整数数组 reward1 ，一个正整数数组 reward2 ，和一个非负整数 k 。\n请你返回第一只老鼠恰好吃掉 k 块奶酪的情况下，最大得分为多少。", "canonical_solution": "def miceAndCheese(reward1, reward2, k):\n    a = sorted(zip(reward1, reward2), key=lambda p: p[1] - p[0])\n    return sum(x for x, _ in a[:k]) + sum(y for _, y in a[k:])", "entry_point": "miceAndCheese", "test_list": ["assert miceAndCheese(reward1 = [1,1,3,4], reward2 = [4,4,1,1], k = 2)==15", "assert miceAndCheese(reward1 = [1,1], reward2 = [1,1], k = 2)==2"]}
{"Contest id": "339/2610", "text_name": "转换二维数组", "text": "给你一个整数数组 nums 。请你创建一个满足以下条件的二维数组：\n二维数组应该只包含数组 nums 中的元素。\n二维数组中的每一行都包含 不同 的整数。\n二维数组的行数应尽可能 少 。\n返回结果数组。如果存在多种答案，则返回其中任何一种。\n请注意，二维数组的每一行上可以存在不同数量的元素。", "canonical_solution": "def findMatrix(nums):\n    from collections import Counter\n    ans = []\n    cnt = Counter(nums)\n    while cnt:\n        ans.append(list(cnt))\n        for x in ans[-1]:\n            cnt[x] -= 1\n            if cnt[x] == 0:\n                del cnt[x]\n    return ans", "entry_point": "findMatrix", "test_list": ["assert findMatrix([1,3,4,1,2,3,1])==[[1,3,4,2],[1,3],[1]]", "assert findMatrix([2,1,1])==[[2,1],[1]]"]}
{"Contest id": "339/2609", "text_name": "最长平衡子字符串", "text": "给你一个仅由 0 和 1 组成的二进制字符串 s 。  \n如果子字符串中 所有的 0 都在 1 之前 且其中 0 的数量等于 1 的数量，则认为 s 的这个子字符串是平衡子字符串。请注意，空子字符串也视作平衡子字符串。 \n返回s中最长的平衡子字符串长度。\n子字符串是字符串中的一个连续字符序列。", "canonical_solution": "def findTheLongestBalancedSubstring(s):\n        temp = '01'\n        while temp in s:\n            temp = '0' + temp + '1'\n        return len(temp) - 2", "entry_point": "findTheLongestBalancedSubstring", "test_list": ["assert findTheLongestBalancedSubstring(\"01000111\")==6", "assert findTheLongestBalancedSubstring(\"00111\")==4", "assert findTheLongestBalancedSubstring(\"111\")==0"]}
{"Contest id": "Bi101/2608", "text_name": "图中的最短环", "text": "现有一个含 n 个顶点的 双向 图，每个顶点按从 0 到 n - 1 标记。图中的边由二维整数数组 edges 表示，其中 edges[i] = [ui, vi] 表示顶点 ui 和 vi 之间存在一条边。每对顶点最多通过一条边连接，并且不存在与自身相连的顶点。\n返回图中 最短 环的长度。如果不存在环，则返回 -1 。\n环 是指以同一节点开始和结束，并且路径中的每条边仅使用一次。", "canonical_solution": "from math import inf\ndef findShortestCycle(n, edges):\n        G = [[] for _ in range(n)]\n        for i, j in edges:\n            G[i].append(j)\n            G[j].append(i)\n        def root(i):\n            dis = [inf] * n\n            dis[i] = 0\n            bfs = [i]\n            for i in bfs:\n                for j in G[i]:\n                    if dis[j] == inf:\n                        dis[j] = 1 + dis[i]\n                        bfs.append(j)\n                    elif dis[i] <= dis[j]:\n                        return dis[i] + dis[j] + 1\n            return inf\n        res = min(map(root, range(n)))\n        return res if res < inf else -1", "entry_point": "findShortestCycle", "test_list": ["assert findShortestCycle(7,[[0,1],[1,2],[2,0],[3,4],[4,5],[5,6],[6,3]])==3", "assert findShortestCycle(4,[[0,1],[0,2]])==-1"]}
{"Contest id": "Bi101/2607", "text_name": "使子数组元素和相等", "text": "给你一个下标从 0 开始的整数数组 arr 和一个整数 k 。数组 arr 是一个循环数组。换句话说，数组中的最后一个元素的下一个元素是数组中的第一个元素，数组中第一个元素的前一个元素是数组中的最后一个元素。\n你可以执行下述运算任意次：\n选中 arr 中任意一个元素，并使其值加上 1 或减去 1 。\n执行运算使每个长度为 k 的 子数组 的元素总和都相等，返回所需要的最少运算次数。\n子数组 是数组的一个连续部分。", "canonical_solution": "def makeSubKSumEqual(arr, k):\n        def gcd(a, b):\n            if b == 0:\n                return a\n            return gcd(b, a % b)\n        n = len(arr)\n        v = [[] for i in range(n + 1)]\n        k = gcd(n, k)\n        for i in range(n):\n            v[i % k].append(arr[i])\n        ans = 0\n        for i in range(k):\n            v[i].sort()\n            x = v[i][len(v[i]) // 2]\n            for j in v[i]:\n                ans += abs(x - j)\n        return ans", "entry_point": "makeSubKSumEqual", "test_list": ["assert makeSubKSumEqual([1,4,1,3],2)==1", "assert makeSubKSumEqual([2,5,5,7],3)==5"]}
{"Contest id": "Bi101/2606", "text_name": "找到最大开销的子字符串", "text": "给你一个字符串 s ，一个字符 互不相同 的字符串 chars 和一个长度与 chars 相同的整数数组 vals 。\n子字符串的开销 是一个子字符串中所有字符对应价值之和。空字符串的开销是 0 。\n字符的价值 定义如下：\n如果字符不在字符串 chars 中，那么它的价值是它在字母表中的位置（下标从 1 开始）。\n比方说，'a' 的价值为 1 ，'b' 的价值为 2 ，以此类推，'z' 的价值为 26 。\n否则，如果这个字符在 chars 中的位置为 i ，那么它的价值就是 vals[i] 。\n请你返回字符串 s 的所有子字符串中的最大开销。", "canonical_solution": "def maximumCostSubstring(s, chars, vals):\n        m = dict(zip(chars, vals))\n        res = cur = 0\n        for c in s:\n            cur = max(cur + m.get(c, ord(c) - ord('a') + 1), 0)\n            res = max(res, cur)\n        return res", "entry_point": "maximumCostSubstring", "test_list": ["assert maximumCostSubstring(\"adaa\",\"d\",[-1000])==2", "assert maximumCostSubstring(\"abc\",\"abc\",[-1,-1,-1])==0"]}
{"Contest id": "Bi101/2605", "text_name": "从两个数字数组里生成最小数字", "text": "给你两个只包含 1 到 9 之间数字的数组 nums1 和 nums2 ，每个数组中的元素 互不相同 ，请你返回 最小 的数字，两个数组都 至少 包含这个数字的某个数位。", "canonical_solution": "def minNumber(nums1, nums2):\n        small1, small2, common = min(nums1), min(nums2), set(nums1) & set(nums2)\n        output1, output2 = int(f\"{small1}{small2}\"), int(f\"{small2}{small1}\")\n        if common:\n            common = min(common)\n            if common < output1 and common < output2:\n                return common\n        if small1 < small2:\n            return output1\n        return output2", "entry_point": "minNumber", "test_list": ["assert minNumber([4,1,3],[5,7])==15", "assert minNumber([3,5,2,6],[3,1,7])==3"]}
{"Contest id": "338/2603", "text_name": "收集树中金币", "text": "给你一个 n 个节点的无向无根树，节点编号从 0 到 n - 1 。给你整数 n 和一个长度为 n - 1 的二维整数数组 edges ，其中 edges[i] = [ai, bi] 表示树中节点 ai 和 bi 之间有一条边。再给你一个长度为 n 的数组 coins ，其中 coins[i] 可能为 0 也可能为 1 ，1 表示节点 i 处有一个金币。\n一开始，你需要选择树中任意一个节点出发。你可以执行下述操作任意次：\n收集距离当前节点距离为 2 以内的所有金币，或者\n移动到树中一个相邻节点。\n你需要收集树中所有的金币，并且回到出发节点，请你返回最少经过的边数。\n如果你多次经过一条边，每一次经过都会给答案加一。", "canonical_solution": "def collectTheCoins(coins, edges):\n        n = len(coins)\n        tree = [set() for _ in range(n)]\n        for e in edges:\n            tree[e[0]].add(e[1])\n            tree[e[1]].add(e[0])\n        leaf = []\n        for i in range(n):\n            u = i\n            while len(tree[u]) == 1 and coins[u] == 0:\n                v = tree[u].pop()\n                tree[v].remove(u)\n                u = v\n            if len(tree[u]) == 1:\n                leaf.append(u)\n        for sz in range(2, 0, -1):\n            temp = []\n            for u in leaf:\n                if len(tree[u]) == 1:\n                    v = tree[u].pop()\n                    tree[v].remove(u)\n                    if len(tree[v]) == 1:\n                        temp.append(v)\n            leaf = temp\n        ans = 0\n        for i in range(n):\n            ans += len(tree[i])\n        return ans", "entry_point": "collectTheCoins", "test_list": ["assert collectTheCoins([1,0,0,0,0,1],[[0,1],[1,2],[2,3],[3,4],[4,5]])==2", "assert collectTheCoins([0,0,0,1,1,0,0,1],[[0,1],[0,2],[1,3],[1,4],[2,5],[5,6],[5,7]])==2"]}
{"Contest id": "338/2602", "text_name": "使数组元素全部相等的最少操作次数", "text": "给你一个正整数数组 nums 。\n同时给你一个长度为 m 的整数数组 queries 。第 i 个查询中，你需要将 nums 中所有元素变成 queries[i] 。你可以执行以下操作 任意 次：\n将数组里一个元素 增大 或者 减小 1 。\n请你返回一个长度为 m 的数组 answer ，其中 answer[i]是将 nums 中所有元素变成 queries[i] 的 最少 操作次数。\n注意，每次查询后，数组变回最开始的值。", "canonical_solution": "def minOperations(nums, queries):\n        nums.sort()\n        aug = [(q, i) for i, q in enumerate(queries)]\n        aug.sort()\n        total = sum(nums)\n        prefix = 0\n        k = 0\n        ans = [0] * len(queries)\n        for q, i in aug:\n            while k < len(nums) and nums[k] < q:\n                prefix += nums[k]\n                k += 1\n            ans[i] = total - 2 * prefix + q * (2 * k - len(nums))\n        return ans", "entry_point": "minOperations", "test_list": ["assert minOperations([3,1,6,8],[1,5])==[14,10]", "assert minOperations([2,9,6,3],[10])==[20]"]}
{"Contest id": "338/2601", "text_name": "质数加减法运算", "text": "给你一个下标从 0 开始的整数数组 nums ，数组长度为 n 。\n你可以执行无限次下述运算：\n选择一个之前未选过的下标 i ，并选择一个 严格小于 nums[i] 的质数 p ，从 nums[i] 中减去 p 。\n如果你能通过上述运算使得 nums 成为严格递增数组，则返回 true ；否则返回 false 。\n严格递增数组 中的每个元素都严格大于其前面的元素。", "canonical_solution": "def primeSubOperation(nums):\n     def isPrime(x):\n        if x == 1:\n           return False\n        for i in range(2, int(x ** 0.5) + 1):\n            if x %i == 0:\n                return False\n        return True\n     p = 0\n     for x in nums:\n         if x <= p:\n             return False\n         prime = x - p - 1\n         while prime > 0 and not isPrime(prime):\n             prime -= 1\n         if prime == 0:\n             p = x\n         else:\n             p = x - prime\n     return True", "entry_point": "primeSubOperation", "test_list": ["assert primeSubOperation([4,9,6,10])==True", "assert primeSubOperation([6,8,11,12])==True", "assert primeSubOperation([5,8,3])==False"]}
{"Contest id": "338/2600", "text_name": "K件物品的最大和", "text": "袋子中装有一些物品，每个物品上都标记着数字 1 、0 或 -1 。\n给你四个非负整数 numOnes 、numZeros 、numNegOnes 和 k 。\n袋子最初包含：\nnumOnes 件标记为 1 的物品。\nnumZeros 件标记为 0 的物品。\nnumNegOnes 件标记为 -1 的物品。\n现计划从这些物品中恰好选出 k 件物品。返回所有可行方案中，物品上所标记数字之和的最大值。", "canonical_solution": "def kItemsWithMaximumSum(numOnes, numZeros, numNegOnes, k):\n        return min(k, numOnes) - max(0, k - numZeros - numOnes)", "entry_point": "kItemsWithMaximumSum", "test_list": ["assert kItemsWithMaximumSum(3,2,0,2)==2", "assert kItemsWithMaximumSum(3,2,0,4)==3"]}
{"Contest id": "337/2598", "text_name": "执行操作后的最大MEX", "text": "给你一个下标从 0 开始的整数数组 nums 和一个整数 value 。\n在一步操作中，你可以对 nums 中的任一元素加上或减去 value 。\n例如，如果 nums = [1,2,3] 且 value = 2 ，你可以选择 nums[0] 减去 value ，得到 nums = [-1,2,3] 。\n数组的 MEX (minimum excluded) 是指其中数组中缺失的最小非负整数。\n例如，[-1,2,3] 的 MEX 是 0 ，而 [1,0,3] 的 MEX 是 2 。\n返回在执行上述操作 任意次 后，nums 的最大 MEX 。", "canonical_solution": "from collections import Counter\ndef findSmallestInteger(nums, value):\n    count = Counter(a % value for a in nums)\n    stop = 0\n    for i in range(value):\n        if count[i] < count[stop]:\n            stop = i\n    return value * count[stop] + stop", "entry_point": "findSmallestInteger", "test_list": ["assert findSmallestInteger([1,-10,7,13,6,8],5)==4", "assert findSmallestInteger([1,-10,7,13,6,8],7)==2"]}
{"Contest id": "337/2597", "text_name": "美丽子集的数目", "text": "给你一个由正整数组成的数组 nums 和一个 正 整数 k 。\n如果 nums 的子集中，任意两个整数的绝对差均不等于 k ，则认为该子数组是一个 美丽 子集。\n返回数组 nums 中 非空 且 美丽 的子集数目。\nnums 的子集定义为：可以经由 nums 删除某些元素（也可能不删除）得到的一个数组。只有在删除元素时选择的索引不同的情况下，两个子集才会被视作是不同的子集。", "canonical_solution": "def beautifulSubsets(nums, k):\n    freq = {}\n\n    def f(i):\n        if i == len(nums):\n            return 1\n        result = f(i + 1)\n        if not nums[i] - k in freq and not nums[i] + k in freq:\n            freq[nums[i]] = freq[nums[i]] + 1 if nums[i] in freq else 1\n            result += f(i + 1)\n            freq[nums[i]] -= 1\n            if freq[nums[i]] == 0:\n                del freq[nums[i]]\n        return result\n\n    return f(0) - 1", "entry_point": "beautifulSubsets", "test_list": ["assert beautifulSubsets([2,4,6],2)==4", "assert beautifulSubsets([1],1)==1"]}
{"Contest id": "337/2596", "text_name": "检查骑士巡视方案", "text": "骑士在一张 n x n 的棋盘上巡视。在 有效 的巡视方案中，骑士会从棋盘的 左上角 出发，并且访问棋盘上的每个格子 恰好一次 。\n给你一个 n x n 的整数矩阵 grid ，由范围 [0, n * n - 1] 内的不同整数组成，其中 grid[row][col] 表示单元格 (row, col) 是骑士访问的第 grid[row][col] 个单元格。骑士的行动是从下标 0 开始的。\n如果 grid 表示了骑士的有效巡视方案，返回 true；否则返回 false。\n注意，骑士行动时可以垂直移动两个格子且水平移动一个格子，或水平移动两个格子且垂直移动一个格子。下图展示了骑士从某个格子出发可能的八种行动路线。", "canonical_solution": "from collections import deque\ndef checkValidGrid(grid):\n        n = len(grid)\n        q = deque( [(0, 0)] )\n        res = 0\n        while q:\n            res += 1\n            x, y = q.popleft()\n            for i, j in [ (x + 1, y + 2), (x + 1, y - 2), (x - 1, y + 2), (x - 1, y - 2), (x + 2, y + 1), (x + 2, y - 1), (x - 2, y + 1), (x - 2, y - 1) ]:\n                if 0 <= i < n and 0 <= j < n and grid[i][j] == grid[x][y] + 1:\n                    q.append( (i, j) )\n        return res == pow(n, 2)", "entry_point": "checkValidGrid", "test_list": ["assert checkValidGrid([[0,11,16,5,20],[17,4,19,10,15],[12,1,8,21,6],[3,18,23,14,9],[24,13,2,7,22]])==True", "assert checkValidGrid([[0,3,6],[5,8,1],[2,7,4]])==False"]}
{"Contest id": "337/2595", "text_name": "奇偶位数", "text": "给你一个 正 整数 n 。\n用 even 表示在 n 的二进制形式（下标从 0 开始）中值为 1 的偶数下标的个数。\n用 odd 表示在 n 的二进制形式（下标从 0 开始）中值为 1 的奇数下标的个数。\n返回整数数组 answer ，其中 answer = [even, odd] 。", "canonical_solution": "def evenOddBit(n):\n        ans = [0, 0]\n        for idx, val in enumerate(bin(n)[2:][::-1]):\n            if idx % 2 == 0 and val == '1':\n                ans[0] += 1\n            elif idx % 2 == 1 and val == '1':\n                ans[1] += 1       \n        return ans", "entry_point": "evenOddBit", "test_list": ["assert evenOddBit(17)==[2,0]", "assert evenOddBit(2)==[0,1]"]}
{"Contest id": "Bi100/2594", "text_name": "修车的最少时间", "text": "给你一个整数数组 ranks ，表示一些机械工的 能力值 。ranksi 是第 i 位机械工的能力值。能力值为 r 的机械工可以在 r * n2 分钟内修好 n 辆车。\n同时给你一个整数 cars ，表示总共需要修理的汽车数目。\n请你返回修理所有汽车 最少 需要多少时间。\n注意：所有机械工可以同时修理汽车。", "canonical_solution": "from collections import Counter\nfrom math import isqrt\ndef repairCars(A, cars):\n    count = Counter(A)\n    left, right = 1, min(count) * cars * cars\n    while left < right:\n        mid = (left + right) // 2\n        if sum(isqrt(mid // a) * count[a] for a in count) < cars:\n            left = mid + 1\n        else:\n            right = mid\n    return left", "entry_point": "repairCars", "test_list": ["assert repairCars([4,2,3,1],10)==16", "assert repairCars([5,1,8],6)==16"]}
{"Contest id": "Bi100/2593", "text_name": "标记所有元素后数组的分数", "text": "给你一个数组 nums ，它包含若干正整数。\n一开始分数 score = 0 ，请你按照下面算法求出最后分数：\n从数组中选择最小且没有被标记的整数。如果有相等元素，选择下标最小的一个。\n将选中的整数加到 score 中。\n标记 被选中元素，如果有相邻元素，则同时标记 与它相邻的两个元素 。\n重复此过程直到数组中所有元素都被标记。\n请你返回执行上述算法后最后的分数。", "canonical_solution": "def findScore(nums):\n        seen = [0] * (len(nums) + 1)\n        res = 0\n        for a,i in sorted([a,i] for i,a in enumerate(nums)):\n            if seen[i]: continue\n            res += a\n            seen[i] = seen[i - 1] = seen[i + 1] = 1\n        return res", "entry_point": "findScore", "test_list": ["assert findScore([2,1,3,4,5,2])==7", "assert findScore([2,3,5,1,3,2])==5"]}
{"Contest id": "Bi100/2592", "text_name": "最大化数组的伟大值", "text": "给你一个下标从 0 开始的整数数组 nums 。你需要将 nums 重新排列成一个新的数组 perm 。\n定义 nums 的 伟大值 为满足 0 <= i < nums.length 且 perm[i] > nums[i] 的下标数目。\n请你返回重新排列 nums 后的 最大 伟大值。", "canonical_solution": "def maximizeGreatness(nums):\n        nums.sort()\n        res = 0\n        for a in nums:\n            if a > nums[res]:\n                res += 1\n        return res", "entry_point": "maximizeGreatness", "test_list": ["assert maximizeGreatness([1,3,5,2,1,3,1])==4", "assert maximizeGreatness([1,2,3,4])==3"]}
{"Contest id": "Bi100/2591", "text_name": "将钱分给最多的儿童", "text": "给你一个整数 money ，表示你总共有的钱数（单位为美元）和另一个整数 children ，表示你要将钱分配给多少个儿童。\n你需要按照如下规则分配：\n所有的钱都必须被分配。\n每个儿童至少获得 1 美元。\n没有人获得 4 美元。\n请你按照上述规则分配金钱，并返回 最多 有多少个儿童获得 恰好 8 美元。如果没有任何分配方案，返回 -1 。", "canonical_solution": "def distMoney(money, children):\n        if children>money:\n            return -1\n        if money>8*children:\n            return children-1\n        money-=children\n        if children-money//7==1 and money%7==3:\n            return money//7-1\n        return money//7", "entry_point": "distMoney", "test_list": ["assert distMoney(20,3)==1", "assert distMoney(16,2)==2"]}
{"Contest id": "336/2589", "text_name": "完成所有任务的最少时间", "text": "你有一台电脑，它可以 同时 运行无数个任务。给你一个二维整数数组 tasks ，其中 tasks[i] = [starti, endi, durationi] 表示第 i 个任务需要在 闭区间 时间段 [starti, endi] 内运行 durationi 个整数时间点（但不需要连续）。\n当电脑需要运行任务时，你可以打开电脑，如果空闲时，你可以将电脑关闭。\n请你返回完成所有任务的情况下，电脑最少需要运行多少秒。", "canonical_solution": "from heapq import heappop, heappush\ndef findMinimumTime(tasks):\n    tasks.append([10 ** 9 + 1, 10 ** 9 + 1, 1])\n    res, q = 0, []\n    for s, e, d in sorted(tasks):\n        while q and q[0][0] + res < s:\n            if q[0][0] + res >= q[0][1]:\n                heappop(q)\n            else:\n                res += min(q[0][1], s) - (q[0][0] + res)\n        heappush(q, [e - d + 1 - res, e + 1])\n    return res", "entry_point": "findMinimumTime", "test_list": ["assert findMinimumTime([[2,3,1],[4,5,1],[1,5,2]])==2", "assert findMinimumTime([[1,3,2],[2,5,3],[5,6,2]])==4"]}
{"Contest id": "336/2588", "text_name": "统计美丽子数组数目", "text": "给你一个下标从 0 开始的整数数组nums 。每次操作中，你可以：\n选择两个满足 0 <= i, j < nums.length 的不同下标 i 和 j 。\n选择一个非负整数 k ，满足 nums[i] 和 nums[j] 在二进制下的第 k 位（下标编号从 0 开始）是 1 。\n将 nums[i] 和 nums[j] 都减去 2k 。\n如果一个子数组内执行上述操作若干次后，该子数组可以变成一个全为 0 的数组，那么我们称它是一个 美丽 的子数组。\n请你返回数组 nums 中 美丽子数组 的数目。\n子数组是一个数组中一段连续 非空 的元素序列。", "canonical_solution": "def beautifulSubarrays(nums):\n        dp = Counter({0: 1})\n        res = pre = 0\n        for a in nums:\n            pre ^= a\n            res += dp[pre]\n            dp[pre] += 1\n        return res", "entry_point": "beautifulSubarrays", "test_list": ["assert beautifulSubarrays([4,3,1,2,4])==2", "assert beautifulSubarrays([1,10,4])==0"]}
{"Contest id": "336/2587", "text_name": "重排数组以得到最大前缀分数", "text": "给你一个下标从 0 开始的整数数组 nums 。你可以将 nums 中的元素按 任意顺序 重排（包括给定顺序）。\n令 prefix 为一个数组，它包含了 nums 重新排列后的前缀和。换句话说，prefix[i] 是 nums 重新排列后下标从 0 到 i 的元素之和。nums 的 分数 是 prefix 数组中正整数的个数。\n返回可以得到的最大分数。", "canonical_solution": "def maxScore(nums):\n        nums.sort(reverse=True)\n        prefix_sums = [0]\n        for num in nums:\n            prefix_sums.append(prefix_sums[-1] + num)\n        max_score = 0\n        for i in range(1, len(prefix_sums)):\n            if prefix_sums[i] > 0:\n                max_score = i\n        return max_score", "entry_point": "maxScore", "test_list": ["assert maxScore([2,-1,0,1,-3,3,-3])==6", "assert maxScore([-2,-3,0])==0"]}
{"Contest id": "336/2586", "text_name": "统计范围内的元音字符串数", "text": "给你一个下标从 0 开始的字符串数组 words 和两个整数：left 和 right 。\n如果字符串以元音字母开头并以元音字母结尾，那么该字符串就是一个 元音字符串 ，其中元音字母是 'a'、'e'、'i'、'o'、'u' 。\n返回 words[i] 是元音字符串的数目，其中 i 在闭区间 [left, right] 内。", "canonical_solution": "def vowelStrings(words, left, right):\n    vowels = 'aeiouAEIOU'\n    count = 0\n    for i in range(left, right + 1):\n        if words[i][0] in vowels and words[i][-1] in vowels:\n            count += 1\n    return count", "entry_point": "vowelStrings", "test_list": ["assert vowelStrings([\"are\",\"amy\",\"u\"],0,2)==2", "assert vowelStrings([\"hey\",\"aeo\",\"mu\",\"ooo\",\"artro\"],1,4)==3"]}
{"Contest id": "335/2585", "text_name": "获得分数的方法数", "text": "考试中有 n 种类型的题目。给你一个整数 target 和一个下标从 0 开始的二维整数数组 types ，其中 types[i] = [counti, marksi] 表示第 i 种类型的题目有 counti 道，每道题目对应 marksi 分。\n返回你在考试中恰好得到 target 分的方法数。由于答案可能很大，结果需要对 109 +7 取余。\n注意，同类型题目无法区分。\n比如说，如果有 3 道同类型题目，那么解答第 1 和第 2 道题目与解答第 1 和第 3 道题目或者第 2 和第 3 道题目是相同的。", "canonical_solution": "def waysToReachTarget(target, types):\n        dp = [1] + [0] * target\n        mod = 10 ** 9 + 7\n        for c,m in types:\n            for i in range(target,-1,-1):\n                for k in range(1, min(c, i // m) + 1):\n                    dp[i] = (dp[i] + dp[i - m * k]) % mod\n        return dp[-1]", "entry_point": "waysToReachTarget", "test_list": ["assert waysToReachTarget(6,[[6,1],[3,2],[2,3]])==7", "assert waysToReachTarget(5,[[50,1],[50,2],[50,5]])==4", "assert waysToReachTarget(18,[[6,1],[3,2],[2,3]])==1"]}
{"Contest id": "335/2584", "text_name": "分割数组使乘积互质", "text": "给你一个长度为 n 的整数数组 nums ，下标从 0 开始。\n如果在下标 i 处 分割 数组，其中 0 <= i <= n - 2 ，使前 i + 1 个元素的乘积和剩余元素的乘积互质，则认为该分割 有效 。\n例如，如果 nums = [2, 3, 3] ，那么在下标 i = 0 处的分割有效，因为 2 和 9 互质，而在下标 i = 1 处的分割无效，因为 6 和 3 不互质。在下标 i = 2 处的分割也无效，因为 i == n - 1 。\n返回可以有效分割数组的最小下标 i ，如果不存在有效分割，则返回 -1 。\n当且仅当 gcd(val1, val2) == 1 成立时，val1 和 val2 这两个值才是互质的，其中 gcd(val1, val2) 表示 val1 和 val2 的最大公约数。", "canonical_solution": "def findValidSplit(nums):\n        def yieldprime(n):\n            while n % 2 == 0:\n                n >>= 1\n                yield 2\n            p = 3\n            while p * p <= n:\n                while n % p == 0:\n                    n //= p\n                    yield p\n                p += 2\n            if n > 1:\n                yield n           \n        lastp = {}\n        for i, n in enumerate(nums):\n            for p in yieldprime(n):\n                lastp[p] = i\n        l = 0\n        maxl = 0\n        while l <= maxl:\n            n = nums[l]\n            for p in yieldprime(nums[l]):\n                maxl = max(maxl, lastp[p])\n            l += 1\n        return maxl if maxl != len(nums) - 1 else -1", "entry_point": "findValidSplit", "test_list": ["assert findValidSplit([4,7,8,15,3,5])==2", "assert findValidSplit([4,7,15,8,3,5])==-1"]}
{"Contest id": "335/2582", "text_name": "递枕头", "text": "n 个人站成一排，按从 1 到 n 编号。\n最初，排在队首的第一个人拿着一个枕头。每秒钟，拿着枕头的人会将枕头传递给队伍中的下一个人。一旦枕头到达队首或队尾，传递方向就会改变，队伍会继续沿相反方向传递枕头。\n例如，当枕头到达第 n 个人时，TA 会将枕头传递给第 n - 1 个人，然后传递给第 n - 2 个人，依此类推。\n给你两个正整数 n 和 time ，返回 time 秒后拿着枕头的人的编号。", "canonical_solution": "def passThePillow(n, time):\n        return n - abs(n - 1 - time % (n * 2 - 2))", "entry_point": "passThePillow", "test_list": ["assert passThePillow(4,5)==2", "assert passThePillow(3,2)==3"]}
{"Contest id": "Bi99/2581", "text_name": "统计可能的树根数目", "text": "Alice 有一棵 n 个节点的树，节点编号为 0 到 n - 1 。树用一个长度为 n - 1 的二维整数数组 edges 表示，其中 edges[i] = [ai, bi] ，表示树中节点 ai 和 bi 之间有一条边。\nAlice 想要 Bob 找到这棵树的根。她允许 Bob 对这棵树进行若干次 猜测 。每一次猜测，Bob 做如下事情：\n选择两个 不相等 的整数 u 和 v ，且树中必须存在边 [u, v] 。\nBob 猜测树中 u 是 v 的 父节点 。\nBob 的猜测用二维整数数组 guesses 表示，其中 guesses[j] = [uj, vj] 表示 Bob 猜 uj 是 vj 的父节点。\nAlice 非常懒，她不想逐个回答 Bob 的猜测，只告诉 Bob 这些猜测里面 至少 有 k 个猜测的结果为 true 。\n给你二维整数数组 edges ，Bob 的所有猜测和整数 k ，请你返回可能成为树根的 节点数目 。如果没有这样的树，则返回 0。", "canonical_solution": "from collections import defaultdict\ndef rootCount(edges, guesses, k):\n    graph = defaultdict(list)\n    for i, j in edges:\n        graph[i].append(j)\n        graph[j].append(i)\n\n    gt = set((i, j) for i, j in guesses)\n\n    def get_correct_pairs(i, parent):\n        next_nodes = graph[i]\n        n_correct = 0\n        for next_node in next_nodes:\n            if next_node == parent:\n                continue\n            if (i, next_node) in gt:\n                n_correct += 1\n            n_correct += get_correct_pairs(next_node, i)\n        return n_correct\n\n    ans = 0\n    for i in graph:\n        if get_correct_pairs(i, None) >= k:\n            ans += 1\n    return ans", "entry_point": "rootCount", "test_list": ["assert rootCount([[0,1],[1,2],[1,3],[4,2]],[[1,3],[0,1],[1,0],[2,4]],3)==3", "assert rootCount([[0,1],[1,2],[2,3],[3,4]],[[1,0],[3,4],[2,1],[3,2]],1)==5"]}
{"Contest id": "Bi99/2580", "text_name": "统计将重叠区间合并成组的方案数", "text": "给你一个二维整数数组 ranges ，其中 ranges[i] = [starti, endi] 表示 starti 到 endi 之间（包括二者）的所有整数都包含在第 i 个区间中。\n你需要将 ranges 分成 两个 组（可以为空），满足：\n每个区间只属于一个组。\n两个有 交集 的区间必须在 同一个 组内。\n如果两个区间有至少 一个 公共整数，那么这两个区间是 有交集 的。\n比方说，区间 [1, 3] 和 [2, 5] 有交集，因为 2 和 3 在两个区间中都被包含。\n请你返回将 ranges 划分成两个组的 总方案数 。由于答案可能很大，将它对 109 + 7 取余 后返回。", "canonical_solution": "def countWays(ranges):\n        pre = -1\n        res = 0\n        for a,b in sorted(ranges):\n            res += pre < a\n            pre = max(pre, b)\n        return pow(2, res, 10**9+7)", "entry_point": "countWays", "test_list": ["assert countWays([[6,10],[5,15]])==2", "assert countWays([[1,3],[10,20],[2,5],[4,8]])==4"]}
{"Contest id": "Bi99/2579", "text_name": "统计染色格子数", "text": "有一个无穷大的二维网格图，一开始所有格子都未染色。给你一个正整数 n ，表示你需要执行以下步骤 n 分钟：\n第一分钟，将 任一 格子染成蓝色。\n之后的每一分钟，将与蓝色格子相邻的 所有 未染色格子染成蓝色。\n请你返回 n 分钟之后 被染色的格子 数目。\n", "canonical_solution": "def coloredCells(n):\n        return n*n + (n-1)*(n-1)", "entry_point": "coloredCells", "test_list": ["assert coloredCells(1)==1", "assert coloredCells(2)==5"]}
{"Contest id": "Bi99/2578", "text_name": "最小和分割", "text": "给你一个正整数 num ，请你将它分割成两个非负整数 num1 和 num2 ，满足：\nnum1 和 num2 直接连起来，得到 num 各数位的一个排列。\n换句话说，num1 和 num2 中所有数字出现的次数之和等于 num 中所有数字出现的次数。\nnum1 和 num2 可以包含前导 0 。\n请你返回 num1 和 num2 可以得到的和的 最小 值。\n注意：\nnum 保证没有前导 0 。\nnum1 和 num2 中数位顺序可以与 num 中数位顺序不同。", "canonical_solution": "def splitNum(num):\n    num = ''.join(sorted(str(num)))\n    return sum(map(int, (num[::2], num[1::2])))", "entry_point": "splitNum", "test_list": ["assert splitNum(4325)==59", "assert splitNum(687)==75"]}
{"Contest id": "334/2577", "text_name": "在网格图中访问一个格子的最少时间", "text": "给你一个 m x n 的矩阵 grid ，每个元素都为 非负 整数，其中 grid[row][col] 表示可以访问格子 (row, col) 的 最早 时间。也就是说当你访问格子 (row, col) 时，最少已经经过的时间为 grid[row][col] 。\n你从 最左上角 出发，出发时刻为 0 ，你必须一直移动到上下左右相邻四个格子中的 任意 一个格子（即不能停留在格子上）。每次移动都需要花费 1 单位时间。\n请你返回 最早 到达右下角格子的时间，如果你无法到达右下角的格子，请你返回 -1 。", "canonical_solution": "import sys\nfrom heapq import heappush, heappop\ndef minimumTime(grid):\n        m,n=len(grid),len(grid[0])\n        directions=((0,1),(1,0),(-1,0),(0,-1))\n        i,j,flag=0,0,0\n        for di,dj in directions:\n            ni,nj=i+di,j+dj\n            if 0<=ni<m and 0<=nj<n and grid[ni][nj]<=1: flag=1;break;\n        if not flag: return -1\n        heap=[]\n        heappush(heap,(0,0,0))\n        dist=[[sys.maxsize]*n for _ in range(m)]\n        while heap:\n            cost,i,j=heappop(heap)\n            if i==m-1 and j==n-1: return cost\n            for di,dj in directions:\n                ni,nj=i+di,j+dj\n                if 0<=ni<m and 0<=nj<n:\n                    new_cost=cost+1\n                    if grid[ni][nj]>cost:\n                        if abs(cost-grid[ni][nj])%2==0:\n                            new_cost=grid[ni][nj]+1\n                        else:\n                            new_cost=grid[ni][nj]\n                    if new_cost<dist[ni][nj]:\n                        dist[ni][nj]=new_cost\n                        heappush(heap,(new_cost,ni,nj))", "entry_point": "minimumTime", "test_list": ["assert minimumTime([[0,1,3,2],[5,1,2,5],[4,3,8,6]])==7", "assert minimumTime([[0,2,4],[3,2,1],[1,0,4]])==-1"]}
{"Contest id": "334/2576", "text_name": "求出最多标记下标", "text": "给你一个下标从 0 开始的整数数组 nums 。\n一开始，所有下标都没有被标记。你可以执行以下操作任意次：\n选择两个 互不相同且未标记 的下标 i 和 j ，满足 2 * nums[i] <= nums[j] ，标记下标 i 和 j 。\n请你执行上述操作任意次，返回 nums 中最多可以标记的下标数目。", "canonical_solution": "def maxNumOfMarkedIndices(nums):\n        n=len(nums)\n        i=0\n        nums.sort()\n        for j in range(n//2,n):\n            i+= nums[j]>=nums[i]*2\n        return i*2", "entry_point": "maxNumOfMarkedIndices", "test_list": ["assert maxNumOfMarkedIndices([3,5,2,4])==2", "assert maxNumOfMarkedIndices([9,2,5,4])==4", "assert maxNumOfMarkedIndices([7,6,8])==0"]}
{"Contest id": "334/2575", "text_name": "找出字符串的可整除数组", "text": "给你一个下标从 0 开始的字符串 word ，长度为 n ，由从 0 到 9 的数字组成。另给你一个正整数 m 。\nword 的 可整除数组 div  是一个长度为 n 的整数数组，并满足：\n如果 word[0,...,i] 所表示的 数值 能被 m 整除，div[i] = 1\n否则，div[i] = 0\n返回 word 的可整除数组。", "canonical_solution": "def divisibilityArray(word, m):\n        temp = 0\n        res = [0] * len(word)\n        for i in range(len(word)):\n            temp = (temp * 10 + int(word[i])) % m\n            if temp == 0:\n                res[i] = 1             \n        return res", "entry_point": "divisibilityArray", "test_list": ["assert divisibilityArray(\"998244353\",3)==[1,1,0,0,0,1,1,0,0]", "assert divisibilityArray(\"1010\",10)==[0,1,0,1]"]}
{"Contest id": "334/2574", "text_name": "左右元素和的差值", "text": "给你一个下标从 0 开始的整数数组 nums ，请你找出一个下标从 0 开始的整数数组 answer ，其中：\nanswer.length == nums.length\nanswer[i] = |leftSum[i] - rightSum[i]|\n其中：\nleftSum[i] 是数组 nums 中下标 i 左侧元素之和。如果不存在对应的元素，leftSum[i] = 0 。\nrightSum[i] 是数组 nums 中下标 i 右侧元素之和。如果不存在对应的元素，rightSum[i] = 0 。\n返回数组 answer 。", "canonical_solution": "def leftRightDifference(nums):\n        result = []\n        left_sum = [0]\n        right_sum = [0]\n        for num in nums[:-1]:\n            left_sum.append(left_sum[-1] + num)\n        for num in nums[::-1][:-1]:\n            right_sum.insert(0, right_sum[0] + num)\n        for index in range(len(nums)):\n            result.append(abs(left_sum[index] - right_sum[index]))\n        return result", "entry_point": "leftRightDifference", "test_list": ["assert leftRightDifference([10,4,8,3])==[15,1,11,22]", "assert leftRightDifference([1])==[0]"]}
{"Contest id": "333/2573", "text_name": "找出对应LCP矩阵的字符串", "text": "对任一由 n 个小写英文字母组成的字符串 word ，我们可以定义一个 n x n 的矩阵，并满足：\nlcp[i][j] 等于子字符串 word[i,...,n-1] 和 word[j,...,n-1] 之间的最长公共前缀的长度。\n给你一个 n x n 的矩阵 lcp 。返回与 lcp 对应的、按字典序最小的字符串 word 。如果不存在这样的字符串，则返回空字符串。\n对于长度相同的两个字符串 a 和 b ，如果在 a 和 b 不同的第一个位置，字符串 a 的字母在字母表中出现的顺序先于 b 中的对应字母，则认为字符串 a 按字典序比字符串 b 小。例如，\"aabd\" 在字典上小于 \"aaca\" ，因为二者不同的第一位置是第三个字母，而 'b' 先于 'c' 出现。", "canonical_solution": "def findTheString(lcp):\n        n = len(lcp)\n        A = [0] * n\n        c = 1\n        for i in range(n):\n            if A[i]: continue\n            if c > 26: return ''\n            for j in range(i, n):\n                if lcp[i][j]:\n                    A[j] = c\n            c += 1\n        for i in range(n):\n            for j in range(n):\n                v = lcp[i + 1][j + 1] if i + 1 < n and j + 1 < n else 0\n                v = v + 1 if A[i] == A[j] else 0\n                if lcp[i][j] != v:\n                    return ''\n        return ''.join(chr(ord('a') + i - 1) for i in A)", "entry_point": "findTheString", "test_list": ["assert findTheString([[4,0,2,0],[0,3,0,1],[2,0,2,0],[0,1,0,1]])==\"abab\"", "assert findTheString([[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,1]])==\"aaaa\"", "assert findTheString([[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,3]])==\"\""]}
{"Contest id": "333/2572", "text_name": "无平方子集计数", "text": "给你一个正整数数组 nums 。\n如果数组 nums 的子集中的元素乘积是一个 无平方因子数 ，则认为该子集是一个 无平方 子集。\n无平方因子数 是无法被除 1 之外任何平方数整除的数字。\n返回数组 nums 中 无平方 且 非空 的子集数目。因为答案可能很大，返回对 109 + 7 取余的结果。\nnums 的 非空子集 是可以由删除 nums 中一些元素（可以不删除，但不能全部删除）得到的一个数组。如果构成两个子集时选择删除的下标不同，则认为这两个子集不同。", "canonical_solution": "def squareFreeSubsets(nums):\n        MOD = 10**9 + 7\n        primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n        dp = [0] * (1 << 10)\n        dp[0] = 1\n        for a in nums:\n            mask = 0\n            for i, x in enumerate(primes):\n                if a % (x * x) == 0:\n                    mask = -1\n                    break\n                if a % x == 0:\n                    mask |= 1 << i\n            if mask >= 0:\n                for i in range(1 << 10):\n                    if (i & mask) == 0:\n                        dp[i | mask] += dp[i]\n        return (sum(dp) - 1) % MOD", "entry_point": "squareFreeSubsets", "test_list": ["assert squareFreeSubsets([3,4,4,5])==3", "assert squareFreeSubsets([1])==1"]}
{"Contest id": "333/2571", "text_name": "将整数减少到零需要的最少操作数", "text": "给你一个正整数 n ，你可以执行下述操作 任意 次：\nn 加上或减去 2 的某个 幂\n返回使 n 等于 0 需要执行的 最少 操作数。\n如果 x == 2i 且其中 i >= 0 ，则数字 x 是 2 的幂。", "canonical_solution": "def minOperations(n):\n        res = 0\n        while n > 0:\n            if n % 2 == 0:\n                n >>= 1\n            elif (n & 2) > 0:\n                n += 1\n                res += 1\n            else:\n                res += 1\n                n >>= 2\n        return res", "entry_point": "minOperations", "test_list": ["assert minOperations(54)==3", "assert minOperations(39)==3"]}
{"Contest id": "333/2570", "text_name": "合并两个二维数组", "text": "给你两个 二维 整数数组 nums1 和 nums2.\nnums1[i] = [idi, vali] 表示编号为 idi 的数字对应的值等于 vali 。\nnums2[i] = [idi, vali] 表示编号为 idi 的数字对应的值等于 vali 。\n每个数组都包含 互不相同 的 id ，并按 id 以 递增 顺序排列。\n请你将两个数组合并为一个按 id 以递增顺序排列的数组，并符合下述条件：\n只有在两个数组中至少出现过一次的 id 才能包含在结果数组内。\n每个 id 在结果数组中 只能出现一次 ，并且其对应的值等于两个数组中该 id 所对应的值求和。如果某个数组中不存在该 id ，则认为其对应的值等于 0 。\n返回结果数组。返回的数组需要按 id 以递增顺序排列。", "canonical_solution": "def mergeArrays(nums1, nums2):\n        arr = [0] * 1001\n        length = 0\n        for num in nums1:\n            if arr[num[0]] == 0:\n                length += 1\n            arr[num[0]] = num[1]\n        for num in nums2:\n            if arr[num[0]] == 0:\n                length += 1\n            arr[num[0]] += num[1]\n        res = [[0, 0] for _ in range(length)]\n        ind = 0\n        for i in range(len(arr)):\n            if arr[i] != 0:\n                res[ind][0] = i\n                res[ind][1] = arr[i]\n                ind += 1\n        return res", "entry_point": "mergeArrays", "test_list": ["assert mergeArrays([[1,2],[2,3],[4,5]],[[1,4],[3,2],[4,1]])==[[1,6],[2,3],[3,2],[4,6]]", "assert mergeArrays([[2,4],[3,6],[5,5]],[[1,3],[4,3]])==[[1,3],[2,4],[3,6],[4,3],[5,5]]"]}
{"Contest id": "Bi98/2569", "text_name": "更新数组后处理求和查询", "text": "给你两个下标从 0 开始的数组 nums1 和 nums2 ，和一个二维数组 queries 表示一些操作。总共有 3 种类型的操作：\n操作类型 1 为 queries[i] = [1, l, r] 。你需要将 nums1 从下标 l 到下标 r 的所有 0 反转成 1 并且所有 1 反转成 0 。l 和 r 下标都从 0 开始。\n操作类型 2 为 queries[i] = [2, p, 0] 。对于 0 <= i < n 中的所有下标，令 nums2[i] = nums2[i] + nums1[i] * p 。\n操作类型 3 为 queries[i] = [3, 0, 0] 。求 nums2 中所有元素的和。\n请你返回一个 数组，包含 所有第三种操作类型 的答案。", "canonical_solution": "def handleQuery(nums1, nums2, queries):\n    n = len(nums1)\n    cnt1 = [0] * (4 * n)\n    flip = [False] * (4 * n)\n    def maintain(o):\n        cnt1[o] = cnt1[o * 2] + cnt1[o * 2 + 1]\n    def do(o, l, r):\n        cnt1[o] = r - l + 1 - cnt1[o]\n        flip[o] = not flip[o]\n    def build(o, l, r) :\n        if l == r:\n            cnt1[o] = nums1[l - 1]\n            return\n        m = (l + r) // 2\n        build(o * 2, l, m)\n        build(o * 2 + 1, m + 1, r)\n        maintain(o)\n    def update(o, l, r, L, R) :\n        if L <= l and r <= R:\n            do(o, l, r)\n            return\n        m = (l + r) // 2\n        if flip[o]:\n            do(o * 2, l, m)\n            do(o * 2 + 1, m + 1, r)\n            flip[o] = False\n        if m >= L: update(o * 2, l, m, L, R)\n        if m < R: update(o * 2 + 1, m + 1, r, L, R)\n        maintain(o)\n    build(1, 1, n)\n    ans, s = [], sum(nums2)\n    for op, l, r in queries:\n        if op == 1: update(1, 1, n, l + 1, r + 1)\n        elif op == 2: s += l * cnt1[1]\n        else: ans.append(s)\n    return ans", "entry_point": "handleQuery", "test_list": ["assert handleQuery(nums1=[1,0,1],nums2=[0,0,0],queries=[[1,1,1],[2,1,0],[3,0,0]])==[3]", "assert handleQuery(nums1=[1],nums2=[5],queries=[[2,0,0],[3,0,0]])==[5]"]}
{"Contest id": "Bi98/2568", "text_name": "最小无法得到的或值", "text": "给你一个下标从 0 开始的整数数组 nums 。\n如果存在一些整数满足 0 <= index1 < index2 < ... < indexk < nums.length ，得到 nums[index1] | nums[index2] | ... | nums[indexk] = x ，那么我们说 x 是 可表达的 。换言之，如果一个整数能由 nums 的某个子序列的或运算得到，那么它就是可表达的。\n请你返回 nums 不可表达的 最小非零整数 。", "canonical_solution": "def minImpossibleOR(nums):\n        nums = set(nums)\n        return next(1 << i for i in range(32) if (1 << i) not in nums)", "entry_point": "minImpossibleOR", "test_list": ["assert minImpossibleOR([2,1])==4", "assert minImpossibleOR([5,3,2])==1"]}
{"Contest id": "Bi98/2567", "text_name": "修改两个元素的最小分数", "text": "给你一个下标从 0 开始的整数数组 nums 。\nnums 的 最小 得分是满足 0 <= i < j < nums.length 的 |nums[i] - nums[j]| 的最小值。\nnums的 最大 得分是满足 0 <= i < j < nums.length 的 |nums[i] - nums[j]| 的最大值。\nnums 的分数是 最大 得分与 最小 得分的和。\n我们的目标是最小化 nums 的分数。你 最多 可以修改 nums 中 2 个元素的值。\n请你返回修改 nums 中 至多两个 元素的值后，可以得到的 最小分数 。\n|x| 表示 x 的绝对值。", "canonical_solution": "def minimizeSum(A):\n        A.sort()\n        return min(A[-1] - A[2], A[-2] - A[1], A[-3] - A[0])", "entry_point": "minimizeSum", "test_list": ["assert minimizeSum([1,4,3])==0", "assert minimizeSum([1,4,7,8,5])==3"]}
{"Contest id": "Bi98/2566", "text_name": "替换一个数字后的最大差值", "text": "给你一个整数 num 。你知道 Danny Mittal 会偷偷将 0 到 9 中的一个数字 替换 成另一个数字。\n请你返回将 num 中 恰好一个 数字进行替换后，得到的最大值和最小值的差为多少。\n注意：\n当 Danny 将一个数字 d1 替换成另一个数字 d2 时，Danny 需要将 nums 中所有 d1 都替换成 d2 。\nDanny 可以将一个数字替换成它自己，也就是说 num 可以不变。\nDanny 可以将数字分别替换成两个不同的数字分别得到最大值和最小值。\n替换后得到的数字可以包含前导 0 。\nDanny Mittal 获得周赛 326 前 10 名，让我们恭喜他。", "canonical_solution": "def minMaxDifference(num):\n        s_num = str(num)\n        ch = s_num[0]\n        min_num = int(s_num.replace(ch, '0'))\n        ch = next((x for x in s_num if x != '9'), '0')\n        max_num = int(s_num.replace(ch, '9'))\n        return max_num - min_num", "entry_point": "minMaxDifference", "test_list": ["assert minMaxDifference(11891)==99009", "assert minMaxDifference(90)==99"]}
{"Contest id": "332/2565", "text_name": "最少得分子序列", "text": "给你两个字符串 s 和 t 。\n你可以从字符串 t 中删除任意数目的字符。\n如果没有从字符串 t 中删除字符，那么得分为 0 ，否则：\n令 left 为删除字符中的最小下标。\n令 right 为删除字符中的最大下标。\n字符串的得分为 right - left + 1 。\n请你返回使 t 成为 s 子序列的最小得分。\n一个字符串的 子序列 是从原字符串中删除一些字符后（也可以一个也不删除），剩余字符不改变顺序得到的字符串。（比方说 \"ace\" 是 \"abcde\" 的子序列，但是 \"aec\" 不是）。", "canonical_solution": "def minimumScore(s, t):\n        sl = 0\n        sr = len(s) - 1\n        tl = 0\n        tr = len(t) - 1\n        k = {}\n        for tl in range(len(t)):\n            while sl < len(s) and s[sl] != t[tl]:\n                sl += 1\n            if sl == len(s):\n                tl -= 1\n                break\n            k[tl] = sl\n            sl += 1\n        k[-1] = -1\n        ans = tr - tl\n        for ntl in range(tl, -2, -1):\n            while tr > ntl and sr > k[ntl]:\n                if s[sr] != t[tr]:\n                    sr -= 1\n                elif s[sr] == t[tr]:\n                    sr -= 1\n                    tr -= 1\n            ans = min(tr - ntl, ans)\n        return ans", "entry_point": "minimumScore", "test_list": ["assert minimumScore(\"abacaba\",\"bzaa\")==1", "assert minimumScore(\"cde\",\"xyz\")==3"]}
{"Contest id": "332/2564", "text_name": "子字符串异或查询", "text": "给你一个 二进制字符串 s 和一个整数数组 queries ，其中 queries[i] = [firsti, secondi] 。\n对于第 i 个查询，找到 s 的 最短子字符串 ，它对应的 十进制值 val 与 firsti 按位异或 得到 secondi ，换言之，val ^ firsti == secondi 。\n第 i 个查询的答案是子字符串 [lefti, righti] 的两个端点（下标从 0 开始），如果不存在这样的子字符串，则答案为 [-1, -1] 。如果有多个答案，请你选择 lefti 最小的一个。\n请你返回一个数组 ans ，其中 ans[i] = [lefti, righti] 是第 i 个查询的答案。\n子字符串 是一个字符串中一段连续非空的字符序列。", "canonical_solution": "def substringXorQueries(s, queries):\n        m = defaultdict(lambda: [-1, -1])\n        for i, ch in enumerate(s):\n            val = 0\n            for j in range(i, min(i + 30, len(s))):\n                val = val * 2 + ord(s[j]) - ord(\"0\")\n                if val not in m:\n                    m[val] = [i, j]\n                if ch == \"0\":\n                    break\n        return [m[f ^ s] for f, s in queries]", "entry_point": "substringXorQueries", "test_list": ["assert substringXorQueries(\"0101\",[[12,8]])==[[-1,-1]]", "assert substringXorQueries(\"1\",[[4,5]])==[[0,0]]"]}
{"Contest id": "332/2563", "text_name": "统计公平数对的数目", "text": "给你一个下标从 0 开始、长度为 n 的整数数组 nums ，和两个整数 lower 和 upper ，返回 公平数对的数目 。\n如果 (i, j) 数对满足以下情况，则认为它是一个 公平数对 ：\n0 <= i < j < n，且\nlower <= nums[i] + nums[j] <= upper", "canonical_solution": "def countFairPairs(nums, lower, upper):\n        nums.sort()\n        result=0\n        start,end=len(nums)-1,len(nums)-1\n        for i in range(len(nums)):\n            while end >=0 and nums[i]+nums[end]>upper:\n                end-=1\n            while start>=0 and nums[i]+nums[start]>=lower:\n                start-=1\n            if(start < i and end >= i):\n                result+=end-start-1\n            else:\n                result+=end-start\n        return result/2", "entry_point": "countFairPairs", "test_list": ["assert countFairPairs([0,1,7,4,4,5],3,6)==6", "assert countFairPairs([1,7,9,2,5],11,11)==1"]}
{"Contest id": "332/2562", "text_name": "找出数组的串联值", "text": "给你一个下标从 0 开始的整数数组 nums 。\n现定义两个数字的 串联 是由这两个数值串联起来形成的新数字。\n例如，15 和 49 的串联是 1549 。\nnums 的 串联值 最初等于 0 。执行下述操作直到 nums 变为空：\n如果 nums 中存在不止一个数字，分别选中 nums 中的第一个元素和最后一个元素，将二者串联得到的值加到 nums 的 串联值 上，然后从 nums 中删除第一个和最后一个元素。\n如果仅存在一个元素，则将该元素的值加到 nums 的串联值上，然后删除这个元素。\n返回执行完所有操作后 nums 的串联值。", "canonical_solution": "def findTheArrayConcVal(nums):\n        concatenation = 0\n        while len(nums)>0:\n            if len(nums)>1:\n                concatenation += int(str(nums[0])+str(nums[-1]))\n                del nums[-1]\n            else:\n                concatenation += nums[0]\n            del nums[0]\n        return concatenation", "entry_point": "findTheArrayConcVal", "test_list": ["assert findTheArrayConcVal([7,52,2,4])==596", "assert findTheArrayConcVal([5,14,13,8,12])==673"]}
{"Contest id": "331/2561", "text_name": "重排水果", "text": "你有两个果篮，每个果篮中有 n 个水果。给你两个下标从 0 开始的整数数组 basket1 和 basket2 ，用以表示两个果篮中每个水果的交换成本。为了让两个果篮中水果的数量相等。为此，可以根据需要多次执行下述操作：\n选中两个下标 i 和 j ，并交换 basket1 中的第 i 个水果和 basket2 中的第 j 个水果。\n交换的成本是 min(basket1i,basket2j) 。\n根据果篮中水果的成本进行排序，如果排序后结果完全相同，则认为两个果篮相等。\n返回使两个果篮相等的最小交换成本，如果无法使两个果篮相等，则返回 -1 。", "canonical_solution": "from collections import Counter\ndef minCost(A, B):\n    count = Counter(A + B)\n    for c in count:\n        if count[c] % 2:\n            return -1\n        count[c] >>= 1\n    A2 = list((Counter(A) - count).elements())\n    B2 = list((Counter(B) - count).elements())\n    small = min(count)\n    C = sorted(A2 + B2)\n    return sum(min(small * 2, C[i]) for i in range(len(A2)))", "entry_point": "minCost", "test_list": ["assert minCost([4,2,2,2],[1,4,1,2])==1", "assert minCost([2,3,4,1],[3,2,5,1])==-1"]}
{"Contest id": "331/2560", "text_name": "打家劫舍IV", "text": "沿街有一排连续的房屋。每间房屋内都藏有一定的现金。现在有一位小偷计划从这些房屋中窃取现金。\n由于相邻的房屋装有相互连通的防盗系统，所以小偷 不会窃取相邻的房屋 。\n小偷的 窃取能力 定义为他在窃取过程中能从单间房屋中窃取的 最大金额 。\n给你一个整数数组 nums 表示每间房屋存放的现金金额。形式上，从左起第 i 间房屋中放有 nums[i] 美元。\n另给你一个整数 k ，表示窃贼将会窃取的 最少 房屋数。小偷总能窃取至少 k 间房屋。\n返回小偷的 最小 窃取能力。", "canonical_solution": "def minCapability(A, k):\n        l, r = min(A), max(A)\n        while l < r:\n            m = (l + r) // 2\n            last = take = 0\n            for a in A:\n                if last:\n                    last = 0\n                    continue\n                if a <= m:\n                    take += 1\n                    last = 1\n            if take >= k:\n                r = m\n            else:\n                l = m + 1\n        return l", "entry_point": "minCapability", "test_list": ["assert minCapability([2,3,5,9],2)==5", "assert minCapability([2,7,9,3,1],2)==2"]}
{"Contest id": "331/2559", "text_name": "统计范围内的元音字符串数", "text": "给你一个下标从 0 开始的字符串数组 words 以及一个二维整数数组 queries 。\n每个查询 queries[i] = [li, ri] 会要求我们统计在 words 中下标在 li 到 ri 范围内（包含 这两个值）并且以元音开头和结尾的字符串的数目。\n返回一个整数数组，其中数组的第 i 个元素对应第 i 个查询的答案。\n注意：元音字母是 'a'、'e'、'i'、'o' 和 'u' 。", "canonical_solution": "def vowelStrings(words, queries):\n        n = len(words)\n        A = [0] * (n + 1)\n        vowel = 'aeiou'\n        ans = []\n        for i in range(n):\n            A[i + 1] = A[i] + (1 if words[i][0] in vowel and words[i][-1] in vowel else 0)\n        for l, r in queries:\n            ans.append(A[r + 1] - A[l])\n        return ans", "entry_point": "vowelStrings", "test_list": ["assert vowelStrings([\"aba\",\"bcb\",\"ece\",\"aa\",\"e\"],[[0,2],[1,4],[1,1]])==[2,3,0]", "assert vowelStrings([\"a\",\"e\",\"i\"],[[0,2],[0,1],[2,2]])==[3,2,1]"]}
{"Contest id": "331/2558", "text_name": "从数量最多的堆取走礼物", "text": "给你一个整数数组 gifts ，表示各堆礼物的数量。每一秒，你需要执行以下操作：\n选择礼物数量最多的那一堆。\n如果不止一堆都符合礼物数量最多，从中选择任一堆即可。\n选中的那一堆留下平方根数量的礼物（向下取整），取走其他的礼物。\n返回在 k 秒后剩下的礼物数量。", "canonical_solution": "import math\nfrom heapq import heapify, heappop, heappush\ndef pickGifts(gifts, k):\n    nums = [-num for num in gifts]\n    heapify(nums)\n    while k:\n        tmp = math.isqrt(-heappop(nums))\n        heappush(nums, -tmp)\n        k -= 1\n    return -sum(nums)", "entry_point": "pickGifts", "test_list": ["assert pickGifts([25,64,9,4,100],4)==29", "assert pickGifts([1,1,1,1],4)==4"]}
{"Contest id": "Bi97/2556", "text_name": "二进制矩阵中翻转最多一次使路径不连通", "text": "给你一个下标从 0 开始的 m x n 二进制 矩阵 grid 。你可以从一个格子 (row, col) 移动到格子 (row + 1, col) 或者 (row, col + 1) ，前提是前往的格子值为 1 。如果从 (0, 0) 到 (m - 1, n - 1) 没有任何路径，我们称该矩阵是 不连通 的。\n你可以翻转 最多一个 格子的值（也可以不翻转）。你 不能翻转 格子 (0, 0) 和 (m - 1, n - 1) 。\n如果可以使矩阵不连通，请你返回 true ，否则返回 false 。\n注意 ，翻转一个格子的值，可以使它的值从 0 变 1 ，或从 1 变 0 。", "canonical_solution": "def isPossibleToCutPath(grid):\n        m, n = len(grid), len(grid[0])\n        if m == 1 and n == 2:\n            return False\n        def dfs(i=0,j=0):\n            if i == m-1 and j == n-1:\n                return True\n            if i >= m or j >= n or grid[i][j]==0:\n                return False\n            grid[i][j]=0\n            if (i, j) != (0, 0):\n                if dfs(i+1, j):\n                    return True\n                return dfs(i, j+1)\n            return not(dfs(i+1, j) and dfs(i, j+1))\n        return dfs()", "entry_point": "isPossibleToCutPath", "test_list": ["assert isPossibleToCutPath([[1,1,1],[1,0,0],[1,1,1]])==True", "assert isPossibleToCutPath([[1,1,1],[1,0,1],[1,1,1]])==False"]}
{"Contest id": "Bi97/2555", "text_name": "两个线段获得的最多奖品", "text": "在 X轴 上有一些奖品。给你一个整数数组 prizePositions ，它按照 非递减 顺序排列，其中 prizePositions[i] 是第 i 件奖品的位置。数轴上一个位置可能会有多件奖品。再给你一个整数 k 。\n你可以选择两个端点为整数的线段。每个线段的长度都必须是 k 。你可以获得位置在任一线段上的所有奖品（包括线段的两个端点）。注意，两个线段可能会有相交。\n比方说 k = 2 ，你可以选择线段 [1, 3] 和 [2, 4] ，你可以获得满足 1 <= prizePositions[i] <= 3 或者 2 <= prizePositions[i] <= 4 的所有奖品 i 。\n请你返回在选择两个最优线段的前提下，可以获得的 最多 奖品数目。", "canonical_solution": "def maximizeWin(A, k):\n        dp = [0] * (len(A) + 1)\n        res = j = 0\n        for i, a in enumerate(A):\n            while A[j] < A[i] - k: j += 1\n            dp[i + 1] = max(dp[i], i - j + 1)\n            res = max(res, i - j + 1 + dp[j])\n        return res", "entry_point": "maximizeWin", "test_list": ["assert maximizeWin([1,1,2,2,3,3,5],2)==7", "assert maximizeWin([1,2,3,4],0)==2"]}
{"Contest id": "Bi97/2554", "text_name": "从一个范围内选择最多整数|", "text": "给你一个整数数组 banned 和两个整数 n 和 maxSum 。你需要按照以下规则选择一些整数：\n被选择整数的范围是 [1, n] 。\n每个整数 至多 选择 一次 。\n被选择整数不能在数组 banned 中。\n被选择整数的和不超过 maxSum 。\n请你返回按照上述规则 最多 可以选择的整数数目。", "canonical_solution": "def maxCount(banned, n, maxSum):\n        banned = set(banned)\n        res, sum_, curr = 0, 0, 1\n        while curr <= n:\n            if curr not in banned:\n                if sum_ + curr <= maxSum:\n                    res += 1\n                    sum_ += curr\n                else: break\n            curr += 1\n        return res", "entry_point": "maxCount", "test_list": ["assert maxCount([1,6,5],5,6)==2", "assert maxCount([1,2,3,4,5,6,7],8,1)==0", "assert maxCount([11],7,50)==7"]}
{"Contest id": "Bi97/2553", "text_name": "分割数组中数字的数位", "text": "给你一个正整数数组 nums ，请你返回一个数组 answer ，你需要将 nums 中每个整数进行数位分割后，按照 nums 中出现的 相同顺序 放入答案数组中。\n对一个整数进行数位分割，指的是将整数各个数位按原本出现的顺序排列成数组。\n比方说，整数 10921 ，分割它的各个数位得到 [1,0,9,2,1] 。", "canonical_solution": "def separateDigits(nums):\n        result = []\n        for num in nums:\n            current_result = []\n            while num > 0:\n                current_result.append(num % 10)\n                num = num // 10\n            result = result + current_result[::-1]\n        return result", "entry_point": "separateDigits", "test_list": ["assert separateDigits([13,25,83,77])==[1,3,2,5,8,3,7,7]", "assert separateDigits([7,1,3,9])==[7,1,3,9]"]}
{"Contest id": "330/2552", "text_name": "统计上升四元组", "text": "给你一个长度为 n 下标从 0 开始的整数数组 nums ，它包含 1 到 n 的所有数字，请你返回上升四元组的数目。\n如果一个四元组 (i, j, k, l) 满足以下条件，我们称它是上升的：\n0 <= i < j < k < l < n 且\nnums[i] < nums[k] < nums[j] < nums[l] 。", "canonical_solution": "def countQuadruplets(nums):\n        n=len(nums)\n        dp=[0]*n\n        cnt=0\n        for j in range(n):\n            prv_small=0\n            for i in range(j):\n                if nums[j]>nums[i]:\n                    prv_small+=1\n                    cnt+=dp[i]\n                else:\n                    if nums[j]<nums[i]:\n                        dp[i]+=prv_small\n        return cnt", "entry_point": "countQuadruplets", "test_list": ["assert countQuadruplets([1,3,2,4,5])==2", "assert countQuadruplets([1,2,3,4])==0"]}
{"Contest id": "330/2551", "text_name": "将珠子放入背包中", "text": "你有 k 个背包。给你一个下标从 0 开始的整数数组 weights ，其中 weights[i] 是第 i 个珠子的重量。同时给你整数 k 。\n请你按照如下规则将所有的珠子放进 k 个背包。\n没有背包是空的。\n如果第 i 个珠子和第 j 个珠子在同一个背包里，那么下标在 i 到 j 之间的所有珠子都必须在这同一个背包中。\n如果一个背包有下标从 i 到 j 的所有珠子，那么这个背包的价格是 weights[i] + weights[j] 。\n一个珠子分配方案的 分数 是所有 k 个背包的价格之和。\n请你返回所有分配方案中，最大分数 与 最小分数 的 差值 为多少。", "canonical_solution": "def putMarbles(weights, K):\n        n = len(weights)\n        min_dp = [[float('inf')] * n for _ in range(K + 1)]\n        max_dp = [[float('-inf')] * n for _ in range(K + 1)]\n        for i in range(n):\n            min_dp[1][i] = weights[0] + weights[i]\n            max_dp[1][i] = weights[0] + weights[i]\n        for i in range(2, K + 1):\n            for j in range(n):\n                for k in range(j):\n                    min_dp[i][j] = min(min_dp[i - 1][k] + weights[k + 1] + weights[j], min_dp[i][j])\n                    max_dp[i][j] = max(max_dp[i - 1][k] + weights[k + 1] + weights[j], max_dp[i][j])\n        return max_dp[K][n - 1] - min_dp[K][n - 1]", "entry_point": "putMarbles", "test_list": ["assert putMarbles([1,3,5,1],2)==4", "assert putMarbles([1, 3],2)==0"]}
{"Contest id": "330/2549", "text_name": "统计桌面上的不同数字", "text": "给你一个正整数 n ，开始时，它放在桌面上。在 109 天内，每天都要执行下述步骤：\n对于出现在桌面上的每个数字 x ，找出符合 1 <= i <= n 且满足 x % i == 1 的所有数字 i 。\n然后，将这些数字放在桌面上。\n返回在 109 天之后，出现在桌面上的 不同 整数的数目。\n注意：\n一旦数字放在桌面上，则会一直保留直到结束。\n% 表示取余运算。例如，14 % 3 等于 2 。", "canonical_solution": "def distinctIntegers(n):\n        return n if n<=1 else n-1", "entry_point": "distinctIntegers", "test_list": ["assert distinctIntegers(5)==4", "assert distinctIntegers(3)==2"]}
{"Contest id": "329/2547", "text_name": "拆分数组的最小代价", "text": "给你一个整数数组 nums 和一个整数 k 。\n将数组拆分成一些非空子数组。拆分的 代价 是每个子数组中的 重要性 之和。\n令 trimmed(subarray) 作为子数组的一个特征，其中所有仅出现一次的数字将会被移除。\n例如，trimmed([3,1,2,4,3,4]) = [3,4,3,4] 。\n子数组的 重要性 定义为 k + trimmed(subarray).length 。\n例如，如果一个子数组是 [1,2,3,3,3,4,4] ，trimmed([1,2,3,3,3,4,4]) = [3,3,3,4,4] 。这个子数组的重要性就是 k + 5 。\n找出并返回拆分 nums 的所有可行方案中的最小代价。\n子数组 是数组的一个连续 非空 元素序列。", "canonical_solution": "def minCost(nums, k):\n        dp=[0]\n        nums=[-1]+nums\n        def main(i):\n            mp=defaultdict(int)\n            s=0\n            ans=10000000000000\n            while i>0:\n                if mp[nums[i]]>0:\n                    s+=1\n                    if mp[nums[i]]==1:\n                        s+=1\n                mp[nums[i]]+=1\n                ans=min(dp[i-1]+s,ans)\n                i-=1\n            return ans+k\n        for i in range(1,len(nums)):\n            dp.append(main(i))\n        return dp[-1]", "entry_point": "minCost", "test_list": ["assert minCost([1,2,1,2,1,3,3],2)==8", "assert minCost([1,2,1,2,1],2)==6", "assert minCost([1,2,1,2,1],5)==10"]}
{"Contest id": "329/2546", "text_name": "执行逐位运算使字符串相等", "text": "给你两个下标从 0 开始的 二元 字符串 s 和 target ，两个字符串的长度均为 n 。你可以对 s 执行下述操作 任意 次：\n选择两个 不同 的下标 i 和 j ，其中 0 <= i, j < n 。\n同时，将 s[i] 替换为 (s[i] OR s[j]) ，s[j] 替换为 (s[i] XOR s[j]) 。\n例如，如果 s = \"0110\" ，你可以选择 i = 0 和 j = 2，然后同时将 s[0] 替换为 (s[0] OR s[2] = 0 OR 1 = 1)，并将 s[2] 替换为 (s[0] XOR s[2] = 0 XOR 1 = 1)，最终得到 s = \"1110\" 。\n如果可以使 s 等于 target ，返回 true ，否则，返回 false 。", "canonical_solution": "def makeStringsEqual(s, t):\n        return ('1' in s) == ('1' in t)", "entry_point": "makeStringsEqual", "test_list": ["assert makeStringsEqual(\"1010\",\"0110\")==True", "assert makeStringsEqual(\"11\",\"00\")==False"]}
{"Contest id": "329/2545", "text_name": "根据第 K 场考试的分数排序", "text": "班里有 m 位学生，共计划组织 n 场考试。给你一个下标从 0 开始、大小为 m x n 的整数矩阵 score ，其中每一行对应一位学生，而 score[i][j] 表示第 i 位学生在第 j 场考试取得的分数。矩阵 score 包含的整数 互不相同 。\n另给你一个整数 k 。请你按第 k 场考试分数从高到低完成对这些学生（矩阵中的行）的排序。\n返回排序后的矩阵。\n", "canonical_solution": "def sortTheStudents(A, k):\n        return sorted(A, key=lambda a: -a[k])", "entry_point": "sortTheStudents", "test_list": ["assert sortTheStudents([[10,6,9,1],[7,5,11,2],[4,8,3,15]],2)==[[7,5,11,2],[10,6,9,1],[4,8,3,15]]", "assert sortTheStudents([[3,4],[5,6]],0)==[[5,6],[3,4]]"]}
{"Contest id": "329/2544", "text_name": "交替数字和", "text": "给你一个正整数 n 。n 中的每一位数字都会按下述规则分配一个符号：\n最高有效位 上的数字分配到 正 号。\n剩余每位上数字的符号都与其相邻数字相反。\n返回所有数字及其对应符号的和。", "canonical_solution": "def alternateDigitSum(n):\n        res = 0\n        while n:\n            res = n % 10 - res\n            n //= 10\n        return res", "entry_point": "alternateDigitSum", "test_list": ["assert alternateDigitSum(521)==4", "assert alternateDigitSum(111)==1", "assert alternateDigitSum(886996)==0"]}
{"Contest id": "Bi96/2543", "text_name": "判断一个点是否可以到达", "text": "给你一个无穷大的网格图。一开始你在 (1, 1) ，你需要通过有限步移动到达点 (targetX, targetY) 。\n每一步 ，你可以从点 (x, y) 移动到以下点之一：\n(x, y - x)\n(x - y, y)\n(2 * x, y)\n(x, 2 * y)\n给你两个整数 targetX 和 targetY ，分别表示你最后需要到达点的 X 和 Y 坐标。如果你可以从 (1, 1) 出发到达这个点，请你返回true ，否则返回 false 。", "canonical_solution": "def isReachable(x, y):\n        return (\n            True if x == 1 and y == 1 else\n            isReachable(x / 2, y) if x % 2 == 0 else\n            isReachable(x, y / 2) if y % 2 == 0 else\n            isReachable(x - y, y) if x > y else\n            isReachable(x, y - x) if y > x else False\n        )", "entry_point": "isReachable", "test_list": ["assert isReachable(6,9)==False", "assert isReachable(4,7)==True"]}
{"Contest id": "Bi96/2542", "text_name": "最大子序列的分数", "text": "给你两个下标从 0 开始的整数数组 nums1 和 nums2 ，两者长度都是 n ，再给你一个正整数 k 。你必须从 nums1 中选一个长度为 k 的 子序列 对应的下标。\n对于选择的下标 i0 ，i1 ，...， ik - 1 ，你的 分数 定义如下：\nnums1 中下标对应元素求和，乘以 nums2 中下标对应元素的 最小值 。\n用公式表示： (nums1[i0] + nums1[i1] +...+ nums1[ik - 1]) * min(nums2[i0] , nums2[i1], ... ,nums2[ik - 1]) 。\n请你返回 最大 可能的分数。\n一个数组的 子序列 下标是集合 {0, 1, ..., n-1} 中删除若干元素得到的剩余集合，也可以不删除任何元素。", "canonical_solution": "def maxScore(A, B, k):\n            import heapq\n            total = res = 0\n            h = []\n            for a,b in sorted(list(zip(A, B)), key=lambda ab: -ab[1]):\n                heapq.heappush(h, a)\n                total += a\n                if len(h) > k:\n                    total -= heapq.heappop(h)\n                if len(h) == k:\n                    res = max(res, total * b)\n            return res", "entry_point": "maxScore", "test_list": ["assert maxScore([1,3,3,2],[2,1,3,4],3)==12", "assert maxScore([4,2,3,1,1],[7,5,10,9,6],1)==30"]}
{"Contest id": "Bi96/2541", "text_name": "使数组中所有元素相等的最小操作数 II", "text": "给你两个整数数组 nums1 和 nums2 ，两个数组长度都是 n ，再给你一个整数 k 。你可以对数组 nums1 进行以下操作：\n选择两个下标 i 和 j ，将 nums1[i] 增加 k ，将 nums1[j] 减少 k 。换言之，nums1[i] = nums1[i] + k 且 nums1[j] = nums1[j] - k 。\n如果对于所有满足 0 <= i < n 都有 num1[i] == nums2[i] ，那么我们称 nums1 等于 nums2 。\n请你返回使 nums1 等于 nums2 的 最少 操作数。如果没办法让它们相等，请你返回 -1 。", "canonical_solution": "def minOperations(nums1, nums2, k):\n        if nums1 == nums2:\n            return 0\n        if k == 0:\n            return -1\n        lo, hi = 0, 0\n        for a, b in zip(nums1, nums2):\n            d = a - b\n            if d % k != 0:\n                return -1\n            if d < 0:\n                lo += d\n            else:\n                hi += d\n        if lo + hi != 0:\n            return -1\n        return hi // k", "entry_point": "minOperations", "test_list": ["assert minOperations([4,3,1,4],[1,3,7,1],3)==2", "assert minOperations([3,8,5,2],[2,4,1,6],1)==-1"]}
{"Contest id": "Bi96/2540", "text_name": "最小公共值", "text": "给你两个整数数组 nums1 和 nums2 ，它们已经按非降序排序，请你返回两个数组的 最小公共整数 。如果两个数组 nums1 和 nums2 没有公共整数，请你返回 -1 。\n如果一个整数在两个数组中都 至少出现一次 ，那么这个整数是数组 nums1 和 nums2 公共 的。\n", "canonical_solution": "def getCommon(nums1, nums2):\n        nums1, nums2 = set(nums1), set(nums2)\n        common = sorted(list(nums1.intersection(nums2)))\n        return -1 if not len(common) else common[0]", "entry_point": "getCommon", "test_list": ["assert getCommon([1,2,3],[2,4])==2", "assert getCommon([1,2,3,6],[2,3,4,5])==2"]}
{"Contest id": "328/2538", "text_name": "最大价值和与最小价值和的差值", "text": "给你一个 n 个节点的无向无根图，节点编号为 0 到 n - 1 。给你一个整数 n 和一个长度为 n - 1 的二维整数数组 edges ，其中 edges[i] = [ai, bi] 表示树中节点 ai 和 bi 之间有一条边。\n每个节点都有一个价值。给你一个整数数组 price ，其中 price[i] 是第 i 个节点的价值。\n一条路径的 价值和 是这条路径上所有节点的价值之和。\n你可以选择树中任意一个节点作为根节点 root 。选择 root 为根的 开销 是以 root 为起点的所有路径中，价值和 最大的一条路径与最小的一条路径的差值。\n请你返回所有节点作为根节点的选择中，最大 的 开销 为多少。", "canonical_solution": "def maxOutput(n, edges, price):\n        g = defaultdict(set)       \n        for u, v in edges:\n            g[u].add(v)\n            g[v].add(u)\n        def dfs(node, parent):\n            curr_price = price[node]\n            m = 0 # find the max path from current node via dfs\n            for v in g[node]:\n                if v == parent: continue\n                m = max(m, dfs(v, node))\n            return curr_price + m # return current_price + max_price_path     \n        m = 0\n        for node in range(n):\n            max_price = dfs(node, -1)\n            min_price = price[node]\n            m = max(m, max_price - min_price)       \n        return m", "entry_point": "maxOutput", "test_list": ["assert maxOutput(6,[[0,1],[1,2],[1,3],[3,4],[3,5]],[9,8,7,6,10,5])==24", "assert maxOutput(3,[[0,1],[1,2]],[1,1,1])==2"]}
{"Contest id": "328/2537", "text_name": "统计好子数组的数目", "text": "给你一个整数数组 nums 和一个整数 k ，请你返回 nums 中 好 子数组的数目。\n一个子数组 arr 如果有 至少 k 对下标 (i, j) 满足 i < j 且 arr[i] == arr[j] ，那么称它是一个 好 子数组。\n子数组 是原数组中一段连续 非空 的元素序列。", "canonical_solution": "def countGood(A,k):\n        from collections import Counter\n        res = cur = i = 0\n        count = Counter()\n        for j in range(len(A)):\n            k -= count[A[j]]\n            count[A[j]] += 1\n            while k <= 0:\n                count[A[i]] -= 1\n                k += count[A[i]]\n                i += 1\n            res += i\n        return res", "entry_point": "countGood", "test_list": ["assert countGood([1,1,1,1,1],10)==1", "assert countGood([3,1,4,3,2,2,4],2)==4"]}
{"Contest id": "328/2536", "text_name": "子矩阵元素加 1", "text": "给你一个正整数 n ，表示最初有一个 n x n 、下标从 0 开始的整数矩阵 mat ，矩阵中填满了 0 。\n另给你一个二维整数数组 query 。针对每个查询 query[i] = [row1i, col1i, row2i, col2i] ，请你执行下述操作：\n找出 左上角 为 (row1i, col1i) 且 右下角 为 (row2i, col2i) 的子矩阵，将子矩阵中的 每个元素 加 1 。也就是给所有满足 row1i <= x <= row2i 和 col1i <= y <= col2i 的 mat[x][y] 加 1 。\n返回执行完所有操作后得到的矩阵 mat 。", "canonical_solution": "def rangeAddQueries(n, queries):\n    diff = [[0] * (n + 2) for _ in range(n + 2)]\n    for r1, c1, r2, c2 in queries:\n        diff[r1 + 1][c1 + 1] += 1\n        diff[r1 + 1][c2 + 2] -= 1\n        diff[r2 + 2][c1 + 1] -= 1\n        diff[r2 + 2][c2 + 2] += 1\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            diff[i][j] += diff[i][j - 1] + diff[i - 1][j] - diff[i - 1][j - 1]\n    diff = diff[1:-1]\n    for i, row in enumerate(diff):\n        diff[i] = row[1:-1]\n    return diff", "entry_point": "rangeAddQueries", "test_list": ["assert rangeAddQueries(3,[[1,1,2,2],[0,0,1,1]])==[[1,1,0],[1,2,1],[0,1,1]]", "assert rangeAddQueries(2,[[0,0,1,1]])==[[1,1],[1,1]]"]}
{"Contest id": "328/2535", "text_name": "数组元素和与数字和的绝对差", "text": "给你一个正整数数组 nums 。\n元素和 是 nums 中的所有元素相加求和。\n数字和 是 nums 中每一个元素的每一数位（重复数位需多次求和）相加求和。\n返回 元素和 与 数字和 的绝对差。\n注意：两个整数 x 和 y 的绝对差定义为 |x - y| 。", "canonical_solution": "def differenceOfSum(nums):\n        digit_sum =0\n        for i in nums:\n            if i >9:\n                while i!=0:\n                    rem = i%10\n                    digit_sum += rem\n                    i = i//10\n            else:\n                digit_sum += i\n        return abs(sum(nums)-digit_sum)", "entry_point": "differenceOfSum", "test_list": ["assert differenceOfSum([1,15,6,3])==9", "assert differenceOfSum([1,2,3,4])==0"]}
{"Contest id": "327/2532", "text_name": "过桥的时间", "text": "共有 k 位工人计划将 n 个箱子从旧仓库移动到新仓库。给你两个整数 n 和 k，以及一个二维整数数组 time ，数组的大小为 k x 4 ，其中 time[i] = [leftToRighti, pickOldi, rightToLefti, putNewi] 。\n一条河将两座仓库分隔，只能通过一座桥通行。旧仓库位于河的右岸，新仓库在河的左岸。开始时，所有 k 位工人都在桥的左侧等待。为了移动这些箱子，第 i 位工人（下标从 0 开始）可以：\n从左岸（新仓库）跨过桥到右岸（旧仓库），用时 leftToRighti 分钟。\n从旧仓库选择一个箱子，并返回到桥边，用时 pickOldi 分钟。不同工人可以同时搬起所选的箱子。\n从右岸（旧仓库）跨过桥到左岸（新仓库），用时 rightToLefti 分钟。\n将箱子放入新仓库，并返回到桥边，用时 putNewi 分钟。不同工人可以同时放下所选的箱子。\n如果满足下面任一条件，则认为工人 i 的 效率低于 工人 j ：\nleftToRighti + rightToLefti > leftToRightj + rightToLeftj\nleftToRighti + rightToLefti == leftToRightj + rightToLeftj 且 i > j\n工人通过桥时需要遵循以下规则：\n如果工人 x 到达桥边时，工人 y 正在过桥，那么工人 x 需要在桥边等待。\n如果没有正在过桥的工人，那么在桥右边等待的工人可以先过桥。如果同时有多个工人在右边等待，那么 效率最低 的工人会先过桥。\n如果没有正在过桥的工人，且桥右边也没有在等待的工人，同时旧仓库还剩下至少一个箱子需要搬运，此时在桥左边的工人可以过桥。如果同时有多个工人在左边等待，那么 效率最低 的工人会先过桥。\n所有 n 个盒子都需要放入新仓库，请你返回最后一个搬运箱子的工人 到达河左岸 的时间。\n", "canonical_solution": "def findCrossingTime(n, k, time):\n        import heapq\n        ql = []\n        qr = []\n        qt = []\n        for x in range(k):\n            heappush(ql, (-(time[x][0] + time[x][2]), -x))\n        ct = 0\n        ans = 0\n        b = 1\n        i = -heappop(ql)[1]\n        heappush(qt, (time[i][0], 0, i))\n        while qt:\n            ct = qt[0][0]\n            def chkgo():\n                nonlocal b\n                if qr:\n                    j = -heappop(qr)[1]\n                    heappush(qt, (ct + time[j][2], 1, j))\n                elif ql:\n                    if n:\n                        j = -heappop(ql)[1]\n                        heappush(qt, (ct + time[j][0], 0, j))\n                    else:\n                        b = 0\n                else:\n                    b = 0  \n            while qt and qt[0][0] == ct:\n                t, st, i = heappop(qt)\n                assert(t == ct)\n                if st == 0:\n                    n -= 1\n                    heappush(qt, (t + time[i][1], 2, i))\n                    b = 0\n                elif st == 1:\n                    heappush(qt, (t + time[i][3], 3, i))\n                    b = 0\n                    ans = ct\n                elif st == 2:\n                    heappush(qr, (-(time[i][0] + time[i][2]), -i))\n                elif st == 3:\n                    heappush(ql, (-(time[i][0] + time[i][2]), -i))\n            if not b:\n                b = 1\n                chkgo()           \n        return ans", "entry_point": "findCrossingTime", "test_list": ["assert findCrossingTime(1,3,[[1,1,2,1],[1,1,3,1],[1,1,4,1]])==6", "assert findCrossingTime(3,2,[[1,9,1,8],[10,10,10,10]])==50"]}
{"Contest id": "327/2531", "text_name": "使字符串中不同字符的数目相等", "text": "给你两个下标从 0 开始的字符串 word1 和 word2 。\n一次 移动 由以下两个步骤组成：\n选中两个下标 i 和 j ，分别满足 0 <= i < word1.length 和 0 <= j < word2.length ，\n交换 word1[i] 和 word2[j] 。\n如果可以通过 恰好一次 移动，使 word1 和 word2 中不同字符的数目相等，则返回 true ；否则，返回 false 。", "canonical_solution": "def isItPossible(word1, word2):\n        from collections import Counter\n        d1 = Counter(word1)\n        d2 = Counter(word2)\n        for c in \"abcdefghijklmnopqrstuvwxyz\":\n            d1[c] = d1.get(c, 0)\n            d2[c] = d2.get(c, 0)\n        for c1 in d1:\n            if d1[c1] > 0:\n                d1[c1] -= 1\n                for c2 in d2:\n                    if d2[c2] > 0:\n                        d2[c1] += 1\n                        d2[c2] -= 1\n                        d1[c2] += 1\n                        if len([1 for c in d1.values() if c > 0]) == len([1 for c in d2.values() if c > 0]):\n                            return True\n                        d2[c1] -= 1\n                        d2[c2] += 1\n                        d1[c2] -= 1\n                d1[c1] += 1\n        return False", "entry_point": "isItPossible", "test_list": ["assert isItPossible(\"ac\",\"b\")==False", "assert isItPossible(\"abcc\",\"aab\")==True", "assert isItPossible(\"abcde\",\"fghij\")==True"]}
{"Contest id": "327/2530", "text_name": "执行 K 次操作后的最大分数", "text": "给你一个下标从 0 开始的整数数组 nums 和一个整数 k 。你的 起始分数 为 0 。\n在一步 操作 中：\n选出一个满足 0 <= i < nums.length 的下标 i ，\n将你的 分数 增加 nums[i] ，并且\n将 nums[i] 替换为 ceil(nums[i] / 3) 。\n返回在 恰好 执行 k 次操作后，你可能获得的最大分数。\n向上取整函数 ceil(val) 的结果是大于或等于 val 的最小整数。", "canonical_solution": "def maxKelements(nums, k):\n        from heapq import heapify,heappop,heappush\n        from math import floor\n        ans = 0\n        nums = [-num for num in nums]\n        heapify(nums)\n        while k:\n            tmp = heappop(nums)\n            ans -= tmp\n            heappush(nums, floor(tmp / 3))\n            k -= 1 \n        return ans", "entry_point": "maxKelements", "test_list": ["assert maxKelements([10,10,10,10,10],5)==50", "assert maxKelements([1,10,3,3,3],3)==17"]}
{"Contest id": "327/2529", "text_name": "正整数和负整数的最大计数", "text": "给你一个按 非递减顺序 排列的数组 nums ，返回正整数数目和负整数数目中的最大值。\n换句话讲，如果 nums 中正整数的数目是 pos ，而负整数的数目是 neg ，返回 pos 和 neg二者中的最大值。\n注意：0 既不是正整数也不是负整数。", "canonical_solution": "def maximumCount(nums):\n        neg=0\n        pos=0\n        for i in nums:\n            if i>0:\n                pos+=1\n            if i<0:\n                neg+=1\n        return pos if pos > neg else neg", "entry_point": "maximumCount", "test_list": ["assert maximumCount([-2,-1,-1,1,2,3])==3", "assert maximumCount([-3,-2,-1,0,0,1,2])==3", "assert maximumCount([5,20,66,1314])==4"]}
{"Contest id": "Bi95/2528", "text_name": "最大化城市的最小电量", "text": "给你一个下标从 0 开始长度为 n 的整数数组 stations ，其中 stations[i] 表示第 i 座城市的供电站数目。\n每个供电站可以在一定 范围 内给所有城市提供电力。换句话说，如果给定的范围是 r ，在城市 i 处的供电站可以给所有满足 |i - j| <= r 且 0 <= i, j <= n - 1 的城市 j 供电。\n|x| 表示 x 的 绝对值 。比方说，|7 - 5| = 2 ，|3 - 10| = 7 。\n一座城市的 电量 是所有能给它供电的供电站数目。\n政府批准了可以额外建造 k 座供电站，你需要决定这些供电站分别应该建在哪里，这些供电站与已经存在的供电站有相同的供电范围。\n给你两个整数 r 和 k ，如果以最优策略建造额外的发电站，返回所有城市中，最小电量的最大值是多少。\n这 k 座供电站可以建在多个城市。", "canonical_solution": "def maxPower(stations, r, k) :\n        def isPossible(min_power,stations,r,k):\n            cur_power = 0\n            for i in range(r+1):\n                cur_power += stations[i]\n            left,right = 0,r\n            for i in range(0,len(stations)):\n                if i-left>r:\n                    cur_power -= stations[left]\n                    left+=1\n                if right-i<r and right<len(stations)-1:\n                    right+=1\n                    cur_power += stations[right]\n                if cur_power < min_power:\n                    power_needed = min_power-cur_power\n                    if k<power_needed: return False\n                    stations[right] += power_needed\n                    cur_power += power_needed\n                    k-=power_needed\n            return True\n        best = min(stations)\n        left,right = 0,10**12\n        while left<=right:\n            mid = (left+right)//2\n            if isPossible(mid,stations[:],r,k):\n                left = mid+1\n                best = mid\n            else:\n                right = mid - 1\n        return best", "entry_point": "maxPower", "test_list": ["assert maxPower([1,2,4,5,0],1,2)==5", "assert maxPower([4,4,4,4],0,3)==4"]}
{"Contest id": "Bi95/2527", "text_name": "查询数组异或美丽值", "text": "给你一个下标从 0 开始的整数数组 nums 。\n三个下标 i ，j 和 k 的 有效值 定义为 ((nums[i] | nums[j]) & nums[k]) 。\n一个数组的 异或美丽值 是数组中所有满足 0 <= i, j, k < n  的三元组 (i, j, k) 的 有效值 的异或结果。\n请你返回 nums 的异或美丽值。\n注意：\nval1 | val2 是 val1 和 val2 的按位或。\nval1 & val2 是 val1 和 val2 的按位与。\n", "canonical_solution": "def xorBeauty(nums):\n        import math\n        import collections\n        import itertools\n        beauty = 0\n        for bit in range(math.floor(math.log2(max(nums))) + 1):\n            cnt = collections.Counter((num >> bit) & 1 for num in nums)\n            for i, j, k in itertools.product((0, 1), repeat=3):\n                if (cnt[i] * cnt[j] * cnt[k]) & 1:\n                    beauty ^= ((i | j) & k) << bit\n        return beauty", "entry_point": "xorBeauty", "test_list": ["assert xorBeauty([1,4])==5", "assert xorBeauty([15,45,20,2,34,35,5,44,32,30])==34"]}
{"Contest id": "Bi95/2525", "text_name": "根据规则将箱子分类", "text": "给你四个整数 length ，width ，height 和 mass ，分别表示一个箱子的三个维度和质量，请你返回一个表示箱子 类别 的字符串。\n如果满足以下条件，那么箱子是 \"Bulky\" 的：\n箱子 至少有一个 维度大于等于 104 。\n或者箱子的 体积 大于等于 109 。\n如果箱子的质量大于等于 100 ，那么箱子是 \"Heavy\" 的。\n如果箱子同时是 \"Bulky\" 和 \"Heavy\" ，那么返回类别为 \"Both\" 。\n如果箱子既不是 \"Bulky\" ，也不是 \"Heavy\" ，那么返回类别为 \"Neither\" 。\n如果箱子是 \"Bulky\" 但不是 \"Heavy\" ，那么返回类别为 \"Bulky\" 。\n如果箱子是 \"Heavy\" 但不是 \"Bulky\" ，那么返回类别为 \"Heavy\" 。\n注意，箱子的体积等于箱子的长度、宽度和高度的乘积。", "canonical_solution": "def categorizeBox(length, width, height, mass):\n        volume = length * width * height\n        category = []\n        if length >= 10**4 or width >= 10**4 or height >= 10**4 or volume >= 10**9:\n            category.append(\"Bulky\")\n        if mass >= 100:\n            category.append(\"Heavy\")\n        if \"Bulky\" in category and \"Heavy\" in category:\n            return \"Both\"\n        if not category:\n            return \"Neither\"\n        return category[0]", "entry_point": "categorizeBox", "test_list": ["assert categorizeBox(1000,35,700,300)==\"Heavy\"", "assert categorizeBox(200,50,800,50)==\"Neither\""]}
{"Contest id": "326/2523", "text_name": "范围内最接近的两个质数", "text": "给你两个正整数 left 和 right ，请你找到两个整数 num1 和 num2 ，它们满足：\nleft <= nums1 < nums2 <= right  。\nnums1 和 nums2 都是 质数 。\nnums2 - nums1 是满足上述条件的质数对中的 最小值 。\n请你返回正整数数组 ans = [nums1, nums2] 。如果有多个整数对满足上述条件，请你返回 nums1 最小的质数对。如果不存在符合题意的质数对，请你返回 [-1, -1] 。\n如果一个整数大于 1 ，且只能被 1 和它自己整除，那么它是一个 质数。", "canonical_solution": "def closestPrimes(left, right):\n        def isPrime(n):\n            if n < 2: return False\n            for x in range(2, int(n**0.5) + 1):\n                if n % x == 0:\n                    return False\n            return True\n        q = []\n        diff = float('inf')\n        pair = [-1,-1]\n        for i in range(left,right+1):\n            if isPrime(i): \n                q.append(i)\n            while len(q)>=2:\n                if abs(q[0]-q[1])<diff:\n                    pair=[q[0],q[1]]\n                    diff=abs(q[0]-q[1])  \n                    if diff<=2: return pair\n                q.pop(0)\n        return pair", "entry_point": "closestPrimes", "test_list": ["assert closestPrimes(10,19)==[11,13]", "assert closestPrimes(4,6)==[-1,-1]"]}
{"Contest id": "326/2522", "text_name": "将字符串分割成值不超过 K 的子字符串", "text": "给你一个字符串 s ，它每一位都是 1 到 9 之间的数字组成，同时给你一个整数 k 。\n如果一个字符串 s 的分割满足以下条件，我们称它是一个 好 分割：\ns 中每个数位 恰好 属于一个子字符串。\n每个子字符串的值都小于等于 k 。\n请你返回 s 所有的 好 分割中，子字符串的 最少 数目。如果不存在 s 的 好 分割，返回 -1 。\n注意：\n一个字符串的 值 是这个字符串对应的整数。比方说，\"123\" 的值为 123 ，\"1\" 的值是 1 。\n子字符串 是字符串中一段连续的字符序列。", "canonical_solution": "def minimumPartition(s, k):\n        tmp = ''\n        cnt = 0\n        for c in s:\n            tmp += c\n            if int(tmp) > k:\n                tmp = c\n                if int(tmp) > k:\n                    return -1\n                cnt += 1\n        return cnt + 1", "entry_point": "minimumPartition", "test_list": ["assert minimumPartition(\"165462\",60)==4", "assert minimumPartition(\"238182\",5)==-1"]}
{"Contest id": "326/2521", "text_name": "数组乘积中的不同质因数数目", "text": "给你一个正整数数组 nums ，对 nums 所有元素求积之后，找出并返回乘积中 不同质因数 的数目。\n注意：\n质数 是指大于 1 且仅能被 1 及自身整除的数字。\n如果 val2 / val1 是一个整数，则整数 val1 是另一个整数 val2 的一个因数。", "canonical_solution": "def distinctPrimeFactors(nums):\n        result = []\n        for i in range (len(nums)) :\n            square_root = int(math.sqrt(nums[i]))\n            for prime_num in range(2, square_root + 1) :\n                if (nums[i] % prime_num == 0) :\n                    result.append(prime_num)\n                    while (nums[i] % prime_num == 0) :\n                        nums[i] = nums[i] // prime_num\n            if (nums[i] >= 2) :\n                result.append(nums[i])\n        result = set(result)\n        return len(result)", "entry_point": "distinctPrimeFactors", "test_list": ["assert distinctPrimeFactors([2,4,3,7,10,6])==4", "assert distinctPrimeFactors([2,4,8,16])==1"]}
{"Contest id": "326/2520", "text_name": "统计能整除数字的位数", "text": "给你一个整数 num ，返回 num 中能整除 num 的数位的数目。\n如果满足 nums % val == 0 ，则认为整数 val 可以整除 nums 。", "canonical_solution": "def countDigits(num):\n        return sum(1 if num % int(d) == 0 else 0 for d in str(num))", "entry_point": "countDigits", "test_list": ["assert countDigits(7)==1", "assert countDigits(121)==2", "assert countDigits(1248)==4"]}
{"Contest id": "325/2518", "text_name": "好分区的数目", "text": "给你一个正整数数组 nums 和一个整数 k 。\n分区 的定义是：将数组划分成两个有序的 组 ，并满足每个元素 恰好 存在于 某一个 组中。如果分区中每个组的元素和都大于等于 k ，则认为分区是一个好分区。\n返回 不同 的好分区的数目。由于答案可能很大，请返回对 109 + 7 取余 后的结果。\n如果在两个分区中，存在某个元素 nums[i] 被分在不同的组中，则认为这两个分区不同。\n", "canonical_solution": "def countPartitions(A,k):\n        if sum(A) < k * 2: return 0\n        mod = 10**9 + 7\n        dp = [1] + [0] * (k - 1)\n        for a in A:\n            for i in range(k - 1 - a, -1, -1):\n                dp[i + a] += dp[i]\n        return (pow(2, len(A), mod) - sum(dp) * 2) % mod", "entry_point": "countPartitions", "test_list": ["assert countPartitions([1,2,3,4],4)==6", "assert countPartitions([3,3,3],4)==0", "assert countPartitions([6,6],2)==2"]}
{"Contest id": "325/2517", "text_name": "礼盒的最大甜蜜度", "text": "给你一个正整数数组 price ，其中 price[i] 表示第 i 类糖果的价格，另给你一个正整数 k 。\n商店组合 k 类 不同 糖果打包成礼盒出售。礼盒的 甜蜜度 是礼盒中任意两种糖果 价格 绝对差的最小值。\n返回礼盒的 最大 甜蜜度。", "canonical_solution": "def maximumTastiness(price, k):\n        if k == 0:\n            return 0\n        price.sort()\n        def isValid(num):\n            n = len(price)\n            cnt = 1\n            diff = price[0] + num\n            for i in range(1,n):\n                if price[i] >= diff:\n                    diff = price[i] + num\n                    cnt += 1\n                else:\n                    continue\n            return cnt\n        low,high = 0,max(price) - min(price)\n        ans = -1\n        while low <= high:\n            mid = (low + high) >> 1\n            if isValid(mid) >= k:\n                ans = mid\n                low = mid + 1\n            else:\n                high = mid - 1\n        return ans", "entry_point": "maximumTastiness", "test_list": ["assert maximumTastiness([13,5,1,8,21,2],3)==8", "assert maximumTastiness([1,3,1],2)==2", "assert maximumTastiness([7,7,7,7],2)==0"]}
{"Contest id": "325/2516", "text_name": "每种字符至少取 K 个", "text": "给你一个由字符 'a'、'b'、'c' 组成的字符串 s 和一个非负整数 k 。每分钟，你可以选择取走 s 最左侧 还是 最右侧 的那个字符。\n你必须取走每种字符 至少 k 个，返回需要的 最少 分钟数；如果无法取到，则返回 -1 。", "canonical_solution": "def takeCharacters(s, k):\n        ra = s.count('a') - k\n        rb = s.count('b') - k\n        rc = s.count('c') - k\n        if any(i < 0 for i in [ra, rb, rc]):\n            return -1\n        hm = defaultdict(int)\n        length = left = res = 0\n        for right in s:\n            hm[right] += 1\n            length += 1\n            while hm['a'] > ra or hm['b'] > rb or hm['c'] > rc:\n                hm[s[left]] -= 1\n                length -= 1\n                left += 1\n            res = max(res, length)\n        return len(s) - res", "entry_point": "takeCharacters", "test_list": ["assert takeCharacters(\"aabaaaacaabc\",2)==8", "assert takeCharacters(\"a\",1)==-1"]}
{"Contest id": "325/2515", "text_name": "到目标字符串的最短距离", "text": "给你一个下标从 0 开始的 环形 字符串数组 words 和一个字符串 target 。环形数组 意味着数组首尾相连。\n形式上， words[i] 的下一个元素是 words[(i + 1) % n] ，而 words[i] 的前一个元素是 words[(i - 1 + n) % n] ，其中 n 是 words 的长度。\n从 startIndex 开始，你一次可以用 1 步移动到下一个或者前一个单词。\n返回到达目标字符串 target 所需的最短距离。如果 words 中不存在字符串 target ，返回 -1 。", "canonical_solution": "def closetTarget(words, target, startIndex):\n        n = len(words)\n        moveright = 0\n        flag = False\n        for i in range(startIndex,len(words)+startIndex):\n            if words[(i+1)%n] == target:\n                flag = True\n                moveright += 1\n                break\n            else:\n                moveright += 1\n        if flag == False:\n            return -1\n        moveleft = 0\n        pointer = startIndex\n        while True:\n            if words[pointer] == target:\n                break\n            else:\n                pointer = (pointer - 1 + n) % n\n                moveleft += 1\n        return min(moveleft,moveright)", "entry_point": "closetTarget", "test_list": ["assert closetTarget([\"hello\",\"i\",\"am\",\"leetcode\",\"hello\"],\"hello\",1)==1", "assert closetTarget([\"a\",\"b\",\"leetcode\"],\"leetcode\",0)==1", "assert closetTarget([\"i\",\"eat\",\"leetcode\"],\"ate\",0)==-1"]}
{"Contest id": "Bi94/2514", "text_name": "统计同位异构字符串数目", "text": "给你一个字符串 s ，它包含一个或者多个单词。单词之间用单个空格 ' ' 隔开。\n如果字符串 t 中第 i 个单词是 s 中第 i 个单词的一个 排列 ，那么我们称字符串 t 是字符串 s 的同位异构字符串。\n比方说，\"acb dfe\" 是 \"abc def\" 的同位异构字符串，但是 \"def cab\" 和 \"adc bef\" 不是。\n请你返回 s 的同位异构字符串的数目，由于答案可能很大，请你将它对 109 + 7 取余 后返回。\n", "canonical_solution": "def countAnagrams(s):\n        from collections import Counter\n        import math\n        res = 1\n        for w in s.split(\" \"):\n            cnt, prem = Counter(w), math.factorial(len(w))\n            for rep in cnt.values():\n                prem = prem // math.factorial(rep)\n            res = res * prem % 1000000007\n        return res", "entry_point": "countAnagrams", "test_list": ["assert countAnagrams(\"too hot\")==18", "assert countAnagrams(\"aa\")==1"]}
{"Contest id": "Bi94/2513", "text_name": "最小化两个数组中的最大值", "text": "给你两个数组 arr1 和 arr2 ，它们一开始都是空的。你需要往它们中添加正整数，使它们满足以下条件：\narr1 包含 uniqueCnt1 个 互不相同 的正整数，每个整数都 不能 被 divisor1 整除 。\narr2 包含 uniqueCnt2 个 互不相同 的正整数，每个整数都 不能 被 divisor2 整除 。\narr1 和 arr2 中的元素 互不相同 。\n给你 divisor1 ，divisor2 ，uniqueCnt1 和 uniqueCnt2 ，请你返回两个数组中 最大元素 的 最小值 。", "canonical_solution": "def minimizeSet(divisor1, divisor2, uniqueCnt1, uniqueCnt2):\n        lcm = math.lcm(divisor1, divisor2)\n        def isok(num):\n            div1 = num - num // divisor1\n            if div1 < uniqueCnt1: \n                return False\n            div2 = num - num // divisor2 \n            if div2 < uniqueCnt2: \n                return False\n            union = num - num // lcm\n            if union < (uniqueCnt1 + uniqueCnt2):\n                return False\n            return True\n        l = 0\n        r = 10**15\n        while l < r: \n            mid = (l+r)//2\n            if isok(mid):\n                r = mid\n            else:\n                l = mid + 1\n        return l", "entry_point": "minimizeSet", "test_list": ["assert minimizeSet(2,7,1,3)==4", "assert minimizeSet(3,5,2,1)==3", "assert minimizeSet(2,4,8,2)==15"]}
{"Contest id": "Bi94/2512", "text_name": "奖励最顶尖的 K 名学生", "text": "给你两个字符串数组 positive_feedback 和 negative_feedback ，分别包含表示正面的和负面的词汇。不会 有单词同时是正面的和负面的。\n一开始，每位学生分数为 0 。每个正面的单词会给学生的分数 加 3 分，每个负面的词会给学生的分数 减  1 分。\n给你 n 个学生的评语，用一个下标从 0 开始的字符串数组 report 和一个下标从 0 开始的整数数组 student_id 表示，其中 student_id[i] 表示这名学生的 ID ，这名学生的评语是 report[i] 。每名学生的 ID 互不相同。\n给你一个整数 k ，请你返回按照得分 从高到低 最顶尖的 k 名学生。如果有多名学生分数相同，ID 越小排名越前。", "canonical_solution": "def topStudents(positive_feedback, negative_feedback, report, student_id, k):\n        import collections\n        ans=collections.defaultdict(int)\n        positive_feedback_d=collections.defaultdict(int)\n        negative_feedback_d=collections.defaultdict(int)\n        for i in positive_feedback:\n            positive_feedback_d[i]+=1\n        for i in negative_feedback:\n            negative_feedback_d[i]+=1\n        for i in range(len(report)):\n            for j in report[i].split(\" \"):\n                if positive_feedback_d[j]>=1:\n                    ans[student_id[i]]+=3\n                elif negative_feedback_d[j]>=1:\n                    ans[student_id[i]]-=1\n                else:\n                    continue\n        temp=[]\n        sorted_d = (sorted(ans, key=lambda x: (-ans[x], x)))\n        i=0\n        for j in sorted_d:\n            temp.append(j)\n            i+=1\n            if i>=k:\n                break\n        return(temp)", "entry_point": "topStudents", "test_list": ["assert topStudents([\"smart\",\"brilliant\",\"studious\"],[\"not\"],[\"this student is studious\",\"the student is smart\"],[1,2],2)==[1,2]", "assert topStudents([\"smart\",\"brilliant\",\"studious\"],[\"not\"],[\"this student is not studious\",\"the student is smart\"],[1,2],2)==[2,1]"]}
{"Contest id": "Bi94/2511", "text_name": "最多可以摧毁的敌人城堡数目", "text": "给你一个长度为 n ，下标从 0 开始的整数数组 forts ，表示一些城堡。forts[i] 可以是 -1 ，0 或者 1 ，其中：\n-1 表示第 i 个位置 没有 城堡。\n0 表示第 i 个位置有一个 敌人 的城堡。\n1 表示第 i 个位置有一个你控制的城堡。\n现在，你需要决定，将你的军队从某个你控制的城堡位置 i 移动到一个空的位置 j ，满足：\n0 <= i, j <= n - 1\n军队经过的位置 只有 敌人的城堡。正式的，对于所有 min(i,j) < k < max(i,j) 的 k ，都满足 forts[k] == 0 。\n当军队移动时，所有途中经过的敌人城堡都会被 摧毁 。\n请你返回 最多 可以摧毁的敌人城堡数目。如果 无法 移动你的军队，或者没有你控制的城堡，请返回 0 。", "canonical_solution": "def captureForts(forts):\n        def solve(arr):\n            max_ = 0\n            count, flag = 0, False\n            for num in arr:\n                if num == 1: \n                    count, flag = 0, True\n                elif num == -1: \n                    max_, count, flag = max(max_, count), 0, False\n                else: \n                    if flag: count += 1\n            return max_\n        return max(solve(forts), solve(forts[::-1]))", "entry_point": "captureForts", "test_list": ["assert captureForts([1,0,0,-1,0,0,0,0,1])==4", "assert captureForts([0,0,1,-1])==0"]}
{"Contest id": "324/2509", "text_name": "查询树中环的长度", "text": "给你一个整数 n ，表示你有一棵含有 2n - 1 个节点的 完全二叉树 。根节点的编号是 1 ，树中编号在[1, 2n - 1 - 1] 之间，编号为 val 的节点都有两个子节点，满足：\n左子节点的编号为 2 * val\n右子节点的编号为 2 * val + 1\n给你一个长度为 m 的查询数组 queries ，它是一个二维整数数组，其中 queries[i] = [ai, bi] 。对于每个查询，求出以下问题的解：\n在节点编号为 ai 和 bi 之间添加一条边。\n求出图中环的长度。\n删除节点编号为 ai 和 bi 之间新添加的边。\n注意：\n环 是开始和结束于同一节点的一条路径，路径中每条边都只会被访问一次。\n环的长度是环中边的数目。\n在树中添加额外的边后，两个点之间可能会有多条边。\n请你返回一个长度为 m 的数组 answer ，其中 answer[i] 是第 i 个查询的结果。", "canonical_solution": "def cycleLengthQueries(n, queries):\n        res = []\n        for x,y in queries:\n            res.append(1)\n            while x != y:\n                x, y = min(x, y), max(x, y) // 2\n                res[-1] += 1\n        return res", "entry_point": "cycleLengthQueries", "test_list": ["assert cycleLengthQueries(3,[[5,3],[4,7],[2,3]])==[4,5,3]", "assert cycleLengthQueries(2,[[1,2]])==[2]"]}
{"Contest id": "324/2508", "text_name": "添加边使所有节点度数都为偶数", "text": "给你一个有 n 个节点的 无向 图，节点编号为 1 到 n 。再给你整数 n 和一个二维整数数组 edges ，其中 edges[i] = [ai, bi] 表示节点 ai 和 bi 之间有一条边。图不一定连通。\n你可以给图中添加 至多 两条额外的边（也可以一条边都不添加），使得图中没有重边也没有自环。\n如果添加额外的边后，可以使得图中所有点的度数都是偶数，返回 true ，否则返回 false 。\n点的度数是连接一个点的边的数目。", "canonical_solution": "def isPossible(n, edges):\n        import collections\n        def areConnected(u,v): return u in N[v]\n        N = collections.defaultdict(set)        \n        for u,v in edges: _,_ = N[u].add(v), N[v].add(u)\n        O = [u for u in N if len(N[u]) % 2 == 1]\n        if len(O) == 0: return True\n        if len(O) > 4: return False\n        if len(O) == 2:\n            u,v = O\n            if not areConnected(u,v): return True\n            return any(not areConnected(u,w) and not areConnected(v,w) for w in range(1,n+1))            \n        if len(O) == 4: \n            u,v,w,x = O\n            if not areConnected(u,v) and not areConnected(w,x): return True\n            if not areConnected(u,w) and not areConnected(v,x): return True\n            if not areConnected(u,x) and not areConnected(v,w): return True\n            return False\n        return False", "entry_point": "isPossible", "test_list": ["assert isPossible(5,[[1,2],[2,3],[3,4],[4,2],[1,4],[2,5]])==True", "assert isPossible(4,[[1,2],[3,4]])==True", "assert isPossible(4,[[1,2],[1,3],[1,4]])==False"]}
{"Contest id": "324/2507", "text_name": "使用质因数之和替换后可以取到的最小值", "text": "给你一个正整数 n 。\n请你将 n 的值替换为 n 的 质因数 之和，重复这一过程。\n注意，如果 n 能够被某个质因数多次整除，则在求和时，应当包含这个质因数同样次数。\n返回 n 可以取到的最小值。", "canonical_solution": "def smallestValue(n):\n        def factorization(n):\n                factors_sum = 0\n                i = 2\n                while n > 1:\n                    while n % i == 0:\n                        n //= i\n                        factors_sum +=i\n                    i += 1\n                return factors_sum\n        while n != (n:=factorization(n)) :pass\n        return n", "entry_point": "smallestValue", "test_list": ["assert smallestValue(15)==5", "assert smallestValue(3)==3"]}
{"Contest id": "324/2506", "text_name": "统计相似字符串对的数目", "text": "给你一个下标从 0 开始的字符串数组 words 。\n如果两个字符串由相同的字符组成，则认为这两个字符串 相似 。\n例如，\"abca\" 和 \"cba\" 相似，因为它们都由字符 'a'、'b'、'c' 组成。\n然而，\"abacba\" 和 \"bcfd\" 不相似，因为它们不是相同字符组成的。\n请你找出满足字符串 words[i] 和 words[j] 相似的下标对 (i, j) ，并返回下标对的数目，其中 0 <= i < j <= word.length - 1 。\n", "canonical_solution": "def similarPairs(words):\n        wordMap = {}\n        for word in words:\n            curr = sorted(set(word))\n            curr = ''.join(curr)\n            if curr in wordMap:\n                wordMap[curr]+=1\n            else:\n                wordMap[curr]=1\n        pairs = 0\n        for word in wordMap:\n            count = wordMap[word]\n            pairs += (count* (count-1))//2\n        return pairs", "entry_point": "similarPairs", "test_list": ["assert similarPairs([\"aba\",\"aabb\",\"abcd\",\"bac\",\"aabc\"])==2", "assert similarPairs([\"aabb\",\"ab\",\"ba\"])==3", "assert similarPairs([\"nba\",\"cba\",\"dba\"])==0"]}
{"Contest id": "323/2503", "text_name": "矩阵查询可获得的最大分数", "text": "给你一个大小为 m x n 的整数矩阵 grid 和一个大小为 k 的数组 queries 。\n找出一个大小为 k 的数组 answer ，且满足对于每个整数 queries[i] ，你从矩阵 左上角 单元格开始，重复以下过程：\n如果 queries[i] 严格 大于你当前所处位置单元格，如果该单元格是第一次访问，则获得 1 分，并且你可以移动到所有 4 个方向（上、下、左、右）上任一 相邻 单元格。\n否则，你不能获得任何分，并且结束这一过程。\n在过程结束后，answer[i] 是你可以获得的最大分数。注意，对于每个查询，你可以访问同一个单元格 多次 。\n返回结果数组 answer 。", "canonical_solution": "def maxPoints(grid, queries):\n    import bisect\n    import heapq\n    m = len(grid)\n    n = len(grid[0])\n    heap = [(grid[0][0], 0, 0)]\n    v = {(0, 0)}\n    order = []\n    while len(heap) > 0:\n            curr, i, j = heapq.heappop(heap)\n            order.append(curr)\n            for x, y in [(i - 1, j), (i, j - 1), (i + 1, j), (i, j + 1)]:\n                    if 0 <= x < m and 0 <= y < n and (x, y) not in v:\n                            v.add((x, y))\n                            heapq.heappush(heap, (grid[x][y], x, y))\n    maxYet = -1\n    for i in range(len(order)):\n            maxYet = max(maxYet, order[i])\n            order[i] = maxYet\n    res = []\n    for q in queries:\n            res.append(bisect.bisect_left(order, q))\n    return res", "entry_point": "maxPoints", "test_list": ["assert maxPoints([[1,2,3],[2,5,7],[3,5,1]],[5,6,2])==[5,8,1]", "assert maxPoints([[5,2,1],[1,1,2]],[3])==[0]"]}
{"Contest id": "323/2501", "text_name": "数组中最长的方波", "text": "给你一个整数数组 nums 。如果 nums 的子序列满足下述条件，则认为该子序列是一个 方波 ：\n子序列的长度至少为 2 ，并且\n将子序列从小到大排序 之后 ，除第一个元素外，每个元素都是前一个元素的 平方 。\n返回 nums 中 最长方波 的长度，如果不存在 方波 则返回 -1 。\n子序列 也是一个数组，可以由另一个数组删除一些或不删除元素且不改变剩余元素的顺序得到。", "canonical_solution": "def longestSquareStreak(nums):\n        uniq = set(nums)\n        res = 0\n        for i in nums:\n            temp = i\n            t = 0\n            while temp * temp in uniq:\n                temp *= temp\n                t += 1          \n            res = max(res, t)\n        return res + 1 if res else -1", "entry_point": "longestSquareStreak", "test_list": ["assert longestSquareStreak([4,3,6,16,8,2])==3", "assert longestSquareStreak([2,3,5,6,7])==-1"]}
{"Contest id": "323/2500", "text_name": "删除每行中的最大值", "text": "给你一个 m x n 大小的矩阵 grid ，由若干正整数组成。\n执行下述操作，直到 grid 变为空矩阵：\n从每一行删除值最大的元素。如果存在多个这样的值，删除其中任何一个。\n将删除元素中的最大值与答案相加。\n注意 每执行一次操作，矩阵中列的数据就会减 1 。\n返回执行上述操作后的答案。", "canonical_solution": "def deleteGreatestValue(grid):\n        i = 0\n        output = 0\n        current_max = 0\n        while True:\n            if len(grid[i]) == 0:\n                break\n            grid[i] = sorted(grid[i])\n            current_max = max(current_max,grid[i][-1])\n            grid[i].pop(-1)\n            i+=1\n            if i == len(grid):\n                output += current_max\n                current_max = 0\n                i = 0\n        return output", "entry_point": "deleteGreatestValue", "test_list": ["assert deleteGreatestValue([[1,2,4],[3,3,1]])==8", "assert deleteGreatestValue([[10]])==10"]}
{"Contest id": "Bi93/2499", "text_name": "让数组不相等的最小总代价", "text": "给你两个下标从 0 开始的整数数组 nums1 和 nums2 ，两者长度都为 n 。\n每次操作中，你可以选择交换 nums1 中任意两个下标处的值。操作的 开销 为两个下标的 和 。\n你的目标是对于所有的 0 <= i <= n - 1 ，都满足 nums1[i] != nums2[i] ，你可以进行任意次操作，请你返回达到这个目标的 最小 总代价。\n请你返回让 nums1 和 nums2 满足上述条件的 最小总代价 ，如果无法达成目标，返回 -1 。", "canonical_solution": "def minimumTotalCost(nums1, nums2):\n    from collections import Counter\n    import  collections\n    d = Counter(nums2)\n    n = len(nums1)\n    h = n//2\n    for i,j in d.items():\n        if j>h:\n            return -1\n    d = collections.defaultdict(int)\n    ans = 0\n    cnt =0\n    for i in range(n):\n        if nums1[i]==nums2[i]:\n            ans+=i\n            cnt+=1\n            d[nums1[i]]+=1\n    val =0\n    mx =0\n    for i,j in d.items():\n        if j>mx:\n            mx =j\n            val = i\n    if mx+mx>cnt:\n        for i in range(n):\n            if nums1[i]!=nums2[i] and nums1[i]!=val and nums2[i]!=val and mx+mx>cnt:\n                ans+=i\n                cnt+=1\n    return ans", "entry_point": "minimumTotalCost", "test_list": ["assert minimumTotalCost([1,2,3,4,5],[1,2,3,4,5])==10", "assert minimumTotalCost([2,2,2,1,3],[1,2,2,3,3])==10", "assert minimumTotalCost([1,2,2],[1,2,2])==-1"]}
{"Contest id": "Bi93/2498", "text_name": "青蛙过河 II", "text": "给你一个下标从 0 开始的整数数组 stones ，数组中的元素 严格递增 ，表示一条河中石头的位置。\n一只青蛙一开始在第一块石头上，它想到达最后一块石头，然后回到第一块石头。同时每块石头 至多 到达 一次。\n一次跳跃的 长度 是青蛙跳跃前和跳跃后所在两块石头之间的距离。\n更正式的，如果青蛙从 stones[i] 跳到 stones[j] ，跳跃的长度为 |stones[i] - stones[j]| 。\n一条路径的 代价 是这条路径里的 最大跳跃长度 。\n请你返回这只青蛙的 最小代价 。", "canonical_solution": "def maxJump(A):\n        res = A[1] - A[0];\n        for i in range(2, len(A)):\n            res = max(res, A[i] - A[i - 2])\n        return res", "entry_point": "maxJump", "test_list": ["assert maxJump([0,2,5,6,7])==5", "assert maxJump([0,3,9])==9"]}
{"Contest id": "Bi93/2496", "text_name": "数组中字符串的最大值", "text": "一个由字母和数字组成的字符串的 值 定义如下：\n如果字符串 只 包含数字，那么值为该字符串在 10 进制下的所表示的数字。\n否则，值为字符串的 长度 。\n给你一个字符串数组 strs ，每个字符串都只由字母和数字组成，请你返回 strs 中字符串的 最大值 。", "canonical_solution": "def maximumValue(strs):\n        def sol(strs, index, max_):\n            if index >= len(strs): return max_\n            if strs[index].isdigit():\n                return sol(strs, index + 1, max(max_, int(strs[index])))\n            return sol(strs, index + 1, max(max_, len(strs[index])))\n        return sol(strs, 0, 0)", "entry_point": "maximumValue", "test_list": ["assert maximumValue([\"alic3\",\"bob\",\"3\",\"4\",\"00000\"])==5", "assert maximumValue([\"1\",\"01\",\"001\",\"0001\"])==1"]}
{"Contest id": "322/2493", "text_name": "将节点分成尽可能多的组", "text": "给你一个正整数 n ，表示一个 无向 图中的节点数目，节点编号从 1 到 n 。\n同时给你一个二维整数数组 edges ，其中 edges[i] = [ai, bi] 表示节点 ai 和 bi 之间有一条 双向 边。注意给定的图可能是不连通的。\n请你将图划分为 m 个组（编号从 1 开始），满足以下要求：\n图中每个节点都只属于一个组。\n图中每条边连接的两个点 [ai, bi] ，如果 ai 属于编号为 x 的组，bi 属于编号为 y 的组，那么 |y - x| = 1 。\n请你返回最多可以将节点分为多少个组（也就是最大的 m ）。如果没办法在给定条件下分组，请你返回 -1 。", "canonical_solution": "def magnificentSets(n,e):\n        ajc = defaultdict(list)\n        for i , j in e:\n            ajc[i].append(j)\n            ajc[j].append(i)\n        def st(i):\n            rt , cur , used , vi = 1 , [i] , {i} , [0] * (n+1)\n            vi[i] = 1\n            while cur:\n                nxt = set()\n                for v in cur:\n                    for u in ajc[v]:\n                        if vi[u] == rt:\n                            return -1 , -1\n                        elif vi[u] == 0:\n                            used.add(u)\n                            nxt.add(u)\n                            vi[u] = rt +1\n                cur = nxt\n                if not cur: break\n                rt += 1\n            return min(used) , rt\n        ans = {}\n        for j in range(1 , n+1):\n            rep , rt = st(j)\n            if rep == -1:\n                return -1\n            ans[rep] = max(ans.get(rep , 0) , rt) \n        return sum(ans.values())", "entry_point": "magnificentSets", "test_list": ["assert magnificentSets(6,[[1,2],[1,4],[1,5],[2,6],[2,3],[4,6]])==4", "assert magnificentSets(3,[[1,2],[2,3],[3,1]])==-1"]}
{"Contest id": "322/2492", "text_name": "两个城市间路径的最小分数", "text": "给你一个正整数 n ，表示总共有 n 个城市，城市从 1 到 n 编号。给你一个二维数组 roads ，其中 roads[i] = [ai, bi, distancei] 表示城市 ai 和 bi 之间有一条 双向 道路，道路距离为 distancei 。城市构成的图不一定是连通的。\n两个城市之间一条路径的 分数 定义为这条路径中道路的 最小 距离。\n城市 1 和城市 n 之间的所有路径的 最小 分数。\n注意：\n一条路径指的是两个城市之间的道路序列。\n一条路径可以 多次 包含同一条道路，你也可以沿着路径多次到达城市 1 和城市 n 。\n测试数据保证城市 1 和城市n 之间 至少 有一条路径。", "canonical_solution": "def minScore(n, roads):\n    import queue\n    from sys import maxsize\n    ans = maxsize\n    gr = [[] for _ in range(n+1)]\n    for edge in roads:\n        gr[edge[0]].append((edge[1], edge[2]))\n        gr[edge[1]].append((edge[0], edge[2]))\n    vis = [0] * (n+1)\n    q = queue.Queue()\n    q.put(1)\n    vis[1] = 1\n    while not q.empty():\n        node = q.get()\n        for v, dis in gr[node]:\n            ans = min(ans, dis)\n            if vis[v] == 0:\n                vis[v] = 1\n                q.put(v)\n    return ans", "entry_point": "minScore", "test_list": ["assert minScore(4,[[1,2,9],[2,3,6],[2,4,5],[1,4,7]])==5", "assert minScore(4,[[1,2,2],[1,3,4],[3,4,7]])==2"]}
{"Contest id": "322/2491", "text_name": "划分技能点相等的团队", "text": "给你一个正整数数组 skill ，数组长度为 偶数 n ，其中 skill[i] 表示第 i 个玩家的技能点。将所有玩家分成 n / 2 个 2 人团队，使每一个团队的技能点之和 相等 。\n团队的 化学反应 等于团队中玩家的技能点 乘积 。\n返回所有团队的 化学反应 之和，如果无法使每个团队的技能点之和相等，则返回 -1 。", "canonical_solution": "def dividePlayers(skill):\n        skill.sort()\n        ans, sum_ = 0, 0\n        ptr1, ptr2 = 0, len(skill) - 1\n        for i in range(len(skill) // 2):\n            if i == 0:\n                sum_ = skill[ptr1] + skill[ptr2]\n                ans += (skill[ptr1] * skill[ptr2])\n            else:\n                if (skill[ptr1] + skill[ptr2]) != sum_: return -1\n                ans += (skill[ptr1] * skill[ptr2])\n            ptr1 += 1\n            ptr2 -= 1\n        return ans", "entry_point": "dividePlayers", "test_list": ["assert dividePlayers([3,2,5,1,3,4])==22", "assert dividePlayers([3,4])==12", "assert dividePlayers([1,1,2,3])==-1"]}
{"Contest id": "322/2490", "text_name": "回环句", "text": "句子 是由单个空格分隔的一组单词，且不含前导或尾随空格。\n例如，\"Hello World\"、\"HELLO\"、\"hello world hello world\" 都是符合要求的句子。\n单词 仅 由大写和小写英文字母组成。且大写和小写字母会视作不同字符。\n如果句子满足下述全部条件，则认为它是一个 回环句 ：\n单词的最后一个字符和下一个单词的第一个字符相等。\n最后一个单词的最后一个字符和第一个单词的第一个字符相等。\n例如，\"leetcode exercises sound delightful\"、\"eetcode\"、\"leetcode eats soul\" 都是回环句。然而，\"Leetcode is cool\"、\"happy Leetcode\"、\"Leetcode\" 和 \"I like Leetcode\" 都 不 是回环句。\n给你一个字符串 sentence ，请你判断它是不是一个回环句。如果是，返回 true ；否则，返回 false 。", "canonical_solution": "def isCircularSentence(s):\n        arr, word = [], ''\n        for ch in s:\n            if ch == ' ':\n                arr.append(word)\n                word = ''\n            else: word += ch\n        arr.append(word)\n        if arr[0][0] != arr[-1][-1]:\n            return False\n        last = arr[0][-1]   \n        for i in range(1, len(arr)):\n            if arr[i][0] == last:\n                last = arr[i][-1]\n            else:\n                return False\n        return True", "entry_point": "isCircularSentence", "test_list": ["assert isCircularSentence(\"leetcode exercises sound delightful\")==True", "assert isCircularSentence(\"eetcode\")==True", "assert isCircularSentence(\"Leetcode is cool\")==False"]}
{"Contest id": "321/2488", "text_name": "统计中位数为K的子数组", "text": "给你一个长度为 n 的数组 nums ，该数组由从 1 到 n 的 不同 整数组成。另给你一个正整数 k 。\n统计并返回 nums 中的 中位数 等于 k 的非空子数组的数目。\n注意：\n数组的中位数是按 递增 顺序排列后位于 中间 的那个元素，如果数组长度为偶数，则中位数是位于中间靠 左 的那个元素。\n例如，[2,3,1,4] 的中位数是 2 ，[8,4,3,5,1] 的中位数是 4 。\n子数组是数组中的一个连续部分。", "canonical_solution": "def countSubarrays(nums, k):\n        d, iMed = defaultdict(int), nums.index(k)\n        ans, diff, d[0] = 0, 0, 1\n        for i, n in enumerate(nums):\n            diff+= (n>k) - (n<k)\n            if i < iMed: d[diff]+= 1\n            else: ans += (d[diff] + d[diff-1])\n        return ans", "entry_point": "countSubarrays", "test_list": ["assert countSubarrays([3,2,1,4,5],4)==3", "assert countSubarrays([2,3,1],3)==1"]}
{"Contest id": "321/2486", "text_name": "追加字符以获得子序列", "text": "给你两个仅由小写英文字母组成的字符串 s 和 t 。\n现在需要通过向 s 末尾追加字符的方式使 t 变成 s 的一个 子序列 ，返回需要追加的最少字符数。\n子序列是一个可以由其他字符串删除部分（或不删除）字符但不改变剩下字符顺序得到的字符串。", "canonical_solution": "def appendCharacters(s, t):\n        it = iter(s)\n        for i,c in enumerate(t):\n            if c not in it:\n                return len(t) - i\n        return 0", "entry_point": "appendCharacters", "test_list": ["assert appendCharacters(\"coaching\",\"coding\")==4", "assert appendCharacters(\"abcde\",\"a\")==0", "assert appendCharacters(\"z\",\"abcde\")==5"]}
{"Contest id": "321/2485", "text_name": "找出中枢整数", "text": "给你一个正整数 n ，找出满足下述条件的 中枢整数 x ：\n1 和 x 之间的所有元素之和等于 x 和 n 之间所有元素之和。\n返回中枢整数 x 。如果不存在中枢整数，则返回 -1 。题目保证对于给定的输入，至多存在一个中枢整数。", "canonical_solution": "def pivotInteger(n):\n    from math import sqrt\n    temp = (n * n + n) // 2\n    sq = int(sqrt(temp))\n    if sq * sq == temp:\n        return sq\n    return -1", "entry_point": "pivotInteger", "test_list": ["assert pivotInteger(8)==6", "assert pivotInteger(1)==1", "assert pivotInteger(4)==-1"]}
{"Contest id": "Bi92/2484", "text_name": "统计回文子序列数目", "text": "给你数字字符串 s ，请你返回 s 中长度为 5 的 回文子序列 数目。由于答案可能很大，请你将答案对 109 + 7 取余 后返回。\n提示：\n如果一个字符串从前往后和从后往前读相同，那么它是 回文字符串 。\n子序列是一个字符串中删除若干个字符后，不改变字符顺序，剩余字符构成的字符串。", "canonical_solution": "def countPalindromes(s):\n        res=0\n        for i in range(10):\n            for j in range(10):\n                pattern=str(i)+str(j)+\"|\"+str(j)+str(i)\n                dp=[0]*6\n                dp[-1]=1\n                for x in range(len(s)):\n                    for y in range(5):\n                        if s[x]==pattern[y] or y==2:\n                            dp[y]+=dp[y+1]\n                res=(res+dp[0])%(10**9+7)\n        return res ", "entry_point": "countPalindromes", "test_list": ["assert countPalindromes(\"103301\")==2", "assert countPalindromes(\"0000000\")==21", "assert countPalindromes(\"9999900000\")==2"]}
{"Contest id": "Bi92/2483", "text_name": "商店的最少代价", "text": "给你一个顾客访问商店的日志，用一个下标从 0 开始且只包含字符 'N' 和 'Y' 的字符串 customers 表示：\n如果第 i 个字符是 'Y' ，它表示第 i 小时有顾客到达。\n如果第 i 个字符是 'N' ，它表示第 i 小时没有顾客到达。\n如果商店在第 j 小时关门（0 <= j <= n），代价按如下方式计算：\n在开门期间，如果某一个小时没有顾客到达，代价增加 1 。\n在关门期间，如果某一个小时有顾客到达，代价增加 1 。\n请你返回在确保代价 最小 的前提下，商店的 最早 关门时间。\n注意，商店在第 j 小时关门表示在第 j 小时以及之后商店处于关门状态。", "canonical_solution": "def bestClosingTime(customers):\n        max_score = 0\n        score = 0\n        right_time = -1\n        for i in range(len(customers)):\n            score += 1 if customers[i] == 'Y' else -1\n            if score > max_score:\n                max_score = score\n                right_time = i\n        return right_time + 1", "entry_point": "bestClosingTime", "test_list": ["assert bestClosingTime(\"YYNY\")==2", "assert bestClosingTime(\"NNNNN\")==0", "assert bestClosingTime(\"YYYY\")==4"]}
{"Contest id": "Bi92/2482", "text_name": "行和列中一和零的差值", "text": "给你一个下标从 0 开始的 m x n 二进制矩阵 grid 。\n我们按照如下过程，定义一个下标从 0 开始的 m x n 差值矩阵 diff ：\n令第 i 行一的数目为 onesRowi 。\n令第 j 列一的数目为 onesColj 。\n令第 i 行零的数目为 zerosRowi 。\n令第 j 列零的数目为 zerosColj 。\ndiff[i][j] = onesRowi + onesColj - zerosRowi - zerosColj\n请你返回差值矩阵 diff 。", "canonical_solution": "def onesMinusZeros(grid):\n        m, n = len(grid), len(grid[0])\n        row_ones = [0] * m\n        col_ones = [0] * n\n        for i in range(m):\n            for j in range(n):\n                row_ones[i] += grid[i][j]\n                col_ones[j] += grid[i][j]\n        for i in range(m):\n            for j in range(n):\n                grid[i][j] = 2 * (row_ones[i] + col_ones[j]) - m - n\n        return grid", "entry_point": "onesMinusZeros", "test_list": ["assert onesMinusZeros([[0,1,1],[1,0,1],[0,0,1]])==[[0,0,4],[0,0,4],[-2,-2,2]]", "assert onesMinusZeros([[1,1,1],[1,1,1]])==[[5,5,5],[5,5,5]]"]}
{"Contest id": "320/2478", "text_name": "完美分割的方案数", "text": "给你一个字符串 s ，每个字符是数字 '1' 到 '9' ，再给你两个整数 k 和 minLength 。\n如果对 s 的分割满足以下条件，那么我们认为它是一个 完美 分割：\ns 被分成 k 段互不相交的子字符串。\n每个子字符串长度都 至少 为 minLength 。\n每个子字符串的第一个字符都是一个 质数 数字，最后一个字符都是一个 非质数 数字。质数数字为 '2' ，'3' ，'5' 和 '7' ，剩下的都是非质数数字。\n请你返回 s 的 完美 分割数目。由于答案可能很大，请返回答案对 109 + 7 取余 后的结果。\n一个 子字符串 是字符串中一段连续字符串序列。", "canonical_solution": "def beautifulPartitions(s, k, minLength):\n        M = 10 ** 9 + 7\n        n = len(s)\n        primes = \"2357\"\n        isPrime = False\n        isComp = False\n        for c in s:\n            if c in primes:\n                isPrime = True\n            else:\n                isComp = True\n        if not isPrime or not isComp:\n            return 0\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        dp[n][0] = 1\n        primesum = [[0] for _ in range(k + 1)]\n        primesum[0][0] = 1\n        for i in range(n - 1, -1, -1):\n            if s[i] in primes:\n                for l in range(1, k + 1):\n                    if minLength <= len(primesum[l - 1]):\n                        dp[i][l] += primesum[l - 1][-minLength]\n            for l in range(k + 1):\n                val = 0\n                if s[i] in primes and (i == 0 or s[i - 1] not in primes):\n                    val = dp[i][l]\n                primesum[l].append(primesum[l][-1] + val)\n        return dp[0][k] % M", "entry_point": "beautifulPartitions", "test_list": ["assert beautifulPartitions(\"23542185131\",3,2)==3", "assert beautifulPartitions(\"23542185131\",3,3)==1", "assert beautifulPartitions(\"3312958\",3,1)==1"]}
{"Contest id": "320/2477", "text_name": "到达首都的最少油耗", "text": "给你一棵 n 个节点的树（一个无向、连通、无环图），每个节点表示一个城市，编号从 0 到 n - 1 ，且恰好有 n - 1 条路。0 是首都。给你一个二维整数数组 roads ，其中 roads[i] = [ai, bi] ，表示城市 ai 和 bi 之间有一条 双向路 。\n每个城市里有一个代表，他们都要去首都参加一个会议。\n每座城市里有一辆车。给你一个整数 seats 表示每辆车里面座位的数目。\n城市里的代表可以选择乘坐所在城市的车，或者乘坐其他城市的车。相邻城市之间一辆车的油耗是一升汽油。\n请你返回到达首都最少需要多少升汽油。", "canonical_solution": "def minimumFuelCost(roads, seats):\n    import math\n    ans = 0\n    graph = [[] for _ in range(len(roads) + 1)]\n    for u, v in roads:\n        graph[u].append(v)\n        graph[v].append(u)\n    def dfs(u,prev):\n        nonlocal ans\n        people = 1\n        for v in graph[u]:\n            if v == prev:\n                continue\n            people += dfs(v, u)\n        if u > 0:\n            ans += int(math.ceil(people / seats))\n        return people\n    dfs(0, -1)\n    return ans", "entry_point": "minimumFuelCost", "test_list": ["assert minimumFuelCost([[0,1],[0,2],[0,3]],5)==3", "assert minimumFuelCost([[3,1],[3,2],[1,0],[0,4],[0,5],[4,6]],2)==7", "assert minimumFuelCost([],1)==0"]}
{"Contest id": "320/2475", "text_name": "数组中不等三元组的数目", "text": "给你一个下标从 0 开始的正整数数组 nums 。请你找出并统计满足下述条件的三元组 (i, j, k) 的数目：\n0 <= i < j < k < nums.length\nnums[i]、nums[j] 和 nums[k] 两两不同 。\n换句话说：nums[i] != nums[j]、nums[i] != nums[k] 且 nums[j] != nums[k] 。\n返回满足上述条件三元组的数目。", "canonical_solution": "def unequalTriplets(A):\n    from collections import Counter\n    trips = pairs = 0\n    count = Counter()\n    for i,a in enumerate(A):\n        trips += pairs - count[a] * (i - count[a])\n        pairs += i - count[a]\n        count[a] += 1\n    return trips\nunequalTriplets([4,4,2,4,3])", "entry_point": "unequalTriplets", "test_list": ["assert unequalTriplets([4,4,2,4,3])==3", "assert unequalTriplets([1,1,1,1,1])==0"]}
{"Contest id": "319/2472", "text_name": "不重叠回文子字符串的最大数目", "text": "给你一个字符串 s 和一个 正 整数 k 。\n从字符串 s 中选出一组满足下述条件且 不重叠 的子字符串：\n每个子字符串的长度 至少 为 k 。\n每个子字符串是一个 回文串 。\n返回最优方案中能选择的子字符串的 最大 数目。\n子字符串 是字符串中一个连续的字符序列。", "canonical_solution": "def maxPalindromes(s, k):\n        n = len(s)\n        def valid(i, j):\n            if j > len(s):\n                return False\n            if s[i : j] == s[i : j][::-1]:\n                return True\n            return False\n        maxSubstrings = 0\n        start = 0\n        while start < n:\n            if valid(start, start + k):\n                maxSubstrings += 1\n                start += k\n            elif valid(start, start + k + 1):\n                maxSubstrings += 1\n                start += k + 1\n            else:\n                start += 1\n        return maxSubstrings", "entry_point": "maxPalindromes", "test_list": ["assert maxPalindromes(\"abaccdbbd\",3)==2", "assert maxPalindromes(\"adbcda\",2)==0"]}
{"Contest id": "319/2470", "text_name": "最小公倍数为K的子数组数目", "text": "给你一个整数数组 nums 和一个整数 k ，请你统计并返回 nums 的 子数组 中满足 元素最小公倍数为 k 的子数组数目。\n子数组 是数组中一个连续非空的元素序列。\n数组的最小公倍数 是可被所有数组元素整除的最小正整数。", "canonical_solution": "def subarrayLCM(nums, k):\n        def gcd(a,b):\n            return math.gcd(a,b)\n        def lcm(n1,n2):\n            return (n1*n2)//gcd(n1,n2)\n        n=len(nums)\n        ans=0\n        for i in range(n):\n            lcmi=nums[i]\n            for j in range(i,n):\n                lcmi=lcm(lcmi,nums[j])\n                if(lcmi==k):\n                    ans+=1\n        return ans", "entry_point": "subarrayLCM", "test_list": ["assert subarrayLCM([3,6,2,7,1],6)==4", "assert subarrayLCM([3],2)==0"]}
{"Contest id": "319/2469", "text_name": "温度转换", "text": "给你一个四舍五入到两位小数的非负浮点数 celsius 来表示温度，以 摄氏度（Celsius）为单位。\n你需要将摄氏度转换为 开氏度（Kelvin）和 华氏度（Fahrenheit），并以数组 ans = [kelvin, fahrenheit] 的形式返回结果。\n返回数组 ans 。与实际答案误差不超过 10-5 的会视为正确答案。", "canonical_solution": "def convertTemperature(celsius):\n        return [(celsius + 273.15),(celsius * 1.80 + 32.00)]", "entry_point": "convertTemperature", "test_list": ["assert convertTemperature(36.50)==[309.65000,97.70000]", "assert convertTemperature(122.11)==[395.26000,251.79800]"]}
{"Contest id": "Bi91/2468", "text_name": "根据限制分割消息", "text": "给你一个字符串 message 和一个正整数 limit 。\n你需要根据 limit 将 message 分割 成一个或多个 部分 。每个部分的结尾都是 \"<a/b>\" ，其中 \"b\" 用分割出来的总数 替换， \"a\" 用当前部分所在的编号 替换 ，编号从 1 到 b 依次编号。除此以外，除了最后一部分长度 小于等于 limit 以外，其他每一部分（包括结尾部分）的长度都应该 等于 limit 。\n你需要确保分割后的结果数组，删掉每部分的结尾并 按顺序 连起来后，能够得到 message 。同时，结果数组越短越好。\n请你返回 message  分割后得到的结果数组。如果无法按要求分割 message ，返回一个空数组。", "canonical_solution": "def splitMessage(s, limit):\n        cur = k = i = 0\n        while 3 + len(str(k)) * 2 < limit and cur + len(s) + (3 + len(str(k))) * k > limit * k:\n            k += 1\n            cur += len(str(k))\n        res = []\n        if 3 + len(str(k)) * 2 < limit:\n            for j in range(1, k + 1):\n                l = limit - (len(str(j)) + 3 + len(str(k)))\n                res.append('%s<%s/%s>' % (s[i:i + l], j, k))\n                i += l\n        return res", "entry_point": "splitMessage", "test_list": ["assert splitMessage(\"this is really a very awesome message\",9) == [\"thi<1/14>\",\"s i<2/14>\",\"s r<3/14>\",\"eal<4/14>\",\"ly <5/14>\",\"a v<6/14>\",\"ery<7/14>\",\" aw<8/14>\",\"eso<9/14>\",\"me<10/14>\",\" m<11/14>\",\"es<12/14>\",\"sa<13/14>\",\"ge<14/14>\"]", "assert splitMessage(\"short message\", 15) == [\"short mess<1/2>\",\"age<2/2>\"]"]}
{"Contest id": "Bi91/2466", "text_name": "统计构造好字符串的方案数", "text": "给你整数 zero ，one ，low 和 high ，我们从空字符串开始构造一个字符串，每一步执行下面操作中的一种：\n将 '0' 在字符串末尾添加 zero  次。\n将 '1' 在字符串末尾添加 one 次。\n以上操作可以执行任意次。\n如果通过以上过程得到一个 长度 在 low 和 high 之间（包含上下边界）的字符串，那么这个字符串我们称为 好 字符串。\n请你返回满足以上要求的 不同 好字符串数目。由于答案可能很大，请将结果对 109 + 7 取余 后返回。", "canonical_solution": "def countGoodStrings(low, high, zero, one):\n        dp = [0] * (high+1)\n        ans, mod = 0, 10**9+7\n        dp[0] = 1\n        for i in range(1, high+1):\n            dp[i] = ((dp[i-zero] if i-zero>=0 else 0) + (dp[i-one] if i-one>=0 else 0)) % mod\n            if i >= low:\n                ans = (ans + dp[i]) % mod\n        return ans", "entry_point": "countGoodStrings", "test_list": ["assert countGoodStrings(low = 3, high = 3, zero = 1, one = 1) == 8", "assert countGoodStrings(low = 2, high = 3, zero = 1, one = 2) == 5"]}
{"Contest id": "Bi91/2465", "text_name": "不同的平均值数目", "text": "给你一个下标从 0 开始长度为 偶数 的整数数组 nums 。\n只要 nums 不是 空数组，你就重复执行以下步骤：\n找到 nums 中的最小值，并删除它。\n找到 nums 中的最大值，并删除它。\n计算删除两数的平均值。\n两数 a 和 b 的 平均值 为 (a + b) / 2 。\n比方说，2 和 3 的平均值是 (2 + 3) / 2 = 2.5 。\n返回上述过程能得到的 不同 平均值的数目。\n注意 ，如果最小值或者最大值有重复元素，可以删除任意一个。\n", "canonical_solution": "def distinctAverages(nums):\n        n = len(nums)\n        nums.sort()\n        r = n-1\n        res = set()\n        for l in range(n//2) :\n            avg = (nums[l]+nums[r])/2\n            res.add(avg)\n            r -= 1\n        return len(res)", "entry_point": "distinctAverages", "test_list": ["assert distinctAverages([4,1,4,0,3,5]) == 2", "assert distinctAverages([1,100]) == 1"]}
{"Contest id": "318/2463", "text_name": "最小移动总距离", "text": "X 轴上有一些机器人和工厂。给你一个整数数组 robot ，其中 robot[i] 是第 i 个机器人的位置。再给你一个二维整数数组 factory ，其中 factory[j] = [positionj, limitj] ，表示第 j 个工厂的位置在 positionj ，且第 j 个工厂最多可以修理 limitj 个机器人。\n每个机器人所在的位置 互不相同 。每个工厂所在的位置也 互不相同 。注意一个机器人可能一开始跟一个工厂在 相同的位置 。\n所有机器人一开始都是坏的，他们会沿着设定的方向一直移动。设定的方向要么是 X 轴的正方向，要么是 X 轴的负方向。当一个机器人经过一个没达到上限的工厂时，这个工厂会维修这个机器人，且机器人停止移动。\n任何时刻，你都可以设置 部分 机器人的移动方向。你的目标是最小化所有机器人总的移动距离。\n请你返回所有机器人移动的最小总距离。测试数据保证所有机器人都可以被维修。\n注意：\n所有机器人移动速度相同。\n如果两个机器人移动方向相同，它们永远不会碰撞。\n如果两个机器人迎面相遇，它们也不会碰撞，它们彼此之间会擦肩而过。\n如果一个机器人经过了一个已经达到上限的工厂，机器人会当作工厂不存在，继续移动。\n机器人从位置 x 到位置 y 的移动距离为 |y - x| 。", "canonical_solution": "def minimumTotalDistance(R, F):\n        R.sort()\n        F.sort()\n        dp = [0] + [float('inf')] * len(R)\n        for j, (f, l) in enumerate(F):\n            for _ in range(l):\n                for i in range(len(R), 0, -1):\n                    dp[i] = min(dp[i], dp[i-1] + abs(R[i-1]-f))\n        return dp[-1]", "entry_point": "minimumTotalDistance", "test_list": ["assert minimumTotalDistance([0,4,6],[[2,2],[6,2]]) == 4", "assert minimumTotalDistance([1,-1],[[-2,1],[2,1]]) == 2"]}
{"Contest id": "318/2462", "text_name": "雇佣 K 位工人的总代价", "text": "给你一个下标从 0 开始的整数数组 costs ，其中 costs[i] 是雇佣第 i 位工人的代价。\n同时给你两个整数 k 和 candidates 。我们想根据以下规则恰好雇佣 k 位工人：\n总共进行 k 轮雇佣，且每一轮恰好雇佣一位工人。\n在每一轮雇佣中，从最前面 candidates 和最后面 candidates 人中选出代价最小的一位工人，如果有多位代价相同且最小的工人，选择下标更小的一位工人。\n比方说，costs = [3,2,7,7,1,2] 且 candidates = 2 ，第一轮雇佣中，我们选择第 4 位工人，因为他的代价最小 [3,2,7,7,1,2] 。\n第二轮雇佣，我们选择第 1 位工人，因为他们的代价与第 4 位工人一样都是最小代价，而且下标更小，[3,2,7,7,2] 。注意每一轮雇佣后，剩余工人的下标可能会发生变化。\n如果剩余员工数目不足 candidates 人，那么下一轮雇佣他们中代价最小的一人，如果有多位代价相同且最小的工人，选择下标更小的一位工人。\n一位工人只能被选择一次。\n返回雇佣恰好 k 位工人的总代价。\n", "canonical_solution": "def totalCost(costs, k, candidates):\n        import heapq\n        q=costs[:candidates]\n        r=costs[max(candidates,len(costs)-candidates):]\n        heapq.heapify(q)\n        heapq.heapify(r)\n        res=0\n        i=candidates\n        j=len(costs)-candidates-1\n        for _  in range(k):\n            if not r or q and q[0]<=r[0]:\n                res+=heapq.heappop(q)\n                if i<=j:\n                    heapq.heappush(q,costs[i])\n                    i+=1\n            else:\n                res+=heapq.heappop(r)\n                if i<=j:\n                    heapq.heappush(r,costs[j])\n                    j-=1       \n        return res", "entry_point": "totalCost", "test_list": ["assert totalCost(costs = [17,12,10,2,7,2,11,20,8], k = 3, candidates = 4) == 11", "assert totalCost(costs = [1,2,4,1], k = 3, candidates = 3) == 4"]}
{"Contest id": "318/2461", "text_name": "长度为 K 子数组中的最大和", "text": "给你一个整数数组 nums 和一个整数 k 。请你从 nums 中满足下述条件的全部子数组中找出最大子数组和：\n子数组的长度是 k，且\n子数组中的所有元素 各不相同 。\n返回满足题面要求的最大子数组和。如果不存在子数组满足这些条件，返回 0 。\n子数组 是数组中一段连续非空的元素序列。\n", "canonical_solution": "def maximumSubarraySum(nums, k):\n        prefixS = [ nums[0] ]\n        for i in range( 1, len(nums) ):\n            prefixS.append( prefixS[-1] + nums[i] )       \n        best = 0            \n        start = 0           \n        summation = 0      \n        lastIndexOf = defaultdict( lambda : -1)\n        for end, number in enumerate(nums):                       \n            if lastIndexOf[number] >= start:\n                summation = prefixS[end] - prefixS[ lastIndexOf[number] ]\n                start = lastIndexOf[number] + 1                \n            elif start + k == end:\n                summation = prefixS[end] - prefixS[start]\n                start += 1                \n            else:\n                summation += nums[end]           \n            if (end - start + 1) == k:\n                best = max(best, summation)\n            lastIndexOf[ number ] = end           \n        return best", "entry_point": "maximumSubarraySum", "test_list": ["assert maximumSubarraySum(nums = [1,5,4,2,9,9,9], k = 3) == 15", "assert maximumSubarraySum(nums = [4,4,4], k = 3) == 0"]}
{"Contest id": "318/2460", "text_name": "对数组执行操作", "text": "给你一个下标从 0 开始的数组 nums ，数组大小为 n ，且由 非负 整数组成。\n你需要对数组执行 n - 1 步操作，其中第 i 步操作（从 0 开始计数）要求对 nums 中第 i 个元素执行下述指令：\n如果 nums[i] == nums[i + 1] ，则 nums[i] 的值变成原来的 2 倍，nums[i + 1] 的值变成 0 。否则，跳过这步操作。\n在执行完 全部 操作后，将所有 0 移动 到数组的 末尾 。\n例如，数组 [1,0,2,0,0,1] 将所有 0 移动到末尾后变为 [1,2,1,0,0,0] 。\n返回结果数组。\n注意 操作应当 依次有序 执行，而不是一次性全部执行。", "canonical_solution": "def applyOperations(nums):\n        for i in range(len(nums)-1):\n            if nums[i]==nums[i+1]:\n                nums[i]*=2\n                nums[i+1]=0                \n        temp = []\n        zeros = []\n        a=nums\n        for i in range(len(a)):\n            if a[i] !=0:\n                temp.append(a[i])\n            else:\n                zeros.append(a[i])\n        return (temp+zeros)", "entry_point": "applyOperations", "test_list": ["assert applyOperations([1,2,2,1,1,0]) == [1,4,2,0,0,0]", "assert applyOperations([0,1]) == [1,0]"]}
{"Contest id": "317/2457", "text_name": "美丽整数的最小增量", "text": "给你两个正整数 n 和 target 。\n如果某个整数每一位上的数字相加小于或等于 target ，则认为这个整数是一个 美丽整数 。\n找出并返回满足 n + x 是 美丽整数 的最小非负整数 x 。生成的输入保证总可以使 n 变成一个美丽整数。", "canonical_solution": "def makeIntegerBeautiful(n, target):\n        n0 = n\n        i = 0\n        while sum(map(int, str(n))) > target:\n            n = n // 10 + 1\n            i += 1\n        return n * (10 ** i) - n0", "entry_point": "makeIntegerBeautiful", "test_list": ["assert makeIntegerBeautiful(16,6)==4", "assert makeIntegerBeautiful(467,6)==33", "assert makeIntegerBeautiful(1,1)==0"]}
{"Contest id": "317/2456", "text_name": "最流行的视频创作者", "text": "给你两个字符串数组 creators 和 ids ，和一个整数数组 views ，所有数组的长度都是 n 。平台上第 i 个视频者是 creator[i] ，视频分配的 id 是 ids[i] ，且播放量为 views[i] 。\n视频创作者的 流行度 是该创作者的 所有 视频的播放量的 总和 。请找出流行度 最高 创作者以及该创作者播放量 最大 的视频的 id 。\n如果存在多个创作者流行度都最高，则需要找出所有符合条件的创作者。\n如果某个创作者存在多个播放量最高的视频，则只需要找出字典序最小的 id 。\n返回一个二维字符串数组 answer ，其中 answer[i] = [creatori, idi] 表示 creatori 的流行度 最高 且其最流行的视频 id 是 idi ，可以按任何顺序返回该结果。", "canonical_solution": "def mostPopularCreator(creators, ids, views):\n        memo = {}\n        overall_max_popular_video_count = -1\n        for i in range(len(creators)):\n            if creators[i] in memo:\n                memo[creators[i]][0] += views[i]\n                if memo[creators[i]][2] < views[i]:\n                    memo[creators[i]][1] = ids[i]\n                    memo[creators[i]][2] = views[i]\n                elif memo[creators[i]][2] == views[i]:\n                    memo[creators[i]][1] = min(memo[creators[i]][1],ids[i])\n            else:\n                memo[creators[i]] = [views[i],ids[i],views[i]]\n            overall_max_popular_video_count = max(memo[creators[i]][0],overall_max_popular_video_count)     \n        result = []\n        for i in memo:\n            if memo[i][0] == overall_max_popular_video_count:\n                result.append([i,memo[i][1]])\n        return result", "entry_point": "mostPopularCreator", "test_list": ["assert mostPopularCreator([\"alice\",\"bob\",\"alice\",\"chris\"],[\"one\",\"two\",\"three\",\"four\"],[5,10,5,4])==[[\"alice\",\"one\"],[\"bob\",\"two\"]]", "assert mostPopularCreator([\"alice\",\"alice\",\"alice\"],  [\"a\",\"b\",\"c\"], [1,2,2])==[[\"alice\",\"b\"]]"]}
{"Contest id": "317/2455", "text_name": "可被三整除的偶数的平均值", "text": "给你一个由正整数组成的整数数组 nums ，返回其中可被 3 整除的所有偶数的平均值。\n注意：n 个元素的平均值等于 n 个元素 求和 再除以 n ，结果 向下取整 到最接近的整数。", "canonical_solution": "def averageValue(nums):\n    nums = [n for n in nums if not n%6]\n    return sum(nums)//len(nums) if nums else 0", "entry_point": "averageValue", "test_list": ["assert averageValue([1,3,6,10,12,15])==9", "assert averageValue([1,2,4,7,10])==0"]}
{"Contest id": "Bi90/2454", "text_name": "下一个更大元素 IV", "text": "给你一个下标从 0 开始的非负整数数组 nums 。对于 nums 中每一个整数，你必须找到对应元素的 第二大 整数。\n如果 nums[j] 满足以下条件，那么我们称它为 nums[i] 的 第二大 整数：\nj > i\nnums[j] > nums[i]\n恰好存在 一个 k 满足 i < k < j 且 nums[k] > nums[i] 。\n如果不存在 nums[j] ，那么第二大整数为 -1 。\n比方说，数组 [1, 2, 4, 3] 中，1 的第二大整数是 4 ，2 的第二大整数是 3 ，3 和 4 的第二大整数是 -1 。\n请你返回一个整数数组 answer ，其中 answer[i]是 nums[i] 的第二大整数。", "canonical_solution": "def secondGreaterElement(nums):\n    res, s1, s2 = [-1] * len(nums), [], []\n    for i,a in enumerate(nums):\n        while s2 and nums[s2[-1]] < a:\n            res[s2.pop()] = a\n        tmp = []\n        while s1 and nums[s1[-1]] < a:\n            tmp.append(s1.pop())\n        s2 += tmp[::-1]\n        s1.append(i)\n    return res", "entry_point": "secondGreaterElement", "test_list": ["assert secondGreaterElement([2,4,0,9,6])==[9,6,6,-1,-1]", "assert secondGreaterElement([3,3])==[-1,-1]"]}
{"Contest id": "Bi90/2453", "text_name": "摧毁一系列目标", "text": "给你一个下标从 0 开始的数组 nums ，它包含若干正整数，表示数轴上你需要摧毁的目标所在的位置。同时给你一个整数 space 。\n你有一台机器可以摧毁目标。给机器 输入 nums[i] ，这台机器会摧毁所有位置在 nums[i] + c * space 的目标，其中 c 是任意非负整数。你想摧毁 nums 中 尽可能多 的目标。\n请你返回在摧毁数目最多的前提下，nums[i] 的 最小值 。", "canonical_solution": "def destroyTargets(nums, space):\n    from collections import Counter\n    count = Counter(a % space for a in nums)\n    maxc = max(count.values())\n    return min(a for a in nums if count[a % space] == maxc)", "entry_point": "destroyTargets", "test_list": ["assert destroyTargets([3,7,8,1,1,5],2)==1", "assert destroyTargets([1,3,5,2,4,6],2)==1", "assert destroyTargets([6,2,5],100)==2"]}
{"Contest id": "Bi90/2452", "text_name": "距离字典两次编辑以内的单词", "text": "给你两个字符串数组 queries 和 dictionary 。数组中所有单词都只包含小写英文字母，且长度都相同。\n一次 编辑 中，你可以从 queries 中选择一个单词，将任意一个字母修改成任何其他字母。从 queries 中找到所有满足以下条件的字符串：不超过 两次编辑内，字符串与 dictionary 中某个字符串相同。\n请你返回 queries 中的单词列表，这些单词距离 dictionary 中的单词 编辑次数 不超过 两次 。单词返回的顺序需要与 queries 中原本顺序相同。", "canonical_solution": "def twoEditWords(queries, dictionary):\n    from collections import Counter\n    lst=[]\n    val=Counter(queries)\n    for i in queries:\n        for j in dictionary:\n            cnt=len(i)\n            idx1=0\n            while idx1<len(i):\n                if i[idx1]==j[idx1]:\n                    cnt-=1\n                idx1+=1\n            if cnt<=2 and val[i]!=0:\n                val[i]-=1\n                lst.append(i)\n                break\n    return lst", "entry_point": "twoEditWords", "test_list": ["assert twoEditWords([\"word\",\"note\",\"ants\",\"wood\"],[\"wood\",\"joke\",\"moat\"])==[\"word\",\"note\",\"wood\"]", "assert twoEditWords([\"yes\"],[\"not\"])==[]"]}
{"Contest id": "Bi90/2451", "text_name": "差值数组不同的字符串", "text": "给你一个字符串数组 words ，每一个字符串长度都相同，令所有字符串的长度都为 n 。\n每个字符串 words[i] 可以被转化为一个长度为 n - 1 的 差值整数数组 difference[i] ，其中对于 0 <= j <= n - 2 有 difference[i][j] = words[i][j+1] - words[i][j] 。注意两个字母的差值定义为它们在字母表中 位置 之差，也就是说 'a' 的位置是 0 ，'b' 的位置是 1 ，'z' 的位置是 25 。\n比方说，字符串 \"acb\" 的差值整数数组是 [2 - 0, 1 - 2] = [2, -1] 。\nwords 中所有字符串 除了一个字符串以外 ，其他字符串的差值整数数组都相同。你需要找到那个不同的字符串。\n请你返回 words中 差值整数数组 不同的字符串。", "canonical_solution": "def oddString(words):\n    from collections import defaultdict\n    hashmap = defaultdict(list)\n    for w in words:\n        difference = []\n        for i in range(1,len(w)):\n            difference.append(ord(w[i])-ord(w[i-1]))\n        hashmap[tuple(difference)].append(w)\n    for k,a in hashmap.items():\n        if len(a) == 1:\n            return a[0]", "entry_point": "oddString", "test_list": ["assert oddString([\"adc\",\"wzy\",\"abc\"])==\"abc\"", "assert oddString([\"aaa\",\"bob\",\"ccc\",\"ddd\"])==\"bob\""]}
{"Contest id": "316/2449", "text_name": "使数组相似的最少操作次数", "text": "给你两个正整数数组 nums 和 target ，两个数组长度相等。\n在一次操作中，你可以选择两个 不同 的下标 i 和 j ，其中 0 <= i, j < nums.length ，并且：\n令 nums[i] = nums[i] + 2 且\n令 nums[j] = nums[j] - 2 。\n如果两个数组中每个元素出现的频率相等，我们称两个数组是 相似 的。\n请你返回将 nums 变得与 target 相似的最少操作次数。测试数据保证 nums 一定能变得与 target 相似。", "canonical_solution": "def makeSimilar(nums, target):\n    nums.sort(key = lambda a: (a & 1, a))\n    target.sort(key = lambda a: (a & 1, a))\n    return sum(abs(a - b) for a,b in zip(nums, target)) // 4", "entry_point": "makeSimilar", "test_list": ["assert makeSimilar([8,12,6],[2,14,10])==2", "assert makeSimilar([1,2,5],[4,1,3])==1", "assert makeSimilar([1,1,1,1,1],[1,1,1,1,1])==0"]}
{"Contest id": "316/2448", "text_name": "使数组相等的最小开销", "text": "给你两个下标从 0 开始的数组 nums 和 cost ，分别包含 n 个 正 整数。\n你可以执行下面操作 任意 次：\n将 nums 中 任意 元素增加或者减小 1 。\n对第 i 个元素执行一次操作的开销是 cost[i] 。\n请你返回使 nums 中所有元素 相等 的 最少 总开销。", "canonical_solution": "def minCost(nums, cost):\n    def f(x):\n        return sum(abs(a - x) * c for a,c in zip(nums, cost))\n    l, r = min(nums), max(nums)\n    res = f(l)\n    while l < r:\n        x = (l + r) // 2\n        y1, y2 = f(x), f(x + 1)\n        res = min(y1, y2)\n        if y1 < y2:\n            r = x\n        else:\n            l = x + 1\n    return res", "entry_point": "minCost", "test_list": ["assert minCost([1,3,5,2],[2,3,1,14])==8", "assert minCost([2,2,2,2,2],[4,2,8,1,3])==0"]}
{"Contest id": "316/2447", "text_name": "最大公因数等于 K 的子数组数目", "text": "给你一个整数数组 nums 和一个整数 k ，请你统计并返回 nums 的子数组中元素的最大公因数等于 k 的子数组数目。\n子数组 是数组中一个连续的非空序列。\n数组的最大公因数 是能整除数组中所有元素的最大整数。", "canonical_solution": "def subarrayGCD(nums, k):\n    def gcd(a, b):\n        while a and b:\n            a, b = b, a % b\n        return a or b\n    cnt = 0\n    n = len(nums)\n    for i in range(n):\n        tmp_gcd = 0 \n        for j in range(i,n):\n            tmp_gcd = gcd(tmp_gcd, nums[j])\n            if tmp_gcd == k:\n                cnt += 1\n            elif tmp_gcd < k:\n                break\n    return cnt", "entry_point": "subarrayGCD", "test_list": ["assert subarrayGCD([9,3,1,2,6,3],3)==4", "assert subarrayGCD([4],7)==0"]}
{"Contest id": "316/2446", "text_name": "判断两个事件是否存在冲突", "text": "给你两个字符串数组 event1 和 event2 ，表示发生在同一天的两个闭区间时间段事件，其中：\nevent1 = [startTime1, endTime1] 且\nevent2 = [startTime2, endTime2]\n事件的时间为有效的 24 小时制且按 HH:MM 格式给出。\n当两个事件存在某个非空的交集时（即，某些时刻是两个事件都包含的），则认为出现 冲突 。\n如果两个事件之间存在冲突，返回 true ；否则，返回 false 。", "canonical_solution": "def haveConflict(event1, event2):\n    return event1[0] <= event2[1] and event2[0] <= event1[1]", "entry_point": "haveConflict", "test_list": ["assert haveConflict([\"01:15\",\"02:00\"],[\"02:00\",\"03:00\"])==True", "assert haveConflict([\"01:00\",\"02:00\"],[\"01:20\",\"03:00\"])==True", "assert haveConflict([\"10:00\",\"11:00\"], [\"14:00\",\"15:00\"])==False"]}
{"Contest id": "315/2444", "text_name": "统计定界子数组的数目", "text": "给你一个整数数组 nums 和两个整数 minK 以及 maxK 。\nnums 的定界子数组是满足下述条件的一个子数组：\n子数组中的 最小值 等于 minK 。\n子数组中的 最大值 等于 maxK 。\n返回定界子数组的数目。\n子数组是数组中的一个连续部分。", "canonical_solution": "def countSubarrays(nums, minK, maxK):\n    res = 0\n    jmin = jmax = jbad = -1\n    for i,a in enumerate(nums):\n        if not minK <= a <= maxK: jbad = i\n        if a == minK: jmin = i\n        if a == maxK: jmax = i\n        res += max(0, min(jmin, jmax) - jbad)\n    return res", "entry_point": "countSubarrays", "test_list": ["assert countSubarrays([1,3,5,2,7,5],1,5)==2", "assert countSubarrays([1,1,1,1],1,1)==10"]}
{"Contest id": "315/2443", "text_name": "反转之后的数字和", "text": "给你一个 非负 整数 num 。如果存在某个 非负 整数 k 满足 k + reverse(k) = num  ，则返回 true ；否则，返回 false 。\nreverse(k) 表示 k 反转每个数位后得到的数字。", "canonical_solution": "def sumOfNumberAndReverse(num):\n    return any(n + int(str(n)[::-1]) == num for n in range(num//2,num+1))", "entry_point": "sumOfNumberAndReverse", "test_list": ["assert sumOfNumberAndReverse(443)==True", "assert sumOfNumberAndReverse(63)==False", "assert sumOfNumberAndReverse(181)==True"]}
{"Contest id": "315/2442", "text_name": "反转之后不同整数的数目", "text": "给你一个由 正 整数组成的数组 nums 。\n你必须取出数组中的每个整数，反转其中每个数位，并将反转后得到的数字添加到数组的末尾。这一操作只针对 nums 中原有的整数执行。\n返回结果数组中 不同 整数的数目。", "canonical_solution": "def countDistinctIntegers(nums):\n    new_array = []\n    for item in nums:\n        new_array.append(int(str(item)[::-1]))\n    nums.extend(new_array) \n    return len(set(nums)) ", "entry_point": "countDistinctIntegers", "test_list": ["assert countDistinctIntegers([1,13,10,12,31])==6", "assert countDistinctIntegers([2,2,2])==1"]}
{"Contest id": "315/2441", "text_name": "与对应负数同时存在的最大正整数", "text": "给你一个 不包含 任何零的整数数组 nums ，找出自身与对应的负数都在数组中存在的最大正整数 k 。\n返回正整数 k ，如果不存在这样的整数，返回 -1 。", "canonical_solution": "def findMaxK(nums):\n    nums.sort()\n    i, j = 0, len(nums)-1\n    while i < j:\n        if nums[i] == - nums[j]:\n            return nums[j]\n        if abs(nums[i]) > abs(nums[j]):\n            i += 1\n        else:\n            j -= 1\n    return -1", "entry_point": "findMaxK", "test_list": ["assert findMaxK([-1,2,-3,3])==3", "assert findMaxK([-1,10,6,7,-7,1])==7", "assert findMaxK([-10,8,6,7,-2,-3])==-1"]}
{"Contest id": "Bi89/2440", "text_name": "创建价值相同的连通块", "text": "有一棵 n 个节点的无向树，节点编号为 0 到 n - 1 。\n给你一个长度为 n 下标从 0 开始的整数数组 nums ，其中 nums[i] 表示第 i 个节点的值。同时给你一个长度为 n - 1 的二维整数数组 edges ，其中 edges[i] = [ai, bi] 表示节点 ai 与 bi 之间有一条边。\n你可以 删除 一些边，将这棵树分成几个连通块。一个连通块的 价值 定义为这个连通块中 所有 节点 i 对应的 nums[i] 之和。\n你需要删除一些边，删除后得到的各个连通块的价值都相等。请返回你可以删除的边数 最多 为多少。", "canonical_solution": "def componentValue(nums, edges):\n    from collections import defaultdict\n    def dfs(a, b):\n        tally = nums[a]\n        for c in graph[a]: \n            if c != b:\n                tally += dfs(c, a)\n        return tally if tally != div else 0\n    graph = defaultdict(list)\n    n, sm, mx, mn = len(nums), sum(nums), max(nums), min(nums)\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    for div in range(mx, sm//mn):\n        if not(sm%div or dfs(0, n-1)):\n            return sm//div-1\n    return 0", "entry_point": "componentValue", "test_list": ["assert componentValue([6,2,2,2,6], [[0,1],[1,2],[1,3],[3,4]] )==2", "assert componentValue([2],[])==0"]}
{"Contest id": "Bi89/2439", "text_name": "最小化数组中的最大值", "text": "给你一个下标从 0 开始的数组 nums ，它含有 n 个非负整数。\n每一步操作中，你需要：\n选择一个满足 1 <= i < n 的整数 i ，且 nums[i] > 0 。\n将 nums[i] 减 1 。\n将 nums[i - 1] 加 1 。\n你可以对数组执行 任意 次上述操作，请你返回可以得到的 nums 数组中 最大值 最小 为多少。", "canonical_solution": "def minimizeArrayValue(nums):\n    from itertools import accumulate\n    return max((a + i) // (i + 1) for i,a in enumerate(accumulate(nums)))", "entry_point": "minimizeArrayValue", "test_list": ["assert minimizeArrayValue([3,7,1,6])==5", "assert minimizeArrayValue([10,1])==10"]}
{"Contest id": "Bi89/2438", "text_name": "二的幂数组中查询范围内的乘积", "text": "给你一个正整数 n ，你需要找到一个下标从 0 开始的数组 powers ，它包含 最少 数目的 2 的幂，且它们的和为 n 。powers 数组是 非递减 顺序的。根据前面描述，构造 powers 数组的方法是唯一的。\n同时给你一个下标从 0 开始的二维整数数组 queries ，其中 queries[i] = [lefti, righti] ，其中 queries[i] 表示请你求出满足 lefti <= j <= righti 的所有 powers[j] 的乘积。\n请你返回一个数组 answers ，长度与 queries 的长度相同，其中 answers[i]是第 i 个查询的答案。由于查询的结果可能非常大，请你将每个 answers[i] 都对 10^9 + 7 取余 。", "canonical_solution": "def productQueries(n, queries):\n    powers_mul = [1]\n    for i in range(30): \n        if n & 1<<i:                \n            powers_mul.append((1<<i) * powers_mul[-1])\n    answers = []\n    for left, right in queries:\n        answers.append((powers_mul[right+1] // powers_mul[left]) % 1_000_000_007)\n    return answers", "entry_point": "productQueries", "test_list": ["assert productQueries(15,[[0,1],[2,2],[0,3]])==[2,4,64]", "assert productQueries(2,[[0,0]])==[2]"]}
{"Contest id": "Bi89/2437", "text_name": "有效时间的数目", "text": "给你一个长度为 5 的字符串 time ，表示一个电子时钟当前的时间，格式为 \"hh:mm\" 。最早 可能的时间是 \"00:00\" ，最晚 可能的时间是 \"23:59\" 。\n在字符串 time 中，被字符 ? 替换掉的数位是 未知的 ，被替换的数字可能是 0 到 9 中的任何一个。\n请你返回一个整数 answer ，将每一个 ? 都用 0 到 9 中一个数字替换后，可以得到的有效时间的数目。", "canonical_solution": "def countTime(time):\n    import re\n    pattern = time.replace('?', '.')\n    return sum(\n        re.fullmatch(pattern, f'{hour:02}:{minute:02}') is not None\n        for hour in range(24)\n        for minute in range(60)\n    )", "entry_point": "countTime", "test_list": ["assert countTime(\"?5:00\")==2", "assert countTime(\"0?:0?\")==100", "assert countTime(\"??:??\")==1440"]}
{"Contest id": "314/2435", "text_name": "矩阵中和能被 K 整除的路径", "text": "给你一个下标从 0 开始的 m x n 整数矩阵 grid 和一个整数 k 。你从起点 (0, 0) 出发，每一步只能往 下 或者往 右 ，你想要到达终点 (m - 1, n - 1) 。\n请你返回路径和能被 k 整除的路径数目，由于答案可能很大，返回答案对 109 + 7 取余 的结果。", "canonical_solution": "def numberOfPaths(grid, k):\n    from collections import Counter\n    n, m, mod = len(grid), len(grid[0]), 10**9 + 7\n    dp = [Counter() for j in range(m + 1)]\n    dp[0][0] = 1\n    for i, r in enumerate(grid):\n        for j, a in enumerate(r):\n            dp[j] = Counter({(a + b) % k: c % mod for b, c in (dp[j] + dp[j-1]).items()})\n    return dp[m - 1][0]", "entry_point": "numberOfPaths", "test_list": ["assert numberOfPaths([[5,2,4],[3,0,5],[0,7,2]],3)==2", "assert numberOfPaths([[0,0]],5)==1", "assert numberOfPaths([[7,3,4,9],[2,3,6,2],[2,3,7,0]],1)==10"]}
{"Contest id": "314/2434", "text_name": "使用机器人打印字典序最小的字符串", "text": "给你一个字符串 s 和一个机器人，机器人当前有一个空字符串 t 。执行以下操作之一，直到 s 和 t 都变成空字符串：\n删除字符串 s 的 第一个 字符，并将该字符给机器人。机器人把这个字符添加到 t 的尾部。\n删除字符串 t 的 最后一个 字符，并将该字符给机器人。机器人将该字符写到纸上。\n请你返回纸上能写出的字典序最小的字符串。", "canonical_solution": "def robotWithString(s):\n    n = len(s)\n    min_suffix, t, ans = [s[-1]] * n, [], []\n    for i in range(n - 2, -1, -1):\n        min_suffix[i] = min(s[i], min_suffix[i + 1])\n    for i, char in enumerate(s):\n        t.append(char)\n        while i + 1 < n and t and min_suffix[i + 1] >= t[-1]:\n            ans += t.pop()\n    ans += t[::-1]\n    return ''.join(ans)", "entry_point": "robotWithString", "test_list": ["assert robotWithString(\"zza\")==\"azz\"", "assert robotWithString(\"bac\")==\"abc\"", "assert robotWithString(\"bdda\")==\"addb\""]}
{"Contest id": "314/2433", "text_name": "找出前缀异或的原始数组", "text": "给你一个长度为 n 的 整数 数组 pref 。找出并返回满足下述条件且长度为 n 的数组 arr ：\npref[i] = arr[0] ^ arr[1] ^ ... ^ arr[i].\n注意 ^ 表示 按位异或（bitwise-xor）运算。\n可以证明答案是 唯一 的。", "canonical_solution": "def findArray(pref):\n    for i in range(len(pref) - 1, 0, -1):\n        pref[i] ^= pref[i - 1]\n    return pref", "entry_point": "findArray", "test_list": ["assert findArray([5,2,0,3,1])==[5,7,2,3,2]", "assert findArray([13])==[13]"]}
{"Contest id": "314/2432", "text_name": "处理用时最长的那个任务的员工", "text": "共有 n 位员工，每位员工都有一个从 0 到 n - 1 的唯一 id 。\n给你一个二维整数数组 logs ，其中 logs[i] = [idi, leaveTimei] ：\nidi 是处理第 i 个任务的员工的 id ，且\nleaveTimei 是员工完成第 i 个任务的时刻。所有 leaveTimei 的值都是 唯一 的。\n注意，第 i 个任务在第 (i - 1) 个任务结束后立即开始，且第 0 个任务从时刻 0 开始。\n返回处理用时最长的那个任务的员工的 id 。如果存在两个或多个员工同时满足，则返回几人中 最小 的 id 。", "canonical_solution": "def hardestWorker(n, logs):\n    time , i_d = logs[0][1] , logs[0][0]  \n    for i in range(1,len(logs)):\n        gap= logs[i][1] - logs[i-1][1]\n        if gap > time or gap == time and i_d > logs[i][0]:\n            time , i_d = gap , logs[i][0]\n    return i_d", "entry_point": "hardestWorker", "test_list": ["assert hardestWorker(10,[[0,3],[2,5],[0,9],[1,15]])==1", "assert hardestWorker(26,[[1,1],[3,7],[2,12],[7,17]])==3", "assert hardestWorker(2,[[0,10],[1,20]])==0"]}
{"Contest id": "313/2430", "text_name": "对字母串可执行的最大删除数", "text": "给你一个仅由小写英文字母组成的字符串 s 。在一步操作中，你可以：\n删除 整个字符串 s ，或者\n对于满足 1 <= i <= s.length / 2 的任意 i ，如果 s 中的 前 i 个字母和接下来的 i 个字母 相等 ，删除 前 i 个字母。\n例如，如果 s = \"ababc\" ，那么在一步操作中，你可以删除 s 的前两个字母得到 \"abc\" ，因为 s 的前两个字母和接下来的两个字母都等于 \"ab\" 。\n返回删除 s 所需的最大操作数。", "canonical_solution": "def deleteString(s):\n    n = len(s)\n    if (len(set(s)) == 1): return n\n    lcs = [[0] * (n + 1) for i in range(n + 1)]\n    dp = [1] * n\n    for i in range(n-1, -1, -1):\n        for j in range(i + 1, n):\n            if s[i] == s[j]:\n                lcs[i][j] = lcs[i + 1][j + 1] + 1\n            if lcs[i][j] >= j - i:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return dp[0]", "entry_point": "deleteString", "test_list": ["assert deleteString(\"abcabcdabc\")==2", "assert deleteString(\"aaabaab\")==4", "assert deleteString(\"aaaaa\")==5"]}
{"Contest id": "313/2429", "text_name": "最小异或", "text": "给你两个正整数 num1 和 num2 ，找出满足下述条件的正整数 x ：\nx 的置位数和 num2 相同，且\nx XOR num1 的值 最小\n注意 XOR 是按位异或运算。\n返回整数 x 。题目保证，对于生成的测试用例， x 是 唯一确定 的。\n整数的 置位数 是其二进制表示中 1 的数目。", "canonical_solution": "def minimizeXor(num1, num2):\n    c = 0\n    for i in range(32):\n        if num2 & (1<<i):\n            c+=1\n    num = 0\n    for i in range(31,-1,-1):\n        if (num1 & (1<<i)) and c>0:\n            num+=pow(2,i)\n            c-=1\n    s = str(bin(num)[2:])\n    s = \"0\"*(32-len(s))+s\n    i = 31\n    while(c>0 and i>0):\n        if (s[i]==\"0\"):\n            s = s[:i]+\"1\"+s[i+1:]\n            c-=1\n        else:\n            i-=1\n    return int(s,2)", "entry_point": "minimizeXor", "test_list": ["assert minimizeXor(3,5)==3", "assert minimizeXor(1,12)==3"]}
{"Contest id": "313/2427", "text_name": "公因子的数目", "text": "给你两个正整数 a 和 b ，返回 a 和 b 的 公 因子的数目。\n如果 x 可以同时整除 a 和 b ，则认为 x 是 a 和 b 的一个 公因子 。", "canonical_solution": "def commonFactors(a, b):\n    return sum(not(a%i or b%i) for i in range(1,min(a,b)+1))", "entry_point": "commonFactors", "test_list": ["assert commonFactors(12,6)==4", "assert commonFactors(25,30)==2"]}
{"Contest id": "Bi88/2426", "text_name": "满足不等式的数对数目", "text": "给你两个下标从 0 开始的整数数组 nums1 和 nums2 ，两个数组的大小都为 n ，同时给你一个整数 diff ，统计满足以下条件的 数对 (i, j) ：\n0 <= i < j <= n - 1 且\nnums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff.\n请你返回满足条件的 数对数目 。", "canonical_solution": "def numberOfPairs(nums1, nums2, diff):\n        import bisect\n        n = len(nums1)\n        d = []\n        for i in range(n):\n            d.append(nums1[i] - nums2[i])\n        res = 0\n        order = []\n        for i in range(n - 1, -1, -1):\n            res += len(order) - bisect.bisect_left(order, d[i] - diff)\n            bisect.insort(order, d[i])\n        return res", "entry_point": "numberOfPairs", "test_list": ["assert numberOfPairs([3,2,5], [2,2,1],1)==3", "assert numberOfPairs([3,-1],[-2,2], -1)==0"]}
{"Contest id": "Bi88/2425", "text_name": "所有数对的异或和", "text": "给你两个下标从 0 开始的数组 nums1 和 nums2 ，两个数组都只包含非负整数。请你求出另外一个数组 nums3 ，包含 nums1 和 nums2 中 所有数对 的异或和（nums1 中每个整数都跟 nums2 中每个整数 恰好 匹配一次）。\n请你返回 nums3 中所有整数的 异或和 。", "canonical_solution": "def xorAllNums(nums1, nums2):\n    from functools import reduce\n    def xor(a, b):\n        return a ^ b\n    return (len(nums1) % 2 * reduce(xor, nums2)) ^ (len(nums2) % 2 * reduce(xor, nums1))", "entry_point": "xorAllNums", "test_list": ["assert xorAllNums([2,1,3],[10,2,5,0])==13", "assert xorAllNums([1,2], [3,4])==0"]}
{"Contest id": "Bi88/2423", "text_name": "删除字符使频率相同", "text": "给你一个下标从 0 开始的字符串 word ，字符串只包含小写英文字母。你需要选择 一个 下标并 删除 下标处的字符，使得 word 中剩余每个字母出现 频率 相同。\n如果删除一个字母后，word 中剩余所有字母的出现频率都相同，那么返回 true ，否则返回 false 。\n注意：\n字母 x 的 频率 是这个字母在字符串中出现的次数。\n你 必须 恰好删除一个字母，不能一个字母都不删除。", "canonical_solution": "def equalFrequency(word):\n    from collections import Counter\n    counter = Counter(word)\n    for c in word:\n        counter[c] -= 1\n        if counter[c] == 0:\n            counter.pop(c)\n        if len(set(counter.values())) == 1:\n            return True\n        counter[c] += 1\n    return False", "entry_point": "equalFrequency", "test_list": ["assert equalFrequency(\"abcc\")==True", "assert equalFrequency(\"aazz\")==False"]}
{"Contest id": "312/2421", "text_name": "好路径的数目", "text": "给你一棵 n 个节点的树（连通无向无环的图），节点编号从 0 到 n - 1 且恰好有 n - 1 条边。\n给你一个长度为 n 下标从 0 开始的整数数组 vals ，分别表示每个节点的值。同时给你一个二维整数数组 edges ，其中 edges[i] = [ai, bi] 表示节点 ai 和 bi 之间有一条 无向 边。\n一条 好路径 需要满足以下条件：\n开始节点和结束节点的值 相同 。\n开始节点和结束节点中间的所有节点值都 小于等于 开始节点的值（也就是说开始节点的值应该是路径上所有节点的最大值）。\n请你返回不同好路径的数目。\n注意，一条路径和它反向的路径算作 同一 路径。比方说， 0 -> 1 与 1 -> 0 视为同一条路径。单个节点也视为一条合法路径。", "canonical_solution": "def numberOfGoodPaths(vals, edges):\n    from collections import Counter\n    res = n = len(vals)\n    f = list(range(n))\n    count = [Counter({vals[i]: 1}) for i in range(n)]\n    edges = sorted([max(vals[i], vals[j]),i,j] for i,j in edges)\n    def find(x):\n        if f[x] != x:\n            f[x] = find(f[x])\n        return f[x]\n    for v,i,j in edges:\n        fi, fj = find(i), find(j)\n        cj, ci = count[fi][v], count[fj][v]\n        res += ci * cj\n        f[fj] = fi\n        count[fi] = Counter({v: ci + cj})\n    return res", "entry_point": "numberOfGoodPaths", "test_list": ["assert numberOfGoodPaths([1,3,2,1,3],[[0,1],[0,2],[2,3],[2,4]])==6", "assert numberOfGoodPaths([1,1,2,2,3],[[0,1],[1,2],[2,3],[2,4]])==7", "assert numberOfGoodPaths([1], [])==1"]}
{"Contest id": "312/2420", "text_name": "找到所有好下标", "text": "给你一个大小为 n 下标从 0 开始的整数数组 nums 和一个正整数 k 。\n对于 k <= i < n - k 之间的一个下标 i ，如果它满足以下条件，我们就称它为一个 好 下标：\n下标 i 之前 的 k 个元素是 非递增的 。\n下标 i 之后 的 k 个元素是 非递减的 。\n按 升序 返回所有好下标。", "canonical_solution": "def goodIndices(nums, k):\n    n, ans= len(nums) ,[]\n    dp1 , dp2= [1]*(n+1), [1]*(n+1)\n    for i in range(1,n):\n        if nums[i-1]>=nums[i]:  dp1[i]= dp1[i-1]+1\n    for i in range(n-2,-1,-1):\n        if nums[i]<=nums[i+1]:  dp2[i]= dp2[i+1]+1\n    for i in range(k,n-k):\n        if dp1[i-1]>=k and dp2[i+1]>=k: ans+= [i]\n    return ans", "entry_point": "goodIndices", "test_list": ["assert goodIndices([2,1,1,1,3,4,1],2)==[2,3]", "assert goodIndices([2,1,1,2],2)==[]"]}
{"Contest id": "312/2419", "text_name": "按位与最大的最长子数组", "text": "给你一个长度为 n 的整数数组 nums 。\n考虑 nums 中进行 按位与（bitwise AND）运算得到的值 最大 的 非空 子数组\n换句话说，令 k 是 nums 任意 子数组执行按位与运算所能得到的最大值。那么，只需要考虑那些执行一次按位与运算后等于 k 的子数组。\n返回满足要求的 最长 子数组的长度。\n数组的按位与就是对数组中的所有数字进行按位与运算。\n子数组 是数组中的一个连续元素序列。", "canonical_solution": "def longestSubarray(nums):\n    val = max(nums)\n    i = j = res = 0\n    while j < len(nums):\n        if nums[j] == val:\n            while j < len(nums) and nums[j] == val: j += 1\n            res = max(res, j - i)\n        i = j = j + 1\n    return res", "entry_point": "longestSubarray", "test_list": ["assert longestSubarray([1,2,3,3,2,2])==2", "assert longestSubarray([1,2,3,4])==1"]}
{"Contest id": "312/2418", "text_name": "按身高排序", "text": "给你一个字符串数组 names ，和一个由 互不相同 的正整数组成的数组 heights 。两个数组的长度均为 n 。\n对于每个下标 i，names[i] 和 heights[i] 表示第 i 个人的名字和身高。\n请按身高 降序 顺序返回对应的名字数组 names 。", "canonical_solution": "def sortPeople(names, heights):\n    height_dict = dict(zip(heights,names)) \n    names.clear()\n    for key in sorted(height_dict.keys(),reverse=True):\n        names.append(height_dict[key])\n    return names", "entry_point": "sortPeople", "test_list": ["assert sortPeople([\"Mary\",\"John\",\"Emma\"],[180,165,170])==[\"Mary\",\"Emma\",\"John\"]", "assert sortPeople([\"Alice\",\"Bob\",\"Bob\"],[155,185,150])==[\"Bob\",\"Alice\",\"Bob\"]"]}
{"Contest id": "311/2416", "text_name": "字符串的前缀分数和", "text": "给你一个长度为 n 的数组 words ，该数组由 非空 字符串组成。\n定义字符串 word 的 分数 等于以 word 作为 前缀 的 words[i] 的数目。\n例如，如果 words = [\"a\", \"ab\", \"abc\", \"cab\"] ，那么 \"ab\" 的分数是 2 ，因为 \"ab\" 是 \"ab\" 和 \"abc\" 的一个前缀。\n返回一个长度为 n 的数组 answer ，其中 answer[i] 是 words[i] 的每个非空前缀的分数 总和 。\n注意：字符串视作它自身的一个前缀。", "canonical_solution": "def sumPrefixScores(words):\n    d = dict()\n    for i in words:\n        s=\"\"\n        for j in range(len(i)):\n            s+=i[j]\n            if s in d:\n                d[s]+=1\n            else:\n                d[s]=1\n    l=[]\n    for i in words:\n        c = 0\n        s=\"\"\n        for j in range(len(i)):\n            s+=i[j]\n            c+=d[s]\n        l.append(c)\n    return l", "entry_point": "sumPrefixScores", "test_list": ["assert sumPrefixScores([\"abc\",\"ab\",\"bc\",\"b\"])==[5,4,3,2]", "assert sumPrefixScores([\"abcd\"])==[4]"]}
{"Contest id": "311/2414", "text_name": "最长的字母序连续子字符串的长度", "text": "字母序连续字符串 是由字母表中连续字母组成的字符串。换句话说，字符串 \"abcdefghijklmnopqrstuvwxyz\" 的任意子字符串都是 字母序连续字符串 。\n例如，\"abc\" 是一个字母序连续字符串，而 \"acb\" 和 \"za\" 不是。\n给你一个仅由小写英文字母组成的字符串 s ，返回其 最长 的 字母序连续子字符串 的长度。", "canonical_solution": "def longestContinuousSubstring(s):\n    cur = 1\n    res = 1\n    for i in range(1,len(s)):\n        if ord(s[i])-ord(s[i-1])==1:\n            cur = cur+1\n            res = max(cur,res)\n        else:\n            cur = 1\n    return res", "entry_point": "longestContinuousSubstring", "test_list": ["assert longestContinuousSubstring(\"abacaba\")==2", "assert longestContinuousSubstring(\"abcde\")==5"]}
{"Contest id": "311/2413", "text_name": "最小偶倍数", "text": "给你一个正整数 n ，返回 2 和 n 的最小公倍数（正整数）。", "canonical_solution": "def smallestEvenMultiple(n):\n        return n << (n & 1)", "entry_point": "smallestEvenMultiple", "test_list": ["assert smallestEvenMultiple(5)==10", "assert smallestEvenMultiple(6)==6"]}
{"Contest id": "Bi87/2412", "text_name": "完成所有交易的初始最少钱数", "text": "给你一个下标从 0 开始的二维整数数组 transactions，其中transactions[i] = [costi, cashbacki] 。\n数组描述了若干笔交易。其中每笔交易必须以 某种顺序 恰好完成一次。在任意一个时刻，你有一定数目的钱 money ，为了完成交易 i ，money >= costi 这个条件必须为真。执行交易后，你的钱数 money 变成 money - costi + cashbacki 。\n请你返回 任意一种 交易顺序下，你都能完成所有交易的最少钱数 money 是多少。", "canonical_solution": "def minimumMoney(transactions):\n    res = v = 0\n    for i,j in transactions:\n        res += max(0, i - j)\n        v = max(v, min(i, j))\n    return res + v", "entry_point": "minimumMoney", "test_list": ["assert minimumMoney([[2,1],[5,0],[4,2]])==10", "assert minimumMoney([[3,0],[0,3]])==3"]}
{"Contest id": "Bi87/2411", "text_name": "按位或最大的最小子数组长度", "text": "给你一个长度为 n 下标从 0 开始的数组 nums ，数组中所有数字均为非负整数。对于 0 到 n - 1 之间的每一个下标 i ，你需要找出 nums 中一个 最小 非空子数组，它的起始位置为 i （包含这个位置），同时有 最大 的 按位或运算值 。\n换言之，令 Bij 表示子数组 nums[i...j] 的按位或运算的结果，你需要找到一个起始位置为 i 的最小子数组，这个子数组的按位或运算的结果等于 max(Bik) ，其中 i <= k <= n - 1 。\n一个数组的按位或运算值是这个数组里所有数字按位或运算的结果。\n请你返回一个大小为 n 的整数数组 answer，其中 answer[i]是开始位置为 i ，按位或运算结果最大，且 最短 子数组的长度。\n子数组 是数组里一段连续非空元素组成的序列。", "canonical_solution": "def smallestSubarrays(nums):\n    last = [0] * 32\n    n = len(nums)\n    res = [0] * n\n    for i in range(n - 1, -1, -1):\n        for j in range(32):\n            if nums[i] & (1 << j):\n                last[j] = i\n        res[i] = max(1, max(last) - i + 1)\n    return res", "entry_point": "smallestSubarrays", "test_list": ["assert smallestSubarrays([1,0,2,1,3])==[3,3,2,2,1]", "assert smallestSubarrays([1,2])==[2,1]"]}
{"Contest id": "Bi87/2410", "text_name": "运动员和训练师的最大匹配数", "text": "给你一个下标从 0 开始的整数数组 players ，其中 players[i] 表示第 i 名运动员的 能力 值，同时给你一个下标从 0 开始的整数数组 trainers ，其中 trainers[j] 表示第 j 名训练师的 训练能力值 。\n如果第 i 名运动员的能力值 小于等于 第 j 名训练师的能力值，那么第 i 名运动员可以 匹配 第 j 名训练师。除此以外，每名运动员至多可以匹配一位训练师，每位训练师最多可以匹配一位运动员。\n请你返回满足上述要求 players 和 trainers 的 最大 匹配数。", "canonical_solution": "def matchPlayersAndTrainers(players, trainers):\n    players, trainers = sorted(players), sorted(trainers)\n    i, j, matchings = len(players) - 1, len(trainers) - 1, 0\n    while i >= 0 and j >= 0:\n        if players[i] > trainers[j]:\n                i -= 1\n        else:\n            matchings, i, j = matchings + 1, i - 1, j - 1\n    return matchings", "entry_point": "matchPlayersAndTrainers", "test_list": ["assert matchPlayersAndTrainers([4,7,9],[8,2,5,8])==2", "assert matchPlayersAndTrainers([1,1,1],[10])==1"]}
{"Contest id": "Bi87/2409", "text_name": "统计共同度过的日子数", "text": "Alice 和 Bob 计划分别去罗马开会。\n给你四个字符串 arriveAlice ，leaveAlice ，arriveBob 和 leaveBob 。Alice 会在日期 arriveAlice 到 leaveAlice 之间在城市里（日期为闭区间），而 Bob 在日期 arriveBob 到 leaveBob 之间在城市里（日期为闭区间）。每个字符串都包含 5 个字符，格式为 \"MM-DD\" ，对应着一个日期的月和日。\n请你返回 Alice和 Bob 同时在罗马的天数。\n你可以假设所有日期都在 同一个 自然年，而且 不是 闰年。每个月份的天数分别为：[31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] 。", "canonical_solution": "def countDaysTogether(arriveAlice, leaveAlice, arriveBob, leaveBob):\n    def getDate(date):\n        monthList = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n        month = int(date[:2])\n        days = int(date[3:])\n        return sum(monthList[: month - 1]) + days\n    return max(0,getDate(min(leaveAlice, leaveBob)) -getDate(max(arriveAlice, arriveBob)) + 1)", "entry_point": "countDaysTogether", "test_list": ["assert countDaysTogether(\"08-15\",\"08-18\",\"08-16\",\"08-19\")==3", "assert countDaysTogether(\"10-01\",\"10-31\",\"11-01\",\"12-31\")==0"]}
{"Contest id": "310/2407", "text_name": "最长递增子序列 II", "text": "给你一个整数数组 nums 和一个整数 k 。\n找到 nums 中满足以下要求的最长子序列：\n子序列 严格递增\n子序列中相邻元素的差值 不超过 k 。\n请你返回满足上述要求的 最长子序列 的长度。\n子序列 是从一个数组中删除部分元素后，剩余元素不改变顺序得到的数组。", "canonical_solution": "def lengthOfLIS(nums, k):\n    from collections import defaultdict\n    from bisect import insort, bisect_left\n    import bisect\n    dp_tracker = defaultdict(list)\n    n = len(nums)\n    dp = [1]*n\n    max_till_now = 1\n    for i in range(n):\n        temp_ans = 1\n        max_ans = 0\n        for j in range(max_till_now, 0, -1):\n            ind = bisect_left(dp_tracker[j], nums[i])\n            if ind != 0:\n                if k >= (nums[i] - dp_tracker[j][ind-1]) > 0:\n                    max_ans = j\n                    break\n        dp[i] = temp_ans + max_ans\n        bisect.insort(dp_tracker[dp[i]], nums[i])\n        max_till_now = max(max_till_now, dp[i])\n    return max(dp)", "entry_point": "lengthOfLIS", "test_list": ["assert lengthOfLIS([4,2,1,4,3,4,5,8,15],3)==5", "assert lengthOfLIS([7,4,5,1,8,12,4,7],5)==4", "assert lengthOfLIS([1,5],1)==1"]}
{"Contest id": "310/2406", "text_name": "将区间分为最少组数", "text": "给你一个二维整数数组 intervals ，其中 intervals[i] = [lefti, righti] 表示 闭 区间 [lefti, righti] 。\n你需要将 intervals 划分为一个或者多个区间 组 ，每个区间 只 属于一个组，且同一个组中任意两个区间 不相交 。\n请你返回 最少 需要划分成多少个组。\n如果两个区间覆盖的范围有重叠（即至少有一个公共数字），那么我们称这两个区间是 相交 的。比方说区间 [1, 5] 和 [5, 8] 相交。", "canonical_solution": "def minGroups(intervals):\n    A = []\n    for a,b in intervals:\n        A.append([a, 1])\n        A.append([b + 1, -1])\n    res = cur = 0\n    for a, diff in sorted(A):\n        cur += diff\n        res = max(res, cur)\n    return res", "entry_point": "minGroups", "test_list": ["assert minGroups([[5,10],[6,8],[1,5],[2,3],[1,10]])==3", "assert minGroups([[1,3],[5,6],[8,10],[11,13]])==1"]}
{"Contest id": "310/2405", "text_name": "子字符串的最优划分", "text": "给你一个字符串 s ，请你将该字符串划分成一个或多个 子字符串 ，并满足每个子字符串中的字符都是 唯一 的。也就是说，在单个子字符串中，字母的出现次数都不超过 一次 。\n满足题目要求的情况下，返回 最少 需要划分多少个子字符串。\n注意，划分后，原字符串中的每个字符都应该恰好属于一个子字符串。", "canonical_solution": "def partitionString(s):\n    idx = 0\n    count = 0\n    mp = {} \n    while idx < len(s):\n        if s[idx] in mp: \n            count += 1\n            mp.clear()\n        mp[s[idx]] = True\n        idx += 1 \n    return count + 1 ", "entry_point": "partitionString", "test_list": ["assert partitionString(\"abacaba\")==4", "assert partitionString(\"ssssss\")==6"]}
{"Contest id": "310/2404", "text_name": "出现最频繁的偶数元素", "text": "给你一个整数数组 nums ，返回出现最频繁的偶数元素。\n如果存在多个满足条件的元素，只需要返回 最小 的一个。如果不存在这样的元素，返回 -1 。", "canonical_solution": "def mostFrequentEven(nums):\n    mp={}\n    val,freq =10**6,0\n    for i in nums:\n        if i%2==0:\n            if i in mp: mp[i]+=1\n            else: mp[i]=1\n            if mp[i]>freq or mp[i]==freq and i<val:\n                val, freq =i , mp[i]\n    return -1 if freq==0 else val", "entry_point": "mostFrequentEven", "test_list": ["assert mostFrequentEven([0,1,2,2,4,4,1])==2", "assert mostFrequentEven([4,4,4,9,2,4])==4", "assert mostFrequentEven([29,47,21,41,13,37,25,7])==-1"]}
{"Contest id": "309/2402", "text_name": "会议室 III", "text": "给你一个整数 n ，共有编号从 0 到 n - 1 的 n 个会议室。\n给你一个二维整数数组 meetings ，其中 meetings[i] = [starti, endi] 表示一场会议将会在 半闭 时间区间 [starti, endi) 举办。所有 starti 的值 互不相同 。\n会议将会按以下方式分配给会议室：\n每场会议都会在未占用且编号 最小 的会议室举办。\n如果没有可用的会议室，会议将会延期，直到存在空闲的会议室。延期会议的持续时间和原会议持续时间 相同 。\n当会议室处于未占用状态时，将会优先提供给原 开始 时间更早的会议。\n返回举办最多次会议的房间 编号 。如果存在多个房间满足此条件，则返回编号 最小 的房间。\n半闭区间 [a, b) 是 a 和 b 之间的区间，包括 a 但 不包括 b 。", "canonical_solution": "def mostBooked(n, meetings):\n    from heapq import heapify,heappop,heappush\n    ready = [r for r in range(n)]\n    rooms = []\n    heapify(ready)\n    res = [0] * n\n    for s,e in sorted(meetings):\n        while rooms and rooms[0][0] <= s:\n            t,r = heappop(rooms)\n            heappush(ready, r)\n        if ready:\n            r = heappop(ready)\n            heappush(rooms, [e, r])\n        else:\n            t,r = heappop(rooms)\n            heappush(rooms, [t + e - s, r])\n        res[r] += 1\n    return res.index(max(res))", "entry_point": "mostBooked", "test_list": ["assert mostBooked(2,[[0,10],[1,5],[2,7],[3,4]])==0", "assert mostBooked(3,[[1,20],[2,10],[3,5],[4,9],[6,8]])==1"]}
{"Contest id": "309/2401", "text_name": "最长优雅子数组", "text": "给你一个由 正 整数组成的数组 nums 。\n如果 nums 的子数组中位于 不同 位置的每对元素按位 与（AND）运算的结果等于 0 ，则称该子数组为 优雅 子数组。\n返回 最长 的优雅子数组的长度。\n子数组 是数组中的一个 连续 部分。\n注意：长度为 1 的子数组始终视作优雅子数组。", "canonical_solution": "def longestNiceSubarray(nums):\n    res = AND = i = 0\n    for j in range(len(nums)):\n        while AND & nums[j]:\n            AND ^= nums[i]\n            i += 1\n        AND |= nums[j]\n        res = max(res, j - i + 1)\n    return res", "entry_point": "longestNiceSubarray", "test_list": ["assert longestNiceSubarray([1,3,8,48,10])==3", "assert longestNiceSubarray([3,1,5,11,13])==1"]}
{"Contest id": "309/2400", "text_name": "恰好移动 k 步到达某一位置的方法数目", "text": "给你两个 正 整数 startPos 和 endPos 。最初，你站在 无限 数轴上位置 startPos 处。在一步移动中，你可以向左或者向右移动一个位置。\n给你一个正整数 k ，返回从 startPos 出发、恰好 移动 k 步并到达 endPos 的 不同 方法数目。由于答案可能会很大，返回对 109 + 7 取余 的结果。\n如果所执行移动的顺序不完全相同，则认为两种方法不同。\n注意：数轴包含负整数。", "canonical_solution": "def numberOfWays(startPos, endPos, k):\n    from math import comb\n    if (startPos - endPos - k) % 2: return 0\n    return comb(k, (endPos - startPos + k) // 2) % (10 ** 9 + 7)", "entry_point": "numberOfWays", "test_list": ["assert numberOfWays(1,2,3)==3", "assert numberOfWays(2,5,10)==0"]}
{"Contest id": "309/2399", "text_name": "检查相同字母间的距离", "text": "给你一个下标从 0 开始的字符串 s ，该字符串仅由小写英文字母组成，s 中的每个字母都 恰好 出现 两次 。另给你一个下标从 0 开始、长度为 26 的的整数数组 distance 。\n字母表中的每个字母按从 0 到 25 依次编号（即，'a' -> 0, 'b' -> 1, 'c' -> 2, ... , 'z' -> 25）。\n在一个 匀整 字符串中，第 i 个字母的两次出现之间的字母数量是 distance[i] 。如果第 i 个字母没有在 s 中出现，那么 distance[i] 可以 忽略 。\n如果 s 是一个 匀整 字符串，返回 true ；否则，返回 false 。", "canonical_solution": "def checkDistances(s, distance):\n    from collections import defaultdict\n    d = defaultdict(list)\n    for i, ch in enumerate(s):\n        d[ch].append(i)\n    return all(b-a-1 == distance[ord(ch)-97] for ch, (a,b) in d.items())", "entry_point": "checkDistances", "test_list": ["assert checkDistances(\"abaccb\",[1,3,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0])==True", "assert checkDistances(\"aa\",[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0])==False"]}
{"Contest id": "Bi86/2398", "text_name": "预算内的最多机器人数目", "text": "你有 n 个机器人，给你两个下标从 0 开始的整数数组 chargeTimes 和 runningCosts ，两者长度都为 n 。第 i 个机器人充电时间为 chargeTimes[i] 单位时间，花费 runningCosts[i] 单位时间运行。再给你一个整数 budget 。\n运行 k 个机器人 总开销 是 max(chargeTimes) + k * sum(runningCosts) ，其中 max(chargeTimes) 是这 k 个机器人中最大充电时间，sum(runningCosts) 是这 k 个机器人的运行时间之和。\n请你返回在 不超过 budget 的前提下，你 最多 可以 连续 运行的机器人数目为多少。", "canonical_solution": "def maximumRobots(chargeTimes, runningCosts, budget):\n        from collections import deque\n        maxQ = deque()\n        maxCons = current = p1 = 0\n        getBudget = lambda: chargeTimes[maxQ[0]]  + ((p2 - p1 + 1) * current) if(maxQ) else 0\n        \n        for p2, (charge, running) in enumerate(zip(chargeTimes, runningCosts)):\n            current += running\n            while(maxQ and chargeTimes[maxQ[-1]] < charge):\n                maxQ.pop()\n            maxQ.append(p2)\n            \n            while(getBudget() > budget):\n                current -= runningCosts[p1]\n                p1 += 1\n                while(maxQ and maxQ[0] < p1):\n                    maxQ.popleft()\n            \n            maxCons = max(maxCons, p2 - p1 + 1)\n        return maxCons", "entry_point": "maximumRobots", "test_list": ["assert maximumRobots([3,6,1,3,4],[2,1,3,4,5],25)==3", "assert maximumRobots([11,12,19],[10,8,7],19)==0"]}
{"Contest id": "Bi86/2397", "text_name": "被列覆盖的最多行数", "text": "给你一个下标从 0 开始、大小为 m x n 的二进制矩阵 matrix ；另给你一个整数 numSelect，表示你必须从 matrix 中选择的 不同 列的数量。\n如果一行中所有的 1 都被你选中的列所覆盖，则认为这一行被 覆盖 了。\n形式上，假设 s = {c1, c2, ...., cnumSelect} 是你选择的列的集合。对于矩阵中的某一行 row ，如果满足下述条件，则认为这一行被集合 s 覆盖：\n对于满足 matrix[row][col] == 1 的每个单元格 matrix[row][col]（0 <= col <= n - 1），col 均存在于 s 中，或者\nrow 中 不存在 值为 1 的单元格。\n你需要从矩阵中选出 numSelect 个列，使集合覆盖的行数最大化。\n返回一个整数，表示可以由 numSelect 列构成的集合 覆盖 的 最大行数 。", "canonical_solution": "def maximumRows(matrix, numSelect):\n        import math\n        from itertools import combinations\n        m, n, ans = len(matrix), len(matrix[0]), -math.inf\n        for comb in combinations((num for num in range(n)),n-numSelect):\n            ct = len(set(r for r in range(m) for c in comb if matrix[r][c] == 1))\n            ans = max(ans,m-ct)\n        return ans", "entry_point": "maximumRows", "test_list": ["assert maximumRows([[0,0,0],[1,0,1],[0,1,1],[0,0,1]],2)==3", "assert maximumRows([[1],[0]],1)==2"]}
{"Contest id": "Bi86/2396", "text_name": "严格回文的数字", "text": "如果一个整数 n 在 b 进制下（b 为 2 到 n - 2 之间的所有整数）对应的字符串 全部 都是 回文的 ，那么我们称这个数 n 是 严格回文 的。\n给你一个整数 n ，如果 n 是 严格回文 的，请返回 true ，否则返回 false 。\n如果一个字符串从前往后读和从后往前读完全相同，那么这个字符串是 回文的 。", "canonical_solution": "def isStrictlyPalindromic(n):\n        return False", "entry_point": "isStrictlyPalindromic", "test_list": ["assert isStrictlyPalindromic(9)==False", "assert isStrictlyPalindromic(4)==False"]}
{"Contest id": "Bi86/2395", "text_name": "和相等的子数组", "text": "给你一个下标从 0 开始的整数数组 nums ，判断是否存在 两个 长度为 2 的子数组且它们的 和 相等。注意，这两个子数组起始位置的下标必须 不相同 。\n如果这样的子数组存在，请返回 true，否则返回 false 。\n子数组 是一个数组中一段连续非空的元素组成的序列。", "canonical_solution": "def findSubarrays(nums):\n    seen = set()\n    for i in range(len(nums)-1):\n        s = nums[i] + nums[i+1]\n        if s in seen:\n            return True\n        seen.add(s)\n    return False", "entry_point": "findSubarrays", "test_list": ["assert findSubarrays([4,2,4])==True", "assert findSubarrays([1,2,3,4,5])==False", "assert findSubarrays([0,0,0])==True"]}
{"Contest id": "308/2392", "text_name": "给定条件下构造矩阵", "text": "给你一个 正 整数 k ，同时给你：\n一个大小为 n 的二维整数数组 rowConditions ，其中 rowConditions[i] = [abovei, belowi] 和\n一个大小为 m 的二维整数数组 colConditions ，其中 colConditions[i] = [lefti, righti] 。\n两个数组里的整数都是 1 到 k 之间的数字。\n你需要构造一个 k x k 的矩阵，1 到 k 每个数字需要 恰好出现一次 。剩余的数字都是 0 。\n矩阵还需要满足以下条件：\n对于所有 0 到 n - 1 之间的下标 i ，数字 abovei 所在的 行 必须在数字 belowi 所在行的上面。\n对于所有 0 到 m - 1 之间的下标 i ，数字 lefti 所在的 列 必须在数字 righti 所在列的左边。\n返回满足上述要求的 任意 矩阵。如果不存在答案，返回一个空的矩阵。", "canonical_solution": "def buildMatrix(k, rowCond, colCond):\n        import collections\n        def topoSort(k, cond):\n            nei = collections.defaultdict(list)\n            for s, e in cond:\n                nei[e].append(s)\n            \n            def helper(i):\n                if i in visited and visited[i] == -1:\n                    return False\n                if i in visited and visited[i] == 1:\n                    return True\n                visited[i] = -1\n                for n in nei[i]:\n                    if not helper(n):\n                        return False \n                res.append(i)\n                visited[i] = 1\n                return True\n            \n            res = []\n            visited = {}\n            for i in range(1, k + 1):\n                if not helper(i):\n                    return []\n            return res\n    \n        rowOrder = topoSort(k, rowCond)\n        if rowOrder == []:\n            return []\n        colOrder = topoSort(k, colCond)\n        if colOrder == []:\n            return []\n        colMap = {}\n        for i in range(len(colOrder)):\n            colMap[colOrder[i]] = i\n        \n        res = [[0 for j in range(k)] for i in range(k)]\n        for i in range(len(rowOrder)):\n            res[i][colMap[rowOrder[i]]] = rowOrder[i]\n        return res", "entry_point": "buildMatrix", "test_list": ["assert buildMatrix(3,[[1,2],[3,2]],[[2,1],[3,2]])==[[3,0,0],[0,0,1],[0,2,0]]", "assert buildMatrix(3,[[1,2],[2,3],[3,1],[2,3]],[[2,1]])==[]"]}
{"Contest id": "308/2391", "text_name": "收集垃圾的最少总时间", "text": "给你一个下标从 0 开始的字符串数组 garbage ，其中 garbage[i] 表示第 i 个房子的垃圾集合。garbage[i] 只包含字符 'M' ，'P' 和 'G' ，但可能包含多个相同字符，每个字符分别表示一单位的金属、纸和玻璃。垃圾车收拾 一 单位的任何一种垃圾都需要花费 1 分钟。\n同时给你一个下标从 0 开始的整数数组 travel ，其中 travel[i] 是垃圾车从房子 i 行驶到房子 i + 1 需要的分钟数。\n城市里总共有三辆垃圾车，分别收拾三种垃圾。每辆垃圾车都从房子 0 出发，按顺序 到达每一栋房子。但它们 不是必须 到达所有的房子。\n任何时刻只有 一辆 垃圾车处在使用状态。当一辆垃圾车在行驶或者收拾垃圾的时候，另外两辆车 不能 做任何事情。\n请你返回收拾完所有垃圾需要花费的 最少 总分钟数。", "canonical_solution": "def garbageCollection(garbage, travel):\n    total_minutes = 0\n    current_travel_time = 0\n    total_minutes += len(garbage[0])\n    last_garbage_indices = [-1, -1, -1]\n    for house_index in range(1, len(garbage)):\n        total_minutes += len(garbage[house_index])\n        if \"M\" in garbage[house_index]:\n            last_garbage_indices[0] = house_index - 1\n        if \"P\" in garbage[house_index]:\n            last_garbage_indices[1] = house_index - 1\n        if \"G\" in garbage[house_index]:\n            last_garbage_indices[2] = house_index - 1\n    for travel_index in range(len(travel)):\n        current_travel_time += travel[travel_index]\n        for truck_index in range(3):\n            if last_garbage_indices[truck_index] == travel_index:\n                total_minutes += current_travel_time\n    return total_minutes", "entry_point": "garbageCollection", "test_list": ["assert garbageCollection([\"G\",\"P\",\"GP\",\"GG\"],[2,4,3])==21", "assert garbageCollection([\"MMM\",\"PGM\",\"GP\"],[3,10])==37"]}
{"Contest id": "308/2390", "text_name": "从字符串中移除星号", "text": "给你一个包含若干星号 * 的字符串 s 。\n在一步操作中，你可以：\n选中 s 中的一个星号。\n移除星号 左侧 最近的那个 非星号 字符，并移除该星号自身。\n返回移除 所有 星号之后的字符串。\n注意：\n生成的输入保证总是可以执行题面中描述的操作。\n可以证明结果字符串是唯一的。", "canonical_solution": "def removeStars(s):\n    stack = []\n    for c in s:\n        if c == '*' and stack:\n            stack.pop()\n        else:\n            stack.append(c)\n    return ''.join(stack)", "entry_point": "removeStars", "test_list": ["assert removeStars(\"leet**cod*e\")==\"lecoe\"", "assert removeStars(\"erase*****\")==\"\""]}
{"Contest id": "308/2389", "text_name": "和有限的最长子序列", "text": "给你一个长度为 n 的整数数组 nums ，和一个长度为 m 的整数数组 queries 。\n返回一个长度为 m 的数组 answer ，其中 answer[i] 是 nums 中 元素之和小于等于 queries[i] 的 子序列 的 最大 长度  。\n子序列 是由一个数组删除某些元素（也可以不删除）但不改变剩余元素顺序得到的一个数组。", "canonical_solution": "def answerQueries(nums, queries):\n    from itertools import accumulate\n    from bisect import bisect_right\n    nums = list(accumulate(sorted(nums)))\n    return [bisect_right(nums, q) for q in queries]", "entry_point": "answerQueries", "test_list": ["assert answerQueries([4,5,2,1],[3,10,21])==[2,3,4]", "assert answerQueries([2,3,4,5],[1])==[0]"]}
{"Contest id": "307/2386", "text_name": "找出数组的第 K 大和", "text": "给你一个整数数组 nums 和一个 正 整数 k 。你可以选择数组的任一 子序列 并且对其全部元素求和。\n数组的 第 k 大和 定义为：可以获得的第 k 个 最大 子序列和（子序列和允许出现重复）\n返回数组的 第 k 大和 。\n子序列是一个可以由其他数组删除某些或不删除元素排生而来的数组，且派生过程不改变剩余元素的顺序。\n注意：空子序列的和视作 0 。", "canonical_solution": "def kSum(nums, k):\n    import heapq\n    maxSum = sum([max(0, num) for num in nums])\n    absNums = sorted([abs(num) for num in nums])\n    maxHeap = [(-maxSum + absNums[0], 0)]\n    ans = [maxSum]\n    while len(ans) < k:\n        nextSum, i = heapq.heappop(maxHeap)\n        heapq.heappush(ans, -nextSum)\n        if i + 1 < len(absNums):\n            heapq.heappush(maxHeap, (nextSum - absNums[i] + absNums[i + 1], i + 1))\n            heapq.heappush(maxHeap, (nextSum + absNums[i + 1], i + 1))\n    return ans[0]", "entry_point": "kSum", "test_list": ["assert kSum([2,4,-2],5)==2", "assert kSum([1,-2,3,4,-10,12],16)==10"]}
{"Contest id": "307/2384", "text_name": "最大回文数字", "text": "给你一个仅由数字（0 - 9）组成的字符串 num 。\n请你找出能够使用 num 中数字形成的 最大回文 整数，并以字符串形式返回。该整数不含 前导零 。\n注意：\n你 无需 使用 num 中的所有数字，但你必须使用 至少 一个数字。\n数字可以重新排序。", "canonical_solution": "def largestPalindromic(num):\n        from collections import Counter\n        c = Counter(num)\n        if len(c)==1 and c['0']>=1:\n            return \"0\"\n        m = -1  \n        res1 = ''\n        res2 = ''\n        for i in range(9,-1,-1):\n            while c[str(i)]:\n                if not res1 and i==0:   \n                    break \n                if c[str(i)]>=2:\n                    res1 += str(i)\n                    res2 = str(i) + res2\n                    c[str(i)]-=2\n                if c[str(i)] == 1:\n                    m = max(m,i)  \n                    c[str(i)]-=1\n                if c[str(i)]==0:\n                    del c[str(i)]\n        return res1+res2 if m==-1 else res1 + str(m) + res2\nlargestPalindromic(\"444947137\")", "entry_point": "largestPalindromic", "test_list": ["assert largestPalindromic(\"444947137\")==\"7449447\"", "assert largestPalindromic(\"00009\")==\"9\""]}
{"Contest id": "307/2383", "text_name": "赢得比赛需要的最少训练时长", "text": "你正在参加一场比赛，给你两个 正 整数 initialEnergy 和 initialExperience 分别表示你的初始精力和初始经验。\n另给你两个下标从 0 开始的整数数组 energy 和 experience，长度均为 n 。\n你将会 依次 对上 n 个对手。第 i 个对手的精力和经验分别用 energy[i] 和 experience[i] 表示。当你对上对手时，需要在经验和精力上都 严格 超过对手才能击败他们，然后在可能的情况下继续对上下一个对手。\n击败第 i 个对手会使你的经验 增加 experience[i]，但会将你的精力 减少  energy[i] 。\n在开始比赛前，你可以训练几个小时。每训练一个小时，你可以选择将增加经验增加 1 或者 将精力增加 1 。\n返回击败全部 n 个对手需要训练的 最少 小时数目。", "canonical_solution": "def minNumberOfHours(initialEnergy, initialExperience, energy, experience):\n        traning = 0\n        totalEnergy = sum(energy)\n        if initialEnergy <= totalEnergy:\n            traning += (totalEnergy - initialEnergy + 1)\n        for opponentExperience in experience:\n            if initialExperience <= opponentExperience:\n                traning += (opponentExperience - initialExperience + 1)\n                initialExperience = opponentExperience + 1\n            initialExperience += opponentExperience            \n        return traning", "entry_point": "minNumberOfHours", "test_list": ["assert minNumberOfHours(5,3,[1,4,3,2],[2,6,3,1])==8", "assert minNumberOfHours(2,4,[1],[3])==0"]}
{"Contest id": "Bi85/2382", "text_name": "删除操作后的最大子段和", "text": "给你两个下标从 0 开始的整数数组 nums 和 removeQueries ，两者长度都为 n 。对于第 i 个查询，nums 中位于下标 removeQueries[i] 处的元素被删除，将 nums 分割成更小的子段。\n一个 子段 是 nums 中连续 正 整数形成的序列。子段和 是子段中所有元素的和。\n请你返回一个长度为 n 的整数数组 answer ，其中 answer[i]是第 i 次删除操作以后的 最大 子段和。\n注意：一个下标至多只会被删除一次。", "canonical_solution": "def maximumSegmentSum(nums, removeQueries):\n        def findParent(i):\n            cur=i\n            while parent[cur]!=cur:\n                cur=parent[cur]\n            parent[i]=cur\n            return cur       \n        def union(u,v):\n            uParent=findParent(u)\n            vParent=findParent(v)\n            if rank[uParent]<rank[vParent]:\n                parent[uParent]=vParent\n                segmentSum[vParent]+=segmentSum[uParent]\n            elif rank[uParent]>rank[vParent]:\n                parent[vParent]=uParent\n                segmentSum[uParent]+=segmentSum[vParent]\n            else:\n                parent[vParent]=uParent\n                rank[uParent]+=1\n                segmentSum[uParent]+=segmentSum[vParent]                \n        n=len(nums)\n        parent=[i for i in range(n)]\n        segmentSum=[0]*n\n        rank=[0]*n\n        ans=[0]*n\n        maxSegmentSum=0\n        for j in range(n-1,-1,-1):\n            idx=removeQueries[j]\n            segmentSum[idx]=nums[idx]\n            if idx>0 and segmentSum[idx-1]>0:\n                union(idx,idx-1)\n            if idx<n-1 and segmentSum[idx+1]>0:\n                union(idx,idx+1)\n            ans[j]=maxSegmentSum\n            maxSegmentSum=max(maxSegmentSum,segmentSum[findParent(idx)])\n        return ans", "entry_point": "maximumSegmentSum", "test_list": ["assert maximumSegmentSum([1,2,5,6,1],[0,3,2,4,1])==[14,7,2,2,0]", "assert maximumSegmentSum([3,2,11,1],[3,2,1,0])==[16,5,3,0]"]}
{"Contest id": "Bi85/2381", "text_name": "字母移位 II", "text": "给你一个小写英文字母组成的字符串 s 和一个二维整数数组 shifts ，其中 shifts[i] = [starti, endi, directioni] 。对于每个 i ，将 s 中从下标 starti 到下标 endi （两者都包含）所有字符都进行移位运算，如果 directioni = 1 将字符向后移位，如果 directioni = 0 将字符向前移位。\n将一个字符 向后 移位的意思是将这个字符用字母表中 下一个 字母替换（字母表视为环绕的，所以 'z' 变成 'a'）。类似的，将一个字符 向前 移位的意思是将这个字符用字母表中 前一个 字母替换（字母表是环绕的，所以 'a' 变成 'z' ）。\n请你返回对 s 进行所有移位操作以后得到的最终字符串。", "canonical_solution": "def shiftingLetters(s, shifts):\n        import collections\n        import string\n        from collections import Counter\n        n = len(s)\n        d = collections.Counter()\n        for st, e, right in shifts:\n            d[st] += 1 if right else -1        \n            if e+1 < n:                         \n                d[e+1] += -1 if right else 1\n        prefix = [0]                           \n        ans = ''\n        for i in range(n):                     \n            cur = prefix[-1] + d[i]\n            prefix.append(cur)\n            ans += string.ascii_lowercase[(ord(s[i]) - ord('a') + cur) % 26]\n        return ans", "entry_point": "shiftingLetters", "test_list": ["assert shiftingLetters(\"abc\",[[0,1,0],[1,2,1],[0,2,1]])==\"ace\"", "assert shiftingLetters(\"dztz\",[[0,0,0],[1,1,1]])==\"catz\""]}
{"Contest id": "Bi85/2380", "text_name": "二进制字符串重新安排顺序需要的时间", "text": "给你一个二进制字符串 s 。在一秒之中，所有 子字符串 \"01\" 同时 被替换成 \"10\" 。这个过程持续进行到没有 \"01\" 存在。\n请你返回完成这个过程所需要的秒数。", "canonical_solution": "def secondsToRemoveOccurrences(s):\n        ans=0\n        while '01' in s:\n            ans+=1\n            s=s.replace('01','10')\n        return ans", "entry_point": "secondsToRemoveOccurrences", "test_list": ["assert secondsToRemoveOccurrences(\"0110101\")==4", "assert secondsToRemoveOccurrences(\"11100\")==0"]}
{"Contest id": "Bi85/2379", "text_name": "得到 K 个黑块的最少涂色次数", "text": "给你一个长度为 n 下标从 0 开始的字符串 blocks ，blocks[i] 要么是 'W' 要么是 'B' ，表示第 i 块的颜色。字符 'W' 和 'B' 分别表示白色和黑色。\n给你一个整数 k ，表示想要 连续 黑色块的数目。\n每一次操作中，你可以选择一个白色块将它 涂成 黑色块。\n请你返回至少出现 一次 连续 k 个黑色块的 最少 操作次数。", "canonical_solution": "def minimumRecolors(blocks, k):\n        n, minOps, flips, count, i = len(blocks), 1e9, 0, 0, 0\n        for j in range (n):\n            if blocks[j] == 'W':\n                flips += 1\n                count += 1\n            elif blocks[j] == 'B':\n                count += 1\n            if count == k:\n                minOps = min(minOps, flips)\n                if blocks[i] == 'W':\n                    flips -= 1\n                    count -= 1\n                else: count -= 1\n                i += 1\n        return minOps", "entry_point": "minimumRecolors", "test_list": ["assert minimumRecolors(\"WBBWWBBWBW\",7)==3", "assert minimumRecolors(\"WBWBBBW\",2)==0"]}
{"Contest id": "306/2376", "text_name": "统计特殊整数", "text": "如果一个正整数每一个数位都是 互不相同 的，我们称它是 特殊整数 。\n给你一个 正 整数 n ，请你返回区间 [1, n] 之间特殊整数的数目。", "canonical_solution": "def countSpecialNumbers(n):\n        dp = [[[[-1 for i in range(2)] for i in range(2)] for i in range(1<<10)] for i in range(10)]\n        def fun(i,leading_zeros,tight,memo):\n            if i==len(str(n)):\n                if leading_zeros==1:\n                    return 0\n                return 1\n            if dp[i][memo][tight][leading_zeros]!=-1:\n                return dp[i][memo][tight][leading_zeros]\n            end = 9\n            if tight==1:\n                end = int(str(n)[i])\n            ans = 0\n            for j in range(end+1):\n                if j==0:\n                    if leading_zeros==1:\n                        ans+=fun(i+1,1,tight&(j==end),memo)\n                    else:\n                        if memo&(1<<j)==0:\n                            ans+=fun(i+1,0,tight&(j==end),memo|(1<<j))\n                else:\n                    if memo&(1<<j)==0:\n                        ans+=fun(i+1,0,tight&(j==end),memo|(1<<j))\n            dp[i][memo][tight][leading_zeros] = ans\n            return ans\n        return fun(0,1,1,0)", "entry_point": "countSpecialNumbers", "test_list": ["assert countSpecialNumbers(20)==19", "assert countSpecialNumbers(5)==5", "assert countSpecialNumbers(135)==110"]}
{"Contest id": "306/2375", "text_name": "根据模式串构造最小数字", "text": "给你下标从 0 开始、长度为 n 的字符串 pattern ，它包含两种字符，'I' 表示 上升 ，'D' 表示 下降 。\n你需要构造一个下标从 0 开始长度为 n + 1 的字符串，且它要满足以下条件：\nnum 包含数字 '1' 到 '9' ，其中每个数字 至多 使用一次。\n如果 pattern[i] == 'I' ，那么 num[i] < num[i + 1] 。\n如果 pattern[i] == 'D' ，那么 num[i] > num[i + 1] 。\n请你返回满足上述条件字典序 最小 的字符串 num。", "canonical_solution": "def smallestNumber(pattern):\n        ans = []\n        dec_count = 0\n        for i in range(len(pattern)):\n            if pattern[i] == \"I\":\n                for j in range(i, i-dec_count-1,-1):\n                    ans.append(str(j+1))\n                dec_count = 0\n            elif pattern[i] == \"D\":\n                dec_count += 1\n        for j in range(len(pattern), len(pattern)-dec_count-1,-1):\n            ans.append(str(j+1))\n        return \"\".join(ans)", "entry_point": "smallestNumber", "test_list": ["assert smallestNumber(\"IIIDIDDD\")==\"123549876\"", "assert smallestNumber(\"DDD\")==\"4321\""]}
{"Contest id": "306/2374", "text_name": "边积分最高的节点", "text": "给你一个有向图，图中有 n 个节点，节点编号从 0 到 n - 1 ，其中每个节点都 恰有一条 出边。\n图由一个下标从 0 开始、长度为 n 的整数数组 edges 表示，其中 edges[i] 表示存在一条从节点 i 到节点 edges[i] 的 有向 边。\n节点 i 的 边积分 定义为：所有存在一条指向节点 i 的边的节点的 编号 总和。\n返回 边积分 最高的节点。如果多个节点的 边积分 相同，返回编号 最小 的那个。", "canonical_solution": "def edgeScore(edges):\n        n = len(edges)\n        edge_score = {i:0 for i in range(n)}  \n        for start, end in enumerate(edges):\n            edge_score[end] += start           \n        maximum = max(edge_score.values())\n        candidates = [node for node, score in edge_score.items() if score == maximum]\n        candidates.sort()\n        return candidates[0]", "entry_point": "edgeScore", "test_list": ["assert edgeScore([1,0,0,0,0,7,7,5])==7", "assert edgeScore([2,0,0,2])==0"]}
{"Contest id": "306/2373", "text_name": "矩阵中的局部最大值", "text": "给你一个大小为 n x n 的整数矩阵 grid 。\n生成一个大小为 (n - 2) x (n - 2) 的整数矩阵  maxLocal ，并满足：\nmaxLocal[i][j] 等于 grid 中以 i + 1 行和 j + 1 列为中心的 3 x 3 矩阵中的 最大值 。\n换句话说，我们希望找出 grid 中每个 3 x 3 矩阵中的最大值。\n返回生成的矩阵。", "canonical_solution": "def largestLocal(grid):\n        l=len(grid)-2\n        ans=[]\n        for i in range(l):\n            ans.append([0]*l)\n        for i in range(l):\n            for j in range(l):\n                ans[i][j] = max(grid[i][j],grid[i][j+1],grid[i][j+2],\n                      grid[i+1][j],grid[i+1][j+1],grid[i+1][j+2],\n                      grid[i+2][j],grid[i+2][j+1],grid[i+2][j+2])\n        return ans", "entry_point": "largestLocal", "test_list": ["assert largestLocal([[9,9,8,1],[5,6,2,6],[8,2,6,4],[6,2,2,2]])==[[9,9],[8,6]]", "assert largestLocal([[1,1,1,1,1],[1,1,1,1,1],[1,1,2,1,1],[1,1,1,1,1],[1,1,1,1,1]])==[[2,2,2],[2,2,2],[2,2,2]]"]}
{"Contest id": "305/2370", "text_name": "最长理想子序列", "text": "给你一个由小写字母组成的字符串 s ，和一个整数 k 。如果满足下述条件，则可以将字符串 t 视作是 理想字符串 ：\nt 是字符串 s 的一个子序列。\nt 中每两个 相邻 字母在字母表中位次的绝对差值小于或等于 k 。\n返回 最长 理想字符串的长度。\n字符串的子序列同样是一个字符串，并且子序列还满足：可以经由其他字符串删除某些字符（也可以不删除）但不改变剩余字符的顺序得到。\n注意：字母表顺序不会循环。例如，'a' 和 'z' 在字母表中位次的绝对差值是 25 ，而不是 1 。", "canonical_solution": "def longestIdealString(s, k):\n        dp = [0] * 128\n        for c in s:\n            i = ord(c)\n            dp[i] = max(dp[i - k : i + k + 1]) + 1\n        return max(dp)", "entry_point": "longestIdealString", "test_list": ["assert longestIdealString(\"acfgbd\",2)==4", "assert longestIdealString(\"abcd\",3)==4"]}
{"Contest id": "305/2369", "text_name": "检查数组是否存在有效划分", "text": "给你一个下标从 0 开始的整数数组 nums ，你必须将数组划分为一个或多个 连续 子数组。\n如果获得的这些子数组中每个都能满足下述条件 之一 ，则可以称其为数组的一种 有效 划分：\n子数组 恰 由 2 个相等元素组成，例如，子数组 [2,2] 。\n子数组 恰 由 3 个相等元素组成，例如，子数组 [4,4,4] 。\n子数组 恰 由 3 个连续递增元素组成，并且相邻元素之间的差值为 1 。例如，子数组 [3,4,5] ，但是子数组 [1,3,5] 不符合要求。\n如果数组 至少 存在一种有效划分，返回 true ，否则，返回 false 。", "canonical_solution": "def validPartition(nums):\n        n = len(nums)\n        dp = [False] * (n + 1)\n        dp[0] = True        \n        if nums[1] == nums[0]:\n            dp[2] = True       \n        for i in range(2, n):\n            if nums[i] == nums[i - 1]:\n                dp[i + 1] = dp[i + 1] or dp[i - 1]            \n            if nums[i] == nums[i - 1] and nums[i] == nums[i - 2]:\n                dp[i + 1] = dp[i + 1] or dp[i - 2]\n            if nums[i] == nums[i - 1] + 1 and nums[i] == nums[i - 2] + 2:\n                dp[i + 1] = dp[i + 1] or dp[i - 2]\n        return dp[n]", "entry_point": "validPartition", "test_list": ["assert validPartition([4,4,4,5,6])==True", "assert validPartition([1,1,1,2])==False"]}
{"Contest id": "305/2367", "text_name": "算术三元组的数目", "text": "给你一个下标从 0 开始、严格递增 的整数数组 nums 和一个正整数 diff 。如果满足下述全部条件，则三元组 (i, j, k) 就是一个 算术三元组 ：\ni < j < k ，\nnums[j] - nums[i] == diff 且\nnums[k] - nums[j] == diff\n返回不同 算术三元组 的数目。", "canonical_solution": "def arithmeticTriplets(nums, diff):\n        ans = 0\n        n = len(nums)\n        for i in range(n):\n            if nums[i] + diff in nums and nums[i] + 2 * diff in nums:\n                ans += 1\n        return ans", "entry_point": "arithmeticTriplets", "test_list": ["assert arithmeticTriplets([0,1,4,6,7,10],3)==2", "assert arithmeticTriplets([4,5,6,7,8,9],2)==2"]}
{"Contest id": "Bi84/2366", "text_name": "将数组排序的最少替换次数", "text": "给你一个下标从 0 开始的整数数组 nums 。每次操作中，你可以将数组中任何一个元素替换为 任意两个 和为该元素的数字。\n比方说，nums = [5,6,7] 。一次操作中，我们可以将 nums[1] 替换成 2 和 4 ，将 nums 转变成 [5,2,4,7] 。\n请你执行上述操作，将数组变成元素按 非递减 顺序排列的数组，并返回所需的最少操作次数。", "canonical_solution": "def minimumReplacement(A):\n        x = A[-1]\n        res = 0\n        for a in reversed(A):\n            k = (a + x - 1) // x\n            x = a // k\n            res += k - 1\n        return res", "entry_point": "minimumReplacement", "test_list": ["assert minimumReplacement([3,9,3])==2", "assert minimumReplacement([1,2,3,4,5])==0"]}
{"Contest id": "Bi84/2365", "text_name": "任务调度器 II", "text": "给你一个下标从 0 开始的正整数数组 tasks ，表示需要 按顺序 完成的任务，其中 tasks[i] 表示第 i 件任务的 类型 。\n同时给你一个正整数 space ，表示一个任务完成 后 ，另一个 相同 类型任务完成前需要间隔的 最少 天数。\n在所有任务完成前的每一天，你都必须进行以下两种操作中的一种：\n完成 tasks 中的下一个任务\n休息一天\n请你返回完成所有任务所需的 最少 天数。", "canonical_solution": "def taskSchedulerII(A,space):\n        last = defaultdict(lambda: - len(A) - 10)\n        res = 0\n        for a in A:\n            last[a] = res = max(res, last[a] + space) + 1\n        return res", "entry_point": "taskSchedulerII", "test_list": ["assert taskSchedulerII([1,2,1,2,3,1],3)==9", "assert taskSchedulerII([5,8,8,5],2)==6"]}
{"Contest id": "Bi84/2364", "text_name": "统计坏数对的数目", "text": "给你一个下标从 0 开始的整数数组 nums 。如果 i < j 且 j - i != nums[j] - nums[i] ，那么我们称 (i, j) 是一个 坏数对 。\n请你返回 nums 中 坏数对 的总数目。", "canonical_solution": "def countBadPairs(nums):\n        count=0\n        n=len(nums)\n        d={}\n        for i in range(n):\n            if nums[i]-i in d:\n                count+=d[nums[i]-i]\n                d[nums[i]-i]+=1\n            else:\n                d[nums[i]-i]=1\n        return (n*(n-1)//2) - count", "entry_point": "countBadPairs", "test_list": ["assert countBadPairs([4,1,3,3])==5", "assert countBadPairs([1,2,3,4,5])==0"]}
{"Contest id": "Bi84/2363", "text_name": "合并相似的物品", "text": "给你两个二维整数数组 items1 和 items2 ，表示两个物品集合。每个数组 items 有以下特质：\nitems[i] = [valuei, weighti] 其中 valuei 表示第 i 件物品的 价值 ，weighti 表示第 i 件物品的 重量 。\nitems 中每件物品的价值都是 唯一的 。\n请你返回一个二维数组 ret，其中 ret[i] = [valuei, weighti]， weighti 是所有价值为 valuei 物品的 重量之和 。\n注意：ret 应该按价值 升序 排序后返回。", "canonical_solution": "def mergeSimilarItems(items1, items2):\n        hashset = {}\n        for i in range(len(items1)):\n            if items1[i][0] in hashset:\n                hashset[items1[i][0]] += items1[i][1]\n            else:\n                hashset[items1[i][0]] = items1[i][1]\n\n        for i in range(len(items2)):\n            if items2[i][0] in hashset:\n                hashset[items2[i][0]] += items2[i][1]\n            else:\n                hashset[items2[i][0]] = items2[i][1]       \n        ans = []\n        for i in sorted(hashset):\n            ans.append([i, hashset[i]])       \n        return ans", "entry_point": "mergeSimilarItems", "test_list": ["assert mergeSimilarItems([[1,1],[4,5],[3,8]],[[3,1],[1,5]])==[[1,6],[3,9],[4,5]]", "assert mergeSimilarItems([[1,1],[3,2],[2,3]],[[2,1],[3,2],[1,3]])==[[1,4],[2,4],[3,4]]", "assert mergeSimilarItems([[1,3],[2,2]],[[7,1],[2,2],[1,4]])==[[1,7],[2,4],[7,1]]"]}
{"Contest id": "304/2360", "text_name": "图中的最长环", "text": "给你一个 n 个节点的 有向图 ，节点编号为 0 到 n - 1 ，其中每个节点 至多 有一条出边。\n图用一个大小为 n 下标从 0 开始的数组 edges 表示，节点 i 到节点 edges[i] 之间有一条有向边。如果节点 i 没有出边，那么 edges[i] == -1 。\n请你返回图中的 最长 环，如果没有任何环，请返回 -1 。\n一个环指的是起点和终点是 同一个 节点的路径。", "canonical_solution": "def longestCycle(edges):\n        from collections import Counter\n        n = len(edges)\n        indeg = Counter(edges)\n        stack = [node for node in range(n) if indeg[node] == 0]\n        inCycle = {node for node in range(n)}\n        while stack:\n            cur = stack.pop()\n            inCycle.remove(cur)\n            nei = edges[cur]\n            if nei == -1:\n                continue\n            indeg[nei] -= 1\n            if indeg[nei] == 0:\n                stack.append(nei)\n        def dfs(s):\n            stack = [s]\n            seen.add(s)\n            res = 0\n            while stack:\n                res += 1\n                cur = stack.pop()\n\n                nei = edges[cur]\n                if nei not in seen:\n                    seen.add(nei)\n                    stack.append(nei)\n            return res\n        seen = set()\n        res = 0\n        for i in inCycle:\n            if i not in seen:\n                res = max(res, dfs(i))\n        return res if res else -1", "entry_point": "longestCycle", "test_list": ["assert longestCycle([3,3,4,2,3])==3", "assert longestCycle([2,-1,3,1])==-1"]}
{"Contest id": "304/2359", "text_name": "找到离给定两个节点最近的节点", "text": "给你一个 n 个节点的 有向图 ，节点编号为 0 到 n - 1 ，每个节点 至多 有一条出边。\n有向图用大小为 n 下标从 0 开始的数组 edges 表示，表示节点 i 有一条有向边指向 edges[i] 。如果节点 i 没有出边，那么 edges[i] == -1 。\n同时给你两个节点 node1 和 node2 。\n请你返回一个从 node1 和 node2 都能到达节点的编号，使节点 node1 和节点 node2 到这个节点的距离 较大值最小化。如果有多个答案，请返回 最小 的节点编号。如果答案不存在，返回 -1 。\n注意 edges 可能包含环。", "canonical_solution": "def closestMeetingNode(edges, node1, node2):\n        visited1 = set()\n        visited2 = set()\n        ans = set()        \n        while node1 != -1 or node2 != -1:\n            if node1 != -1 and ((node1 in visited2) or node1 == node2):\n                ans.add(node1)\n            if node2 != -1 and ((node2 in visited1) or node1 == node2):\n                ans.add(node2)\n            if ans:\n                return min(ans)\n            if node1 != -1 and node1 not in visited1:\n                visited1.add(node1)\n                node1 = edges[node1]\n            else:\n                node1 = -1\n            if node2 != -1 and node2 not in visited2:\n                visited2.add(node2)\n                node2 = edges[node2]\n            else:\n                node2 = -1\n        return -1", "entry_point": "closestMeetingNode", "test_list": ["assert closestMeetingNode([2,2,3,-1],0,1)==2", "assert closestMeetingNode([1,2,-1],0,2)==2"]}
{"Contest id": "304/2358", "text_name": "分组的最大数量", "text": "给你一个正整数数组 grades ，表示大学中一些学生的成绩。你打算将 所有 学生分为一些 有序 的非空分组，其中分组间的顺序满足以下全部条件：\n第 i 个分组中的学生总成绩 小于 第 (i + 1) 个分组中的学生总成绩，对所有组均成立（除了最后一组）。\n第 i 个分组中的学生总数 小于 第 (i + 1) 个分组中的学生总数，对所有组均成立（除了最后一组）。\n返回可以形成的 最大 组数。", "canonical_solution": "def maximumGroups(grades):\n     from math import sqrt\n     return  int(-.5+sqrt(.25+2*len(grades)))", "entry_point": "maximumGroups", "test_list": ["assert maximumGroups([10,6,12,7,3,5])==3", "assert maximumGroups([8,8])==1"]}
{"Contest id": "304/2357", "text_name": "使数组中所有元素都等于零", "text": "给你一个非负整数数组 nums 。在一步操作中，你必须：\n选出一个正整数 x ，x 需要小于或等于 nums 中 最小 的 非零 元素。\nnums 中的每个正整数都减去 x。\n返回使 nums 中所有元素都等于 0 需要的 最少 操作数。", "canonical_solution": "def minimumOperations(nums):\n        c,n=0,len(nums)\n        def smallestNonZero():\n            x=101\n            for i in nums:\n                if i==0:\n                    continue\n                if i<x:\n                    x=i\n            return x\n        while sum(nums)!=0:\n            c+=1\n            x=smallestNonZero()\n            for i in range(n):\n                if nums[i]==0:\n                    continue\n                nums[i]-=x\n        return c", "entry_point": "minimumOperations", "test_list": ["assert minimumOperations([1,5,0,3,5])==3", "assert minimumOperations([0])==0"]}
{"Contest id": "303/2354", "text_name": "优质数对的数目", "text": "给你一个下标从 0 开始的正整数数组 nums 和一个正整数 k 。\n如果满足下述条件，则数对 (num1, num2) 是 优质数对 ：\nnum1 和 num2 都 在数组 nums 中存在。\nnum1 OR num2 和 num1 AND num2 的二进制表示中值为 1 的位数之和大于等于 k ，其中 OR 是按位 或 操作，而 AND 是按位 与 操作。\n返回 不同 优质数对的数目。\n如果 a != c 或者 b != d ，则认为 (a, b) 和 (c, d) 是不同的两个数对。例如，(1, 2) 和 (2, 1) 不同。\n注意：如果 num1 在数组中至少出现 一次 ，则满足 num1 == num2 的数对 (num1, num2) 也可以是优质数对。", "canonical_solution": "def countExcellentPairs(nums, k):\n        A  = sorted([bin(n).count('1') for n in set(nums)])\n        res = 0\n        p1, p2 = 0, len(A) - 1\n        while p1 < p2:\n            if A[p1] + A[p2] >= k:\n                res += (p2 - p1) * 2 \n                p2 -= 1\n            else:\n                p1 += 1        \n        for n in A:\n            if 2 * n >= k:\n                res += 1\n        return res", "entry_point": "countExcellentPairs", "test_list": ["assert countExcellentPairs([1,2,3,1],3)==5", "assert countExcellentPairs([5,1,1],10)==0"]}
{"Contest id": "303/2352", "text_name": "相等行列对", "text": "给你一个下标从 0 开始、大小为 n x n 的整数矩阵 grid ，返回满足 Ri 行和 Cj 列相等的行列对 (Ri, Cj) 的数目。\n如果行和列以相同的顺序包含相同的元素（即相等的数组），则认为二者是相等的。", "canonical_solution": "def equalPairs(grid):\n        from collections import Counter\n        tpse = Counter(zip(*grid))                \n        grid = Counter(map(tuple,grid))            \n        return  sum(tpse[t]*grid[t] for t in tpse)  ", "entry_point": "equalPairs", "test_list": ["assert equalPairs([[3,2,1],[1,7,6],[2,7,7]])==1", "assert equalPairs([[3,1,2,2],[1,4,4,5],[2,4,2,2],[2,4,2,2]])==3"]}
{"Contest id": "303/2351", "text_name": "第一个出现两次的字母", "text": "给你一个由小写英文字母组成的字符串 s ，请你找出并返回第一个出现 两次 的字母。\n注意：\n如果 a 的 第二次 出现比 b 的 第二次 出现在字符串中的位置更靠前，则认为字母 a 在字母 b 之前出现两次。\ns 包含至少一个出现两次的字母。", "canonical_solution": "def repeatedCharacter(s):\n        from collections import defaultdict\n        occurences = defaultdict(int)\n        for char in s:\n            occurences[char] += 1\n            if occurences[char] == 2:\n                return char", "entry_point": "repeatedCharacter", "test_list": ["assert repeatedCharacter(\"abccbaacz\")==\"c\"", "assert repeatedCharacter(\"abcdd\")==\"d\""]}
{"Contest id": "Bi83/2350", "text_name": "不可能得到的最短骰子序列", "text": "给你一个长度为 n 的整数数组 rolls 和一个整数 k 。你扔一个 k 面的骰子 n 次，骰子的每个面分别是 1 到 k ，其中第 i 次扔得到的数字是 rolls[i] 。\n请你返回 无法 从 rolls 中得到的 最短 骰子子序列的长度。\n扔一个 k 面的骰子 len 次得到的是一个长度为 len 的 骰子子序列 。\n注意 ，子序列只需要保持在原数组中的顺序，不需要连续。", "canonical_solution": "def shortestSequence(rolls, k):\n        res = 1\n        s = set()\n        for a in rolls:\n            s.add(a)\n            if len(s) == k:\n                res += 1\n                s.clear()\n        return res", "entry_point": "shortestSequence", "test_list": ["assert shortestSequence([4,2,1,2,3,3,2,4,1],4)==3", "assert shortestSequence([1,1,2,2],2)==2", "assert shortestSequence([1,1,3,2,2,2,3,3],4)==1"]}
{"Contest id": "Bi83/2348", "text_name": "全0子数组的数目", "text": "给你一个整数数组 nums ，返回全部为 0 的 子数组 数目。\n子数组 是一个数组中一段连续非空元素组成的序列。", "canonical_solution": "def zeroFilledSubarray(nums):\n        total_zero_subarrays = current_zero_subarrays = 0                \n        for num in nums:\n            if num == 0:\n                current_zero_subarrays += 1\n                total_zero_subarrays += current_zero_subarrays\n            else:\n                current_zero_subarrays = 0                \n        return total_zero_subarrays", "entry_point": "zeroFilledSubarray", "test_list": ["assert zeroFilledSubarray([1,3,0,0,2,0,0,4])==6", "assert zeroFilledSubarray([0,0,0,2,0,0])==9", "assert zeroFilledSubarray([2,10,2019])==0"]}
{"Contest id": "Bi83/2347", "text_name": "最好的扑克手牌", "text": "给你一个整数数组 ranks 和一个字符数组 suit 。你有 5 张扑克牌，第 i 张牌大小为 ranks[i] ，花色为 suits[i] 。\n下述是从好到坏你可能持有的 手牌类型 ：\n\"Flush\"：同花，五张相同花色的扑克牌。\n\"Three of a Kind\"：三条，有 3 张大小相同的扑克牌。\n\"Pair\"：对子，两张大小一样的扑克牌。\n\"High Card\"：高牌，五张大小互不相同的扑克牌。\n请你返回一个字符串，表示给定的 5 张牌中，你能组成的 最好手牌类型 。\n注意：返回的字符串 大小写 需与题目描述相同。", "canonical_solution": "def bestHand(ranks, suits):\n    from collections import Counter\n    max_rank_cnt = max(Counter(ranks).values())\n    max_suit_cnt = max(Counter(suits).values())\n    return {\n        max_rank_cnt == 2: 'Pair',\n        max_rank_cnt >= 3: 'Three of a Kind',\n        max_suit_cnt == 5: 'Flush',\n    }.get(True, 'High Card')", "entry_point": "bestHand", "test_list": ["assert bestHand([13,2,3,1,9],[\"a\",\"a\",\"a\",\"a\",\"a\"])==\"Flush\"", "assert bestHand([4,4,2,4,4],[\"d\",\"a\",\"a\",\"b\",\"c\"])==\"Three of a Kind\"", "assert bestHand([10,10,2,12,9], [\"a\",\"b\",\"c\",\"a\",\"d\"])==\"Pair\""]}
{"Contest id": "302/2343", "text_name": "裁剪数字后查询第k小的数字", "text": "给你一个下标从 0 开始的字符串数组 nums ，其中每个字符串 长度相等 且只包含数字。\n再给你一个下标从 0 开始的二维整数数组 queries ，其中 queries[i] = [ki, trimi] 。对于每个 queries[i] ，你需要：\n将 nums 中每个数字 裁剪 到剩下 最右边 trimi 个数位。\n在裁剪过后的数字中，找到 nums 中第 ki 小数字对应的 下标 。如果两个裁剪后数字一样大，那么下标 更小 的数字视为更小的数字。\n将 nums 中每个数字恢复到原本字符串。\n请你返回一个长度与 queries 相等的数组 answer，其中 answer[i]是第 i 次查询的结果。\n提示：\n裁剪到剩下最右边 x 个数位的意思是不断删除最左边的数位，直到剩下 x 个数位。\nnums 中的字符串可能会有前导 0 。", "canonical_solution": "def smallestTrimmedNumbers(nums, queries):\n        from collections import defaultdict\n        sl = len(nums[0])\n        len_to_sorted = defaultdict(list)\n        ans = [0] * len(queries)       \n        for i, (k_smallest, trim_len) in enumerate(queries):\n            if trim_len not in len_to_sorted:\n                # have to trim\n                for ni, num in enumerate(nums):\n                    len_to_sorted[trim_len].append( (int(num[sl - trim_len:]), ni) )                    \n                len_to_sorted[trim_len] = sorted(len_to_sorted[trim_len])\n            ans[i] = len_to_sorted[trim_len][k_smallest -1][1]           \n        return ans", "entry_point": "smallestTrimmedNumbers", "test_list": ["assert smallestTrimmedNumbers([\"102\",\"473\",\"251\",\"814\"],[[1,1],[2,3],[4,2],[1,2]])==[2,2,1,0]", "assert smallestTrimmedNumbers([\"24\",\"37\",\"96\",\"04\"],[[2,1],[2,2]])==[3,0]"]}
{"Contest id": "302/2342", "text_name": "数位和相等数对的最大和", "text": "给你一个下标从 0 开始的数组 nums ，数组中的元素都是 正 整数。请你选出两个下标 i 和 j（i != j），且 nums[i] 的数位和 与  nums[j] 的数位和相等。\n请你找出所有满足条件的下标 i 和 j ，找出并返回 nums[i] + nums[j] 可以得到的 最大值 。", "canonical_solution": "def maximumSum(nums):\n        dict_map = {}        \n        res = -1\n        for num in nums:\n            temp = num\n            new_num = 0\n            while temp:\n                new_num += temp % 10\n                temp = temp // 10\n            if new_num in dict_map:\n                new_res = num + dict_map[new_num]\n                res = max(res, new_res)\n                dict_map[new_num] = max(num, dict_map[new_num])\n            else:\n                dict_map[new_num] = num\n        return res", "entry_point": "maximumSum", "test_list": ["assert maximumSum([18,43,36,13,7])==54", "assert maximumSum([10,12,19,14])==-1"]}
{"Contest id": "302/2341", "text_name": "数组能形成多少数对", "text": "给你一个下标从 0 开始的整数数组 nums 。在一步操作中，你可以执行以下步骤：\n从 nums 选出 两个 相等的 整数\n从 nums 中移除这两个整数，形成一个 数对\n请你在 nums 上多次执行此操作直到无法继续执行。\n返回一个下标从 0 开始、长度为 2 的整数数组 answer 作为答案，其中 answer[0] 是形成的数对数目，answer[1] 是对 nums 尽可能执行上述操作后剩下的整数数目。", "canonical_solution": "def numberOfPairs(nums):\n        output = []  \n        pair = 0\n        unique = list(set(nums)) \n        for i in range(len(unique)):\n            count = nums.count(unique[i]) \n            if count % 2 !=0:\n                output.append(unique[i]) \n            pair += (count)//2 \n        return [pair,len(output)] ", "entry_point": "numberOfPairs", "test_list": ["assert numberOfPairs([1,3,2,1,3,2,2])==[3,1]", "assert numberOfPairs([1,1])==[1,0]", "assert numberOfPairs([0])==[0,1]"]}
{"Contest id": "301/2338", "text_name": "统计理想数组的数目", "text": "给你两个整数 n 和 maxValue ，用于描述一个 理想数组 。\n对于下标从 0 开始、长度为 n 的整数数组 arr ，如果满足以下条件，则认为该数组是一个 理想数组 ：\n每个 arr[i] 都是从 1 到 maxValue 范围内的一个值，其中 0 <= i < n 。\n每个 arr[i] 都可以被 arr[i - 1] 整除，其中 0 < i < n 。\n返回长度为 n 的 不同 理想数组的数目。由于答案可能很大，返回对 109 + 7 取余的结果。", "canonical_solution": "def idealArrays(n, m):\n        mod, ans, comb = 10**9 + 7, m, 1\n        dp = [0] + [1] * m       \n        for i in range(1, min(n, 14)):\n            for j in range(m, 0, -1):\n                if dp[j] == 0: continue\n                for k in range(j << 1, m + 1, j):\n                    dp[k] += dp[j]\n                dp[j] = 0\n            comb = (comb * (n-i)) // i\n            ans = (ans + sum(dp) * comb) % mod\n        return ans", "entry_point": "idealArrays", "test_list": ["assert idealArrays(n = 2, m= 5) == 10", "assert idealArrays(n = 5, m= 3) == 11"]}
{"Contest id": "301/2337", "text_name": "移动片段得到字符串", "text": "给你两个字符串 start 和 target ，长度均为 n 。每个字符串 仅 由字符 'L'、'R' 和 '_' 组成，其中：\n字符 'L' 和 'R' 表示片段，其中片段 'L' 只有在其左侧直接存在一个 空位 时才能向 左 移动，而片段 'R' 只有在其右侧直接存在一个 空位 时才能向 右 移动。\n字符 '_' 表示可以被 任意 'L' 或 'R' 片段占据的空位。\n如果在移动字符串 start 中的片段任意次之后可以得到字符串 target ，返回 true ；否则，返回 false 。", "canonical_solution": "def canChange(start, target):\n        lcnt, rcnt = 0, 0\n        for c1, c2 in zip(start, target):\n            if c1 == 'L': lcnt += 1\n            if c2 == 'L': lcnt -= 1\n            if c1 == 'R': rcnt += 1\n            if c2 == 'R': rcnt -= 1\n        if lcnt or rcnt: return False\n        \n        s_ptr = 0\n        for t_ptr in range(len(target)):\n            if target[t_ptr] == '_':\n                continue\n            else:\n                while s_ptr < len(start) and start[s_ptr] == '_':\n                    s_ptr += 1\n                if (target[t_ptr] != start[s_ptr] or\n                    target[t_ptr] == 'L' and s_ptr < t_ptr or\n                    target[t_ptr] == 'R' and s_ptr > t_ptr):\n                    return False\n                s_ptr += 1\n        return True", "entry_point": "canChange", "test_list": ["assert canChange(start = \"_L__R__R_\", target = \"L______RR\") == True", "assert canChange(start = \"R_L_\", target = \"__LR\") == False", "assert canChange(start = \"_R\", target = \"R_\") == False"]}
{"Contest id": "301/2335", "text_name": "装满杯子需要的最短总时长", "text": "现有一台饮水机，可以制备冷水、温水和热水。每秒钟，可以装满 2 杯 不同 类型的水或者 1 杯任意类型的水。\n给你一个下标从 0 开始、长度为 3 的整数数组 amount ，其中 amount[0]、amount[1] 和 amount[2] 分别表示需要装满冷水、温水和热水的杯子数量。返回装满所有杯子所需的 最少 秒数。", "canonical_solution": "def fillCups(A):\n        return max(max(A), (sum(A) + 1) // 2)", "entry_point": "fillCups", "test_list": ["assert fillCups([1,4,2]) == 4", "assert fillCups([5,4,4]) == 7", "assert fillCups([5,0,0]) == 5"]}
{"Contest id": "Bi82/2334", "text_name": "元素值大于变化阈值的子数组", "text": "给你一个整数数组 nums 和一个整数 threshold 。\n找到长度为 k 的 nums 子数组，满足数组中 每个 元素都 大于 threshold / k 。\n请你返回满足要求的 任意 子数组的 大小 。如果没有这样的子数组，返回 -1 。\n子数组 是数组中一段连续非空的元素序列。\n ", "canonical_solution": "def validSubarraySize(nums, threshold):\n        nums = [0] + nums + [0]\n        stack = [0]\n        for i in range(1,len(nums)):\n            while nums[i] < nums[stack[-1]]:\n                tmp = nums[stack.pop()]\n                if tmp > threshold / (i - stack[-1] - 1):\n                    return i - stack[-1] - 1\n            stack.append(i)\n        return -1", "entry_point": "validSubarraySize", "test_list": ["assert validSubarraySize(nums = [1,3,4,3,1], threshold = 6) == 3", "assert validSubarraySize(nums = [6,5,6,5,8], threshold = 7) == 1"]}
{"Contest id": "Bi82/2333", "text_name": "最小差值平方和", "text": "给你两个下标从 0 开始的整数数组 nums1 和 nums2 ，长度为 n 。\n数组 nums1 和 nums2 的 差值平方和 定义为所有满足 0 <= i < n 的 (nums1[i] - nums2[i])2 之和。\n同时给你两个正整数 k1 和 k2 。你可以将 nums1 中的任意元素 +1 或者 -1 至多 k1 次。类似的，你可以将 nums2 中的任意元素 +1 或者 -1 至多 k2 次。\n请你返回修改数组 nums1 至多 k1 次且修改数组 nums2 至多 k2 次后的最小 差值平方和 。\n注意：你可以将数组中的元素变成 负 整数。", "canonical_solution": "def minSumSquareDiff(nums1, nums2, k1, k2):\n        from heapq import heapify, heappush, heappop\n        heap = [ -abs(x-y) for x, y in zip(nums1, nums2)]\n        s = -sum(heap)\n        if k1+k2 >= s: return 0\n        delta = k1 + k2\n        heapify(heap)\n        n = len(nums1)\n        while delta > 0:\n            d = -heappop(heap)\n            gap = max(delta//n, 1) if heap else delta\n            d -= gap\n            heappush(heap, -d)\n            delta -= gap\n        return sum(pow(e,2) for e in heap)", "entry_point": "minSumSquareDiff", "test_list": ["assert minSumSquareDiff(nums1 = [1,2,3,4], nums2 = [2,10,20,19], k1 = 0, k2 = 0) == 579", "assert minSumSquareDiff(nums1 = [1,4,10,12], nums2 = [5,8,6,9], k1 = 1, k2 = 1) == 43"]}
{"Contest id": "Bi82/2332", "text_name": "坐上公交的最晚时间", "text": "给你一个下标从 0 开始长度为 n 的整数数组 buses ，其中 buses[i] 表示第 i 辆公交车的出发时间。同时给你一个下标从 0 开始长度为 m 的整数数组 passengers ，其中 passengers[j] 表示第 j 位乘客的到达时间。所有公交车出发的时间互不相同，所有乘客到达的时间也互不相同。\n给你一个整数 capacity ，表示每辆公交车 最多 能容纳的乘客数目。\n每位乘客都会搭乘下一辆有座位的公交车。如果你在 y 时刻到达，公交在 x 时刻出发，满足 y <= x  且公交没有满，那么你可以搭乘这一辆公交。最早 到达的乘客优先上车。\n返回你可以搭乘公交车的最晚到达公交站时间。你 不能 跟别的乘客同时刻到达。\n注意：数组 buses 和 passengers 不一定是有序的。", "canonical_solution": "def latestTimeCatchTheBus(buses, passengers, capacity):\n        passengers.sort()\n        cur = 0\n\n        for time in sorted(buses):\n            cap = capacity\n            while cur < len(passengers) and passengers[cur] <= time and cap > 0:\n                cur += 1\n                cap -= 1\n\n        best = time if cap > 0 else passengers[cur - 1]\n\n        passengers = set(passengers)\n        while best in passengers:\n            best -= 1\n        return best", "entry_point": "latestTimeCatchTheBus", "test_list": ["assert latestTimeCatchTheBus(buses = [10,20], passengers = [2,17,18,19], capacity = 2) == 16", "assert latestTimeCatchTheBus(buses = [20,30,10], passengers = [19,13,26,4,25,11,21], capacity = 2) == 20"]}
{"Contest id": "300/2328", "text_name": "网格图中递增路径的数目", "text": "给你一个 m x n 的整数网格图 grid ，你可以从一个格子移动到 4 个方向相邻的任意一个格子。\n请你返回在网格图中从 任意 格子出发，达到 任意 格子，且路径中的数字是 严格递增 的路径数目。由于答案可能会很大，请将结果对 109 + 7 取余 后返回。\n如果两条路径中访问过的格子不是完全相同的，那么它们视为两条不同的路径。", "canonical_solution": "def countPaths(A):\n        m, n, mod = len(A), len(A[0]), 10 ** 9 + 7\n        dp = [[1] * n for i in range(m)]\n        for a, i, j in sorted([A[i][j], i, j] for i in range(m) for j in range(n)):\n            for x, y in [[i, j + 1], [i, j - 1], [i + 1, j], [i - 1, j]]:\n                if 0 <= x < m and 0 <= y < n and A[x][y] < A[i][j]:\n                    dp[i][j] += dp[x][y] % mod\n        return sum(map(sum, dp)) % mod", "entry_point": "countPaths", "test_list": ["assert countPaths([[1,1],[3,4]]) == 8", "assert countPaths([[1],[2]]) == 3"]}
{"Contest id": "300/2327", "text_name": "知道秘密的人数", "text": "在第 1 天，有一个人发现了一个秘密。\n给你一个整数 delay ，表示每个人会在发现秘密后的 delay 天之后，每天 给一个新的人 分享 秘密。同时给你一个整数 forget ，表示每个人在发现秘密 forget 天之后会 忘记 这个秘密。一个人 不能 在忘记秘密那一天及之后的日子里分享秘密。\n给你一个整数 n ，请你返回在第 n 天结束时，知道秘密的人数。由于答案可能会很大，请你将结果对 109 + 7 取余 后返回。\n ", "canonical_solution": "def peopleAwareOfSecret(n, delay, forget):\n        dp = [1] + [0] * forget\n        mod = 10 ** 9 + 7\n        share = 0\n        for i in range(1, n):\n            dp[i % forget] = share = (share + dp[(i - delay) % forget] - dp[i % forget]) % mod\n        return sum(dp) % mod", "entry_point": "peopleAwareOfSecret", "test_list": ["assert peopleAwareOfSecret(n = 6, delay = 2, forget = 4) == 5", "assert peopleAwareOfSecret(n = 4, delay = 1, forget = 3) == 6"]}
{"Contest id": "300/2325", "text_name": "解密消息", "text": "给你字符串 key 和 message ，分别表示一个加密密钥和一段加密消息。解密 message 的步骤如下：\n使用 key 中 26 个英文小写字母第一次出现的顺序作为替换表中的字母 顺序 。\n将替换表与普通英文字母表对齐，形成对照表。\n按照对照表 替换 message 中的每个字母。\n空格 ' ' 保持不变。\n例如，key = \"happy boy\"（实际的加密密钥会包含字母表中每个字母 至少一次），据此，可以得到部分对照表（'h' -> 'a'、'a' -> 'b'、'p' -> 'c'、'y' -> 'd'、'b' -> 'e'、'o' -> 'f'）。\n返回解密后的消息。", "canonical_solution": "def decodeMessage(key, message):\n        mapping = {' ': ' '}\n        i = 0\n        res = ''\n        letters = 'abcdefghijklmnopqrstuvwxyz'\n        \n        for char in key:\n            if char not in mapping:\n                mapping[char] = letters[i]\n                i += 1\n        \n        for char in message:\n            res += mapping[char]\n                \n        return res", "entry_point": "decodeMessage", "test_list": ["assert decodeMessage(key = \"the quick brown fox jumps over the lazy dog\", message = \"vkbs bs t suepuv\") == \"this is a secret\"", "assert decodeMessage(key = \"eljuxhpwnyrdgtqkviszcfmabo\", message = \"zwx hnfx lqantp mnoeius ycgk vcnjrdb\") == \"the five boxing wizards jump quickly\""]}
{"Contest id": "299/2321", "text_name": "拼接数组的最大分数", "text": "给你两个下标从 0 开始的整数数组 nums1 和 nums2 ，长度都是 n 。\n你可以选择两个整数 left 和 right ，其中 0 <= left <= right < n ，接着 交换 两个子数组 nums1[left...right] 和 nums2[left...right] 。\n例如，设 nums1 = [1,2,3,4,5] 和 nums2 = [11,12,13,14,15] ，整数选择 left = 1 和 right = 2，那么 nums1 会变为 [1,12,13,4,5] 而 nums2 会变为 [11,2,3,14,15] 。\n你可以选择执行上述操作 一次 或不执行任何操作。\n数组的 分数 取 sum(nums1) 和 sum(nums2) 中的最大值，其中 sum(arr) 是数组 arr 中所有元素之和。\n返回 可能的最大分数 。\n子数组 是数组中连续的一个元素序列。arr[left...right] 表示子数组包含 nums 中下标 left 和 right 之间的元素（含 下标 left 和 right 对应元素）。", "canonical_solution": "def maximumsSplicedArray(a, b):\n\n        n = len(a)\n\n        def C(a, b):\n\n            x, y, z = 0, 0, 0\n\n            for i in range(n):\n\n                x = max(a[i] + x, b[i] + y)\n                y = max(a[i] + z, b[i] + y)\n                z = a[i] + z\n\n            return max(x, y, z)\n\n        return max(C(a, b), C(b, a))", "entry_point": "maximumsSplicedArray", "test_list": ["assert maximumsSplicedArray([60,60,60], [10,90,10]) == 210", "assert maximumsSplicedArray([20,40,20,70,30], [50,20,50,40,20]) == 220", "assert maximumsSplicedArray([7,11,13], [1,1,1]) == 31"]}
{"Contest id": "299/2320", "text_name": "统计放置房子的方式数", "text": "一条街道上共有 n * 2 个 地块 ，街道的两侧各有 n 个地块。每一边的地块都按从 1 到 n 编号。每个地块上都可以放置一所房子。\n现要求街道同一侧不能存在两所房子相邻的情况，请你计算并返回放置房屋的方式数目。由于答案可能很大，需要对 109 + 7 取余后再返回。\n注意，如果一所房子放置在这条街某一侧上的第 i 个地块，不影响在另一侧的第 i 个地块放置房子。", "canonical_solution": "def countHousePlacements(n):\n        a, b, mod = 1, 1, 10**9 + 7\n        for i in range(n):\n            a, b = b, (a + b) % mod\n        return b * b % mod", "entry_point": "countHousePlacements", "test_list": ["assert countHousePlacements(n = 1) == 4", "assert countHousePlacements(n = 2) == 9"]}
{"Contest id": "299/2319", "text_name": "判断矩阵是否是一个 X 矩阵", "text": "如果一个正方形矩阵满足下述 全部 条件，则称之为一个 X 矩阵 ：\n矩阵对角线上的所有元素都 不是 0\n矩阵中所有其他元素都是 0\n给你一个大小为 n x n 的二维整数数组 grid ，表示一个正方形矩阵。如果 grid 是一个 X 矩阵 ，返回 true ；否则，返回 false 。", "canonical_solution": "def checkXMatrix(grid):\n        n = len(grid)\n        for i in range(n):\n            for j in range(n):\n                if i==j or (i+j) ==n-1:\n                    if grid[i][j] == 0:\n                        return False\n                elif grid[i][j] != 0: \n                    return False\n        return True", "entry_point": "checkXMatrix", "test_list": ["assert checkXMatrix(grid = [[2,0,0,1],[0,3,1,0],[0,5,2,0],[4,0,0,2]]) == True", "assert checkXMatrix(grid = [[5,7,0],[0,3,1],[0,5,0]]) == False"]}
{"Contest id": "Bi81/2318", "text_name": "不同骰子序列的数目", "text": "给你一个整数 n 。你需要掷一个 6 面的骰子 n 次。请你在满足以下要求的前提下，求出 不同 骰子序列的数目：\n序列中任意 相邻 数字的 最大公约数 为 1 。\n序列中 相等 的值之间，至少有 2 个其他值的数字。正式地，如果第 i 次掷骰子的值 等于 第 j 次的值，那么 abs(i - j) > 2 。\n请你返回不同序列的 总数目 。由于答案可能很大，请你将答案对 109 + 7 取余 后返回。\n如果两个序列中至少有一个元素不同，那么它们被视为不同的序列。\n ", "canonical_solution": "def distinctSequences(n):\n        l1 = [5, 3, 4, 3, 5, 2]\n        l2 = [12, 11, 12, 11, 12, 8]       \n        if n==1:\n            return 6\n        if n==2:\n            return sum(l1)       \n        mod = 10**9+7\n        for i in range(n-3):           \n            temp = [0]*6            \n            temp[0] = (sum(l2[1:]) - 4*l1[0] )%mod           \n            temp[1] = (l2[0]+l2[2]+l2[4] - 2*l1[1])%mod          \n            temp[2] = (l2[0]+l2[1]+l2[3]+l2[4] - 3*l1[2] )%mod           \n            temp[3] = (l2[0]+l2[2]+l2[4] - 2*l1[3])%mod           \n            temp[4] = (sum(l2[:4])+l2[5] - 4*l1[4])%mod           \n            temp[5] = (l2[0]+l2[4] - 1*l1[5] )%mod           \n            l1, l2 = l2, temp\n        return sum(l2)%mod", "entry_point": "distinctSequences", "test_list": ["assert distinctSequences(n = 4) == 184", "assert distinctSequences(n = 2) == 22"]}
{"Contest id": "Bi81/2317", "text_name": "操作后的最大异或和", "text": "给你一个下标从 0 开始的整数数组 nums 。一次操作中，选择 任意 非负整数 x 和一个下标 i ，更新 nums[i] 为 nums[i] AND (nums[i] XOR x) 。\n注意，AND 是逐位与运算，XOR 是逐位异或运算。\n请你执行 任意次 更新操作，并返回 nums 中所有元素 最大 逐位异或和。", "canonical_solution": "def maximumXOR(nums):\n        res=0\n        for i in nums:\n            res |= i\n        return res", "entry_point": "maximumXOR", "test_list": ["assert maximumXOR(nums = [3,2,4,6]) == 7", "assert maximumXOR(nums = [1,2,3,9,2]) == 11"]}
{"Contest id": "Bi81/2316", "text_name": "统计无向图中无法互相到达点对数", "text": "给你一个整数 n ，表示一张 无向图 中有 n 个节点，编号为 0 到 n - 1 。同时给你一个二维整数数组 edges ，其中 edges[i] = [ai, bi] 表示节点 ai 和 bi 之间有一条 无向 边。\n请你返回 无法互相到达 的不同 点对数目 。\n ", "canonical_solution": "def countPairs(n, edges):\n        from collections import deque\n        graph = {i: set() for i in range(n)}\n        for a, b in edges:\n            graph[a].add(b)\n            graph[b].add(a)\n        cmps, used = [], set()\n        for eg in graph:\n            if eg in used:\n                continue\n            q, counter = deque([eg]), 0\n            used.add(eg)\n            while q:\n                pp = q.popleft()\n                counter += 1\n                for nn in graph[pp]:\n                    if nn not in used:\n                        q.append(nn)\n                        used.add(nn)\n            cmps.append(counter)\n        prefix = [cmps[0]] + [0]*(len(cmps) - 1)\n        for i in range(1, len(cmps)):\n            prefix[i] = prefix[i - 1] + cmps[i]\n        ans = 0\n        for i in range(len(cmps)):\n            ans += (n - prefix[i])*cmps[i]\n        return ans", "entry_point": "countPairs", "test_list": ["assert countPairs(n = 3, edges = [[0,1],[0,2],[1,2]]) == 0", "assert countPairs(n = 7, edges = [[0,2],[0,5],[2,4],[1,6],[5,4]]) == 14"]}
{"Contest id": "Bi81/2315", "text_name": "统计星号", "text": "给你一个字符串 s ，每 两个 连续竖线 '|' 为 一对 。换言之，第一个和第二个 '|' 为一对，第三个和第四个 '|' 为一对，以此类推。\n请你返回 不在 竖线对之间，s 中 '*' 的数目。\n注意，每个竖线 '|' 都会 恰好 属于一个对。", "canonical_solution": "def countAsterisks(s):\n        lst=[] \n        for i in s: \n            if '|' not in lst: \n                lst.append(i) \n            elif '|' in lst and i=='|': \n                lst.pop() \n        return lst.count('*')", "entry_point": "countAsterisks", "test_list": ["assert countAsterisks(s = \"l|*e*et|c**o|*de|\") == 2", "assert countAsterisks(s = \"iamprogrammer\") == 0", "assert countAsterisks(s = \"yo|uar|e**|b|e***au|tifu|l\") == 5"]}
{"Contest id": "298/2312", "text_name": "卖木头块", "text": "给你两个整数 m 和 n ，分别表示一块矩形木块的高和宽。同时给你一个二维整数数组 prices ，其中 prices[i] = [hi, wi, pricei] 表示你可以以 pricei 元的价格卖一块高为 hi 宽为 wi 的矩形木块。\n每一次操作中，你必须按下述方式之一执行切割操作，以得到两块更小的矩形木块：\n沿垂直方向按高度 完全 切割木块，或\n沿水平方向按宽度 完全 切割木块\n在将一块木块切成若干小木块后，你可以根据 prices 卖木块。你可以卖多块同样尺寸的木块。你不需要将所有小木块都卖出去。你 不能 旋转切好后木块的高和宽。\n请你返回切割一块大小为 m x n 的木块后，能得到的 最多 钱数。\n注意你可以切割木块任意次。", "canonical_solution": "def sellingWood(m, n, prices):\n        dp = [[0] * (n + 1) for i in range(m+1)]\n        for w, h, p in prices:\n            dp[w][h] = p\n        for w in range(1, m + 1):\n            for h in range(1, n + 1):\n                for a in range(1, w // 2 + 1):\n                    dp[w][h] = max(dp[w][h], dp[a][h] + dp[w - a][h])\n                for a in range(1, h // 2 + 1):\n                    dp[w][h] = max(dp[w][h], dp[w][a] + dp[w][h - a])\n        return dp[m][n]", "entry_point": "sellingWood", "test_list": ["assert sellingWood(m = 3, n = 5, prices = [[1,4,2],[2,2,7],[2,1,3]]) == 19", "assert sellingWood(m = 4, n = 6, prices = [[3,2,10],[1,4,2],[4,1,3]]) == 32"]}
{"Contest id": "298/2311", "text_name": "小于等于 K 的最长二进制子序列", "text": "给你一个二进制字符串 s 和一个正整数 k 。\n请你返回 s 的 最长 子序列，且该子序列对应的 二进制 数字小于等于 k 。\n注意：\n子序列可以有 前导 0 。\n空字符串视为 0 。\n子序列 是指从一个字符串中删除零个或者多个字符后，不改变顺序得到的剩余字符序列。", "canonical_solution": "def longestSubsequence(s, k):\n        dp = [0]\n        for v in map(int, s):\n            if dp[-1] * 2 + v <= k:\n                dp.append(dp[-1] * 2 + v)\n            for i in range(len(dp) - 1, 0, -1):\n                dp[i] = min(dp[i], dp[i - 1] * 2 + v)\n        return len(dp) - 1", "entry_point": "longestSubsequence", "test_list": ["assert longestSubsequence(s = \"1001010\", k = 5) == 5", "assert longestSubsequence(s = \"00101001\", k = 1) == 6"]}
{"Contest id": "298/2310", "text_name": "个位数字为 K 的整数之和", "text": "给你两个整数 num 和 k ，考虑具有以下属性的正整数多重集：\n每个整数个位数字都是 k 。\n所有整数之和是 num 。\n返回该多重集的最小大小，如果不存在这样的多重集，返回 -1 。\n注意：\n多重集与集合类似，但多重集可以包含多个同一整数，空多重集的和为 0 。\n个位数字 是数字最右边的数位。", "canonical_solution": "def minimumNumbers(num, k):\n        if num == 0: return 0\n        for i in range(1, 11):\n            if k * i % 10 == num % 10 and i * k <= num:\n                return i\n        return -1", "entry_point": "minimumNumbers", "test_list": ["assert minimumNumbers(num = 58, k = 9) == 2", "assert minimumNumbers(num = 37, k = 2) == -1", "assert minimumNumbers(num = 0, k = 7) == 0"]}
{"Contest id": "298/2309", "text_name": "兼具大小写的最好英文字母", "text": "给你一个由英文字母组成的字符串 s ，请你找出并返回 s 中的 最好 英文字母。返回的字母必须为大写形式。如果不存在满足条件的字母，则返回一个空字符串。\n最好 英文字母的大写和小写形式必须 都 在 s 中出现。\n英文字母 b 比另一个英文字母 a 更好 的前提是：英文字母表中，b 在 a 之 后 出现。", "canonical_solution": "def greatestLetter(s):\n        s = set(s)\n        upper, lower = ord('Z'), ord('z')\n        for i in range(26):\n            if chr(upper - i) in s and chr(lower - i) in s:\n                return chr(upper - i)\n        return ''", "entry_point": "greatestLetter", "test_list": ["assert greatestLetter(s = \"lEeTcOdE\") == \"E\"", "assert greatestLetter(s = \"arRAzFif\") == \"R\"", "assert greatestLetter(s = \"AbCdEfGhIjK\") == \"\""]}
{"Contest id": "297/2306", "text_name": "公司命名", "text": "给你一个字符串数组 ideas 表示在公司命名过程中使用的名字列表。公司命名流程如下：\n从 ideas 中选择 2 个 不同 名字，称为 ideaA 和 ideaB 。\n交换 ideaA 和 ideaB 的首字母。\n如果得到的两个新名字 都 不在 ideas 中，那么 ideaA ideaB（串联 ideaA 和 ideaB ，中间用一个空格分隔）是一个有效的公司名字。\n否则，不是一个有效的名字。\n返回 不同 且有效的公司名字的数目。", "canonical_solution": "def distinctNames(ideas):\n    ans = 0\n    suffixes = [set() for _ in range(26)]\n\n    for idea in ideas:\n      suffixes[ord(idea[0]) - ord('a')].add(idea[1:])\n\n    for i in range(25):\n      for j in range(i + 1, 26):\n        count = len(suffixes[i] & suffixes[j])\n        ans += 2 * (len(suffixes[i]) - count) * (len(suffixes[j]) - count)\n\n    return ans", "entry_point": "distinctNames", "test_list": ["assert distinctNames(ideas = [\"coffee\",\"donuts\",\"time\",\"toffee\"]) == 6", "assert distinctNames(ideas = [\"lack\",\"back\"]) == 0"]}
{"Contest id": "297/2305", "text_name": "公平分发饼干", "text": "给你一个整数数组 cookies ，其中 cookies[i] 表示在第 i 个零食包中的饼干数量。另给你一个整数 k 表示等待分发零食包的孩子数量，所有 零食包都需要分发。在同一个零食包中的所有饼干都必须分发给同一个孩子，不能分开。\n分发的 不公平程度 定义为单个孩子在分发过程中能够获得饼干的最大总数。\n返回所有分发的最小不公平程度。\n ", "canonical_solution": "def distributeCookies(cookies, k):\n        size = len(cookies)     \n        dp = [[0] * (1 << size) for _ in range(k)]\n        sum_ = [0] * (1 << size)\n        inf = int(1e9)\n        for i in range(1, 1 << size):\n            for j, c in enumerate(cookies):\n                if i >> j & 1: sum_[i] += c\n        dp[0] = sum_\n        for i in range(1, k):\n            for j in range(1 << size):\n                dp[i][j] = inf\n                sub = j\n                while sub:\n                    max_cost = max(dp[i-1][j^sub], sum_[sub])\n                    dp[i][j] = min(dp[i][j], max_cost)\n                    sub = (sub - 1) & j\n        return dp[k-1][-1]    ", "entry_point": "distributeCookies", "test_list": ["assert distributeCookies(cookies = [8,15,10,20,8], k = 2) == 31", "assert distributeCookies(cookies = [6,1,3,2,2,4,1,2], k = 3) == 7"]}
{"Contest id": "297/2304", "text_name": "网格中的最小路径代价", "text": "给你一个下标从 0 开始的整数矩阵 grid ，矩阵大小为 m x n ，由从 0 到 m * n - 1 的不同整数组成。你可以在此矩阵中，从一个单元格移动到 下一行 的任何其他单元格。如果你位于单元格 (x, y) ，且满足 x < m - 1 ，你可以移动到 (x + 1, 0), (x + 1, 1), ..., (x + 1, n - 1) 中的任何一个单元格。注意： 在最后一行中的单元格不能触发移动。\n每次可能的移动都需要付出对应的代价，代价用一个下标从 0 开始的二维数组 moveCost 表示，该数组大小为 (m * n) x n ，其中 moveCost[i][j] 是从值为 i 的单元格移动到下一行第 j 列单元格的代价。从 grid 最后一行的单元格移动的代价可以忽略。\ngrid 一条路径的代价是：所有路径经过的单元格的 值之和 加上 所有移动的 代价之和 。从 第一行 任意单元格出发，返回到达 最后一行 任意单元格的最小路径代价。", "canonical_solution": "def minPathCost(grid, moveCost):\n        max_row, max_col = len(grid), len(grid[0])\n        dp = [[-1] * max_col for _ in range(max_row)] \n\n        def recursion(row, col):\n            if row == max_row - 1:\n                return grid[row][col]\n            if dp[row][col] == -1:\n                current = grid[row][col] \n                res = float('inf')\n                for c in range(max_col):\n                    val = moveCost[current][c] + recursion(row + 1, c) \n                    res = min(res, val)\n                dp[row][col] = res + current \n            return dp[row][col]\n\n        for c in range(max_col):\n            recursion(0, c)\n        return min(dp[0])", "entry_point": "minPathCost", "test_list": ["assert minPathCost(grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]) == 17", "assert minPathCost(grid = [[5,1,2],[4,0,3]], moveCost = [[12,10,15],[20,23,8],[21,7,1],[8,1,13],[9,10,25],[5,3,2]]) == 6"]}
{"Contest id": "297/2303", "text_name": "计算应缴税款总额", "text": "给你一个下标从 0 开始的二维整数数组 brackets ，其中 brackets[i] = [upperi, percenti] ，表示第 i 个税级的上限是 upperi ，征收的税率为 percenti 。税级按上限 从低到高排序（在满足 0 < i < brackets.length 的前提下，upperi-1 < upperi）。\n税款计算方式如下：\n不超过 upper0 的收入按税率 percent0 缴纳\n接着 upper1 - upper0 的部分按税率 percent1 缴纳\n然后 upper2 - upper1 的部分按税率 percent2 缴纳\n以此类推\n给你一个整数 income 表示你的总收入。返回你需要缴纳的税款总额。与标准答案误差不超 10-5 的结果将被视作正确答案。\n ", "canonical_solution": "def calculateTax(brackets, income):\n        taxtot=0\n        if(brackets[0][0]<income):\n            taxtot+=brackets[0][0]*(brackets[0][1])\n            income-=brackets[0][0]\n        else:\n            taxtot+=income*(brackets[0][1])\n            return taxtot/100\n        i=1\n        while(income>0 and i<len(brackets)):\n            if(income>(brackets[i][0]-brackets[i-1][0])):\n                taxtot+=(brackets[i][0]-brackets[i-1][0])*brackets[i][1]\n                income-=brackets[i][0]-brackets[i-1][0]\n            else:\n                taxtot+=income*brackets[i][1]\n                income=0\n            i+=1\n        return taxtot/100", "entry_point": "calculateTax", "test_list": ["assert calculateTax(brackets = [[3,50],[7,10],[12,25]], income = 10) == 2.65000", "assert calculateTax(brackets = [[1,0],[4,25],[5,50]], income = 2) == 0.25000", "assert calculateTax(brackets = [[2,50]], income = 0) == 0.00000"]}
{"Contest id": "Bi80/2302", "text_name": "统计得分小于 K 的子数组数目", "text": "一个数组的 分数 定义为数组之和 乘以 数组的长度。\n比方说，[1, 2, 3, 4, 5] 的分数为 (1 + 2 + 3 + 4 + 5) * 5 = 75 。\n给你一个正整数数组 nums 和一个整数 k ，请你返回 nums 中分数 严格小于 k 的 非空整数子数组数目。\n子数组 是数组中的一个连续元素序列。", "canonical_solution": "def countSubarrays(A, k):\n        res = cur = i = 0\n        for j in range(len(A)):\n            cur += A[j]\n            while cur * (j - i + 1) >= k:\n                cur -= A[i]\n                i += 1\n            res += j - i + 1\n        return res", "entry_point": "countSubarrays", "test_list": ["assert countSubarrays([2,1,4,3,5], 10) == 6", "assert countSubarrays([1,1,1], 5) == 5"]}
{"Contest id": "Bi80/2301", "text_name": "替换字符后匹配", "text": "给你两个字符串 s 和 sub 。同时给你一个二维字符数组 mappings ，其中 mappings[i] = [oldi, newi] 表示你可以将 sub 中任意数目的 oldi 字符替换为 newi 。sub 中每个字符 不能 被替换超过一次。\n如果使用 mappings 替换 0 个或者若干个字符，可以将 sub 变成 s 的一个子字符串，请你返回 true，否则返回 false 。\n一个 子字符串 是字符串中连续非空的字符序列。", "canonical_solution": "def matchReplacement(s, sub, mappings):\n        from collections import defaultdict\n        regexp = []\n        m = defaultdict(lambda: set())\n        for f, t in mappings:\n            m[f].add(t)\n        def search(i, j):\n            len_s = len(s)\n            len_sub = len(sub)\n            while j < len(sub):\n                lenlefts = len_s - i\n                lenleftsub = len_sub - j\n                if lenlefts < lenleftsub:\n                    return False\n                elif (s[i] == sub[j]) or (s[i] in m[sub[j]]):\n                    i+=1\n                    j+=1\n                    continue\n                else:\n                    return False\n            return True\n        for i in range(len(s)):\n            if search(i, 0):\n                return True\n        return False", "entry_point": "matchReplacement", "test_list": ["assert matchReplacement(s = \"fool3e7bar\", sub = \"leet\", mappings = [[\"e\",\"3\"],[\"t\",\"7\"],[\"t\",\"8\"]]) == True", "assert matchReplacement(s = \"fooleetbar\", sub = \"f00l\", mappings = [[\"o\",\"0\"]]) == False", "assert matchReplacement(s = \"Fool33tbaR\", sub = \"leetd\", mappings = [[\"e\",\"3\"],[\"t\",\"7\"],[\"t\",\"8\"],[\"d\",\"b\"],[\"p\",\"b\"]]) == True"]}
{"Contest id": "Bi80/2300", "text_name": "咒语和药水的成功对数", "text": "给你两个正整数数组 spells 和 potions ，长度分别为 n 和 m ，其中 spells[i] 表示第 i 个咒语的能量强度，potions[j] 表示第 j 瓶药水的能量强度。\n同时给你一个整数 success 。一个咒语和药水的能量强度 相乘 如果 大于等于 success ，那么它们视为一对 成功 的组合。\n请你返回一个长度为 n 的整数数组 pairs，其中 pairs[i] 是能跟第 i 个咒语成功组合的 药水 数目。\n ", "canonical_solution": "def successfulPairs(spells, potions, success):\n        n = len(spells)\n        m = len(potions)\n        pairs = [0] * n\n        potions.sort()\n        for i in range(n):\n            spell = spells[i]\n            left = 0\n            right = m - 1\n            while left <= right:\n                mid = left + (right - left) // 2\n                product = spell * potions[mid]\n                if product >= success:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            pairs[i] = m - left\n        return pairs", "entry_point": "successfulPairs", "test_list": ["assert successfulPairs(spells = [5,1,3], potions = [1,2,3,4,5], success = 7) == [4,0,3]", "assert successfulPairs(spells = [3,1,2], potions = [8,5,8], success = 16) == [2,0,2]"]}
{"Contest id": "Bi80/2299", "text_name": "强密码检验器 II", "text": "如果一个密码满足以下所有条件，我们称它是一个 强 密码：\n它有至少 8 个字符。\n至少包含 一个小写英文 字母。\n至少包含 一个大写英文 字母。\n至少包含 一个数字 。\n至少包含 一个特殊字符 。特殊字符为：\"!@#$%^&*()-+\" 中的一个。\n它 不 包含 2 个连续相同的字符（比方说 \"aab\" 不符合该条件，但是 \"aba\" 符合该条件）。\n给你一个字符串 password ，如果它是一个 强 密码，返回 true，否则返回 false 。\n \n ", "canonical_solution": "def strongPasswordCheckerII(password):\n        if len(password) < 8:\n            return False\n        lowercase, uppercase, digit, special = False, False, False, False\n        special_char = \"!@#$%^&*()-+\"\n        for i in range(len(password)):\n            if i != len(password)-1 and password[i] == password[i+1]: \n                return False\n            if not lowercase: \n                lowercase = password[i].islower()\n            if not uppercase:\n                uppercase = password[i].isupper()\n            if not digit:\n                digit = password[i].isdigit()\n            if not special:\n                special = password[i] in special_char\n        return lowercase and uppercase and digit and special", "entry_point": "strongPasswordCheckerII", "test_list": ["assert strongPasswordCheckerII(password = \"IloveLe3tcode!\") == True", "assert strongPasswordCheckerII(password = \"Me+You--IsMyDream\") == False", "assert strongPasswordCheckerII(password = \"1aB!\") == False"]}
{"Contest id": "296/2295", "text_name": "替换数组中的元素", "text": "给你一个下标从 0 开始的数组 nums ，它包含 n 个 互不相同 的正整数。请你对这个数组执行 m 个操作，在第 i 个操作中，你需要将数字 operations[i][0] 替换成 operations[i][1] 。\n题目保证在第 i 个操作中：\noperations[i][0] 在 nums 中存在。\noperations[i][1] 在 nums 中不存在。\n请你返回执行完所有操作后的数组。", "canonical_solution": "def arrayChange(nums, operations):\n            replacements = {}\n            for x, y in reversed(operations):\n                replacements[x] = replacements.get(y, y)\n            for idx, val in enumerate(nums):\n                if val in replacements:\n                    nums[idx] = replacements[val]\n            return nums", "entry_point": "arrayChange", "test_list": ["assert arrayChange(nums = [1,2,4,6], operations = [[1,3],[4,7],[6,1]]) == [3,2,7,1]", "assert arrayChange(nums = [1,2], operations = [[1,3],[2,1],[3,2]]) == [2,1]"]}
{"Contest id": "296/2294", "text_name": "划分数组使最大差为 K", "text": "给你一个整数数组 nums 和一个整数 k 。你可以将 nums 划分成一个或多个 子序列 ，使 nums 中的每个元素都 恰好 出现在一个子序列中。\n在满足每个子序列中最大值和最小值之间的差值最多为 k 的前提下，返回需要划分的 最少 子序列数目。\n子序列 本质是一个序列，可以通过删除另一个序列中的某些元素（或者不删除）但不改变剩下元素的顺序得到。", "canonical_solution": "def partitionArray(A, k):\n        A.sort()\n        res = 1\n        mn = mx = A[0]\n        for a in A:\n            mn = min(mn, a)\n            mx = max(mx, a)\n            if mx - mn > k:\n                res += 1\n                mn = mx = a\n        return res", "entry_point": "partitionArray", "test_list": ["assert partitionArray([3,6,1,2,5], 2) == 2", "assert partitionArray([1,2,3], 1) == 2", "assert partitionArray([2,2,4,5], 0) == 3"]}
{"Contest id": "296/2293", "text_name": "极大极小游戏", "text": "给你一个下标从 0 开始的整数数组 nums ，其长度是 2 的幂。\n对 nums 执行下述算法：\n设 n 等于 nums 的长度，如果 n == 1 ，终止 算法过程。否则，创建 一个新的整数数组 newNums ，新数组长度为 n / 2 ，下标从 0 开始。\n对于满足 0 <= i < n / 2 的每个 偶数 下标 i ，将 newNums[i] 赋值 为 min(nums[2 * i], nums[2 * i + 1]) 。\n对于满足 0 <= i < n / 2 的每个 奇数 下标 i ，将 newNums[i] 赋值 为 max(nums[2 * i], nums[2 * i + 1]) 。\n用 newNums 替换 nums 。\n从步骤 1 开始 重复 整个过程。\n执行算法后，返回 nums 中剩下的那个数字。\n \n ", "canonical_solution": "def minMaxGame(nums):\n        l=nums\n        while len(l)>1:\n            is_min=True     \n            tmp=[]\n            for i in range(0, len(l), 2):\n                if is_min:\n                    tmp.append(min(l[i:i+2]))\n                else:\n                    tmp.append(max(l[i:i+2]))\n                is_min=not is_min            \n            l=tmp            \n        return l[0]", "entry_point": " minMaxGame", "test_list": ["assert  minMaxGame(nums = [1,3,5,2,4,8,2,2]) == 1", "assert  minMaxGame(nums = [3]) == 3"]}
{"Contest id": "295/2290", "text_name": "到达角落需要移除障碍物的最小数目", "text": "给你一个下标从 0 开始的二维整数数组 grid ，数组大小为 m x n 。每个单元格都是两个值之一：\n0 表示一个 空 单元格，\n1 表示一个可以移除的 障碍物 。\n你可以向上、下、左、右移动，从一个空单元格移动到另一个空单元格。\n现在你需要从左上角 (0, 0) 移动到右下角 (m - 1, n - 1) ，返回需要移除的障碍物的 最小 数目。", "canonical_solution": "def minimumObstacles(grid):\n        from collections import deque\n        R, C = len(grid), len(grid[0])\n        d = [(1,0),(-1,0),(0,1),(0,-1)]\n        distances = [[-1] * C for _ in range(R)]\n        q = deque([(0, 0, 0)])\n        while q:\n            for _ in range(len(q)):\n                dist, r, c = q.popleft()\n                \n                for dr, dc in d:\n                    rr, cc = r + dr, c + dc\n                    if 0 <= rr < R and 0 <= cc < C and distances[rr][cc] == -1:\n                        \n                        if grid[rr][cc] == 1:\n                            distances[rr][cc] = dist + 1\n                            q.append((dist + 1, rr, cc))\n                            \n                        else:\n                            distances[rr][cc] = dist\n                            q.appendleft((dist, rr, cc))\n                            \n        return distances[R - 1][C - 1]", "entry_point": "minimumObstacles", "test_list": ["assert minimumObstacles(grid = [[0,1,1],[1,1,0],[1,1,0]]) == 2", "assert minimumObstacles(grid = [[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]]) == 0"]}
{"Contest id": "295/2289", "text_name": "使数组按非递减顺序排列", "text": "给你一个下标从 0 开始的整数数组 nums 。在一步操作中，移除所有满足 nums[i - 1] > nums[i] 的 nums[i] ，其中 0 < i < nums.length 。\n重复执行步骤，直到 nums 变为 非递减 数组，返回所需执行的操作数。", "canonical_solution": "def totalSteps(nums):\n        st = []\n        ans = 0\n        for i in nums:\n            t = 0\n            while st and st[-1][0] <= i:\n                t = max(t, st.pop()[1])\n            x = 0 \n            if st: \n                x = t+1 \n            st.append([i, x])\n            ans = max(ans, x)\n        return ans", "entry_point": "totalStep", "test_list": ["assert totalSteps([5,3,4,4,7,3,6,11,8,5,11]) == 3", "assert totalSteps([4,5,7,7,13]) == 0"]}
{"Contest id": "295/2288", "text_name": "价格减免", "text": "句子 是由若干个单词组成的字符串，单词之间用单个空格分隔，其中每个单词可以包含数字、小写字母、和美元符号 '$' 。如果单词的形式为美元符号后跟着一个非负实数，那么这个单词就表示一个 价格 。\n例如 \"$100\"、\"$23\" 和 \"$6\" 表示价格，而 \"100\"、\"$\" 和 \"$1e5 不是。\n给你一个字符串 sentence 表示一个句子和一个整数 discount 。对于每个表示价格的单词，都在价格的基础上减免 discount% ，并 更新 该单词到句子中。所有更新后的价格应该表示为一个 恰好保留小数点后两位 的数字。\n返回表示修改后句子的字符串。\n注意：所有价格 最多 为  10 位数字。", "canonical_solution": "def discountPrices(sentence, discount):\n        s = sentence.split()\n        m = discount / 100 \n        for i,word in enumerate(s):\n            if word[0] == \"$\" and word[1:].isdigit():\n                num = int(word[1:]) * (1-m)\n                w = \"$\" + \"{:.2f}\".format(num)\n                s[i] = w\n        \n        return \" \".join(s)", "entry_point": "discountPrices", "test_list": ["assert discountPrices(sentence = \"there are $1 $2 and 5$ candies in the shop\", discount = 50) == \"there are $0.50 $1.00 and 5$ candies in the shop\"", "assert discountPrices(sentence = \"1 2 $3 4 $5 $6 7 8$ $9 $10$\", discount = 100) == \"1 2 $0.00 4 $0.00 $0.00 7 8$ $0.00 $10$\""]}
{"Contest id": "295/2287", "text_name": "重排字符形成目标字符串", "text": "给你两个下标从 0 开始的字符串 s 和 target 。你可以从 s 取出一些字符并将其重排，得到若干新的字符串。\n从 s 中取出字符并重新排列，返回可以形成 target 的 最大 副本数。", "canonical_solution": "def rearrangeCharacters(s, target):\n        from collections import Counter\n        counter_s = Counter(s)        \n        return min(counter_s[c] // count for c,count in Counter(target).items())", "entry_point": "rearrangeCharacters", "test_list": ["assert rearrangeCharacters(s = \"ilovecodingonleetcode\", target = \"code\") == 2", "assert rearrangeCharacters(s = \"abcba\", target = \"abc\") == 1", "assert rearrangeCharacters(s = \"abbaccaddaeea\", target = \"aaaaa\") == 1"]}
{"Contest id": "Bi79/2285", "text_name": "道路的最大总重要性", "text": "给你一个整数 n ，表示一个国家里的城市数目。城市编号为 0 到 n - 1 。\n给你一个二维整数数组 roads ，其中 roads[i] = [ai, bi] 表示城市 ai 和 bi 之间有一条 双向 道路。\n你需要给每个城市安排一个从 1 到 n 之间的整数值，且每个值只能被使用 一次 。道路的 重要性 定义为这条道路连接的两座城市数值 之和 。\n请你返回在最优安排下，所有道路重要性 之和 最大 为多少。", "canonical_solution": "def maximumImportance(n, roads):\n        Arr = [0] * n \n        for A,B in roads:\n            Arr[A] += 1\n            Arr[B] += 1\n        Arr.sort()\n        summ = 0\n        for i in range(len(Arr)):\n            summ += Arr[i] * (i+1)\n        \n        return summ", "entry_point": "maximumImportance", "test_list": ["assert maximumImportance(n = 5, roads = [[0,1],[1,2],[2,3],[0,2],[1,3],[2,4]]) == 43", "assert maximumImportance(n = 5, roads = [[0,3],[2,4],[1,3]]) == 20"]}
{"Contest id": "Bi79/2284", "text_name": "最多单词数的发件人", "text": "给你一个聊天记录，共包含 n 条信息。给你两个字符串数组 messages 和 senders ，其中 messages[i] 是 senders[i] 发出的一条 信息 。\n一条 信息 是若干用单个空格连接的 单词 ，信息开头和结尾不会有多余空格。发件人的 单词计数 是这个发件人总共发出的 单词数 。注意，一个发件人可能会发出多于一条信息。\n请你返回发出单词数 最多 的发件人名字。如果有多个发件人发出最多单词数，请你返回 字典序 最大的名字。\n注意：\n字典序里，大写字母小于小写字母。\n\"Alice\" 和 \"alice\" 是不同的名字。", "canonical_solution": "def largestWordCount(messages, senders):\n        d={}\n        l=[]\n        for i in range(len(messages)):\n            if senders[i] not in d:\n                d[senders[i]]=len(messages[i].split())\n            else:\n                d[senders[i]]+=len(messages[i].split())\n        x=max(d.values())\n        for k,v in d.items():\n            if v==x :\n                l.append(k)\n        if len(l)==1:\n            return l[0]\n        else:\n            l=sorted(l)[::-1] \n            return l[0]", "entry_point": "largestWordCount", "test_list": ["assert largestWordCount(messages = [\"Hello userTwooo\",\"Hi userThree\",\"Wonderful day Alice\",\"Nice day userThree\"], senders = [\"Alice\",\"userTwo\",\"userThree\",\"Alice\"]) == \"Alice\"", "assert largestWordCount(messages = [\"How is leetcode for everyone\",\"Leetcode is useful for practice\"], senders = [\"Bob\",\"Charlie\"]) == \"Charlie\""]}
{"Contest id": "Bi79/2283", "text_name": "判断一个数的数字计数是否等于数位的值", "text": "给你一个下标从 0 开始长度为 n 的字符串 num ，它只包含数字。\n如果对于 每个 0 <= i < n 的下标 i ，都满足数位 i 在 num 中出现了 num[i]次，那么请你返回 true ，否则返回 false 。", "canonical_solution": "def digitCount(num):\n        from collections import Counter\n        d = Counter(num)\n        for i in range(len(num)):\n            if int(num[i])!=d.get(str(i), 0):\n                return False\n        return True", "entry_point": "digitCount", "test_list": ["assert digitCount(num = \"1210\") == True", "assert digitCount(num = \"030\") == False"]}
{"Contest id": "294/2281", "text_name": "巫师的总力量和", "text": "作为国王的统治者，你有一支巫师军队听你指挥。\n给你一个下标从 0 开始的整数数组 strength ，其中 strength[i] 表示第 i 位巫师的力量值。对于连续的一组巫师（也就是这些巫师的力量值是 strength 的 子数组），总力量 定义为以下两个值的 乘积 ：\n巫师中 最弱 的能力值。\n组中所有巫师的个人力量值 之和 。\n请你返回 所有 巫师组的 总 力量之和。由于答案可能很大，请将答案对 109 + 7 取余 后返回。\n子数组 是一个数组里 非空 连续子序列。", "canonical_solution": "def totalStrength(A):\n        res, ac, mod, stack, acc = 0, 0, 10 ** 9 + 7, [-1], [0]\n        A += [0]\n        for r, a in enumerate(A):\n            ac += a\n            acc.append(ac + acc[-1])\n            while stack and A[stack[-1]] > a:\n                i = stack.pop()\n                l = stack[-1]\n                lacc = acc[i] - acc[max(l, 0)]\n                racc = acc[r] - acc[i]\n                ln, rn = i - l, r - i\n                res += A[i] * (racc * ln - lacc * rn) % mod\n            stack.append(r)\n        return res % mod", "entry_point": "totalStrength", "test_list": ["assert totalStrength([1,3,1,2]) == 44", "assert totalStrength([5,4,6]) == 213"]}
{"Contest id": "294/2280", "text_name": "表示一个折线图的最少线段数", "text": "给你一个二维整数数组 stockPrices ，其中 stockPrices[i] = [dayi, pricei] 表示股票在 dayi 的价格为 pricei 。折线图 是一个二维平面上的若干个点组成的图，横坐标表示日期，纵坐标表示价格，折线图由相邻的点连接而成。比方说下图是一个例子：\n请你返回要表示一个折线图所需要的 最少线段数 。", "canonical_solution": "def minimumLines(A):\n        n = len(A)\n        res = n - 1\n        A.sort()\n        for i in range(1, n - 1):\n            a, b, c = A[i-1], A[i], A[i+1]\n            if (b[0] - a[0]) * (c[1] - b[1]) == (c[0] - b[0]) * (b[1] - a[1]):\n                res -= 1\n        return res", "entry_point": "minimumLines", "test_list": ["assert minimumLines([[1,7],[2,6],[3,5],[4,4],[5,4],[6,3],[7,2],[8,1]]) == 3", "assert minimumLines([[3,4],[1,2],[7,8],[2,3]]) == 1"]}
{"Contest id": "294/2279", "text_name": "装满石头的背包的最大数量", "text": "现有编号从 0 到 n - 1 的 n 个背包。给你两个下标从 0 开始的整数数组 capacity 和 rocks 。第 i 个背包最大可以装 capacity[i] 块石头，当前已经装了 rocks[i] 块石头。另给你一个整数 additionalRocks ，表示你可以放置的额外石头数量，石头可以往 任意 背包中放置。\n请你将额外的石头放入一些背包中，并返回放置后装满石头的背包的 最大 数量。", "canonical_solution": "def maximumBags(capacity, rocks, x):\n        count = sorted(c - r for c,r in zip(capacity, rocks))[::-1]\n        while count and x and count[-1] <= x:\n            x -= count.pop()\n        return len(rocks) - len(count)", "entry_point": "maximumBags", "test_list": ["assert maximumBags([2,3,4,5], [1,2,4,4], 2) == 3", "assert maximumBags([10,2,2], [2,2,0], 100) == 3"]}
{"Contest id": "294/2278", "text_name": "字母在字符串中的百分比", "text": "给你一个字符串 s 和一个字符 letter ，返回在 s 中等于 letter 字符所占的 百分比 ，向下取整到最接近的百分比。\n ", "canonical_solution": "def percentageLetter(s, letter):\n        return (s.count(letter)*100)//len(s)", "entry_point": "percentageLetter", "test_list": ["assert percentageLetter(s = \"foobar\", letter = \"o\") == 33", "assert percentageLetter(s = \"jjjj\", letter = \"k\") == 0"]}
{"Contest id": "293/2275", "text_name": "按位与结果大于零的最长组合", "text": "对数组 nums 执行 按位与 相当于对数组 nums 中的所有整数执行 按位与 。\n例如，对 nums = [1, 5, 3] 来说，按位与等于 1 & 5 & 3 = 1 。\n同样，对 nums = [7] 而言，按位与等于 7 。\n给你一个正整数数组 candidates 。计算 candidates 中的数字每种组合下 按位与 的结果。 candidates 中的每个数字在每种组合中只能使用 一次 。\n返回按位与结果大于 0 的 最长 组合的长度。", "canonical_solution": "def largestCombination(A):\n        return max(sum(1 << i & a > 0 for a in A) for i in range(30))", "entry_point": "largestCombination", "test_list": ["assert largestCombination([16,17,71,62,12,24,14]) == 4", "assert largestCombination([8,8]) == 2"]}
{"Contest id": "293/2274", "text_name": "不含特殊楼层的最大连续楼层数", "text": "Alice 管理着一家公司，并租用大楼的部分楼层作为办公空间。Alice 决定将一些楼层作为 特殊楼层 ，仅用于放松。\n给你两个整数 bottom 和 top ，表示 Alice 租用了从 bottom 到 top（含 bottom 和 top 在内）的所有楼层。另给你一个整数数组 special ，其中 special[i] 表示  Alice 指定用于放松的特殊楼层。\n返回不含特殊楼层的 最大 连续楼层数。", "canonical_solution": "def maxConsecutive(bottom, top, A):\n        A.sort()\n        res = max(top - A[-1], A[0] - bottom)\n        for i in range(1, len(A)):\n            res = max(res, A[i] - A[i - 1] - 1)\n        return res", "entry_point": "maxConsecutive", "test_list": ["assert maxConsecutive(2, 9, [4,6]) == 3", "assert maxConsecutive(6, 8,  [7,6,8]) == 0"]}
{"Contest id": "293/2273", "text_name": "移除字母异位词后的结果数组", "text": "给你一个下标从 0 开始的字符串 words ，其中 words[i] 由小写英文字符组成。\n在一步操作中，需要选出任一下标 i ，从 words 中 删除 words[i] 。其中下标 i 需要同时满足下述两个条件：\n0 < i < words.length\nwords[i - 1] 和 words[i] 是 字母异位词 。\n只要可以选出满足条件的下标，就一直执行这个操作。\n在执行所有操作后，返回 words 。可以证明，按任意顺序为每步操作选择下标都会得到相同的结果。\n字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。例如，\"dacb\" 是 \"abdc\" 的一个字母异位词。", "canonical_solution": "def removeAnagrams(words):\n        def get_counts(x):\n            count = [0] * 26 \n            for c in x:\n                count[ord(c) - ord('a')] += 1\n            return count\n        \n        \n        if not words:\n            return []\n        \n        \n        i = 0\n        while i < len(words) - 1:\n            if get_counts(words[i]) == get_counts(words[i + 1]):\n                words.remove(words[i + 1])\n                continue\n            i += 1\n        return words", "entry_point": "removeAnagrams", "test_list": ["assert removeAnagrams(words = [\"abba\",\"baba\",\"bbaa\",\"cd\",\"cd\"]) == [\"abba\",\"cd\"]", "assert removeAnagrams(words = [\"a\",\"b\",\"c\",\"d\",\"e\"]) == [\"a\",\"b\",\"c\",\"d\",\"e\"]"]}
{"Contest id": "Bi78/2272", "text_name": "最大波动的子字符串", "text": "字符串的 波动 定义为子字符串中出现次数 最多 的字符次数与出现次数 最少 的字符次数之差。\n给你一个字符串 s ，它只包含小写英文字母。请你返回 s 里所有 子字符串的 最大波动 值。\n子字符串 是一个字符串的一段连续字符序列。\n ", "canonical_solution": "def largestVariance(s):\n        counter=[0]*26\n        for ch in s:\n            counter[ord(ch)-ord('a')]+=1\n        global_max=0\n        for i in range(26):\n            for j in range(26):\n                if i==j or counter[i]==0 or counter[j]==0:\n                    continue\n                \n                major= chr(ord('a')+i)\n                minor= chr(ord('a')+j)\n                majorCount=0\n                minorCount=0\n\n                restMinor= counter[j]\n\n                for ch in s:\n                    if ch==major:\n                        majorCount+=1\n\n                    if ch==minor:\n                        minorCount+=1\n                        restMinor-=1\n\n                    if minorCount>0:\n                        global_max=max(global_max, majorCount-minorCount)\n                    \n                    if majorCount<minorCount and restMinor>0:\n                        majorCount=0\n                        minorCount=0\n\n        return global_max", "entry_point": "largestVariance", "test_list": ["assert largestVariance(s = \"aababbb\") == 3", "assert largestVariance(s = \"abcde\") == 0"]}
{"Contest id": "Bi78/2271", "text_name": "毯子覆盖的最多白色砖块数", "text": "给你一个二维整数数组 tiles ，其中 tiles[i] = [li, ri] ，表示所有在 li <= j <= ri 之间的每个瓷砖位置 j 都被涂成了白色。\n同时给你一个整数 carpetLen ，表示可以放在 任何位置 的一块毯子的长度。\n请你返回使用这块毯子，最多 可以盖住多少块瓷砖。", "canonical_solution": "def maximumWhiteTiles(tiles, carpetLen):\n        tiles.sort()\n        j = cover = res = 0\n        for i in range(len(tiles)):\n            while j<len(tiles) and tiles[j][1]-tiles[i][0] + 1 <= carpetLen:\n                cover += tiles[j][1]-tiles[j][0] + 1\n                j += 1\n            if j<len(tiles) and tiles[j][0]-tiles[i][0] + 1 <= carpetLen:\n                res = max(res, cover + carpetLen-(tiles[j][0]-tiles[i][0]))\n            else:\n                res = max(res, cover)\n            if i!=j:\n                cover -= tiles[i][1]-tiles[i][0]+1\n            j = max(j, i+1)\n        return res", "entry_point": "maximumWhiteTiles", "test_list": ["assert maximumWhiteTiles(tiles = [[1,5],[10,11],[12,18],[20,25],[30,32]], carpetLen = 10) == 9", "assert maximumWhiteTiles(tiles = [[10,11],[1,1]], carpetLen = 2) == 2"]}
{"Contest id": "Bi78/2270", "text_name": "分割数组的方案数", "text": "给你一个下标从 0 开始长度为 n 的整数数组 nums 。\n如果以下描述为真，那么 nums 在下标 i 处有一个 合法的分割 ：\n前 i + 1 个元素的和 大于等于 剩下的 n - i - 1 个元素的和。\n下标 i 的右边 至少有一个 元素，也就是说下标 i 满足 0 <= i < n - 1 。\n请你返回 nums 中的 合法分割 方案数。", "canonical_solution": "def waysToSplitArray(nums):\n        count = 0\n        left_sum, right_sum = 0, sum(nums)\n        for i in range(len(nums) - 1):\n            left_sum += nums[i]\n            right_sum -= nums[i]\n            if left_sum >= right_sum:\n                count += 1\n        return count", "entry_point": "waysToSplitArray", "test_list": ["assert waysToSplitArray(nums = [10,4,-8,7]) == 2", "assert waysToSplitArray(nums = [2,3,1,0]) == 2"]}
{"Contest id": "Bi78/2269", "text_name": "找到一个数字的 K 美丽值", "text": "一个整数 num 的 k 美丽值定义为 num 中符合以下条件的 子字符串 数目：\n子字符串长度为 k 。\n子字符串能整除 num 。\n给你整数 num 和 k ，请你返回 num 的 k 美丽值。\n注意：\n允许有 前缀 0 。\n0 不能整除任何值。\n一个 子字符串 是一个字符串里的连续一段字符序列。", "canonical_solution": "def divisorSubstrings(num, k):\n    l = 0\n    r = k\n\n    num = str(num)\n    count = 0\n    while r <= len(num):            \n        n = int(num[l: r])\n\n        if not n:\n            l += 1\n            r += 1\n            continue\n\n        if int(num) % n == 0:\n            count += 1   \n            \n        l += 1\n        r += 1\n\n    return count", "entry_point": "divisorSubstrings", "test_list": ["assert divisorSubstrings(num = 240, k = 2) == 2", "assert divisorSubstrings(num = 430043, k = 2) == 2"]}
{"Contest id": "292/2267", "text_name": "检查是否有合法括号字符串路径", "text": "一个括号字符串是一个 非空 且只包含 '(' 和 ')' 的字符串。如果下面 任意 条件为 真 ，那么这个括号字符串就是 合法的 。\n字符串是 () 。\n字符串可以表示为 AB（A 连接 B），A 和 B 都是合法括号序列。\n字符串可以表示为 (A) ，其中 A 是合法括号序列。\n给你一个 m x n 的括号网格图矩阵 grid 。网格图中一个 合法括号路径 是满足以下所有条件的一条路径：\n路径开始于左上角格子 (0, 0) 。\n路径结束于右下角格子 (m - 1, n - 1) 。\n路径每次只会向 下 或者向 右 移动。\n路径经过的格子组成的括号字符串是 合法 的。\n如果网格图中存在一条 合法括号路径 ，请返回 true ，否则返回 false 。", "canonical_solution": "def hasValidPath(A):\n        m, n = len(A), len(A[0])\n        dp = defaultdict(set)\n        dp[0, -1] = dp[-1, 0] = {0}\n        for i in range(m):\n            for j in range(n):\n                d = 1 if A[i][j] == '(' else -1\n                dp[i,j] |= {a + d for a in dp[i-1,j] | dp[i,j-1] if a + d >= 0}\n        return 0 in dp[m - 1, n - 1]", "entry_point": "hasValidPath", "test_list": ["assert hasValidPath([[\"(\",\"(\",\"(\"],[\")\",\"(\",\")\"],[\"(\",\"(\",\")\"],[\"(\",\"(\",\")\"]]) == True", "assert hasValidPath([[\")\",\")\"],[\"(\",\"(\"]]) == False"]}
{"Contest id": "292/2266", "text_name": "统计打字方案数", "text": "Alice 在给 Bob 用手机打字。数字到字母的 对应 如下图所示。\n为了 打出 一个字母，Alice 需要 按 对应字母 i 次，i 是该字母在这个按键上所处的位置。\n比方说，为了按出字母 's' ，Alice 需要按 '7' 四次。类似的， Alice 需要按 '5' 两次得到字母  'k' 。\n注意，数字 '0' 和 '1' 不映射到任何字母，所以 Alice 不 使用它们。\n但是，由于传输的错误，Bob 没有收到 Alice 打字的字母信息，反而收到了 按键的字符串信息 。\n比方说，Alice 发出的信息为 \"bob\" ，Bob 将收到字符串 \"2266622\" 。\n给你一个字符串 pressedKeys ，表示 Bob 收到的字符串，请你返回 Alice 总共可能发出多少种文字信息 。\n由于答案可能很大，将它对 109 + 7 取余 后返回。", "canonical_solution": "def countTexts(pressedKeys):\n        dp = [1] + [0]*len(pressedKeys)\n        mod = 10**9 + 7\n        for i, n in enumerate(pressedKeys):\n            dp[i+1] = dp[i]\n            if i >= 1 and pressedKeys[i-1] == n:\n                dp[i+1] += dp[i-1]\n                dp[i+1] %= mod\n                if i >= 2 and pressedKeys[i-2] == n:\n                    dp[i+1] += dp[i-2]\n                    dp[i+1] %= mod\n                    if i >= 3 and pressedKeys[i-3] == n and (n == \"7\" or n == \"9\"):\n                        dp[i+1] += dp[i-3]\n                        dp[i+1] %= mod\n        return dp[-1]", "entry_point": "countTexts", "test_list": ["assert countTexts(pressedKeys = \"22233\") == 8", "assert countTexts(pressedKeys = \"222222222222222222222222222222222222\") == 82876089"]}
{"Contest id": "292/2264", "text_name": "字符串中最大的 3 位相同数字", "text": "给你一个字符串 num ，表示一个大整数。如果一个整数满足下述所有条件，则认为该整数是一个 优质整数 ：\n该整数是 num 的一个长度为 3 的 子字符串 。\n该整数由唯一一个数字重复 3 次组成。\n以字符串形式返回 最大的优质整数 。如果不存在满足要求的整数，则返回一个空字符串 \"\" 。\n注意：\n子字符串 是字符串中的一个连续字符序列。\nnum 或优质整数中可能存在 前导零 。", "canonical_solution": "def largestGoodInteger(num):\n        result = -1\n        for i in range(len(num) - 2):\n            if num[i] == num[i + 1] == num[i + 2]:\n                result = max(result, int(num[i]))\n        return \"\" if result == -1 else str(result) * 3", "entry_point": "largestGoodInteger", "test_list": ["assert largestGoodInteger(num = \"6777133339\") == \"777\"", "assert largestGoodInteger(num = \"2300019\") == \"000\"", "assert largestGoodInteger(num = \"42352338\") == \"\""]}
{"Contest id": "291/2262", "text_name": "字符串的总引力", "text": "字符串的 引力 定义为：字符串中 不同 字符的数量。\n例如，\"abbca\" 的引力为 3 ，因为其中有 3 个不同字符 'a'、'b' 和 'c' 。\n给你一个字符串 s ，返回 其所有子字符串的总引力 。\n子字符串 定义为：字符串中的一个连续字符序列。", "canonical_solution": "def appealSum(s):\n        last = {}\n        res = 0\n        for i,c in enumerate(s):\n            last[c] = i + 1\n            res += sum(last.values())\n        return res", "entry_point": "appealSum", "test_list": ["assert appealSum(s = \"abbca\") == 28", "assert appealSum(s = \"code\") == 20"]}
{"Contest id": "291/2261", "text_name": "含最多 K 个可整除元素的子数组", "text": "给你一个整数数组 nums 和两个整数 k 和 p ，找出并返回满足要求的不同的子数组数，要求子数组中最多 k 个可被 p 整除的元素。\n如果满足下述条件之一，则认为数组 nums1 和 nums2 是 不同 数组：\n两数组长度 不同 ，或者\n存在 至少 一个下标 i 满足 nums1[i] != nums2[i] 。\n子数组 定义为：数组中的连续元素组成的一个 非空 序列。", "canonical_solution": "def countDistinct(nums, k, p):\n        n = len(nums)                        \n        sub_arrays = set()\n\n        for start in range(n):\n            cnt = 0\n            temp = ''\n            for i in range(start, n):\n                if nums[i]%p == 0:\n                    cnt+=1                 \n                temp+=str(nums[i]) + ','          \n                if cnt>k:\n                    break\n                sub_arrays.add(temp)                                    \n                \n        return len(sub_arrays)", "entry_point": "countDistinct", "test_list": ["assert countDistinct(nums = [2,3,3,2,2], k = 2, p = 2) == 11", "assert countDistinct(nums = [1,2,3,4], k = 4, p = 1) == 10"]}
{"Contest id": "291/2260", "text_name": "必须拿起的最小连续卡牌数", "text": "给你一个整数数组 cards ，其中 cards[i] 表示第 i 张卡牌的 值 。如果两张卡牌的值相同，则认为这一对卡牌 匹配 。\n返回你必须拿起的最小连续卡牌数，以使在拿起的卡牌中有一对匹配的卡牌。如果无法得到一对匹配的卡牌，返回 -1 。", "canonical_solution": "def minimumCardPickup(cards):\n        ans = math.inf\n        n = len(cards)\n        pos = defaultdict(lambda: -1)\n        for i in range(n):\n            if pos[cards[i]] != -1:\n                ans = min(i - pos[cards[i]] + 1, ans)\n            pos[cards[i]] = i\n        return ans if ans != math.inf else -1", "entry_point": "minimumCardPickup", "test_list": ["assert minimumCardPickup(cards = [3,4,2,3,4,7]) == 4", "assert minimumCardPickup(cards = [1,0,5,3]) == -1"]}
{"Contest id": "291/2259", "text_name": "移除指定数字得到的最大结果", "text": "给你一个表示某个正整数的字符串 number 和一个字符 digit 。\n从 number 中 恰好 移除 一个 等于 digit 的字符后，找出并返回按 十进制 表示 最大 的结果字符串。生成的测试用例满足 digit 在 number 中出现至少一次。", "canonical_solution": "def removeDigit(number, digit):\n        \n        last_index = 0\n\n        for num in range(1, len(number)):\n\n            if number[num-1] == digit:\n                if int(number[num]) > int(number[num-1]):\n                    return number[:num-1] + number[num:]\n                else:\n                    last_index = num - 1\n\n        if number[-1] == digit:\n            last_index = len(number) - 1\n\n        return number[:last_index] + number[last_index + 1:]", "entry_point": "removeDigit", "test_list": ["assert removeDigit(number = \"123\", digit = \"3\") == \"12\"", "assert removeDigit(number = \"1231\", digit = \"1\") == \"231\"", "assert removeDigit(number = \"551\", digit = \"5\") == \"51\""]}
{"Contest id": "Bi77/2258", "text_name": "逃离火灾", "text": "给你一个下标从 0 开始大小为 m x n 的二维整数数组 grid ，它表示一个网格图。每个格子为下面 3 个值之一：\n0 表示草地。\n1 表示着火的格子。\n2 表示一座墙，你跟火都不能通过这个格子。\n一开始你在最左上角的格子 (0, 0) ，你想要到达最右下角的安全屋格子 (m - 1, n - 1) 。每一分钟，你可以移动到 相邻 的草地格子。每次你移动 之后 ，着火的格子会扩散到所有不是墙的 相邻 格子。\n请你返回你在初始位置可以停留的 最多 分钟数，且停留完这段时间后你还能安全到达安全屋。如果无法实现，请你返回 -1 。如果不管你在初始位置停留多久，你 总是 能到达安全屋，请你返回 109 。\n注意，如果你到达安全屋后，火马上到了安全屋，这视为你能够安全到达安全屋。\n如果两个格子有共同边，那么它们为 相邻 格子。", "canonical_solution": "def maximumMinutes(grid):\n        from collections import deque\n        m, n = len(grid), len(grid[0])\n        fire = [[float('inf') for _ in range(n)] for _ in range(m)]\n        def bfsFire():\n            q = deque()\n            for i in range(m):\n                for j in range(n):\n                    if grid[i][j] == 1:\n                        q.append((i, j))\n            dist = 0\n            while q:\n                size = len(q)\n                for _ in range(size):\n                    i, j = q.popleft()\n                    if fire[i][j] != float('inf'):\n                        continue\n                    fire[i][j] = dist\n                    if i < m - 1 and grid[i + 1][j] == 0 and fire[i + 1][j] == float('inf'): q.append((i + 1, j))\n                    if i > 0 and grid[i - 1][j] == 0 and fire[i - 1][j] == float('inf'): q.append((i - 1, j))\n                    if j < n - 1 and grid[i][j + 1] == 0 and fire[i][j + 1] == float('inf'): q.append((i, j + 1))\n                    if j > 0 and grid[i][j - 1] == 0 and fire[i][j - 1] == float('inf'): q.append((i, j - 1))\n                dist += 1\n        def bfsCanReach(time):\n            q = deque()\n            q.append((0, 0))\n            curGrid = [[grid[i][j] for j in range(n)] for i in range(m)]\n            while q:\n                size = len(q)\n                for _ in range(size):\n                    i, j = q.popleft()\n                    if i == m - 1 and j == n - 1 and time <= fire[i][j]:\n                        return True\n                    if fire[i][j] <= time or curGrid[i][j] == \"#\":\n                        continue\n                    curGrid[i][j] = \"#\"\n                    if i < m - 1 and curGrid[i + 1][j] == 0: q.append((i + 1, j))\n                    if i > 0 and curGrid[i - 1][j] == 0: q.append((i - 1, j))\n                    if j < n - 1 and curGrid[i][j + 1] == 0: q.append((i, j + 1))\n                    if j > 0 and curGrid[i][j - 1] == 0: q.append((i, j - 1))\n                time += 1\n            return False\n        bfsFire()\n        canReachHouse = bfsCanReach(0)\n        if not canReachHouse:\n            return -1\n        if canReachHouse and fire[m - 1][n - 1] == float('inf'):\n            return 10 ** 9\n        left, right = 0, 10 ** 9\n        while left < right:\n            mid = (left + right + 1) // 2\n            if bfsCanReach(mid):\n                left = mid\n            else:\n                right = mid - 1\n        return left", "entry_point": "maximumMinutes", "test_list": ["assert maximumMinutes(grid = [[0,2,0,0,0,0,0],[0,0,0,2,2,1,0],[0,2,0,0,1,2,0],[0,0,2,2,2,0,2],[0,0,0,0,0,0,0]]) == 3", "assert maximumMinutes(grid = [[0,0,0,0],[0,1,2,0],[0,2,0,0]]) == -1", "assert maximumMinutes(grid = [[0,0,0],[2,2,0],[1,2,0]]) == 1000000000"]}
{"Contest id": "Bi77/2257", "text_name": "统计网格图中没有被保卫的格子数", "text": "给你两个整数 m 和 n 表示一个下标从 0 开始的 m x n 网格图。同时给你两个二维整数数组 guards 和 walls ，其中 guards[i] = [rowi, coli] 且 walls[j] = [rowj, colj] ，分别表示第 i 个警卫和第 j 座墙所在的位置。\n一个警卫能看到 4 个坐标轴方向（即东、南、西、北）的 所有 格子，除非他们被一座墙或者另外一个警卫 挡住 了视线。如果一个格子能被 至少 一个警卫看到，那么我们说这个格子被 保卫 了。\n请你返回空格子中，有多少个格子是 没被保卫 的。", "canonical_solution": "def countUnguarded(m, n, guards, walls):\n        dp = [[0] * n for _ in range(m)]\n        for x, y in guards+walls:\n            dp[x][y] = 1\n               \n        directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n        \n        for x, y in guards:\n            for dx, dy in directions:\n                curr_x = x\n                curr_y = y\n                \n                while 0 <= curr_x+dx < m and 0 <= curr_y+dy < n and dp[curr_x+dx][curr_y+dy] != 1:\n                    curr_x += dx\n                    curr_y += dy\n                    dp[curr_x][curr_y] = 2\n                    \n        return sum(1 for i in range(m) for j in range(n) if dp[i][j] == 0)                    ", "entry_point": "countUnguarded", "test_list": ["assert countUnguarded(m = 4, n = 6, guards = [[0,0],[1,1],[2,3]], walls = [[0,1],[2,2],[1,4]]) == 7", "assert countUnguarded(m = 3, n = 3, guards = [[1,1]], walls = [[0,1],[1,0],[2,1],[1,2]]) == 4"]}
{"Contest id": "Bi77/2256", "text_name": "最小平均差", "text": "给你一个下标从 0 开始长度为 n 的整数数组 nums 。\n下标 i 处的 平均差 指的是 nums 中 前 i + 1 个元素平均值和 后 n - i - 1 个元素平均值的 绝对差 。两个平均值都需要 向下取整 到最近的整数。\n请你返回产生 最小平均差 的下标。如果有多个下标最小平均差相等，请你返回 最小 的一个下标。\n注意：\n两个数的 绝对差 是两者差的绝对值。\n n 个元素的平均值是 n 个元素之 和 除以（整数除法） n 。\n0 个元素的平均值视为 0 。", "canonical_solution": "def minimumAverageDifference(nums):\n    from collections import deque\n    import sys\n    n = len(nums)\n    if n == 1:\n        return 0\n\n    queue = deque(nums[1: ])\n\n    left_sum = sum(nums[0: 1])\n    right_sum = sum(queue)\n\n    left_length = 1\n    right_length = n - 1\n\n    i = 0\n\n    min_avg = sys.maxsize\n    min_avg_idx = None\n\n    while i < n:\n        left_avg = left_sum // left_length\n        if right_length:\n            right_avg = right_sum // right_length\n        else:\n            right_avg = 0\n\n        diff = abs(left_avg - right_avg)\n        if diff < min_avg:\n            min_avg = diff\n            min_avg_idx = i\n\n        if not queue:\n            break\n        element = queue.popleft()\n\n        left_sum = left_sum + element\n        right_sum = right_sum - element\n\n        left_length += 1\n        right_length -= 1\n\n        i += 1\n\n    return min_avg_idx", "entry_point": "minimumAverageDifference", "test_list": ["assert minimumAverageDifference(nums = [2,5,3,9,5,3]) == 3", "assert minimumAverageDifference(nums = [0]) == 0"]}
{"Contest id": "Bi77/2255", "text_name": "统计是给定字符串前缀的字符串数目", "text": "给你一个字符串数组 words 和一个字符串 s ，其中 words[i] 和 s 只包含 小写英文字母 。\n请你返回 words 中是字符串 s 前缀 的 字符串数目 。\n一个字符串的 前缀 是出现在字符串开头的子字符串。子字符串 是一个字符串中的连续一段字符序列。", "canonical_solution": "def countPrefixes(words, s):\n        return sum(map(s.startswith, words))", "entry_point": "countPrefixes", "test_list": ["assert countPrefixes(words = [\"a\",\"b\",\"c\",\"ab\",\"bc\",\"abc\"], s = \"abc\") == 3", "assert countPrefixes(words = [\"a\",\"a\"], s = \"aa\") == 2"]}
{"Contest id": "290/2251", "text_name": "花期内花的数目", "text": "给你一个下标从 0 开始的二维整数数组 flowers ，其中 flowers[i] = [starti, endi] 表示第 i 朵花的 花期 从 starti 到 endi （都 包含）。同时给你一个下标从 0 开始大小为 n 的整数数组 people ，people[i] 是第 i 个人来看花的时间。\n请你返回一个大小为 n 的整数数组 answer ，其中 answer[i]是第 i 个人到达时在花期内花的 数目 。\n ", "canonical_solution": "def fullBloomFlowers(flowers, people):\n        sorted_arrival_times = sorted(people)\n        flowers.sort()\n        \n        bloom_counts = {}\n        bloom_end_times = [] \n\n        flower_idx = 0\n        for person_time in sorted_arrival_times:\n            while flower_idx < len(flowers) and flowers[flower_idx][0] <= person_time:\n                heapq.heappush(bloom_end_times, flowers[flower_idx][1])\n                flower_idx += 1\n\n            while bloom_end_times and bloom_end_times[0] < person_time:\n                heapq.heappop(bloom_end_times)\n\n            bloom_counts[person_time] = len(bloom_end_times)\n\n        flower_counts = [bloom_counts[arrival_time] for arrival_time in people]\n\n        return flower_counts", "entry_point": "fullBloomFlowers", "test_list": ["assert fullBloomFlowers(flowers = [[1,6],[3,7],[9,12],[4,13]], people = [2,3,7,11]) == [1,2,2,2]", "assert fullBloomFlowers(flowers = [[1,10],[3,3]], people = [3,3,2]) == [2,2,1]"]}
{"Contest id": "290/2250", "text_name": "统计包含每个点的矩形数目", "text": "给你一个二维整数数组 rectangles ，其中 rectangles[i] = [li, hi] 表示第 i 个矩形长为 li 高为 hi 。给你一个二维整数数组 points ，其中 points[j] = [xj, yj] 是坐标为 (xj, yj) 的一个点。\n第 i 个矩形的 左下角 在 (0, 0) 处，右上角 在 (li, hi) 。\n请你返回一个整数数组 count ，长度为 points.length，其中 count[j]是 包含 第 j 个点的矩形数目。\n如果 0 <= xj <= li 且 0 <= yj <= hi ，那么我们说第 i 个矩形包含第 j 个点。如果一个点刚好在矩形的 边上 ，这个点也被视为被矩形包含。", "canonical_solution": "def countRectangles(rectangles, points):\n        import bisect\n        maxH = 101 \n        hToL = [[] for _ in range(maxH)]\n        \n        for l, h in rectangles:\n            hToL[h].append(l)\n            \n        for h in range(1, maxH):\n            hToL[h].sort()\n        \n        res = []\n        for px, py in points:\n            count = 0\n            for h in range(py, maxH):\n                if len(hToL[h]) == 0:\n                    continue\n                idx = bisect.bisect_left(hToL[h], px) \n                count += len(hToL[h]) - idx\n            res.append(count)\n        return res", "entry_point": "countRectangles", "test_list": ["assert countRectangles(rectangles = [[1,2],[2,3],[2,5]], points = [[2,1],[1,4]]) == [2,1]", "assert countRectangles(rectangles = [[1,1],[2,2],[3,3]], points = [[1,3],[1,1]]) == [1,3]"]}
{"Contest id": "290/2249", "text_name": "统计圆内格点数目", "text": "给你一个二维整数数组 circles ，其中 circles[i] = [xi, yi, ri] 表示网格上圆心为 (xi, yi) 且半径为 ri 的第 i 个圆，返回出现在 至少一个 圆内的 格点数目 。", "canonical_solution": "def countLatticePoints(circles):\n        intervals = [[] for _ in range(201)]\n        for x, y, r in circles:\n            for i in range(-r, r + 1):\n                d = math.floor(math.sqrt(r**2 - i**2))\n                intervals[x + i].append([y - d, 0])\n                intervals[x + i].append([y + d, 1])\n        res = 0\n\n        for l in intervals:\n            if l:\n                l.sort()\n                count = 0\n                for i, ind in l:\n                    if count == 0:\n                        s = i\n                    if ind == 0:\n                        count += 1\n                    else:\n                        count -= 1\n                        if count == 0:\n                            res += i - s + 1\n        return res", "entry_point": "countLatticePoints", "test_list": ["assert countLatticePoints(circles = [[2,2,1]]) == 5", "assert countLatticePoints(circles = [[2,2,2],[3,4,1]]) == 16"]}
{"Contest id": "290/2248", "text_name": "多个数组求交集", "text": "给你一个二维整数数组 nums ，其中 nums[i] 是由 不同 正整数组成的一个非空数组，按 升序排列 返回一个数组，数组中的每个元素在 nums 所有数组 中都出现过。", "canonical_solution": "def intersection(A):\n        from collections import Counter\n        return sorted([k for k,v in Counter([x for l in A for x in l]).items() if v==len(A)])\n        ", "entry_point": "intersection", "test_list": ["assert intersection([[3,1,2,4,5],[1,2,3,4],[3,4,5,6]]) == [3,4]", "assert intersection([[1,2,3],[4,5,6]]) == []"]}
{"Contest id": "289/2245", "text_name": "转角路径的乘积中最多能有几个尾随零", "text": "给你一个二维整数数组 grid ，大小为 m x n，其中每个单元格都含一个正整数。\n转角路径 定义为：包含至多一个弯的一组相邻单元。具体而言，路径应该完全 向水平方向 或者 向竖直方向 移动过弯（如果存在弯），而不能访问之前访问过的单元格。在过弯之后，路径应当完全朝 另一个 方向行进：如果之前是向水平方向，那么就应该变为向竖直方向；反之亦然。当然，同样不能访问之前已经访问过的单元格。\n一条路径的 乘积 定义为：路径上所有值的乘积。\n请你从 grid 中找出一条乘积中尾随零数目最多的转角路径，并返回该路径中尾随零的数目。\n注意：\n水平 移动是指向左或右移动。\n竖直 移动是指向上或下移动。", "canonical_solution": "def maxTrailingZeros(grid):\n        ans = 0\n        m, n = len(grid), len(grid[0])\n        prefixH = [[[0] * 2 for _ in range(n + 1)] for __ in range(m)]\n        prefixV = [[[0] * 2 for _ in range(n)] for __ in range(m + 1)]\n        for i in range(m):\n            for j in range(n):\n                temp= grid[i][j]\n                while temp % 2 == 0:\n                    prefixH[i][j + 1][0] += 1\n                    prefixV[i + 1][j][0] += 1\n                    temp //= 2\n                while temp % 5 == 0:\n                    prefixH[i][j + 1][1] += 1\n                    prefixV[i + 1][j][1] += 1\n                    temp //= 5\n                for k in range(2):\n                    prefixH[i][j + 1][k] += prefixH[i][j][k]\n                    prefixV[i + 1][j][k] += prefixV[i][j][k]\n        for i in range(m):\n            for j in range(n):\n                left = prefixH[i][j]\n                up = prefixV[i][j]\n                right, down, center = [0] * 2, [0] * 2, [0] * 2\n                for k in range(2):\n                    right[k] = prefixH[i][n][k] - prefixH[i][j + 1][k]\n                    down[k] = prefixV[m][j][k] - prefixV[i + 1][j][k]\n                    center[k] = prefixH[i][j + 1][k] - prefixH[i][j][k]\n                LU, LD, RU, RD = [0] * 2, [0] * 2, [0] * 2, [0] * 2\n                for k in range(2):\n                    LU[k] += left[k] + up[k] + center[k]\n                    LD[k] += left[k] + down[k] + center[k]\n                    RU[k] += right[k] + up[k] + center[k]\n                    RD[k] += right[k] + down[k] + center[k]\n                ans = max(ans,\n                          min(LU[0], LU[1]),\n                          min(LD[0], LD[1]),\n                          min(RU[0], RU[1]),\n                          min(RD[0], RD[1]))\n        return ans", "entry_point": "maxTrailingZeros", "test_list": ["assert maxTrailingZeros(grid = [[23,17,15,3,20],[8,1,20,27,11],[9,4,6,2,21],[40,9,1,10,6],[22,7,4,5,3]]) == 3", "assert maxTrailingZeros(grid = [[4,3,2],[7,6,1],[8,8,8]]) == 0"]}
{"Contest id": "289/2244", "text_name": "完成所有任务需要的最少轮数", "text": "给你一个下标从 0 开始的整数数组 tasks ，其中 tasks[i] 表示任务的难度级别。在每一轮中，你可以完成 2 个或者 3 个 相同难度级别 的任务。\n返回完成所有任务需要的 最少 轮数，如果无法完成所有任务，返回 -1 。", "canonical_solution": "def minimumRounds(tasks):\n        from collections import Counter\n        freq = Counter(tasks).values()\n        return -1 if 1 in freq else sum((a + 2) // 3 for a in freq)\n        ", "entry_point": "minimumRounds", "test_list": ["assert minimumRounds(tasks = [2,2,3,3,2,4,4,4,4,4]) == 4", "assert minimumRounds(tasks = [2,3,3]) == -1"]}
{"Contest id": "289/2243", "text_name": "计算字符串的数字和", "text": "给你一个由若干数字（0 - 9）组成的字符串 s ，和一个整数。\n如果 s 的长度大于 k ，则可以执行一轮操作。在一轮操作中，需要完成以下工作：\n将 s 拆分 成长度为 k 的若干 连续数字组 ，使得前 k 个字符都分在第一组，接下来的 k 个字符都分在第二组，依此类推。注意，最后一个数字组的长度可以小于 k 。\n用表示每个数字组中所有数字之和的字符串来 替换 对应的数字组。例如，\"346\" 会替换为 \"13\" ，因为 3 + 4 + 6 = 13 。\n合并 所有组以形成一个新字符串。如果新字符串的长度大于 k 则重复第一步。\n返回在完成所有轮操作后的 s 。", "canonical_solution": "def digitSum(s, k):\n        while len(s) > k:\n            set_3 = [s[i:i+k] for i in range(0, len(s), k)]\n            s = ''\n            for e in set_3:\n                val = 0\n                for n in e:\n                    val += int(n)\n                s += str(val)\n        return s", "entry_point": "digitSum", "test_list": ["assert digitSum(s = \"11111222223\", k = 3) == \"135\"", "assert digitSum(s = \"00000000\", k = 3) == \"000\""]}
{"Contest id": "Bi76/2242", "text_name": "设计一个 ATM 机器", "text": "一个 ATM 机器，存有 5 种面值的钞票：20 ，50 ，100 ，200 和 500 美元。初始时，ATM 机是空的。用户可以用它存或者取任意数目的钱。\n取款时，机器会优先取 较大 数额的钱。\n比方说，你想取 $300 ，并且机器里有 2 张 $50 的钞票，1 张 $100 的钞票和1 张 $200 的钞票，那么机器会取出 $100 和 $200 的钞票。\n但是，如果你想取 $600 ，机器里有 3 张 $200 的钞票和1 张 $500 的钞票，那么取款请求会被拒绝，因为机器会先取出 $500 的钞票，然后无法取出剩余的 $100 。注意，因为有 $500 钞票的存在，机器 不能 取 $200 的钞票。\n请你实现 ATM 类：\nATM() 初始化 ATM 对象。\nvoid deposit(int[] banknotesCount) 分别存入 $20 ，$50，$100，$200 和 $500 钞票的数目。\nint[] withdraw(int amount) 返回一个长度为 5 的数组，分别表示 $20 ，$50，$100 ，$200 和 $500 钞票的数目，并且更新 ATM 机里取款后钞票的剩余数量。如果无法取出指定数额的钱，请返回 [-1] （这种情况下 不 取出任何钞票）。", "canonical_solution": "def maximumScore(scores, edges):\n        from collections import defaultdict\n        G = defaultdict(list)\n        for v,w in edges:\n            G[v].append(w)\n            G[w].append(v)\n        res = float('-inf')\n        for v in G:\n            G[v].sort(key = lambda w:-scores[w])\n        for v in G:\n            G[v] = set(G[v][:3])\n        res = float('-inf')\n        for v, w in edges:\n            tmp = scores[v]+scores[w]\n            for x in G[v]-set([w]):\n                for y in G[w]-set([v]):\n                    if x!=y:\n                        res = max(res, tmp + scores[x]+scores[y])\n        return res if res != float('-inf') else -1", "entry_point": "maximumScore", "test_list": ["assert maximumScore([5,2,9,8,4], [[0,1],[1,2],[2,3],[0,2],[1,3],[2,4]]) == 24", "assert maximumScore( [9,20,6,4,11,12],  [[0,3],[5,3],[2,4],[1,3]]) == -1"]}
{"Contest id": "Bi76/2240", "text_name": "买钢笔和铅笔的方案数", "text": "给你一个整数 total ，表示你拥有的总钱数。同时给你两个整数 cost1 和 cost2 ，分别表示一支钢笔和一支铅笔的价格。你可以花费你部分或者全部的钱，去买任意数目的两种笔。\n请你返回购买钢笔和铅笔的 不同方案数目 。", "canonical_solution": "def waysToBuyPensPencils(total, cost1, cost2):\n        ways = 0;\n        penscost = 0;\n        while penscost <= total:\n            remainingAmount = total - penscost;\n            pencils = remainingAmount//cost2 + 1;\n            ways += pencils;\n            penscost += cost1;\n        return ways", "entry_point": "waysToBuyPensPencils", "test_list": ["assert waysToBuyPensPencils(total = 20, cost1 = 10, cost2 = 5) == 9", "assert waysToBuyPensPencils(total = 5, cost1 = 10, cost2 = 10) == 1"]}
{"Contest id": "Bi76/2239", "text_name": "找到最接近 0 的数字", "text": "给你一个长度为 n 的整数数组 nums ，请你返回 nums 中最 接近 0 的数字。如果有多个答案，请你返回它们中的 最大值 。", "canonical_solution": "def findClosestNumber(A):\n        return max([-abs(a), a] for a in A)[1] ", "entry_point": "findClosestNumber", "test_list": ["assert findClosestNumber( [-4,-2,1,4,8]) == 1", "assert findClosestNumber( [2,-1,1]) == 1"]}
{"Contest id": "288/2234", "text_name": "花园的最大总美丽值", "text": "Alice 是 n 个花园的园丁，她想通过种花，最大化她所有花园的总美丽值。\n给你一个下标从 0 开始大小为 n 的整数数组 flowers ，其中 flowers[i] 是第 i 个花园里已经种的花的数目。已经种了的花 不能 移走。同时给你 newFlowers ，表示 Alice 额外可以种花的 最大数目 。同时给你的还有整数 target ，full 和 partial 。\n如果一个花园有 至少 target 朵花，那么这个花园称为 完善的 ，花园的 总美丽值 为以下分数之 和 ：\n完善 花园数目乘以 full.\n剩余 不完善 花园里，花的 最少数目 乘以 partial 。如果没有不完善花园，那么这一部分的值为 0 。\n请你返回 Alice 种最多 newFlowers 朵花以后，能得到的 最大 总美丽值。\n ", "canonical_solution": "def maximumBeauty(flowers, newFlowers, target, full, partial):\n        import bisect\n        n = len(flowers)\n        flowers.sort()\n        pre,lack = [0],[0]\n         \n        if flowers[0] >= target:\n            return n*full\n        \n        for i in flowers:\n            pre.append(pre[-1]+i)\n        \n        cnt = 0\n        for i in flowers[::-1]:\n            if i >= target:\n                cnt+=1\n            lack.append(lack[-1]+max(target-i,0))\n        \n        def fill(flower,f,k):\n            i = bisect.bisect_left(flowers,flower,lo=0,hi=k)\n            return pre[i] + f >= i*flower\n            \n        res = 0\n        for k in range(cnt,n):\n            if lack[k] < newFlowers:\n                left, right = flowers[0], target+1\n                while left < right:\n                    mid = (left+right)//2\n                    if not fill(mid,newFlowers-lack[k],n-k):\n                        right = mid\n                    else:\n                        left = mid + 1\n                left -= 1\n                \n                if left >= target:\n                    \n                    res = max(res,(target-1)*partial+k*full)\n                else:\n                    res = max(res,k*full+left*partial)\n        \n        if lack[-1] <= newFlowers:\n            res = max(res,n*full)\n        return res", "entry_point": "maximumBeauty", "test_list": ["assert maximumBeauty(flowers = [1,3,1,1], newFlowers = 7, target = 6, full = 12, partial = 1) == 14", "assert maximumBeauty(flowers = [2,4,5,3], newFlowers = 10, target = 5, full = 2, partial = 6) == 30"]}
{"Contest id": "288/2233", "text_name": "K 次增加后的最大乘积", "text": "给你一个非负整数数组 nums 和一个整数 k 。每次操作，你可以选择 nums 中 任一 元素并将它 增加 1 。\n请你返回 至多 k 次操作后，能得到的 nums的 最大乘积 。由于答案可能很大，请你将答案对 109 + 7 取余后返回。\n ", "canonical_solution": "def maximumProduct(nums, k):\n        import heapq\n        heap = []\n        for i in nums:\n            heapq.heappush (heap,i)\n            \n        while k :\n            current = heapq.heappop(heap)\n            heapq.heappush(heap, current+1)\n            k-=1\n            \n        result =1\n        \n        while len(heap)>0:\n            x= heapq.heappop(heap)\n            result =(result*x )% (10**9+7)\n            \n        return result", "entry_point": "maximumProduct", "test_list": ["assert maximumProduct(nums = [0,4], k = 5) == 20", "assert maximumProduct(nums = [6,3,3,2], k = 2) == 216"]}
{"Contest id": "288/2232", "text_name": "向表达式添加括号后的最小结果", "text": "给你一个下标从 0 开始的字符串 expression ，格式为 \"<num1>+<num2>\" ，其中 <num1> 和 <num2> 表示正整数。\n请你向 expression 中添加一对括号，使得在添加之后， expression 仍然是一个有效的数学表达式，并且计算后可以得到 最小 可能值。左括号 必须 添加在 '+' 的左侧，而右括号必须添加在 '+' 的右侧。\n返回添加一对括号后形成的表达式 expression ，且满足 expression 计算得到 最小 可能值。如果存在多个答案都能产生相同结果，返回任意一个答案。\n生成的输入满足：expression 的原始值和添加满足要求的任一对括号之后 expression 的值，都符合 32-bit 带符号整数范围。", "canonical_solution": "def minimizeResult(expression):\n        left, right = expression.split('+')                             \n        value = lambda s:eval(s.replace('(','*(').replace(')',')*').strip('*'))                                                                \n        lft = [ left[0:i]+'('+ left[i:] for i in range(  len(left )  )] \n        rgt = [right[0:i]+')'+right[i:] for i in range(1,len(right)+1)] \n        return  min([l+'+'+r for l in lft for r in rgt], key = value)", "entry_point": "minimizeResult", "test_list": ["assert minimizeResult(expression = \"247+38\") == \"2(47+38)\"", "assert minimizeResult(expression = \"12+34\") == \"1(2+3)4\"", "assert minimizeResult(expression = \"999+999\") == \"(999+999)\""]}
{"Contest id": "288/2231", "text_name": "按奇偶性交换后的最大数字", "text": "给你一个正整数 num 。你可以交换 num 中 奇偶性 相同的任意两位数字（即，都是奇数或者偶数）。\n返回交换 任意 次之后 num 的 最大 可能值。", "canonical_solution": "def largestInteger(num):\n        n = len(str(num))\n        arr = [int(i) for i in str(num)]\n        odd, even = [], []\n        for i in arr:\n            if i % 2 == 0:\n                even.append(i)\n            else:\n                odd.append(i)\n        odd.sort()\n        even.sort()\n        res = 0\n        for i in range(n):\n            if arr[i] % 2 == 0:\n                res = res*10 + even.pop()\n            else:\n                res = res*10 + odd.pop()\n        return res", "entry_point": "largestInteger", "test_list": ["assert largestInteger(num = 1234) == 3412", "assert largestInteger(num = 65875) == 87655"]}
{"Contest id": "287/2226", "text_name": "每个小孩最多能分到多少糖果", "text": "给你一个 下标从 0 开始 的整数数组 candies 。数组中的每个元素表示大小为 candies[i] 的一堆糖果。你可以将每堆糖果分成任意数量的 子堆 ，但 无法 再将两堆合并到一起。\n另给你一个整数 k 。你需要将这些糖果分配给 k 个小孩，使每个小孩分到 相同 数量的糖果。每个小孩可以拿走 至多一堆 糖果，有些糖果可能会不被分配。\n返回每个小孩可以拿走的 最大糖果数目 。", "canonical_solution": "def maximumCandies(candies, k):\n        def canSplit(candies, mid, k):\n            split = 0\n            for i in candies:\n                split += i//mid\n            if split >= k:\n                return True\n            else:\n                return False\n        end = sum(candies)//k\n        start = 1\n        ans = 0\n        while start <= end:\n            mid = (start + end)//2\n            if canSplit(candies, mid, k):\n                start = mid + 1\n                ans = mid\n            else:\n                end = mid - 1\n        return ans", "entry_point": "maximumCandies", "test_list": ["assert maximumCandies([5,8,6], 3) == 5", "assert maximumCandies([2,5], 11) == 0"]}
{"Contest id": "287/2225", "text_name": "找出输掉零场或一场比赛的玩家", "text": "给你一个整数数组 matches 其中 matches[i] = [winneri, loseri] 表示在一场比赛中 winneri 击败了 loseri 。\n返回一个长度为 2 的列表 answer ：\nanswer[0] 是所有 没有 输掉任何比赛的玩家列表。\nanswer[1] 是所有恰好输掉 一场 比赛的玩家列表。\n两个列表中的值都应该按 递增 顺序返回。\n注意：\n只考虑那些参与 至少一场 比赛的玩家。\n生成的测试用例保证 不存在 两场比赛结果 相同 。", "canonical_solution": "def findWinners(matches):\n        zeroLoss, oneLoss, moreLoss = set(), set(), set()\n\n        for match in matches:\n            winner, loser = match[0], match[1]\n\n            # Add winner.\n            if winner not in oneLoss and winner not in moreLoss:\n                zeroLoss.add(winner)\n\n            # Add or move loser.\n            if loser in zeroLoss:\n                zeroLoss.remove(loser)\n                oneLoss.add(loser)\n            elif loser in oneLoss:\n                oneLoss.remove(loser)\n                moreLoss.add(loser)\n            elif loser in moreLoss:\n                continue\n            else:\n                oneLoss.add(loser)\n\n        answer = [sorted(list(zeroLoss)), sorted(list(oneLoss))]\n        return answer", "entry_point": "findWinners", "test_list": ["assert findWinners(matches = [[1,3],[2,3],[3,6],[5,6],[5,7],[4,5],[4,8],[4,9],[10,4],[10,9]]) == [[1,2,10],[4,5,7,8]]", "assert findWinners(matches = [[2,3],[1,3],[5,4],[6,4]]) == [[1,2,5,6],[]]"]}
{"Contest id": "287/2224", "text_name": "转化时间需要的最少操作数", "text": "给你两个字符串 current 和 correct ，表示两个 24 小时制时间 。\n24 小时制时间 按 \"HH:MM\" 进行格式化，其中 HH 在 00 和 23 之间，而 MM 在 00 和 59 之间。最早的 24 小时制时间为 00:00 ，最晚的是 23:59 。\n在一步操作中，你可以将 current 这个时间增加 1、5、15 或 60 分钟。你可以执行这一操作 任意 次数。\n返回将 current 转化为 correct 需要的 最少操作数 。", "canonical_solution": "def convertTime(current, correct):\n        current_time = 60 * int(current[0:2]) + int(current[3:5])\n        target_time = 60 * int(correct[0:2]) + int(correct[3:5])\n        diff = target_time - current_time\n        count = 0\n        for i in [60, 15, 5, 1]:\n            count += diff // i\n            diff %= i\n        return count", "entry_point": "convertTime", "test_list": ["assert convertTime(current = \"02:30\", correct = \"04:35\") == 3", "assert convertTime(current = \"11:00\", correct = \"11:01\") == 1"]}
{"Contest id": "Bi75/2223", "text_name": "构造字符串的总得分和", "text": "你需要从空字符串开始 构造 一个长度为 n 的字符串 s ，构造的过程为每次给当前字符串 前面 添加 一个 字符。构造过程中得到的所有字符串编号为 1 到 n ，其中长度为 i 的字符串编号为 si 。\n比方说，s = \"abaca\" ，s1 == \"a\" ，s2 == \"ca\" ，s3 == \"aca\" 依次类推。\nsi 的 得分 为 si 和 sn 的 最长公共前缀 的长度（注意 s == sn ）。\n给你最终的字符串 s ，请你返回每一个 si 的 得分之和 。", "canonical_solution": "def sumScores(s):\n        n = len(s)\n        lps = [0] * n\n        dp = [1] * n\n        j = 0\n        i = 1\n        while i < n:\n            if s[i] == s[j]:\n                lps[i] = j + 1\n\n                dp[i] += dp[j]\n                \n                i += 1\n                j += 1\n            elif j:\n                j = lps[j - 1]\n            else:\n                i += 1\n        \n        return sum(dp)   ", "entry_point": "sumScores", "test_list": ["assert sumScores(s = \"babab\") == 9", "assert sumScores(s = \"azbazbzaz\") == 14"]}
{"Contest id": "Bi75/2222", "text_name": "选择建筑的方案数", "text": "给你一个下标从 0 开始的二进制字符串 s ，它表示一条街沿途的建筑类型，其中：\ns[i] = '0' 表示第 i 栋建筑是一栋办公楼，\ns[i] = '1' 表示第 i 栋建筑是一间餐厅。\n作为市政厅的官员，你需要随机 选择 3 栋建筑。然而，为了确保多样性，选出来的 3 栋建筑 相邻 的两栋不能是同一类型。\n比方说，给你 s = \"001101\" ，我们不能选择第 1 ，3 和 5 栋建筑，因为得到的子序列是 \"011\" ，有相邻两栋建筑是同一类型，所以 不合 题意。\n请你返回可以选择 3 栋建筑的 有效方案数 。", "canonical_solution": "def numberOfWays(s):\n        z, o, zo, oz, total = 0, 0, 0, 0, 0\n        for c in s:\n            if c == '1':\n                total += oz\n                zo += z\n                o += 1\n            elif c == '0':\n                total += zo\n                oz += o\n                z += 1\n        return total", "entry_point": "numberOfWays", "test_list": ["assert numberOfWays(s = \"001101\") == 6", "assert numberOfWays(s = \"11100\") == 0"]}
{"Contest id": "Bi75/2221", "text_name": "数组的三角和", "text": "给你一个下标从 0 开始的整数数组 nums ，其中 nums[i] 是 0 到 9 之间（两者都包含）的一个数字。\nnums 的 三角和 是执行以下操作以后最后剩下元素的值：\nnums 初始包含 n 个元素。如果 n == 1 ，终止 操作。否则，创建 一个新的下标从 0 开始的长度为 n - 1 的整数数组 newNums 。\n对于满足 0 <= i < n - 1 的下标 i ，newNums[i] 赋值 为 (nums[i] + nums[i+1]) % 10 ，% 表示取余运算。\n将 newNums 替换 数组 nums 。\n从步骤 1 开始 重复 整个过程。\n请你返回 nums 的三角和。", "canonical_solution": "def triangularSum(nums):\n    n = len(nums)\n    while n > 0:\n      for i in range(n-1):\n        nums[i] = (nums[i] + nums[i+1]) % 10\n      n -= 1\n    return nums[0]", "entry_point": "triangularSum", "test_list": ["assert triangularSum(nums = [1,2,3,4,5]) == 8", "assert triangularSum(nums = [5]) == 5"]}
{"Contest id": "Bi75/2220", "text_name": "转换数字的最少位翻转次数", "text": "一次 位翻转 定义为将数字 x 二进制中的一个位进行 翻转 操作，即将 0 变成 1 ，或者将 1 变成 0 。\n比方说，x = 7 ，二进制表示为 111 ，我们可以选择任意一个位（包含没有显示的前导 0 ）并进行翻转。比方说我们可以翻转最右边一位得到 110 ，或者翻转右边起第二位得到 101 ，或者翻转右边起第五位（这一位是前导 0 ）得到 10111 等等。\n给你两个整数 start 和 goal ，请你返回将 start 转变成 goal 的 最少位翻转 次数。", "canonical_solution": "def minBitFlips(start, goal):\n        n = start ^ goal \n        count = 0\n        while n:\n            n = n & (n-1) \n            count += 1\n        return count", "entry_point": "minBitFlips", "test_list": ["assert minBitFlips(start = 10, goal = 7) == 3", "assert minBitFlips(start = 3, goal = 4) == 3"]}
{"Contest id": "286/2218", "text_name": "从栈中取出 K 个硬币的最大面值和", "text": "一张桌子上总共有 n 个硬币 栈 。每个栈有 正整数 个带面值的硬币。\n每一次操作中，你可以从任意一个栈的 顶部 取出 1 个硬币，从栈中移除它，并放入你的钱包里。\n给你一个列表 piles ，其中 piles[i] 是一个整数数组，分别表示第 i 个栈里 从顶到底 的硬币面值。同时给你一个正整数 k ，请你返回在 恰好 进行 k 次操作的前提下，你钱包里硬币面值之和 最大为多少 。", "canonical_solution": "def maxValueOfCoins(piles, k):\n        dp = [[0] * (k + 1) for _ in range(len(piles) + 1)]\n        for i in range(1, len(piles) + 1):\n            for j in range(1, k + 1):\n                cur = 0\n                for x in range(min(len(piles[i - 1]), j)):\n                    cur += piles[i - 1][x]\n                    dp[i][j] = max(dp[i][j], cur + dp[i - 1][j - x - 1])\n                dp[i][j] = max(dp[i][j], dp[i - 1][j])\n        return dp[len(piles)][k]  ", "entry_point": "maxValueOfCoins", "test_list": ["assert maxValueOfCoins(piles = [[1,100,3],[7,8,9]], k = 2) == 101", "assert maxValueOfCoins(piles = [[100],[100],[100],[100],[100],[100],[1,1,1,1,1,1,700]], k = 7) == 706"]}
{"Contest id": "286/2217", "text_name": "找到指定长度的回文数", "text": "给你一个整数数组 queries 和一个 正 整数 intLength ，请你返回一个数组 answer ，其中 answer[i] 是长度为 intLength 的 正回文数 中第 queries[i] 小的数字，如果不存在这样的回文数，则为 -1 。\n回文数 指的是从前往后和从后往前读一模一样的数字。回文数不能有前导 0 。", "canonical_solution": "def kthPalindrome(queries, intLength):\n        ogLength = intLength\n        isOdd = intLength & 1\n        if isOdd:\n            intLength += 1\n        k = intLength // 2\n        k = 10 ** (k - 1)\n        op = []\n        for q in queries:\n            pal = str(k + q - 1)\n            if isOdd:\n                pal += pal[::-1][1:]\n            else:\n                pal += pal[::-1]\n            if len(pal) == ogLength:\n                op.append(int(pal))\n            else:\n                op.append(-1)\n        return op", "entry_point": "kthPalindrome", "test_list": ["assert kthPalindrome([1,2,3,4,5,90],  3) == [101,111,121,131,141,999]", "assert kthPalindrome([2,4,6],  4) == [1111,1331,1551]"]}
{"Contest id": "286/2216", "text_name": "美化数组的最少删除数", "text": "给你一个下标从 0 开始的整数数组 nums ，如果满足下述条件，则认为数组 nums 是一个 美丽数组 ：\nnums.length 为偶数\n对所有满足 i % 2 == 0 的下标 i ，nums[i] != nums[i + 1] 均成立\n注意，空数组同样认为是美丽数组。\n你可以从 nums 中删除任意数量的元素。当你删除一个元素时，被删除元素右侧的所有元素将会向左移动一个单位以填补空缺，而左侧的元素将会保持 不变 。\n返回使 nums 变为美丽数组所需删除的 最少 元素数目。\n \n ", "canonical_solution": "def minDeletion(A):\n        res, pre = 0, -1\n        for a in A:\n            if a == pre:\n                res += 1\n            else:\n                pre = a if pre < 0 else -1\n        return res + (pre >= 0)", "entry_point": "minDeletion", "test_list": ["assert minDeletion([1,1,2,3,5]) == 1", "assert minDeletion([1,1,2,2,3,3]) == 2"]}
{"Contest id": "286/2215", "text_name": "找出两数组的不同", "text": "给你两个下标从 0 开始的整数数组 nums1 和 nums2 ，请你返回一个长度为 2 的列表 answer ，其中：\nanswer[0] 是 nums1 中所有 不 存在于 nums2 中的 不同 整数组成的列表。\nanswer[1] 是 nums2 中所有 不 存在于 nums1 中的 不同 整数组成的列表。\n注意：列表中的整数可以按 任意 顺序返回。", "canonical_solution": "def findDifference(nums1, nums2):\n        n1=set(nums1)\n        n2=set(nums2)\n        r1=list(set(x for x in nums1 if x not in n2))\n        r2=list(set(x for x in nums2 if x not in n1))\n        return [r1,r2]", "entry_point": "findDifference", "test_list": ["assert findDifference(nums1 = [1,2,3], nums2 = [2,4,6]) == [[1,3],[4,6]]", "assert findDifference(nums1 = [1,2,3,3], nums2 = [1,1,2,2]) == [[3],[]]"]}
{"Contest id": "285/2212", "text_name": "射箭比赛中的最大得分", "text": "Alice 和 Bob 是一场射箭比赛中的对手。比赛规则如下：\nAlice 先射 numArrows 支箭，然后 Bob 也射 numArrows 支箭。\n分数按下述规则计算：\n箭靶有若干整数计分区域，范围从 0 到 11 （含 0 和 11）。\n箭靶上每个区域都对应一个得分 k（范围是 0 到 11），Alice 和 Bob 分别在得分 k 区域射中 ak 和 bk 支箭。如果 ak >= bk ，那么 Alice 得 k 分。如果 ak < bk ，则 Bob 得 k 分\n如果 ak == bk == 0 ，那么无人得到 k 分。\n例如，Alice 和 Bob 都向计分为 11 的区域射 2 支箭，那么 Alice 得 11 分。如果 Alice 向计分为 11 的区域射 0 支箭，但 Bob 向同一个区域射 2 支箭，那么 Bob 得 11 分。\n给你整数 numArrows 和一个长度为 12 的整数数组 aliceArrows ，该数组表示 Alice 射中 0 到 11 每个计分区域的箭数量。现在，Bob 想要尽可能 最大化 他所能获得的总分。\n返回数组 bobArrows ，该数组表示 Bob 射中 0 到 11 每个 计分区域的箭数量。且 bobArrows 的总和应当等于 numArrows 。\n如果存在多种方法都可以使 Bob 获得最大总分，返回其中 任意一种 即可。", "canonical_solution": "def maximumBobPoints(numArrows, aliceArrows):\n    currMax = 0\n    result = [[0]*12]\n\n    def maxscore(section, score, arrows, i):\n        nonlocal currMax\n        if arrows < 0:\n            return\n        if arrows == 0 or i == 0:\n            if score >= currMax:\n                currMax = score\n                if arrows > 0:\n                    result[0] = [arrows] + section[1:]\n                else:\n                    result[0] = section[:]\n            return\n        section[i] = aliceArrows[i]+1\n        maxscore(section, score+i, arrows-aliceArrows[i]-1, i-1)\n        section[i] = 0\n        maxscore(section, score, arrows, i-1)\n    \n    maxscore([0]*12, 0, numArrows, 11)\n    return result[0]", "entry_point": "maximumBobPoints", "test_list": ["assert maximumBobPoints(numArrows = 9, aliceArrows = [1,1,0,1,0,0,2,1,0,1,2,0]) == [0,0,0,0,1,1,0,0,1,2,3,1]", "assert maximumBobPoints(numArrows = 3, aliceArrows = [0,0,1,0,0,0,0,0,0,0,0,2]) == [0,0,0,0,0,0,0,0,1,1,1,0]"]}
{"Contest id": "285/2211", "text_name": "统计道路上的碰撞次数", "text": "在一条无限长的公路上有 n 辆汽车正在行驶。汽车按从左到右的顺序按从 0 到 n - 1 编号，每辆车都在一个 独特的 位置。\n给你一个下标从 0 开始的字符串 directions ，长度为 n 。directions[i] 可以是 'L'、'R' 或 'S' 分别表示第 i 辆车是向 左 、向 右 或者 停留 在当前位置。每辆车移动时 速度相同 。\n碰撞次数可以按下述方式计算：\n当两辆移动方向 相反 的车相撞时，碰撞次数加 2 。\n当一辆移动的车和一辆静止的车相撞时，碰撞次数加 1 。\n碰撞发生后，涉及的车辆将无法继续移动并停留在碰撞位置。除此之外，汽车不能改变它们的状态或移动方向。\n返回在这条道路上发生的 碰撞总次数 。", "canonical_solution": "def countCollisions(directions):       \n        res, n, i, carsFromRight = 0, len(directions), 0, 0\n        \n        while i < n and directions[i] == 'L':\n               i+=1\n        \n        while i<n:\n            if directions[i] == 'R':\n                carsFromRight+=1\n            else:\n                res += carsFromRight if directions[i] == 'S' else carsFromRight+1;\n                carsFromRight = 0\n            i+=1\n                \n        return res", "entry_point": "countCollisions", "test_list": ["assert countCollisions(directions = \"RLRSLL\") == 5", "assert countCollisions(directions = \"LLRR\") == 0"]}
{"Contest id": "285/2210", "text_name": "统计数组中峰和谷的数量", "text": "给你一个下标从 0 开始的整数数组 nums 。如果两侧距 i 最近的不相等邻居的值均小于 nums[i] ，则下标 i 是 nums 中，某个峰的一部分。类似地，如果两侧距 i 最近的不相等邻居的值均大于 nums[i] ，则下标 i 是 nums 中某个谷的一部分。对于相邻下标 i 和 j ，如果 nums[i] == nums[j] ， 则认为这两下标属于 同一个 峰或谷。\n注意，要使某个下标所做峰或谷的一部分，那么它左右两侧必须 都 存在不相等邻居。\n返回 nums 中峰和谷的数量。", "canonical_solution": "def countHillValley(nums):\n        hillValley = 0\n        for i in range(1, len(nums)-1):\n            if nums[i] == nums[i+1]:\n                nums[i] = nums[i-1]\n            if nums[i] > nums[i-1] and nums[i] > nums[i+1]:     #hill check\n                hillValley += 1\n            if nums[i] < nums[i-1] and nums[i] < nums[i+1]:     #valley check\n                hillValley += 1\n        return hillValley", "entry_point": "countHillValley", "test_list": ["assert countHillValley(nums = [2,4,1,1,6,5]) == 3", "assert countHillValley(nums = [6,6,5,5,4,1]) == 0"]}
{"Contest id": "Bi74/2209", "text_name": "用地毯覆盖后的最少白色砖块", "text": "给你一个下标从 0 开始的 二进制 字符串 floor ，它表示地板上砖块的颜色。\nfloor[i] = '0' 表示地板上第 i 块砖块的颜色是 黑色 。\nfloor[i] = '1' 表示地板上第 i 块砖块的颜色是 白色 。\n同时给你 numCarpets 和 carpetLen 。你有 numCarpets 条 黑色 的地毯，每一条 黑色 的地毯长度都为 carpetLen 块砖块。请你使用这些地毯去覆盖砖块，使得未被覆盖的剩余 白色 砖块的数目 最小 。地毯相互之间可以覆盖。\n请你返回没被覆盖的白色砖块的 最少 数目。", "canonical_solution": "def minimumWhiteTiles(floor, numCarpets, carpetLen):\n        n = len(floor)\n        if carpetLen*numCarpets >= n:\n            return 0\n        floorlist = []\n        for i in floor:\n            if i == '1':\n                floorlist.append(1)\n            else:\n                floorlist.append(0)\n        dp=[[0] * n for i in range(numCarpets)]        \n        for i in range(carpetLen, n):\n            dp[0][i] = min(floorlist[i] + dp[0][i-1], sum(floorlist[:i - carpetLen + 1]))\n        for j in range(1, numCarpets):\n            for i in range(carpetLen * j, n):\n                dp[j][i] = min(floorlist[i] + dp[j][i - 1], dp[j - 1][i - carpetLen])\n        return dp[-1][-1]", "entry_point": "minimumWhiteTiles", "test_list": ["assert minimumWhiteTiles( \"10110101\",  2,  2) == 2", "assert minimumWhiteTiles(\"11111\",  2,  3) == 0"]}
{"Contest id": "Bi74/2208", "text_name": "将数组和减半的最少操作次数", "text": "给你一个正整数数组 nums 。每一次操作中，你可以从 nums 中选择 任意 一个数并将它减小到 恰好 一半。（注意，在后续操作中你可以对减半过的数继续执行操作）\n请你返回将 nums 数组和 至少 减少一半的 最少 操作数。", "canonical_solution": "def halveArray(nums):\n        import heapq\n        if len(nums)==1:return 1       \n        count = 0\n        total = sum(nums)\n        half = float(total)/2\n        for i,val in enumerate(nums):\n            nums[i]=-val       \n        heapq.heapify(nums)        \n        while total > half:\n            halved = float(nums[0])/2\n            total+=halved\n            count+=1\n            heapq.heapreplace(nums,halved)                       \n        return count", "entry_point": "halveArray", "test_list": ["assert halveArray([5,19,8,1]) == 3", "assert halveArray([3,8,20]) == 3"]}
{"Contest id": "Bi74/2207", "text_name": "字符串中最多数目的子字符串", "text": "给你一个下标从 0 开始的字符串 text 和另一个下标从 0 开始且长度为 2 的字符串 pattern ，两者都只包含小写英文字母。\n你可以在 text 中任意位置插入 一个 字符，这个插入的字符必须是 pattern[0] 或者 pattern[1] 。注意，这个字符可以插入在 text 开头或者结尾的位置。\n请你返回插入一个字符后，text 中最多包含多少个等于 pattern 的 子序列 。\n子序列 指的是将一个字符串删除若干个字符后（也可以不删除），剩余字符保持原本顺序得到的字符串。", "canonical_solution": "def maximumSubsequenceCount(text, pattern):\n        res = cnt1 = cnt2 = 0\n        for c in text:\n            if c == pattern[1]:\n                res += cnt1\n                cnt2 += 1\n            if c == pattern[0]:\n                cnt1 += 1\n        return res + max(cnt1, cnt2)", "entry_point": "maximumSubsequenceCount", "test_list": ["assert maximumSubsequenceCount(text = \"abdcdbc\", pattern = \"ac\") == 4", "assert maximumSubsequenceCount(text = \"aabb\", pattern = \"ab\") == 6"]}
{"Contest id": "Bi74/2206", "text_name": "将数组划分成相等数对", "text": "给你一个整数数组 nums ，它包含 2 * n 个整数。\n你需要将 nums 划分成 n 个数对，满足：\n每个元素 只属于一个 数对。\n同一数对中的元素 相等 。\n如果可以将 nums 划分成 n 个数对，请你返回 true ，否则返回 false 。", "canonical_solution": "def divideArray(nums):\n        from collections import Counter\n        return all(i % 2 == 0 for i in Counter(nums).values())", "entry_point": "divideArray", "test_list": ["assert divideArray(nums = [3,2,3,2,2,2]) == True", "assert divideArray(nums = [1,2,3,4]) == False"]}
{"Contest id": "284/2203", "text_name": "得到要求路径的最小带权子图", "text": "给你一个整数 n ，它表示一个 带权有向 图的节点数，节点编号为 0 到 n - 1 。\n同时给你一个二维整数数组 edges ，其中 edges[i] = [fromi, toi, weighti] ，表示从 fromi 到 toi 有一条边权为 weighti 的 有向 边。\n最后，给你三个 互不相同 的整数 src1 ，src2 和 dest ，表示图中三个不同的点。\n请你从图中选出一个 边权和最小 的子图，使得从 src1 和 src2 出发，在这个子图中，都 可以 到达 dest 。如果这样的子图不存在，请返回 -1 。\n子图 中的点和边都应该属于原图的一部分。子图的边权和定义为它所包含的所有边的权值之和。", "canonical_solution": "def minimumWeight(n, edges, src1, src2, dest):\n        from math import inf\n        forward, backward = dict(), dict()\n        for start, end, weight in edges:\n            if start in forward:\n                if end in forward[start]:\n                    forward[start][end] = min(weight, forward[start][end])\n                else:\n                    forward[start][end] = weight\n            else:\n                forward[start] = {end: weight}\n            if end in backward:\n                if start in backward[end]:\n                    backward[end][start] = min(weight, backward[end][start])\n                else:\n                    backward[end][start] = weight\n            else:\n                backward[end] = {start: weight}\n\n        def travel(origin: int, relations: dict, costs: list) -> None:\n            level = {origin}\n            costs[origin] = 0\n            while level:\n                new_level = set()\n                for node in level:\n                    if node in relations:\n                        for next_node, w in relations[node].items():\n                            if w + costs[node] < costs[next_node]:\n                                new_level.add(next_node)\n                                costs[next_node] = w + costs[node]\n                level = new_level\n\n        from_src1 = [inf] * n\n        from_src2 = [inf] * n\n        from_dest = [inf] * n\n\n        travel(src1, forward, from_src1)\n        travel(src2, forward, from_src2)\n        travel(dest, backward, from_dest)\n\n        combined_cost = min(sum(tpl)\n                            for tpl in zip(from_src1, from_src2, from_dest))\n\n        return combined_cost if combined_cost < inf else -1", "entry_point": "minimumWeight", "test_list": ["assert minimumWeight(n = 6, edges = [[0,2,2],[0,5,6],[1,0,3],[1,4,5],[2,1,1],[2,3,3],[2,3,4],[3,4,2],[4,5,1]], src1 = 0, src2 = 1, dest = 5) == 9", "assert minimumWeight(n = 3, edges = [[0,1,1],[2,1,1]], src1 = 0, src2 = 1, dest = 2) == -1"]}
{"Contest id": "284/2202", "text_name": "K 次操作后最大化顶端元素", "text": "给你一个下标从 0 开始的整数数组 nums ，它表示一个 栈 ，其中 nums[0] 是栈顶的元素。\n每一次操作中，你可以执行以下操作 之一 ：\n如果栈非空，那么 删除 栈顶端的元素。\n如果存在 1 个或者多个被删除的元素，你可以从它们中选择任何一个，添加 回栈顶，这个元素成为新的栈顶元素。\n同时给你一个整数 k ，它表示你总共需要执行操作的次数。\n请你返回 恰好 执行 k 次操作以后，栈顶元素的 最大值 。如果执行完 k 次操作以后，栈一定为空，请你返回 -1 。", "canonical_solution": "def maximumTop(nums, k):\n        if len(nums) == 1:\n            if k%2 != 0:\n                return -1\n            return nums[0]\n        \n        if k == 0:\n            return nums[0]\n        if k == len(nums):\n            return max(nums[:-1])\n        if k > len(nums):\n            return max(nums)\n        if k == 1:\n            return nums[1]\n        m = max(nums[:k-1])\n        m = max(m, nums[k])\n        return m", "entry_point": "maximumTop", "test_list": ["assert maximumTop(nums = [5,2,2,4,0,6], k = 4) == 5", "assert maximumTop(nums = [2], k = 1) == -1"]}
{"Contest id": "284/2201", "text_name": "统计可以提取的工件", "text": "存在一个 n x n 大小、下标从 0 开始的网格，网格中埋着一些工件。给你一个整数 n 和一个下标从 0 开始的二维整数数组 artifacts ，artifacts 描述了矩形工件的位置，其中 artifacts[i] = [r1i, c1i, r2i, c2i] 表示第 i 个工件在子网格中的填埋情况：\n(r1i, c1i) 是第 i 个工件 左上 单元格的坐标，且\n(r2i, c2i) 是第 i 个工件 右下 单元格的坐标。\n你将会挖掘网格中的一些单元格，并清除其中的填埋物。如果单元格中埋着工件的一部分，那么该工件这一部分将会裸露出来。如果一个工件的所有部分都都裸露出来，你就可以提取该工件。\n给你一个下标从 0 开始的二维整数数组 dig ，其中 dig[i] = [ri, ci] 表示你将会挖掘单元格 (ri, ci) ，返回你可以提取的工件数目。\n生成的测试用例满足：\n不存在重叠的两个工件。\n每个工件最多只覆盖 4 个单元格。\ndig 中的元素互不相同。", "canonical_solution": "def digArtifacts(n, artifacts, dig):\n\n        dig = set((r,c) for r,c in dig)\n\n        count =0\n        for r1,c1, r2,c2 in artifacts:\n            positions = set()\n            for r in range(r1, r2+1):\n                for c in range(c1, c2+1):\n                    positions.add((r,c))\n\n            if all([pos in dig for pos in positions]):\n                count+=1\n\n        return count", "entry_point": "digArtifacts", "test_list": ["assert digArtifacts(n = 2, artifacts = [[0,0,0,0],[0,1,1,1]], dig = [[0,0],[0,1]]) == 1", "assert digArtifacts(n = 2, artifacts = [[0,0,0,0],[0,1,1,1]], dig = [[0,0],[0,1],[1,1]]) == 2"]}
{"Contest id": "284/2200", "text_name": "找出数组中的所有 K 近邻下标", "text": "给你一个下标从 0 开始的整数数组 nums 和两个整数 key 和 k 。K 近邻下标 是 nums 中的一个下标 i ，并满足至少存在一个下标 j 使得 |i - j| <= k 且 nums[j] == key 。\n以列表形式返回按 递增顺序 排序的所有 K 近邻下标。", "canonical_solution": "def findKDistantIndices(nums, key, k):\n        ind_j = []\n        for ind, elem in enumerate(nums):\n            if elem == key:\n                ind_j.append(ind)\n        res = []\n        for i in range(len(nums)):\n            for j in ind_j:\n                if abs(i - j) <= k:\n                    res.append(i)\n                    break\n        return sorted(res)", "entry_point": "findKDistantIndices", "test_list": ["assert findKDistantIndices(nums = [3,4,9,1,3,9,5], key = 9, k = 1) == [1,2,3,4,5,6]", "assert findKDistantIndices(nums = [2,2,2,2,2], key = 2, k = 2) == [0,1,2,3,4]"]}
{"Contest id": "283/2197", "text_name": "替换数组中的非互质数", "text": "给你一个整数数组 nums 。请你对数组执行下述操作：\n从 nums 中找出 任意 两个 相邻 的 非互质 数。\n如果不存在这样的数，终止 这一过程。\n否则，删除这两个数，并 替换 为它们的 最小公倍数（Least Common Multiple，LCM）。\n只要还能找出两个相邻的非互质数就继续 重复 这一过程。\n返回修改后得到的 最终 数组。可以证明的是，以 任意 顺序替换相邻的非互质数都可以得到相同的结果。\n生成的测试用例可以保证最终数组中的值 小于或者等于 108 。\n两个数字 x 和 y 满足 非互质数 的条件是：GCD(x, y) > 1 ，其中 GCD(x, y) 是 x 和 y 的 最大公约数 。", "canonical_solution": "def replaceNonCoprimes(A):\n        res = []\n        for a in A:\n            while True:\n                x = math.gcd(res[-1] if res else 1, a)\n                if x == 1: break\n                a *= res.pop() // x\n            res.append(a)\n        return res", "entry_point": "replaceNonCoprimes", "test_list": ["assert replaceNonCoprimes( [6,4,3,2,7,6,2]) == [12,7,6]", "assert replaceNonCoprimes( [2,2,1,1,3,3,3]) == [2,1,1,3]"]}
{"Contest id": "283/2195", "text_name": "向数组中追加 K 个整数", "text": "给你一个整数数组 nums 和一个整数 k 。请你向 nums 中追加 k 个 未 出现在 nums 中的、互不相同 的 正 整数，并使结果数组的元素和 最小 。\n返回追加到 nums 中的 k 个整数之和。", "canonical_solution": "def minimalKSum(nums, k):\n        nums.sort()\n        res = 0\n        nums.insert(0, 0)\n        nums.append(2000000001)\n        n = len(nums)\n        for i in range(n-1):\n            start = nums[i]\n            end = nums[i+1]\n            if start == end:\n                continue\n            a = start + 1\n            n = min(end - start - 1, k)\n            v = (n*(2*a + n - 1))//2\n            res += v\n            k -= n\n        return res", "entry_point": "minimalKSum", "test_list": ["assert minimalKSum(nums = [1,4,25,10,25], k = 2) == 5", "assert minimalKSum(nums = [5,6], k = 6) == 25"]}
{"Contest id": "283/2194", "text_name": "Excel 表中某个范围内的单元格", "text": "Excel 表中的一个单元格 (r, c) 会以字符串 \"<col><row>\" 的形式进行表示，其中：\n<col> 即单元格的列号 c 。用英文字母表中的 字母 标识。\n例如，第 1 列用 'A' 表示，第 2 列用 'B' 表示，第 3 列用 'C' 表示，以此类推。\n<row> 即单元格的行号 r 。第 r 行就用 整数 r 标识。\n给你一个格式为 \"<col1><row1>:<col2><row2>\" 的字符串 s ，其中 <col1> 表示 c1 列，<row1> 表示 r1 行，<col2> 表示 c2 列，<row2> 表示 r2 行，并满足 r1 <= r2 且 c1 <= c2 。\n找出所有满足 r1 <= x <= r2 且 c1 <= y <= c2 的单元格，并以列表形式返回。单元格应该按前面描述的格式用 字符串 表示，并以 非递减 顺序排列（先按列排，再按行排）。", "canonical_solution": "def cellsInRange(s):\n        return [chr(c) + chr(r) for c in range(ord(s[0]), ord(s[3]) + 1) for r in range(ord(s[1]), ord(s[4]) + 1)]", "entry_point": "cellsInRange", "test_list": ["assert cellsInRange(s = \"K1:L2\") == [\"K1\",\"K2\",\"L1\",\"L2\"]", "assert cellsInRange(s = \"A1:F1\") == [\"A1\",\"B1\",\"C1\",\"D1\",\"E1\",\"F1\"]"]}
{"Contest id": "Bi73/2193", "text_name": "得到回文串的最少操作次数", "text": "给你一个只包含小写英文字母的字符串 s 。\n每一次 操作 ，你可以选择 s 中两个 相邻 的字符，并将它们交换。\n请你返回将 s 变成回文串的 最少操作次数 。\n注意 ，输入数据会确保 s 一定能变成一个回文串。", "canonical_solution": "def minMovesToMakePalindrome(s):\n        count, length_of_s = 0, len(s)\n        if length_of_s <= 2:\n            return count\n        for i in reversed(range(length_of_s)):\n            if s[i] != s[0]:\n                continue\n            if i == 0:\n                count += len(s)/2 + minMovesToMakePalindrome(s[1:])  \n            else:\n                count += len(s)-1-i + minMovesToMakePalindrome(s[1:i]+s[i+1:])\n            break\n        return count", "entry_point": "minMovesToMakePalindrome", "test_list": ["assert minMovesToMakePalindrome(s = \"aabb\") == 2", "assert minMovesToMakePalindrome(s = \"letelt\") == 2"]}
{"Contest id": "Bi73/2192", "text_name": "有向无环图中一个节点的所有祖先", "text": "给你一个正整数 n ，它表示一个 有向无环图 中节点的数目，节点编号为 0 到 n - 1 （包括两者）。\n给你一个二维整数数组 edges ，其中 edges[i] = [fromi, toi] 表示图中一条从 fromi 到 toi 的单向边。\n请你返回一个数组 answer，其中 answer[i]是第 i 个节点的所有 祖先 ，这些祖先节点 升序 排序。\n如果 u 通过一系列边，能够到达 v ，那么我们称节点 u 是节点 v 的 祖先 节点。", "canonical_solution": "def getAncestors(n, edges):\n    direct_child = defaultdict(list)\n    ans = [[] for _ in range(n)]\n    for x, y in edges:\n        direct_child[x].append(y)\n\n    def dfs(x, curr):\n        for ch in direct_child[curr]:\n            if ans[ch] and ans[ch][-1] == x: continue\n            ans[ch].append(x)\n            dfs(x, ch) \n\n    for i in range(n): dfs(i, i)\n    return ans", "entry_point": "getAncestors", "test_list": ["assert getAncestors( 8,  [[0,3],[0,4],[1,3],[2,4],[2,7],[3,5],[3,6],[3,7],[4,6]]) == [[],[],[],[0,1],[0,2],[0,1,3],[0,1,2,3,4],[0,1,2,3]]", "assert getAncestors( 5,  [[0,1],[0,2],[0,3],[0,4],[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]) == [[],[0],[0,1],[0,1,2],[0,1,2,3]]"]}
{"Contest id": "Bi73/2191", "text_name": "将杂乱无章的数字排序", "text": "给你一个下标从 0 开始的整数数组 mapping ，它表示一个十进制数的映射规则，mapping[i] = j 表示这个规则下将数位 i 映射为数位 j 。\n一个整数 映射后的值 为将原数字每一个数位 i （0 <= i <= 9）映射为 mapping[i] 。\n另外给你一个整数数组 nums ，请你将数组 nums 中每个数按照它们映射后对应数字非递减顺序排序后返回。\n注意：\n如果两个数字映射后对应的数字大小相同，则将它们按照输入中的 相对顺序 排序。\nnums 中的元素只有在排序的时候需要按照映射后的值进行比较，返回的值应该是输入的元素本身。", "canonical_solution": "def sortJumbled(mapping, nums):\n        \n        def convert(num):\n            if num == 0: \n                return mapping[0]\n            mapped, multiplier = 0, 1\n            while num:\n                mapped += multiplier * mapping[num%10]\n                multiplier *= 10\n                num = num // 10\n            return mapped\n        \n        return sorted(nums, key=convert)", "entry_point": "sortJumbled", "test_list": ["assert sortJumbled(mapping = [8,9,4,0,2,1,3,5,7,6], nums = [991,338,38]) == [338,38,991]", "assert sortJumbled(mapping = [0,1,2,3,4,5,6,7,8,9], nums = [789,456,123]) == [123,456,789]"]}
{"Contest id": "Bi73/2190", "text_name": "数组中紧跟 key 之后出现最频繁的数字", "text": "给你一个下标从 0 开始的整数数组 nums ，同时给你一个整数 key ，它在 nums 出现过。\n统计 在 nums 数组中紧跟着 key 后面出现的不同整数 target 的出现次数。换言之，target 的出现次数为满足以下条件的 i 的数目：\n0 <= i <= n - 2\nnums[i] == key 且\nnums[i + 1] == target 。\n请你返回出现 最多 次数的 target 。测试数据保证出现次数最多的 target 是唯一的。", "canonical_solution": "def mostFrequent(nums, key):\n        cnt=0\n        res=[]\n        res1=0\n        a=0\n        for i in range(len(nums)-1):\n            if(nums[i]==key):\n                res.append(nums[i+1])\n        for i in res:\n            if(a<res.count(i)):\n                cnt=i\n            a=max(a,res.count(i))\n        return cnt", "entry_point": "mostFrequent", "test_list": ["assert mostFrequent(nums = [1,100,200,1,100], key = 1) == 100", "assert mostFrequent(nums = [2,2,2,2,3], key = 2) == 2"]}
{"Contest id": "282/2188", "text_name": "完成比赛的最少时间", "text": "给你一个下标从 0 开始的二维整数数组 tires ，其中 tires[i] = [fi, ri] 表示第 i 种轮胎如果连续使用，第 x 圈需要耗时 fi * ri(x-1) 秒。\n比方说，如果 fi = 3 且 ri = 2 ，且一直使用这种类型的同一条轮胎，那么该轮胎完成第 1 圈赛道耗时 3 秒，完成第 2 圈耗时 3 * 2 = 6 秒，完成第 3 圈耗时 3 * 22 = 12 秒，依次类推。\n同时给你一个整数 changeTime 和一个整数 numLaps 。\n比赛总共包含 numLaps 圈，你可以选择 任意 一种轮胎开始比赛。每一种轮胎都有 无数条 。每一圈后，你可以选择耗费 changeTime 秒 换成 任意一种轮胎（也可以换成当前种类的新轮胎）。\n请你返回完成比赛需要耗费的 最少 时间。", "canonical_solution": "def minimumFinishTime(tires, changeTime, numLaps):\n    minimum = []\n    total = [0] * len(tires)\n    while True:\n        for t in range(len(tires)):\n            total[t] += tires[t][0]\n            tires[t][0] *= tires[t][1]\n        minimum.append(min(total))\n        if minimum[-1] > changeTime + minimum[0]: break\n\n    dp = [float('inf')] * numLaps\n    for l in range(numLaps):\n        for pre in range(len(minimum)):\n            if l - pre - 1 < 0:\n                dp[l] = min(dp[l], minimum[pre])\n                break\n            dp[l] = min(dp[l], minimum[pre] + dp[l - pre - 1] + changeTime)\n    return dp[-1]", "entry_point": "minimumFinishTime", "test_list": ["assert minimumFinishTime(tires = [[2,3],[3,4]], changeTime = 5, numLaps = 4) == 21", "assert minimumFinishTime(tires = [[1,10],[2,2],[3,4]], changeTime = 6, numLaps = 5) == 25"]}
{"Contest id": "282/2187", "text_name": "完成旅途的最少时间", "text": "给你一个数组 time ，其中 time[i] 表示第 i 辆公交车完成 一趟旅途 所需要花费的时间。\n每辆公交车可以 连续 完成多趟旅途，也就是说，一辆公交车当前旅途完成后，可以 立马开始 下一趟旅途。每辆公交车 独立 运行，也就是说可以同时有多辆公交车在运行且互不影响。\n给你一个整数 totalTrips ，表示所有公交车 总共 需要完成的旅途数目。请你返回完成 至少 totalTrips 趟旅途需要花费的 最少 时间。", "canonical_solution": "def minimumTime(time, totalTrips):\n        l, r = 0, time[0] * totalTrips\n        while l < r:\n            m = (l + r) // 2\n            if sum(m // t for t in time) < totalTrips:\n                l = m + 1\n            else:\n                r = m\n        return l", "entry_point": "minimumTime", "test_list": ["assert minimumTime(time = [1,2,3], totalTrips = 5) == 3", "assert minimumTime(time = [2], totalTrips = 1) == 2"]}
{"Contest id": "282/2186", "text_name": "使两字符串互为字母异位词的最少步骤数", "text": "给你两个字符串 s 和 t 。在一步操作中，你可以给 s 或者 t 追加 任一字符 。\n返回使 s 和 t 互为 字母异位词 所需的最少步骤数。\n字母异位词 指字母相同但是顺序不同（或者相同）的字符串。", "canonical_solution": "def minSteps(s, t):\n        from collections import Counter\n        a=Counter(s)\n        b=Counter(t)\n        c=(a-b)+(b-a)\n        \n        count=0\n        for i in c:\n            count+=c[i]\n        return count", "entry_point": "minSteps", "test_list": ["assert minSteps(s = \"leetcode\", t = \"coats\") == 7", "assert minSteps(s = \"night\", t = \"thing\") == 0"]}
{"Contest id": "282/2185", "text_name": "统计包含给定前缀的字符串", "text": "给你一个字符串数组 words 和一个字符串 pref 。\n返回 words 中以 pref 作为 前缀 的字符串的数目。\n字符串 s 的 前缀 就是  s 的任一前导连续字符串。", "canonical_solution": "def prefixCount(words, pref):\n    return sum([word.startswith(pref) for word in words])", "entry_point": "prefixCount", "test_list": ["assert prefixCount(words = [\"pay\",\"attention\",\"practice\",\"attend\"], pref = \"at\") == 2", "assert prefixCount(words = [\"leetcode\",\"win\",\"loops\",\"success\"], pref = \"code\") == 0"]}
{"Contest id": "281/2183", "text_name": "构造限制重复的字符串", "text": "给你一个字符串 s 和一个整数 repeatLimit ，用 s 中的字符构造一个新字符串 repeatLimitedString ，使任何字母 连续 出现的次数都不超过 repeatLimit 次。你不必使用 s 中的全部字符。\n返回 字典序最大的 repeatLimitedString 。\n如果在字符串 a 和 b 不同的第一个位置，字符串 a 中的字母在字母表中出现时间比字符串 b 对应的字母晚，则认为字符串 a 比字符串 b 字典序更大 。如果字符串中前 min(a.length, b.length) 个字符都相同，那么较长的字符串字典序更大。", "canonical_solution": "def coutPairs(A, k):\n        from collections import Counter\n        import math\n        cnt = Counter(math.gcd(a, k) for a in A)\n        res = 0\n        for a in cnt:\n            for b in cnt:\n                if a <= b and a * b % k == 0:\n                    res += cnt[a] * cnt[b] if a < b else cnt[a] * (cnt[a] - 1) // 2\n        return res", "entry_point": "countPairs", "test_list": ["assert coutPairs([1,2,3,4,5], 2) == 7", "assert coutPairs( [1,2,3,4], 5) == 0"]}
{"Contest id": "281/2182", "text_name": "合并零之间的节点", "text": "给你一个链表的头节点 head ，该链表包含由 0 分隔开的一连串整数。链表的 开端 和 末尾 的节点都满足 Node.val == 0 。\n对于每两个相邻的 0 ，请你将它们之间的所有节点合并成一个节点，其值是所有已合并节点的值之和。然后将所有 0 移除，修改后的链表不应该含有任何 0 。\n 返回修改后链表的头节点 head 。", "canonical_solution": "def repeatLimitedString(s, repeatLimit):\n        from collections import Counter\n        table = Counter(s)\n        char_set = ['0', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's',\n                    't', 'u', 'v', 'w', 'x', 'y', 'z']\n        sorted_table = []\n        for i in range(26,-1,-1):\n            if char_set[i] in table:\n                sorted_table.append((char_set[i],table[char_set[i]]))\n\n        result = \"\"\n        n = len(sorted_table)\n        for i in range(n):\n            char, curr_freq = sorted_table[i]\n            index_to_take_from = i + 1\n            while curr_freq > repeatLimit:\n                result += char*repeatLimit\n                curr_freq -= repeatLimit\n                while index_to_take_from < n:\n                    ch_avail, freq_avail = sorted_table[index_to_take_from]\n                    if freq_avail == 0:\n                        index_to_take_from += 1\n                    else:\n                        result += ch_avail\n                        sorted_table[index_to_take_from] = (ch_avail,freq_avail-1)\n                        break\n                else:\n                    break\n            else:\n                result += char*curr_freq\n        return result", "entry_point": "repeatLimitedString", "test_list": ["assert repeatLimitedString(s = \"cczazcc\", repeatLimit = 3) == \"zzcccac\"", "assert repeatLimitedString(s = \"aababab\", repeatLimit = 2) == \"bbabaa\""]}
{"Contest id": "281/2180", "text_name": "统计各位数字之和为偶数的整数个数", "text": "给你一个正整数 num ，请你统计并返回 小于或等于 num 且各位数字之和为 偶数 的正整数的数目。\n正整数的 各位数字之和 是其所有位上的对应数字相加的结果。", "canonical_solution": "def countEven(num):\n        return num // 2 if sum([int(k) for k in str(num)]) % 2 == 0 else (num - 1) // 2", "entry_point": "countEven", "test_list": ["assert countEven(num = 4) == 2", "assert countEven(num = 30) == 14"]}
{"Contest id": "Bi72/2179", "text_name": "统计数组中好三元组数目", "text": "给你两个下标从 0 开始且长度为 n 的整数数组 nums1 和 nums2 ，两者都是 [0, 1, ..., n - 1] 的 排列 。\n好三元组 指的是 3 个 互不相同 的值，且它们在数组 nums1 和 nums2 中出现顺序保持一致。换句话说，如果我们将 pos1v 记为值 v 在 nums1 中出现的位置，pos2v 为值 v 在 nums2 中的位置，那么一个好三元组定义为 0 <= x, y, z <= n - 1 ，且 pos1x < pos1y < pos1z 和 pos2x < pos2y < pos2z 都成立的 (x, y, z) 。\n请你返回好三元组的 总数目 。", "canonical_solution": "def goodTriplets(nums1, nums2):\n        import bisect\n        n = len(nums1)\n        res = 0\n        m2 = [0] * n\n        q = []\n        for i in range(n):\n            m2[nums2[i]] = i           \n        for p1 in range(n):\n            p2 = m2[nums1[p1]] #\n            idx = bisect.bisect(q, p2) \n            q.insert(idx, p2)\n            before = idx\n            after = n-1 - p1 - p2 + before \n            res += before * after           \n        return res", "entry_point": "goodTriplets", "test_list": ["assert goodTriplets(nums1 = [2,0,1,3], nums2 = [0,1,2,3]) == 1", "assert goodTriplets(nums1 = [4,0,1,3,2], nums2 = [4,1,0,2,3]) == 4"]}
{"Contest id": "Bi72/2178", "text_name": "拆分成最多数目的正偶数之和", "text": "给你一个整数 finalSum 。请你将它拆分成若干个 互不相同 的正偶数之和，且拆分出来的正偶数数目 最多 。\n比方说，给你 finalSum = 12 ，那么这些拆分是 符合要求 的（互不相同的正偶数且和为 finalSum）：(2 + 10) ，(2 + 4 + 6) 和 (4 + 8) 。它们中，(2 + 4 + 6) 包含最多数目的整数。注意 finalSum 不能拆分成 (2 + 2 + 4 + 4) ，因为拆分出来的整数必须互不相同。\n请你返回一个整数数组，表示将整数拆分成 最多 数目的正偶数数组。如果没有办法将 finalSum 进行拆分，请你返回一个 空 数组。你可以按 任意 顺序返回这些整数。", "canonical_solution": "def maximumEvenSplit(finalSum):\n        arr = []\n        if finalSum % 2 == 0: \n            a, i = finalSum \n            while i <= a: \n                arr.append(2*i) \n                a -= i \n                i += 1 \n            s = sum(arr)\n            arr[-1] += finalSum - s \n        return arr", "entry_point": "maximumEvenSplit", "test_list": ["assert maximumEvenSplit(finalSum = 12) == [2,4,6]", "assert maximumEvenSplit(finalSum = 7) == []", "assert maximumEvenSplit(finalSum = 28) == [6,8,2,12]"]}
{"Contest id": "Bi72/2177", "text_name": "找到和为给定整数的三个连续整数", "text": "给你一个整数 num ，请你返回三个连续的整数，它们的 和 为 num 。如果 num 无法被表示成三个连续整数的和，请你返回一个 空 数组。", "canonical_solution": "def sumOfThree(num):\n        val=num//3\n        while val>=0 and 3*val==num:\n            return [val-1,val,val+1]\n        return []", "entry_point": "sumOfThree", "test_list": ["assert sumOfThree(num = 33) == [10,11,12]", "assert sumOfThree(num = 4) == []"]}
{"Contest id": "Bi72/2176", "text_name": "统计数组中相等且可以被整除的数对", "text": "给你一个下标从 0 开始长度为 n 的整数数组 nums 和一个整数 k ，请你返回满足 0 <= i < j < n ，nums[i] == nums[j] 且 (i * j) 能被 k 整除的数对 (i, j) 的 数目 。", "canonical_solution": "def countPairs(nums, k):\n        n=len(nums)\n        c=0\n        for i in range(0,n):\n            for j in range(i+1,n):\n                if nums[i]==nums[j] and ((i*j)%k==0):\n                    c+=1\n        return c   ", "entry_point": "countPairs", "test_list": ["assert countPairs(nums = [3,1,2,2,2,1,3], k = 2) == 4", "assert countPairs(nums = [1,2,3,4], k = 1) == 0"]}
{"Contest id": "280/2172", "text_name": "数组的最大与和", "text": "给你一个长度为 n 的整数数组 nums 和一个整数 numSlots ，满足2 * numSlots >= n 。总共有 numSlots 个篮子，编号为 1 到 numSlots 。\n你需要把所有 n 个整数分到这些篮子中，且每个篮子 至多 有 2 个整数。一种分配方案的 与和 定义为每个数与它所在篮子编号的 按位与运算 结果之和。\n比方说，将数字 [1, 3] 放入篮子 1 中，[4, 6] 放入篮子 2 中，这个方案的与和为 (1 AND 1) + (3 AND 1) + (4 AND 2) + (6 AND 2) = 1 + 1 + 0 + 2 = 4 。\n请你返回将 nums 中所有数放入 numSlots 个篮子中的最大与和。", "canonical_solution": "def maximumANDSum(A, ns):\n        from functools import lru_cache \n        @lru_cache(None)\n        def dp(i, mask):\n            res = 0\n            if i == len(A): return 0\n            for slot in range(1, ns + 1):\n                b = 3 ** (slot - 1)\n                if mask // b % 3 > 0:\n                    res = max(res, (A[i] & slot) + dp(i + 1, mask - b))\n            return res\n        \n        return dp(0, 3 ** ns - 1)", "entry_point": "maximumANDSum", "test_list": ["assert maximumANDSum([1,2,3,4,5,6], 3) == 9", "assert maximumANDSum([1,3,10,4,7,1],  9) == 24"]}
{"Contest id": "280/2171", "text_name": "拿出最少数目的魔法豆", "text": "给定一个 正整数 数组 beans ，其中每个整数表示一个袋子里装的魔法豆的数目。\n请你从每个袋子中 拿出 一些豆子（也可以 不拿出），使得剩下的 非空 袋子中（即 至少还有一颗 魔法豆的袋子）魔法豆的数目 相等。一旦把魔法豆从袋子中取出，你不能再将它放到任何袋子中。\n请返回你需要拿出魔法豆的 最少数目。", "canonical_solution": "def minimumRemoval(beans):\n    beans.sort()\n    s = sum(beans)\n    l = len(beans)\n    res = float('inf')\n\n    for i in range(len(beans)):\n        res = min(res, s - l * beans[i])\n        l -= 1\n        \n    return res", "entry_point": "minimumRemoval", "test_list": ["assert minimumRemoval(beans = [4,1,6,5]) == 4", "assert minimumRemoval(beans = [2,10,3,2]) == 7"]}
{"Contest id": "280/2170", "text_name": "使数组变成交替数组的最少操作数", "text": "给你一个下标从 0 开始的数组 nums ，该数组由 n 个正整数组成。\n如果满足下述条件，则数组 nums 是一个 交替数组 ：\nnums[i - 2] == nums[i] ，其中 2 <= i <= n - 1 。\nnums[i - 1] != nums[i] ，其中 1 <= i <= n - 1 。\n在一步 操作 中，你可以选择下标 i 并将 nums[i] 更改 为 任一 正整数。\n返回使数组变成交替数组的 最少操作数 。", "canonical_solution": "def minimumOperations(nums):\n        n = len(nums)\n        odd, even = defaultdict(int), defaultdict(int)\n        for i in range(n):\n            if i % 2 == 0:\n                even[nums[i]] += 1\n            else:\n                odd[nums[i]] += 1\n        topEven, secondEven = (None, 0), (None, 0)\n        for num in even:\n            if even[num] > topEven[1]:\n                topEven, secondEven = (num, even[num]), topEven\n            elif even[num] > secondEven[1]:\n                secondEven = (num, even[num])\n        topOdd, secondOdd = (None, 0), (None, 0)\n        for num in odd:\n            if odd[num] > topOdd[1]:\n                topOdd, secondOdd = (num, odd[num]), topOdd\n            elif odd[num] > secondOdd[1]:\n                secondOdd = (num, odd[num])\n        if topOdd[0] != topEven[0]:\n            return n - topOdd[1] - topEven[1]\n        else:\n            return n - max(secondOdd[1] + topEven[1], secondEven[1] + topOdd[1])", "entry_point": "minimumOperations", "test_list": ["assert minimumOperations(nums = [3,1,3,2,4,3]) == 3", "assert minimumOperations(nums = [1,2,2,2,2]) == 2"]}
{"Contest id": "280/2169", "text_name": "得到 0 的操作数", "text": "给你两个 非负 整数 num1 和 num2 。\n每一步 操作 中，如果 num1 >= num2 ，你必须用 num1 减 num2 ；否则，你必须用 num2 减 num1 。\n例如，num1 = 5 且 num2 = 4 ，应该用 num1 减 num2 ，因此，得到 num1 = 1 和 num2 = 4 。然而，如果 num1 = 4且 num2 = 5 ，一步操作后，得到 num1 = 4 和 num2 = 1 。\n返回使 num1 = 0 或 num2 = 0 的 操作数 。\n \n ", "canonical_solution": "def countOperations(num1, num2):\n        count = 0\n        while num1 != 0 and num2 != 0:\n            if num1 >= num2:\n                num1 -= num2\n            else:\n                num2 -= num1\n            count +=1\n        return count", "entry_point": "countOperations", "test_list": ["assert countOperations(num1 = 2, num2 = 3) == 3", "assert countOperations(num1 = 10, num2 = 10) == 1"]}
{"Contest id": "279/2167", "text_name": "移除所有载有违禁货物车厢所需的最少时间", "text": "给你一个下标从 0 开始的二进制字符串 s ，表示一个列车车厢序列。s[i] = '0' 表示第 i 节车厢 不 含违禁货物，而 s[i] = '1' 表示第 i 节车厢含违禁货物。\n作为列车长，你需要清理掉所有载有违禁货物的车厢。你可以不限次数执行下述三种操作中的任意一个：\n从列车 左 端移除一节车厢（即移除 s[0]），用去 1 单位时间。\n从列车 右 端移除一节车厢（即移除 s[s.length - 1]），用去 1 单位时间。\n从列车车厢序列的 任意位置 移除一节车厢，用去 2 单位时间。\n返回移除所有载有违禁货物车厢所需要的 最少 单位时间数。\n注意，空的列车车厢序列视为没有车厢含违禁货物。", "canonical_solution": "def minimumTime(s):\n        left, res, n = 0, len(s), len(s)\n        for i,c in enumerate(s):\n            left = min(left + (c == '1') * 2, i + 1)\n            res = min(res, left + n - 1 - i)\n        return res", "entry_point": "minimumTime", "test_list": ["assert minimumTime(s = \"1100101\") == 5", "assert minimumTime(s = \"0010\") == 2"]}
{"Contest id": "279/2165", "text_name": "重排数字的最小值", "text": "给你一个整数 num 。重排 num 中的各位数字，使其值 最小化 且不含 任何 前导零。\n返回不含前导零且值最小的重排数字。\n注意，重排各位数字后，num 的符号不会改变。\n ", "canonical_solution": "def smallestNumber(a):\n        s = sorted(str(abs(a)))\n        if a <= 0:\n            return -int(''.join(s[::-1]))\n        i = next(i for i,a in enumerate(s) if a > '0')\n        s[i], s[0] = s[0], s[i]\n        return int(''.join(s))", "entry_point": "smallestNumber", "test_list": ["assert smallestNumber(310) == 103", "assert smallestNumber(-7605) == -7650"]}
{"Contest id": "279/2164", "text_name": "对奇偶下标分别排序", "text": "给你一个下标从 0 开始的整数数组 nums 。根据下述规则重排 nums 中的值：\n按 非递增 顺序排列 nums 奇数下标 上的所有值。\n举个例子，如果排序前 nums = [4,1,2,3] ，对奇数下标的值排序后变为 [4,3,2,1] 。奇数下标 1 和 3 的值按照非递增顺序重排。\n按 非递减 顺序排列 nums 偶数下标 上的所有值。\n举个例子，如果排序前 nums = [4,1,2,3] ，对偶数下标的值排序后变为 [2,1,4,3] 。偶数下标 0 和 2 的值按照非递减顺序重排。\n返回重排 nums 的值之后形成的数组。", "canonical_solution": "def sortEvenOdd(nums):\n        nums[::2], nums[1::2] = sorted(nums[::2]), sorted(nums[1::2], reverse=True)\n        return nums", "entry_point": "sortEvenOdd", "test_list": ["assert sortEvenOdd(nums = [4,1,2,3]) == [2,3,4,1]", "assert sortEvenOdd(nums = [2,1]) == [2,1]"]}
{"Contest id": "Bi71/2163", "text_name": "删除元素后和的最小差值", "text": "给你一个下标从 0 开始的整数数组 nums ，它包含 3 * n 个元素。\n你可以从 nums 中删除 恰好 n 个元素，剩下的 2 * n 个元素将会被分成两个 相同大小 的部分。\n前面 n 个元素属于第一部分，它们的和记为 sumfirst 。\n后面 n 个元素属于第二部分，它们的和记为 sumsecond 。\n两部分和的 差值 记为 sumfirst - sumsecond 。\n比方说，sumfirst = 3 且 sumsecond = 2 ，它们的差值为 1 。\n再比方，sumfirst = 2 且 sumsecond = 3 ，它们的差值为 -1 。\n请你返回删除 n 个元素之后，剩下两部分和的 差值的最小值 是多少。", "canonical_solution": "def minimumDifference(nums):\n    n = len(nums) // 3\n    first, second = list(), list()\n    sum_1, sum_2 = 0, 0\n\n    for i in range(n):\n        heapq.heappush(first, -nums[i])\n        sum_1 += nums[i]\n    for i in range(2 * n, 3 * n):\n        heapq.heappush(second, nums[i])\n        sum_2 += nums[i]\n\n    sum_first = [sum_1]\n    sum_second = [sum_2]\n\n    middle = nums[n : 2 * n]\n    for i in middle:\n        rep = heapq.heappushpop(first, -i)\n        sum_1 += i + rep\n        sum_first.append(sum_1)\n\n    for i in middle[::-1]:\n        rep = heapq.heappushpop(second, i)\n        sum_2 += i - rep\n        sum_second.append(sum_2)\n\n    return min(i - j for i, j in zip(sum_first, sum_second[::-1]))", "entry_point": "minimumDifference", "test_list": ["assert minimumDifference(nums = [3,1,2]) == -1", "assert minimumDifference(nums = [7,9,5,8,1,3]) == 1"]}
{"Contest id": "Bi71/2162", "text_name": "设置时间的最少代价", "text": "常见的微波炉可以设置加热时间，且加热时间满足以下条件：\n至少为 1 秒钟。\n至多为 99 分 99 秒。\n你可以 最多 输入 4 个数字 来设置加热时间。如果你输入的位数不足 4 位，微波炉会自动加 前缀 0 来补足 4 位。微波炉会将设置好的四位数中，前 两位当作分钟数，后 两位当作秒数。它们所表示的总时间就是加热时间。比方说：\n你输入 9 5 4 （三个数字），被自动补足为 0954 ，并表示 9 分 54 秒。\n你输入 0 0 0 8 （四个数字），表示 0 分 8 秒。\n你输入 8 0 9 0 ，表示 80 分 90 秒。\n你输入 8 1 3 0 ，表示 81 分 30 秒。\n给你整数 startAt ，moveCost ，pushCost 和 targetSeconds 。一开始，你的手指在数字 startAt 处。将手指移到 任何其他数字 ，需要花费 moveCost 的单位代价。每 输入你手指所在位置的数字一次，需要花费 pushCost 的单位代价。\n要设置 targetSeconds 秒的加热时间，可能会有多种设置方法。你想要知道这些方法中，总代价最小为多少。\n请你能返回设置 targetSeconds 秒钟加热时间需要花费的最少代价。\n请记住，虽然微波炉的秒数最多可以设置到 99 秒，但一分钟等于 60 秒。", "canonical_solution": "def minCostSetTime(startAt, moveCost, pushCost, targetSeconds):\n        def count_cost(minutes, seconds):\n            time = f'{minutes // 10}{minutes % 10}{seconds // 10}{seconds % 10}'\n            time = time.lstrip('0')\n            t = [int(i) for i in time]\n            current = startAt\n            cost = 0\n            for i in t:\n                if i != current:\n                    current = i\n                    cost += moveCost\n                cost += pushCost\n            return cost\n        ans = float('inf')\n        for m in range(100):\n            for s in range(100):\n                if m * 60 + s == targetSeconds: \n                    ans = min(ans, count_cost(m, s))\n        return ans", "entry_point": "minCostSetTime", "test_list": ["assert minCostSetTime(startAt = 1, moveCost = 2, pushCost = 1, targetSeconds = 600) == 6", "assert minCostSetTime(startAt = 0, moveCost = 1, pushCost = 2, targetSeconds = 76) == 6"]}
{"Contest id": "Bi71/2161", "text_name": "根据给定数字划分数组", "text": "给你一个下标从 0 开始的整数数组 nums 和一个整数 pivot 。请你将 nums 重新排列，使得以下条件均成立：\n所有小于 pivot 的元素都出现在所有大于 pivot 的元素 之前 。\n所有等于 pivot 的元素都出现在小于和大于 pivot 的元素 中间 。\n小于 pivot 的元素之间和大于 pivot 的元素之间的 相对顺序 不发生改变。\n更正式的，考虑每一对 pi，pj ，pi 是初始时位置 i 元素的新位置，pj 是初始时位置 j 元素的新位置。对于小于 pivot 的元素，如果 i < j 且 nums[i] < pivot 和 nums[j] < pivot 都成立，那么 pi < pj 也成立。类似的，对于大于 pivot 的元素，如果 i < j 且 nums[i] > pivot 和 nums[j] > pivot 都成立，那么 pi < pj 。", "canonical_solution": "def pivotArray(nums, p):\n        return [n for n in nums if n < p] + [n for n in nums if n == p] + [n for n in nums if n > p]", "entry_point": "pivotArray", "test_list": ["assert pivotArray([9,12,5,10,14,3,10],  10) == [9,5,3,10,10,12,14]", "assert pivotArray([-3,4,3,2], 2) == [-3,2,4,3]"]}
{"Contest id": "Bi71/2160", "text_name": "拆分数位后四位数字的最小和", "text": "给你一个四位 正 整数 num 。请你使用 num 中的 数位 ，将 num 拆成两个新的整数 new1 和 new2 。new1 和 new2 中可以有 前导 0 ，且 num 中 所有 数位都必须使用。\n\n比方说，给你 num = 2932 ，你拥有的数位包括：两个 2 ，一个 9 和一个 3 。一些可能的 [new1, new2] 数对为 [22, 93]，[23, 92]，[223, 9] 和 [2, 329] 。\n请你返回可以得到的 new1 和 new2 的 最小 和。", "canonical_solution": "def minimumSum(num):\n        num = sorted(str(num),reverse=True)\n        n = len(num)    \n        res = 0\n        even_iteration = False\n        position = 0\n        for i in range(n):\n            res += int(num[i])*(10**position)\n            if even_iteration:\n                position += 1\n                even_iteration = False\n            else:\n                even_iteration = True\n        return res", "entry_point": "minimumSum", "test_list": ["assert minimumSum(num = 2932) == 52", "assert minimumSum(num = 4009) == 13"]}
{"Contest id": "278/2157", "text_name": "字符串分组", "text": "给你一个下标从 0 开始的字符串数组 words 。每个字符串都只包含 小写英文字母 。words 中任意一个子串中，每个字母都至多只出现一次。\n如果通过以下操作之一，我们可以从 s1 的字母集合得到 s2 的字母集合，那么我们称这两个字符串为 关联的 ：\n往 s1 的字母集合中添加一个字母。\n从 s1 的字母集合中删去一个字母。\n将 s1 中的一个字母替换成另外任意一个字母（也可以替换为这个字母本身）。\n数组 words 可以分为一个或者多个无交集的 组 。如果一个字符串与另一个字符串关联，那么它们应当属于同一个组。\n注意，你需要确保分好组后，一个组内的任一字符串与其他组的字符串都不关联。可以证明在这个条件下，分组方案是唯一的。\n请你返回一个长度为 2 的数组 ans ：\nans[0] 是 words 分组后的 总组数 。\nans[1] 是字符串数目最多的组所包含的字符串数目。", "canonical_solution": "def groupStrings(words):\n    import collections\n    n = len(words)\n    m = {}\n    f = []\n    def find(x):\n        if x != f[x]:\n            f[x] = find(f[x])\n        return f[x]\n    def connected(x):\n        for i in range(26):\n            yield x ^ (1 << i)\n            if (x & (1 << i)) > 0:\n                for j in range(26):\n                        if x & (1 << j) == 0:\n                            yield x ^ (1 << i) ^ (1 << j)\n    for i,w in enumerate(words):\n        x = sum(1 << (ord(c) - ord('a')) for c in w)\n        f.append(m.setdefault(x, i))\n        for y in connected(x):\n            if y in m:\n                i, j = find(m[x]), find(m[y])\n                if i != j:\n                    f[i] = j\n    count = collections.Counter(find(i) for i in range(n))\n    return [len(count), max(count.values())]", "entry_point": "groupStrings", "test_list": ["assert groupStrings(words = [\"a\",\"b\",\"ab\",\"cde\"]) == [2,3]", "assert groupStrings(words = [\"a\",\"ab\",\"abc\"]) == [1,3]"]}
{"Contest id": "278/2156", "text_name": "查找给定哈希值的子串", "text": "给定整数 p 和 m ，一个长度为 k 且下标从 0 开始的字符串 s 的哈希值按照如下函数计算：\n\nhash(s, p, m) = (val(s[0]) * p0 + val(s[1]) * p1 + ... + val(s[k-1]) * pk-1) mod m.\n其中 val(s[i]) 表示 s[i] 在字母表中的下标，从 val('a') = 1 到 val('z') = 26 。\n\n给你一个字符串 s 和整数 power，modulo，k 和 hashValue 。请你返回 s 中 第一个 长度为 k 的 子串 sub ，满足 hash(sub, power, modulo) == hashValue 。\n\n测试数据保证一定 存在 至少一个这样的子串。\n\n子串 定义为一个字符串中连续非空字符组成的序列。", "canonical_solution": "def subStrHash(s, p, m, k, hashValue):\n    def val(c):\n        return ord(c) - ord('a') + 1\n    res = n = len(s)\n    pk = pow(p,k,m)\n    cur = 0\n    for i in range(n - 1, -1, -1):\n        cur = (cur * p + val(s[i])) % m\n        if i + k < n:\n            cur = (cur - val(s[i + k]) * pk) % m\n        if cur == hashValue:\n            res = i\n    return s[res: res + k]", "entry_point": "subStrHash", "test_list": ["assert subStrHash(\"leetcode\",7,20,2,0)==\"ee\"", "assert subStrHash(\"fbxzaad\",31,100,3,32)==\"fbx\""]}
{"Contest id": "278/2155", "text_name": "分组得分最高的所有下标", "text": "给你一个下标从 0 开始的二进制数组 nums ，数组长度为 n 。nums 可以按下标 i（ 0 <= i <= n ）拆分成两个数组（可能为空）：numsleft 和 numsright 。\nnumsleft 包含 nums 中从下标 0 到 i - 1 的所有元素（包括 0 和 i - 1 ），而 numsright 包含 nums 中从下标 i 到 n - 1 的所有元素（包括 i 和 n - 1 ）。\n如果 i == 0 ，numsleft 为 空 ，而 numsright 将包含 nums 中的所有元素。\n如果 i == n ，numsleft 将包含 nums 中的所有元素，而 numsright 为 空 。\n下标 i 的 分组得分 为 numsleft 中 0 的个数和 numsright 中 1 的个数之 和 。\n返回 分组得分 最高 的 所有不同下标 。你可以按 任意顺序 返回答案。", "canonical_solution": "def maxScoreIndices(nums):\n        zeroFromLeft = [0] * (len(nums) + 1)\n        oneFromRight = [0] * (len(nums) + 1)\n        for i in range(len(nums)):\n            if nums[i] == 0:\n                zeroFromLeft[i + 1] = zeroFromLeft[i] + 1\n            else:\n                zeroFromLeft[i + 1] = zeroFromLeft[i]\n                \n        for i in range(len(nums))[::-1]:\n            if nums[i] == 1:\n                oneFromRight[i] = oneFromRight[i + 1] + 1\n            else:\n                oneFromRight[i] = oneFromRight[i + 1]\n        \n        allSum = [0] * (len(nums) + 1)\n        currentMax = 0\n        res = []\n        for i in range(len(nums) + 1):\n            allSum[i] = oneFromRight[i] + zeroFromLeft[i]\n            if allSum[i] > currentMax:\n                res = []\n                currentMax = allSum[i]\n            if allSum[i] == currentMax:\n                res.append(i)\n        return res", "entry_point": "maxScoreIndices", "test_list": ["assert maxScoreIndices(nums = [0,0,1,0]) == [2,4]", "assert maxScoreIndices(nums = [0,0,0]) == [3]", "assert maxScoreIndices(nums = [1,1]) == [0]"]}
{"Contest id": "278/2154", "text_name": "将找到的值乘以 2", "text": "给你一个整数数组 nums ，另给你一个整数 original ，这是需要在 nums 中搜索的第一个数字。\n接下来，你需要按下述步骤操作：\n如果在 nums 中找到 original ，将 original 乘以 2 ，得到新 original（即，令 original = 2 * original）。\n否则，停止这一过程。\n只要能在数组中找到新 original ，就对新 original 继续 重复 这一过程。\n返回 original 的 最终 值。", "canonical_solution": "def findFinalValue(nums, original):\n        nums = set(nums)\n        while original in nums:\n            original *= 2\n        return original", "entry_point": "findFinalValue", "test_list": ["assert findFinalValue(nums = [5,3,6,1,12], original = 3) == 24", "assert findFinalValue(nums = [2,7,9], original = 4) == 4"]}
{"Contest id": "277/2151", "text_name": "基于陈述统计最多好人数", "text": "游戏中存在两种角色：\n好人：该角色只说真话。\n坏人：该角色可能说真话，也可能说假话。\n给你一个下标从 0 开始的二维整数数组 statements ，大小为 n x n ，表示 n 个玩家对彼此角色的陈述。具体来说，statements[i][j] 可以是下述值之一：\n0 表示 i 的陈述认为 j 是 坏人 。\n1 表示 i 的陈述认为 j 是 好人 。\n2 表示 i 没有对 j 作出陈述。\n另外，玩家不会对自己进行陈述。形式上，对所有 0 <= i < n ，都有 statements[i][i] = 2 。\n根据这 n 个玩家的陈述，返回可以认为是 好人 的 最大 数目。", "canonical_solution": "def maximumGood(A):\n    n, ans = len(A), 0\n        \n    def check(perm):\n        for i in range(n):\n            if perm[i] == '0': continue\n            for j in range(n):\n                if A[i][j] == 2: continue\n                if (A[i][j] == 1 and perm[j] == '0') or (A[i][j] == 0 and perm[j] == '1'): \n                    return False\n        return True\n\n    for num in range(1 << n, 1 << (n + 1)):\n        permutation = bin(num)[3:]\n        if check(permutation): \n            ans = max(ans, permutation.count('1'))\n    return ans", "entry_point": "maximumGood", "test_list": ["assert maximumGood([[2,1,2],[1,2,2],[2,0,2]]) == 2", "assert maximumGood([[2,0],[0,2]]) == 1"]}
{"Contest id": "277/2150", "text_name": "找出数组中的所有孤独数字", "text": "给你一个整数数组 nums 。如果数字 x 在数组中仅出现 一次 ，且没有 相邻 数字（即，x + 1 和 x - 1）出现在数组中，则认为数字 x 是 孤独数字 。\n返回 nums 中的 所有 孤独数字。你可以按 任何顺序 返回答案。", "canonical_solution": "from collections import defaultdict\ndef findLonely(nums):\n        check = defaultdict(int)\n        for i in nums:\n            check[i] += 1\n        ans = []\n        for i in nums:\n            if ((i==0) or (i>=1 and check[i-1]==0)):\n                if check[i]==1 and check[i+1]==0:\n                    ans.append(i)\n        return ans", "entry_point": "findLonely", "test_list": ["assert findLonely(nums = [10,6,5,8]) == [10,8]", "assert findLonely(nums = [1,3,5,3]) == [1,5]"]}
{"Contest id": "277/2149", "text_name": "按符号重排数组", "text": "给你一个下标从 0 开始的整数数组 nums ，数组长度为 偶数 ，由数目相等的正整数和负整数组成。\n你需要 重排 nums 中的元素，使修改后的数组满足下述条件：\n任意 连续 的两个整数 符号相反\n对于符号相同的所有整数，保留 它们在 nums 中的 顺序 。\n重排后数组以正整数开头。\n重排元素满足上述条件后，返回修改后的数组。", "canonical_solution": "def rearrangeArray(nums):\n    a,b=list(filter(lambda x: x<0,nums)),list(filter(lambda x: x>0,nums))\n    result=[]\n    for i in range(len(a)):\n        result.append(b[i])\n        result.append(a[i])\n    return (result)", "entry_point": "rearrangeArray", "test_list": ["assert rearrangeArray(nums = [3,1,-2,-5,2,-4]) == [3,-2,1,-5,2,-4]", "assert rearrangeArray(nums = [-1,1]) == [1,-1]"]}
{"Contest id": "277/2148", "text_name": "元素计数", "text": "给你一个整数数组 nums ，统计并返回在 nums 中同时至少具有一个严格较小元素和一个严格较大元素的元素数目。", "canonical_solution": "def countElements(nums):\n        M = max(nums)\n        m = min(nums)\n        return sum(1 for i in nums if m<i<M)", "entry_point": "countElements", "test_list": ["assert countElements(nums = [11,7,2,15]) == 2", "assert countElements(nums = [-3,3,3,90]) == 2"]}
{"Contest id": "Bi70/2147", "text_name": "分隔长廊的方案数", "text": "在一个图书馆的长廊里，有一些座位和装饰植物排成一列。给你一个下标从 0 开始，长度为 n 的字符串 corridor ，它包含字母 'S' 和 'P' ，其中每个 'S' 表示一个座位，每个 'P' 表示一株植物。\n在下标 0 的左边和下标 n - 1 的右边 已经 分别各放了一个屏风。你还需要额外放置一些屏风。每一个位置 i - 1 和 i 之间（1 <= i <= n - 1），至多能放一个屏风。\n请你将走廊用屏风划分为若干段，且每一段内都 恰好有两个座位 ，而每一段内植物的数目没有要求。可能有多种划分方案，如果两个方案中有任何一个屏风的位置不同，那么它们被视为 不同 方案。\n请你返回划分走廊的方案数。由于答案可能很大，请你返回它对 109 + 7 取余 的结果。如果没有任何方案，请返回 0 。", "canonical_solution": "def numberOfWays(corridor):\n        seatsToLeft = 0        \n        consecutivePlants = 0\n        ans = 1           \n        for c in corridor:\n            if c == \"P\":\n                if seatsToLeft and seatsToLeft % 2 == 0:\n                    consecutivePlants += 1\n            else:\n                seatsToLeft += 1            \n                if seatsToLeft % 2 == 1 and consecutivePlants != 0:\n                    ans *= (consecutivePlants+1)\n                    consecutivePlants = 0              \n        return ans%(10**9+7) if (seatsToLeft and seatsToLeft%2 == 0) else 0", "entry_point": "numberOfWays", "test_list": ["assert numberOfWays(corridor = \"PPSPSP\") == 1", "assert numberOfWays(corridor = \"S\") == 0", "assert numberOfWays(corridor = \"SSPPSPS\") == 3"]}
{"Contest id": "Bi70/2146", "text_name": "价格范围内最高排名的 K 样物品", "text": "给你一个下标从 0 开始的二维整数数组 grid ，它的大小为 m x n ，表示一个商店中物品的分布图。数组中的整数含义为：\n\n0 表示无法穿越的一堵墙。\n1 表示可以自由通过的一个空格子。\n所有其他正整数表示该格子内的一样物品的价格。你可以自由经过这些格子。\n从一个格子走到上下左右相邻格子花费 1 步。\n\n同时给你一个整数数组 pricing 和 start ，其中 pricing = [low, high] 且 start = [row, col] ，表示你开始位置为 (row, col) ，同时你只对物品价格在 闭区间 [low, high] 之内的物品感兴趣。同时给你一个整数 k 。\n\n你想知道给定范围 内 且 排名最高 的 k 件物品的 位置 。排名按照优先级从高到低的以下规则制定：\n\n距离：定义为从 start 到一件物品的最短路径需要的步数（较近 距离的排名更高）。\n价格：较低 价格的物品有更高优先级，但只考虑在给定范围之内的价格。\n行坐标：较小 行坐标的有更高优先级。\n列坐标：较小 列坐标的有更高优先级。\n请你返回给定价格内排名最高的 k 件物品的坐标，将它们按照排名排序后返回。如果给定价格内少于 k 件物品，那么请将它们的坐标 全部 返回。\n ", "canonical_solution": "import heapq\ndef highestRankedKItems(grid, pricing, start, k):\n        row, col = len(grid), len(grid[0])\n        q = [(0, grid[start[0]][start[1]], start[0], start[1])]\n        visit = set()\n        result = []\n        while q:\n            dis, price, x, y = heapq.heappop(q)\n            if (x, y) in visit:\n                continue\n            visit.add((x, y))\n            if price != 1 and price >= pricing[0] and price <= pricing[1]:\n                result.append([x, y])\n            if len(result) == k:\n                return result\n            for dx, dy in (0, 1), (0, -1), (1, 0), (-1, 0):\n                new_x, new_y = x + dx, y + dy\n                if 0 <= new_x < row and 0 <= new_y < col and (new_x, new_y) not in visit:\n                    temp = grid[new_x][new_y]\n                    if temp == 0:\n                        continue\n                    elif temp == 1:\n                        heapq.heappush(q, (dis + 1, 1, new_x, new_y))\n                    else:\n                        heapq.heappush(q, (dis + 1, temp, new_x, new_y))\n        \n        return result", "entry_point": "highestRankedKItems", "test_list": ["assert highestRankedKItems(grid = [[1,2,0,1],[1,3,0,1],[0,2,5,1]], pricing = [2,5], start = [0,0], k = 3) == [[0,1],[1,1],[2,1]]", "assert highestRankedKItems([[1,2,0,1],[1,3,3,1],[0,2,5,1]], pricing = [2,3], start = [2,3], k = 2) == [[2,1],[1,2]]", "assert highestRankedKItems(grid = [[1,1,1],[0,0,1],[2,3,4]], pricing = [2,3], start = [0,0], k = 3) == [[2,1],[2,0]]"]}
{"Contest id": "Bi70/2145", "text_name": "统计隐藏数组数目", "text": "给你一个下标从 0 开始且长度为 n 的整数数组 differences ，它表示一个长度为 n + 1 的 隐藏 数组 相邻 元素之间的 差值 。更正式的表述为：我们将隐藏数组记作 hidden ，那么 differences[i] = hidden[i + 1] - hidden[i] 。\n同时给你两个整数 lower 和 upper ，它们表示隐藏数组中所有数字的值都在 闭 区间 [lower, upper] 之间。\n比方说，differences = [1, -3, 4] ，lower = 1 ，upper = 6 ，那么隐藏数组是一个长度为 4 且所有值都在 1 和 6 （包含两者）之间的数组。\n[3, 4, 1, 5] 和 [4, 5, 2, 6] 都是符合要求的隐藏数组。\n[5, 6, 3, 7] 不符合要求，因为它包含大于 6 的元素。\n[1, 2, 3, 4] 不符合要求，因为相邻元素的差值不符合给定数据。\n请你返回 符合 要求的隐藏数组的数目。如果没有符合要求的隐藏数组，请返回 0 。", "canonical_solution": "from itertools import accumulate\ndef numberOfArrays(differences, lower, upper):\n           A = list(accumulate(differences, initial = 0))\n           return max(0, (upper - lower) - (max(A) - min(A)) + 1)", "entry_point": "numberOfArrays", "test_list": ["assert numberOfArrays(differences = [1,-3,4], lower = 1, upper = 6) == 2", "assert numberOfArrays(differences = [3,-4,5,1,-2], lower = -4, upper = 5) == 4", "assert numberOfArrays(differences = [4,-7,2], lower = 3, upper = 6) == 0"]}
{"Contest id": "Bi70/2144", "text_name": "打折购买糖果的最小开销", "text": "一家商店正在打折销售糖果。每购买 两个 糖果，商店会 免费 送一个糖果。\n免费送的糖果唯一的限制是：它的价格需要小于等于购买的两个糖果价格的 较小值 。\n比方说，总共有 4 个糖果，价格分别为 1 ，2 ，3 和 4 ，一位顾客买了价格为 2 和 3 的糖果，那么他可以免费获得价格为 1 的糖果，但不能获得价格为 4 的糖果。\n给你一个下标从 0 开始的整数数组 cost ，其中 cost[i] 表示第 i 个糖果的价格，请你返回获得 所有 糖果的 最小 总开销。", "canonical_solution": "def minimumCost(cost):\n            return sum(a for i,a in enumerate(sorted(cost)) if (len(cost) - i) % 3)", "entry_point": "minimumCost", "test_list": ["assert minimumCost(cost = [1,2,3]) == 5", "assert minimumCost(cost = [6,5,7,9,2,2]) == 23", "assert minimumCost(cost = [5,5]) == 10"]}
{"Contest id": "276/2141", "text_name": "同时运行 N 台电脑的最长时间", "text": "你有 n 台电脑。给你整数 n 和一个下标从 0 开始的整数数组 batteries ，其中第 i 个电池可以让一台电脑 运行 batteries[i] 分钟。你想使用这些电池让 全部 n 台电脑 同时 运行。\n一开始，你可以给每台电脑连接 至多一个电池 。然后在任意整数时刻，你都可以将一台电脑与它的电池断开连接，并连接另一个电池，你可以进行这个操作 任意次 。新连接的电池可以是一个全新的电池，也可以是别的电脑用过的电池。断开连接和连接新的电池不会花费任何时间。\n注意，你不能给电池充电。\n请你返回你可以让 n 台电脑同时运行的 最长 分钟数。", "canonical_solution": "def maxRunTime(n, batteries):\n        left=0\n        right=sum(batteries)//n+1\n        def check(time):\n            return sum(min(time,b) for b in batteries)>=n*time\n\n        while left<=right:\n            mid=(left+right)//2\n            if check(mid):\n                left=mid+1\n\n            else:\n                right=mid-1\n\n        return right                    ", "entry_point": "maxRunTime", "test_list": ["assert maxRunTime(n = 2, batteries = [3,3,3]) == 4", "assert maxRunTime(n = 2, batteries = [1,1,1,1]) == 2"]}
{"Contest id": "276/2140", "text_name": " 解决智力问题", "text": "给你一个下标从 0 开始的二维整数数组 questions ，其中 questions[i] = [pointsi, brainpoweri] 。\n\n这个数组表示一场考试里的一系列题目，你需要 按顺序 （也就是从问题 0 开始依次解决），针对每个问题选择 解决 或者 跳过 操作。解决问题 i 将让你 获得  pointsi 的分数，但是你将 无法 解决接下来的 brainpoweri 个问题（即只能跳过接下来的 brainpoweri 个问题）。如果你跳过问题 i ，你可以对下一个问题决定使用哪种操作。\n\n比方说，给你 questions = [[3, 2], [4, 3], [4, 4], [2, 5]] ：\n如果问题 0 被解决了， 那么你可以获得 3 分，但你不能解决问题 1 和 2 。\n如果你跳过问题 0 ，且解决问题 1 ，你将获得 4 分但是不能解决问题 2 和 3 。\n请你返回这场考试里你能获得的 最高 分数。", "canonical_solution": "def mostPoints(questions):\n    def max_score(i: int) -> int:\n        return i < len(questions) and max(questions[i][0] + max_score(i + 1 + questions[i][1]), max_score(i + 1))\n    return max_score(0)", "entry_point": "mostPoints", "test_list": ["assert mostPoints(questions = [[3,2],[4,3],[4,4],[2,5]]) == 5", "assert mostPoints(questions = [[1,1],[2,2],[3,3],[4,4],[5,5]]) == 7"]}
{"Contest id": "276/2139", "text_name": "得到目标值的最少行动次数", "text": "你正在玩一个整数游戏。从整数 1 开始，期望得到整数 target 。\n在一次行动中，你可以做下述两种操作之一：\n递增，将当前整数的值加 1（即， x = x + 1）。\n加倍，使当前整数的值翻倍（即，x = 2 * x）。\n在整个游戏过程中，你可以使用 递增 操作 任意 次数。但是只能使用 加倍 操作 至多 maxDoubles 次。\n给你两个整数 target 和 maxDoubles ，返回从 1 开始得到 target 需要的最少行动次数。", "canonical_solution": "def minMoves(target, maxDoubles):\n        cnt=0\n        while target>1 and maxDoubles>0:\n            if target%2==0:\n                target=target//2\n                maxDoubles-=1\n            else:\n                target-=1\n            cnt+=1\n        if target>1:cnt+=target-1\n        return cnt", "entry_point": "minMoves", "test_list": ["assert minMoves(target = 5, maxDoubles = 0) == 4", "assert minMoves(target = 19, maxDoubles = 2) == 7", "assert minMoves(target = 10, maxDoubles = 4) == 4"]}
{"Contest id": "276/2138", "text_name": "将字符串拆分为若干长度为 k 的组", "text": "字符串 s 可以按下述步骤划分为若干长度为 k 的组：\n第一组由字符串中的前 k 个字符组成，第二组由接下来的 k 个字符串组成，依此类推。每个字符都能够成为 某一个 组的一部分。\n对于最后一组，如果字符串剩下的字符 不足 k 个，需使用字符 fill 来补全这一组字符。\n注意，在去除最后一个组的填充字符 fill（如果存在的话）并按顺序连接所有的组后，所得到的字符串应该是 s 。\n给你一个字符串 s ，以及每组的长度 k 和一个用于填充的字符 fill ，按上述步骤处理之后，返回一个字符串数组，该数组表示 s 分组后 每个组的组成情况 。", "canonical_solution": "def divideString(s, k, fill):\n        l=[]\n        if len(s)%k!=0:\n            s+=fill*(k-len(s)%k)\n        for i in range(0,len(s),k):\n            l.append(s[i:i+k])\n        return l", "entry_point": "divideString", "test_list": ["assert divideString(s = \"abcdefghi\", k = 3, fill = \"x\") == [\"abc\",\"def\",\"ghi\"]", "assert divideString(s = \"abcdefghij\", k = 3, fill = \"x\") == [\"abc\",\"def\",\"ghi\",\"jxx\"]"]}
{"Contest id": "275/2136", "text_name": "全部开花的最早一天", "text": "你有 n 枚花的种子。每枚种子必须先种下，才能开始生长、开花。播种需要时间，种子的生长也是如此。给你两个下标从 0 开始的整数数组 plantTime 和 growTime ，每个数组的长度都是 n ：\nplantTime[i] 是 播种 第 i 枚种子所需的 完整天数 。每天，你只能为播种某一枚种子而劳作。无须 连续几天都在种同一枚种子，但是种子播种必须在你工作的天数达到 plantTime[i] 之后才算完成。\ngrowTime[i] 是第 i 枚种子完全种下后生长所需的 完整天数 。在它生长的最后一天 之后 ，将会开花并且永远 绽放 。\n从第 0 开始，你可以按 任意 顺序播种种子。\n返回所有种子都开花的 最早 一天是第几天。", "canonical_solution": "def earliestFullBloom(plantTime, growTime):\n        comb=[(plantTime[i],growTime[i]) for i in range(len(plantTime))]\n        mx,passed_days=0,0\n        comb.sort(key=lambda x:(-x[1],x[0]))\n        for i in range(len(plantTime)):\n            mx=max(mx,(passed_days+comb[i][0]+comb[i][1]))\n            passed_days+=comb[i][0]\n        return mx", "entry_point": "earliestFullBloom", "test_list": ["assert earliestFullBloom(plantTime = [1,4,3], growTime = [2,3,1]) == 9", "assert earliestFullBloom(plantTime = [1,2,3,2], growTime = [2,1,2,1]) == 9", "assert earliestFullBloom(plantTime = [1], growTime = [1]) == 2"]}
{"Contest id": "275/2135", "text_name": "统计追加字母可以获得的单词数", "text": "给你两个下标从 0 开始的字符串数组 startWords 和 targetWords 。每个字符串都仅由 小写英文字母 组成。\n对于 targetWords 中的每个字符串，检查是否能够从 startWords 中选出一个字符串，执行一次 转换操作 ，得到的结果与当前 targetWords 字符串相等。\n转换操作 如下面两步所述：\n追加 任何 不存在 于当前字符串的任一小写字母到当前字符串的末尾。\n例如，如果字符串为 \"abc\" ，那么字母 'd'、'e' 或 'y' 都可以加到该字符串末尾，但 'a' 就不行。如果追加的是 'd' ，那么结果字符串为 \"abcd\" 。\n重排 新字符串中的字母，可以按 任意 顺序重新排布字母。\n例如，\"abcd\" 可以重排为 \"acbd\"、\"bacd\"、\"cbda\"，以此类推。注意，它也可以重排为 \"abcd\" 自身。\n找出 targetWords 中有多少字符串能够由 startWords 中的 任一 字符串执行上述转换操作获得。返回 targetWords 中这类 字符串的数目 。\n注意：你仅能验证 targetWords 中的字符串是否可以由 startWords 中的某个字符串经执行操作获得。startWords  中的字符串在这一过程中 不 发生实际变更。", "canonical_solution": "def wordCount(startWords, targetWords):\n        cnt = 0\n        for target in targetWords:\n            for start in startWords:\n                if len(target) - len(start) == 1 and len(set(list(target)) - set(list(start))) == 1:\n                    cnt += 1\n                    break\n        return cnt", "entry_point": "wordCount", "test_list": ["assert wordCount(startWords = [\"ant\",\"act\",\"tack\"], targetWords = [\"tack\",\"act\",\"acti\"]) == 2", "assert wordCount(startWords = [\"ab\",\"a\"], targetWords = [\"abc\",\"abcd\"]) == 1"]}
{"Contest id": "275/2134", "text_name": "最少交换次数来组合所有的 1 II", "text": "交换 定义为选中一个数组中的两个 互不相同 的位置并交换二者的值。\n环形 数组是一个数组，可以认为 第一个 元素和 最后一个 元素 相邻 。\n给你一个 二进制环形 数组 nums ，返回在 任意位置 将数组中的所有 1 聚集在一起需要的最少交换次数。", "canonical_solution": "def minSwaps(nums):\n    width = sum(num == 1 for num in nums)\n    nums += nums\n    res = width\n    curr_zeros = sum(num == 0 for num in nums[:width])     \n    for i in range(width, len(nums)):\n        curr_zeros -= (nums[i - width] == 0)\n        curr_zeros += (nums[i] == 0)\n        res = min(res, curr_zeros)\n    return res", "entry_point": "minSwaps", "test_list": ["assert minSwaps(nums = [0,1,0,1,1,0,0]) == 1", "assert minSwaps(nums = [0,1,1,1,0,0,1,1,0]) == 2", "assert minSwaps(nums = [1,1,0,0,1]) == 0"]}
{"Contest id": "275/2133", "text_name": "检查是否每一行每一列都包含全部整数", "text": "对一个大小为 n x n 的矩阵而言，如果其每一行和每一列都包含从 1 到 n 的 全部 整数（含 1 和 n），则认为该矩阵是一个 有效 矩阵。\n给你一个大小为 n x n 的整数矩阵 matrix ，请你判断矩阵是否为一个有效矩阵：如果是，返回 true ；否则，返回 false 。", "canonical_solution": "def checkValid(matrix):\n        set_ = set(range(1,len(matrix)+1))\n        return all(set_ == set(x) for x in matrix+list(zip(*matrix)))", "entry_point": "checkValid", "test_list": ["assert checkValid(matrix = [[1,2,3],[3,1,2],[2,3,1]]) == True", "assert checkValid(matrix = [[1,1,1],[1,2,3],[1,2,3]]) == False"]}
{"Contest id": "Bi69/2132", "text_name": "用邮票贴满网格图", "text": "给你一个 m x n 的二进制矩阵 grid ，每个格子要么为 0 （空）要么为 1 （被占据）。\n给你邮票的尺寸为 stampHeight x stampWidth 。我们想将邮票贴进二进制矩阵中，且满足以下 限制 和 要求 ：\n覆盖所有 空 格子。\n不覆盖任何 被占据 的格子。\n我们可以放入任意数目的邮票。\n邮票可以相互有 重叠 部分。\n邮票不允许 旋转 。\n邮票必须完全在矩阵 内 。\n如果在满足上述要求的前提下，可以放入邮票，请返回 true ，否则返回 false 。", "canonical_solution": "def possibleToStamp(M, h, w):\n        m, n = len(M), len(M[0])\n        A = [[0] * (n + 1) for _ in range(m + 1)]\n        good = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                A[i + 1][j + 1] = A[i + 1][j] + A[i][j + 1] - A[i][j] + (1 - M[i][j])\n                if i + 1 >= h and j + 1 >= w:\n                    x, y = i + 1 - h, j + 1 -w\n                    if A[i + 1][j + 1] - A[x][j + 1] - A[i + 1][y] + A[x][y] == w * h:\n                        good[i][j] += 1\n        B = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(m):\n            for j in range(n):\n                B[i + 1][j + 1] = B[i + 1][j] + B[i][j + 1] - B[i][j] + good[i][j]\n        for i in range(m):\n            for j in range(n):\n                x, y = min(i + h, m), min(j + w, n)\n                if M[i][j] == 0 and B[x][y] - B[i][y] - B[x][j] + B[i][j] == 0:\n                    return False\n        return True", "entry_point": "possibleToStamp", "test_list": ["assert possibleToStamp( [[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0]], 4, 3) == True", "assert possibleToStamp([[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]], 2, 2 ) == False"]}
{"Contest id": "Bi69/2131", "text_name": "连接两字母单词得到的最长回文串", "text": "给你一个字符串数组 words 。words 中每个元素都是一个包含 两个 小写英文字母的单词。\n请你从 words 中选择一些元素并按 任意顺序 连接它们，并得到一个 尽可能长的回文串 。每个元素 至多 只能使用一次。\n请你返回你能得到的最长回文串的 长度 。如果没办法得到任何一个回文串，请你返回 0 。\n回文串 指的是从前往后和从后往前读一样的字符串。", "canonical_solution": "def longestPalindrome(words):\n        dc=defaultdict(lambda:0)\n        for a in words:\n            dc[a]+=1\n        count=0\n        palindromswords=0\n        inmiddle=0\n        wds=set(words)\n        for a in wds:\n            if(a==a[::-1]):\n                if(dc[a]%2==1):\n                    inmiddle=1\n                palindromswords+=(dc[a]//2)*2\n            elif(dc[a[::-1]]>0):\n                count+=(2*(min(dc[a],dc[a[::-1]])))\n                dc[a]=0\n        return (palindromswords+count+inmiddle)*2", "entry_point": "longestPalindrome", "test_list": ["assert longestPalindrome(words = [\"lc\",\"cl\",\"gg\"]) == 6", "assert longestPalindrome(words = [\"ab\",\"ty\",\"yt\",\"lc\",\"cl\",\"ab\"]) == 8", "assert longestPalindrome(words = [\"cc\",\"ll\",\"xx\"]) == 2"]}
{"Contest id": "Bi69/2129", "text_name": "将标题首字母大写", "text": "给你一个字符串 title ，它由单个空格连接一个或多个单词组成，每个单词都只包含英文字母。请你按以下规则将每个单词的首字母 大写 ：\n如果单词的长度为 1 或者 2 ，所有字母变成小写。\n否则，将单词首字母大写，剩余字母变成小写。\n请你返回 大写后 的 title ", "canonical_solution": "def capitalizeTitle(title):\n    return \" \".join([word.lower() if len(word) < 3 else word.title() for word in title.split()])", "entry_point": "capitalizeTitle", "test_list": ["assert capitalizeTitle(title = \"capiTalIze tHe titLe\") == \"Capitalize The Title\"", "assert capitalizeTitle(title = \"First leTTeR of EACH Word\") ==  \"First Letter of Each Word\"", "assert capitalizeTitle(title = \"i lOve leetcode\") == \"i Love Leetcode\""]}
{"Contest id": "274/2127", "text_name": "参加会议的最多员工数", "text": "一个公司准备组织一场会议，邀请名单上有 n 位员工。公司准备了一张 圆形 的桌子，可以坐下 任意数目 的员工。\n员工编号为 0 到 n - 1 。每位员工都有一位 喜欢 的员工，每位员工 当且仅当 他被安排在喜欢员工的旁边，他才会参加会议。每位员工喜欢的员工 不会 是他自己。\n给你一个下标从 0 开始的整数数组 favorite ，其中 favorite[i] 表示第 i 位员工喜欢的员工。请你返回参加会议的 最多员工数目 。", "canonical_solution": "def maximumInvitations(favorite):\n    import collections\n    pre = collections.defaultdict(list)\n    for i, j in enumerate(favorite):\n        pre[j].append(i)\n    seen, max_cycle_length, sequence_length = set(), 0, 0\n    for node in range(len(favorite)):  # for each island, there is one and only one cycle\n        if node in seen: continue\n        path = [node]\n        while favorite[path[-1]] not in seen:\n            seen.add(favorite[path[-1]])\n            path.append(favorite[path[-1]])\n        if favorite[path[-1]] not in path: continue\n        cycle_length = len(path) - path.index(favorite[path[-1]])\n        if cycle_length == 2: \n            max_sub_len = [0, 0]\n            cycle = path[-2:]\n            pre[cycle[0]].remove(cycle[1])\n            pre[cycle[1]].remove(cycle[0])\n            for k in [0, 1]: \n                dq = collections.deque([(cycle[k], 0)])\n                while dq:\n                    i, depth = dq.pop()  # DFS\n                    # i, depth = dq.popleft()  # BFS\n                    if i in pre:\n                        for j in pre[i]:\n                            dq.append((j, depth + 1))\n                            seen.add(j)\n                    else:\n                        max_sub_len[k] = max(max_sub_len[k], depth) \n            sequence_length += 2 + sum(max_sub_len)\n        else: \n            max_cycle_length = max(max_cycle_length, cycle_length)\n    return max(max_cycle_length, sequence_length)", "entry_point": "maximumInvitations", "test_list": ["assert maximumInvitations(favorite = [2,2,1,2]) == 3", "assert maximumInvitations(favorite = [1,2,0]) == 3"]}
{"Contest id": "274/2126", "text_name": "摧毁小行星", "text": "给你一个整数 mass ，它表示一颗行星的初始质量。再给你一个整数数组 asteroids ，其中 asteroids[i] 是第 i 颗小行星的质量。\n你可以按 任意顺序 重新安排小行星的顺序，然后让行星跟它们发生碰撞。如果行星碰撞时的质量 大于等于 小行星的质量，那么小行星被 摧毁 ，并且行星会 获得 这颗小行星的质量。否则，行星将被摧毁。\n如果所有小行星 都 能被摧毁，请返回 true ，否则返回 false 。", "canonical_solution": "def asteroidsDestroyed(mass, asteroids):\n        asteroids.sort()\n        for asteroid in asteroids:\n            if mass >= asteroid:\n                mass += asteroid\n            else:\n                return False\n        return True", "entry_point": "asteroidsDestroyed", "test_list": ["assert asteroidsDestroyed(mass = 10, asteroids = [3,9,19,5,21]) == True", "assert asteroidsDestroyed(mass = 5, asteroids = [4,9,23,4]) == False"]}
{"Contest id": "274/2125", "text_name": "银行中的激光束数量", "text": "银行内部的防盗安全装置已经激活。给你一个下标从 0 开始的二进制字符串数组 bank ，表示银行的平面图，这是一个大小为 m x n 的二维矩阵。 bank[i] 表示第 i 行的设备分布，由若干 '0' 和若干 '1' 组成。'0' 表示单元格是空的，而 '1' 表示单元格有一个安全设备。\n对任意两个安全设备而言，如果同时 满足下面两个条件，则二者之间存在 一个 激光束：\n两个设备位于两个 不同行 ：r1 和 r2 ，其中 r1 < r2 。\n满足 r1 < i < r2 的 所有 行 i ，都 没有安全设备 。\n激光束是独立的，也就是说，一个激光束既不会干扰另一个激光束，也不会与另一个激光束合并成一束。\n返回银行中激光束的总数量。", "canonical_solution": "def numberOfBeams(bank):\n        if len(bank) < 2:\n            return 0\n        solution = 0\n        beacons_in_prev_row = 0\n        beacons_in_current_row = 0\n        for row in bank:\n            beacons_in_current_row = 0\n            for c in row:\n                if c == '1':\n                    beacons_in_current_row += 1\n            solution += beacons_in_current_row * beacons_in_prev_row\n            beacons_in_prev_row = beacons_in_current_row or beacons_in_prev_row\n        return solution", "entry_point": "numberOfBeams", "test_list": ["assert numberOfBeams(bank = [\"011001\",\"000000\",\"010100\",\"001000\"]) == 8", "assert numberOfBeams(bank = [\"000\",\"111\",\"000\"]) == 0"]}
{"Contest id": "274/2124", "text_name": "检查是否所有 A 都在 B 之前", "text": "给你一个 仅 由字符 'a' 和 'b' 组成的字符串  s 。如果字符串中 每个 'a' 都出现在 每个 'b' 之前，返回 true ；否则，返回 false 。", "canonical_solution": "def checkString(s):\n    return (''.join(sorted(list(s))))==s\n    def checkString(s):\n        return \"ba\" not in s", "entry_point": "checkString", "test_list": ["assert checkString(s = \"aaabbb\") == True", "assert checkString(s = \"abab\") == False", "assert checkString(s = \"bbb\") == True"]}