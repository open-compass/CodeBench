{"Contest id": "378/2983", "text_name": "Palindrome Rearrangement Queries", "text": "You are given a 0-indexed string s having an even length n.\nYou are also given a 0-indexed 2D integer array, queries, where queries[i] = [ai, bi, ci, di].\nFor each query i, you are allowed to perform the following operations:\nRearrange the characters within the substring s[ai:bi], where 0 <= ai <= bi < n / 2.\nRearrange the characters within the substring s[ci:di], where n / 2 <= ci <= di < n.\nFor each query, your task is to determine whether it is possible to make s a palindrome by performing the operations.\nEach query is answered independently of the others.\nReturn a 0-indexed array answer, where answer[i] == true if it is possible to make s a palindrome by performing operations specified by the ith query, and false otherwise.\nA substring is a contiguous sequence of characters within a string.\ns[x:y] represents the substring consisting of characters from the index x to index y in s, both inclusive.", "canonical_solution": "def canMakePalindromeQueries(s, queries):\n        from collections import Counter\n        n = len(s)\n        q = len(queries)\n        s1 = s[:n//2]\n        s2 = s[n//2:][::-1]\n        if Counter(s1) != Counter(s2):\n            return [False] * q       \n        for i, ls in enumerate(queries):\n            queries[i] = [ls[0], ls[1], n - 1 - ls[3], n - 1 - ls[2]]       \n        n //= 2\n        left = [-1] * n\n        l = -1\n        for i in range(n):\n            if s1[i] == s2[i]:\n                if l == -1:\n                    l = i\n            else:\n                if l != -1:\n                    for j in range(l, i):\n                        left[j] = i - 1\n                    l = -1\n        if l != -1:\n            for j in range(l, n):\n                left[j] = n - 1\n        cnt1 = [[0] * 26]\n        curr = [0] * 26\n        for i in range(n):\n            curr[ord(s1[i]) - 97] += 1\n            cnt1.append(curr[:])      \n        cnt2 = [[0] * 26]\n        curr = [0] * 26\n        for i in range(n):\n            curr[ord(s2[i]) - 97] += 1\n            cnt2.append(curr[:])           \n        res = []\n        for a, b, c, d in queries:\n            flag = True\n            if a > c:\n                a, b, c, d = c, d, a, b\n                flag = False\n            if b < c - 1:\n                if left[b + 1] >= c - 1 and left[0] >= a - 1 and (d == n - 1 or left[d + 1] == n - 1):\n                    curr = [0] * 26\n                    total = [0] * 26\n                    for i in range(26):\n                        curr[i] = cnt2[b + 1][i] - cnt2[a][i]\n                        total[i] = cnt1[b + 1][i] - cnt1[a][i]\n                        if total[i] < curr[i]:\n                            res.append(False)\n                            break\n                    else:\n                        res.append(True)\n                else:\n                    res.append(False)\n            elif b >= d:\n                if left[0] >= a - 1 and (b == n - 1 or left[b + 1] == n - 1):\n                    res.append(True)\n                else:\n                    res.append(False)\n            else:\n                if left[0] >= a - 1 and (d == n - 1 or left[d + 1] == n - 1):\n                    curr = [0] * 26\n                    total = [0] * 26\n                    if flag:\n                        for i in range(26):\n                            curr[i] = cnt2[c][i] - cnt2[a][i]\n                            total[i] = cnt1[b + 1][i] - cnt1[a][i]\n                            if total[i] < curr[i]:\n                                res.append(False)\n                                break\n                        else:\n                            res.append(True)\n                    else:\n                        for i in range(26):\n                            curr[i] = cnt1[c][i] - cnt1[a][i]\n                            total[i] = cnt2[b + 1][i] - cnt2[a][i]\n                            if total[i] < curr[i]:\n                                res.append(False)\n                                break\n                        else:\n                            res.append(True)\n                else:\n                    res.append(False)\n        return res", "entry_point": "canMakePalindromeQueries", "test_list": ["assert canMakePalindromeQueries(s = \"abcabc\", queries = [[1,1,3,5],[0,2,5,5]]) == [True,True]", "assert canMakePalindromeQueries(s = \"abbcdecbba\", queries = [[0,2,7,9]]) == [False]", "assert canMakePalindromeQueries(s = \"acbcab\", queries = [[1,2,4,5]]) ==  [True]"]}
{"Contest id": "378/2982", "text_name": "Find Longest Special Substring That Occurs Thrice II", "text": "You are given a string s that consists of lowercase English letters.\nA string is called special if it is made up of only a single character. For example, the string \"abc\" is not special, whereas the strings \"ddd\", \"zz\", and \"f\" are special.\nReturn the length of the longest special substring of s which occurs at least thrice, or -1 if no special substring occurs at least thrice.\nA substring is a contiguous non-empty sequence of characters within a string.", "canonical_solution": "from collections import defaultdict\ndef maximumLength(s):\n        special_substrings = defaultdict(int)\n        start = 0\n        while start < len(s):\n            curr = start\n            while curr < len(s) - 1 and s[curr] == s[curr + 1]:\n                curr += 1\n            window_size = curr + 1 - start\n            for length in range(1, window_size + 1):\n                special_substrings[(s[start], length)] += window_size + 1 - length  \n            start = curr + 1\n        res = -1\n        for k in special_substrings:\n            if special_substrings[k] >= 3:\n                res = max(res, k[1])   \n        return res", "entry_point": "maximumLength", "test_list": ["assert maximumLength(\"aaaa\") == 2", "assert maximumLength(\"abcdef\") == -1", "assert maximumLength(\"abcaba\") == 1"]}
{"Contest id": "378/2981", "text_name": "Find Longest Special Substring That Occurs Thrice I", "text": "You are given a string s that consists of lowercase English letters.\nA string is called special if it is made up of only a single character. For example, the string \"abc\" is not special, whereas the strings \"ddd\", \"zz\", and \"f\" are special.\nReturn the length of the longest special substring of s which occurs at least thrice, or -1 if no special substring occurs at least thrice.\nA substring is a contiguous non-empty sequence of characters within a string.\n", "canonical_solution": "def maximumLength(st):\n        from collections import defaultdict\n        mps = defaultdict(int)\n        count = 0        \n        for i in range(len(st)):\n            count = 1\n            mps[(st[i], count)] += 1\n            for j in range(i, len(st)):\n                if j + 1 < len(st) and st[j] == st[j + 1]:\n                    count += 1\n                    mps[(st[i], count)] += 1\n                else:\n                    break        \n        ans1 = 0\n        for key, value in mps.items():\n            if value >= 3:\n                ans1 = max(ans1, key[1])       \n        return ans1 if ans1 != 0 else -1", "entry_point": "maximumLength", "test_list": ["assert maximumLength(\"aaaa\") == 2", "assert maximumLength(\"abcdef\") == -1", "assert maximumLength(\"abcaba\") == 1"]}
{"Contest id": "378/2980", "text_name": "Check if Bitwise OR Has Trailing Zeros", "text": "You are given an array of positive integers nums.\nYou have to check if it is possible to select two or more elements in the array such that the bitwise OR of the selected elements has at least one trailing zero in its binary representation.\nFor example, the binary representation of 5, which is \"101\", does not have any trailing zeros, whereas the binary representation of 4, which is \"100\", has two trailing zeros.\nReturn true if it is possible to select two or more elements whose bitwise OR has trailing zeros, return false otherwise.", "canonical_solution": "def hasTrailingZeros(nums):\n        n = len(nums)       \n        for i in range(n):\n            for j in range(n):\n                if i != j and (nums[i] | nums[j]) % 2 == 0:\n                    return True        \n        return False", "entry_point": "hasTrailingZeros", "test_list": ["assert hasTrailingZeros([1,2,3,4,5]) == True", "assert hasTrailingZeros([2,4,8,16]) == True", "assert hasTrailingZeros([1,3,5,7,9]) == False"]}
{"Contest id": "377/2977", "text_name": "Minimum Cost to Convert String II", "text": "You are given two 0-indexed strings source and target, both of length n and consisting of lowercase English characters. You are also given two 0-indexed string arrays original and changed, and an integer array cost, where cost[i] represents the cost of converting the string original[i] to the string changed[i].\nYou start with the string source. In one operation, you can pick a substring x from the string, and change it to y at a cost of z if there exists any index j such that cost[j] == z, original[j] == x, and changed[j] == y. You are allowed to do any number of operations, but any pair of operations must satisfy either of these two conditions:\nThe substrings picked in the operations are source[a..b] and source[c..d] with either b < c or d < a. In other words, the indices picked in both operations are disjoint.\nThe substrings picked in the operations are source[a..b] and source[c..d] with a == c and b == d. In other words, the indices picked in both operations are identical.\nReturn the minimum cost to convert the string source to the string target using any number of operations. If it is impossible to convert source to target, return -1.\nNote that there may exist indices i, j such that original[j] == original[i] and changed[j] == changed[i].", "canonical_solution": "def minimumCost(source, target, original, changed, cost):\n        index = {}\n        for o in original:\n            if o not in index:\n                index[o] = len(index)\n        for c in changed:\n            if c not in index:\n                index[c] = len(index)\n        n = len(index)\n        dis = [[float('inf')] * n for _ in range(n)]\n        for i in range(len(cost)):\n            dis[index[original[i]]][index[changed[i]]] = min(dis[index[original[i]]][index[changed[i]]], cost[i])\n        for k in range(n):\n            for i in range(n):\n                if dis[i][k] < float('inf'):\n                    for j in range(n):\n                        if dis[k][j] < float('inf'):\n                            dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])\n        substr_lengths = set(len(o) for o in original)\n        dp = [float('inf')] * (len(target) + 1)\n        dp[0] = 0\n        for i in range(len(target)):\n            if dp[i] == float('inf'):\n                continue\n            if target[i] == source[i]:\n                dp[i + 1] = min(dp[i + 1], dp[i])\n            for t in substr_lengths:\n                if i + t >= len(dp):\n                    continue\n                sub_source = source[i:i + t]\n                sub_target = target[i:i + t]\n                c1 = index[sub_source] if sub_source in index else -1\n                c2 = index[sub_target] if sub_target in index else -1\n                if c1 >= 0 and c2 >= 0 and dis[c1][c2] < float('inf'):\n                    dp[i + t] = min(dp[i + t], dp[i] + dis[c1][c2])\n        return dp[-1] if dp[-1] != float('inf') else -1", "entry_point": "minimumCost", "test_list": ["assert minimumCost(source = \"abcd\", target = \"acbe\", original = [\"a\",\"b\",\"c\",\"c\",\"e\",\"d\"], changed = [\"b\",\"c\",\"b\",\"e\",\"b\",\"e\"], cost = [2,5,5,1,2,20]) == 28", "assert minimumCost(source = \"abcdefgh\", target = \"acdeeghh\", original = [\"bcd\",\"fgh\",\"thh\"], changed = [\"cde\",\"thh\",\"ghh\"], cost = [1,3,5]) == 9", "assert minimumCost(source = \"abcdefgh\", target = \"addddddd\", original = [\"bcd\",\"defgh\"], changed = [\"ddd\",\"ddddd\"], cost = [100,1578]) == -1"]}
{"Contest id": "377/2976", "text_name": "Minimum Cost to Convert String I", "text": "You are given two 0-indexed strings source and target, both of length n and consisting of lowercase English letters. You are also given two 0-indexed character arrays original and changed, and an integer array cost, where cost[i] represents the cost of changing the character original[i] to the character changed[i].\nYou start with the string source. In one operation, you can pick a character x from the string and change it to the character y at a cost of z if there exists any index j such that cost[j] == z, original[j] == x, and changed[j] == y.\nReturn the minimum cost to convert the string source to the string target using any number of operations. If it is impossible to convert source to target, return -1.\nNote that there may exist indices i, j such that original[j] == original[i] and changed[j] == changed[i].", "canonical_solution": "def minimumCost(source, target, original, changed, cost):\n        inf = 10 ** 18\n        c = [[inf] * 26 for _ in range(26)]\n        m = len(original)\n        for i in range(26):\n            c[i][i] = 0\n        for i in range(m):\n            c[ord(original[i]) - ord('a')][ord(changed[i]) - ord('a')] = min(c[ord(original[i]) - ord('a')][ord(changed[i]) - ord('a')], cost[i])\n        for k in range(26):\n            for i in range(26):\n                for j in range(26):\n                    c[i][j] = min(c[i][j], c[i][k] + c[k][j])\n        ans = 0\n        n = len(source)\n        for i in range(n):\n            ans += c[ord(source[i]) - ord('a')][ord(target[i]) - ord('a')]\n            if ans >= inf:\n                return -1\n        return ans", "entry_point": "minimumCost", "test_list": ["assert minimumCost(source = \"abcd\", target = \"acbe\", original = [\"a\",\"b\",\"c\",\"c\",\"e\",\"d\"], changed = [\"b\",\"c\",\"b\",\"e\",\"b\",\"e\"], cost = [2,5,5,1,2,20]) == 28", "assert minimumCost(source = \"aaaa\", target = \"bbbb\", original = [\"a\",\"c\"], changed = [\"c\",\"b\"], cost = [1,2]) == 12", "assert minimumCost(source = \"abcd\", target = \"abce\", original = [\"a\"], changed = [\"e\"], cost = [10000]) == -1"]}
{"Contest id": "377/2975", "text_name": "Maximum Square Area by Removing Fences From a Field", "text": "There is a large (m - 1) x (n - 1) rectangular field with corners at (1, 1) and (m, n) containing some horizontal and vertical fences given in arrays hFences and vFences respectively.\nHorizontal fences are from the coordinates (hFences[i], 1) to (hFences[i], n) and vertical fences are from the coordinates (1, vFences[i]) to (m, vFences[i]).\nReturn the maximum area of a square field that can be formed by removing some fences (possibly none) or -1 if it is impossible to make a square field.\nSince the answer may be large, return it modulo 109 + 7.\nNote: The field is surrounded by two horizontal fences from the coordinates (1, 1) to (1, n) and (m, 1) to (m, n) and two vertical fences from the coordinates (1, 1) to (m, 1) and (1, n) to (m, n). These fences cannot be removed.", "canonical_solution": "def maximizeSquareArea(m, n, hFences, vFences):\n        hFences.sort()\n        vFences.sort()\n        hFences = [1] + hFences + [m]\n        vFences = [1] + vFences + [n]\n        ans = -1\n        cnt = {}\n        for i in range(len(hFences)):\n            for j in range(i + 1, len(hFences)):\n                cnt[hFences[j] - hFences[i]] = 1\n        for i in range(len(vFences)):\n            for j in range(i + 1, len(vFences)):\n                if (vFences[j] - vFences[i]) in cnt:\n                    ans = max(ans, vFences[j] - vFences[i])\n        if ans == -1:\n            return ans\n        mod = 10**9 + 7\n        return (ans * ans) % mod", "entry_point": "maximizeSquareArea", "test_list": ["assert maximizeSquareArea(m = 4, n = 3, hFences = [2,3], vFences = [2]) == 4", "assert maximizeSquareArea(m = 6, n = 7, hFences = [2], vFences = [4]) == -1"]}
{"Contest id": "377/2974", "text_name": "Minimum Number Game", "text": "You are given a 0-indexed integer array nums of even length and there is also an empty array arr. Alice and Bob decided to play a game where in every round Alice and Bob will do one move. The rules of the game are as follows:\nEvery round, first Alice will remove the minimum element from nums, and then Bob does the same.\nNow, first Bob will append the removed element in the array arr, and then Alice does the same.\nThe game continues until nums becomes empty.\nReturn the resulting array arr.", "canonical_solution": "def numberGame(nums):\n        nums.sort()\n        for i in range (0,len(nums),2):\n            nums[i] , nums[i+1] = nums[i+1] ,nums[i]\n        return nums", "entry_point": "numberGame", "test_list": ["assert numberGame([5,4,2,3]) == [3,2,5,4]", "assert numberGame([2,5]) == [5,2]"]}
{"Contest id": "Bi120/2973", "text_name": "Find Number of Coins to Place in Tree Nodes", "text": "You are given an undirected tree with n nodes labeled from 0 to n - 1, and rooted at node 0. You are given a 2D integer array edges of length n - 1, where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nYou are also given a 0-indexed integer array cost of length n, where cost[i] is the cost assigned to the ith node.\nYou need to place some coins on every node of the tree. The number of coins to be placed at node i can be calculated as:\nIf size of the subtree of node i is less than 3, place 1 coin.\nOtherwise, place an amount of coins equal to the maximum product of cost values assigned to 3 distinct nodes in the subtree of node i. If this product is negative, place 0 coins.\nReturn an array coin of size n such that coin[i] is the number of coins placed at node i.", "canonical_solution": "def placedCoins(edges, cost):\n        res, al = [0] * len(cost), [[] for _ in range(len(cost))]\n        for  a, b in edges:\n                al[a].append(b)\n                al[b].append(a)\n        def dfs(i, p):\n            c = [cost[i]]\n            for j in al[i]:\n                if j != p:\n                    c.extend(dfs(j, i))\n            c.sort()\n            res[i] = 1 if len(c) < 3 else max(0, c[0] * c[1] * c[-1], c[-3] * c[-2] * c[-1])\n            return c if len(c) < 5 else [c[0], c[1], c[-3], c[-2], c[-1]]\n        dfs(0, 0)\n        return res", "entry_point": "placedCoins", "test_list": ["assert placedCoins(edges = [[0,1],[0,2],[1,3],[1,4],[1,5],[2,6],[2,7],[2,8]], cost = [1,4,2,3,5,7,8,-4,2]) == [280,140,32,1,1,1,1,1,1]", "assert placedCoins(edges = [[0,1],[0,2]], cost = [1,2,-2]) == [0,1,1]", "assert placedCoins(edges = [[0,1],[0,2],[0,3],[0,4],[0,5]], cost = [1,2,3,4,5,6]) == [120,1,1,1,1,1]"]}
{"Contest id": "Bi120/2972", "text_name": "Count the Number of Incremovable Subarrays II", "text": "You are given a 0-indexed array of positive integers nums.\nA subarray of nums is called incremovable if nums becomes strictly increasing on removing the subarray. For example, the subarray [3, 4] is an incremovable subarray of [5, 3, 4, 6, 7] because removing this subarray changes the array [5, 3, 4, 6, 7] to [5, 6, 7] which is strictly increasing.\nReturn the total number of incremovable subarrays of nums.\nNote that an empty array is considered strictly increasing.\nA subarray is a contiguous non-empty sequence of elements within an array.", "canonical_solution": "def incremovableSubarrayCount(A):\n        n = len(A)\n        i = 0\n        while i + 1 < n and A[i] < A[i + 1]:\n            i += 1\n        if i == n - 1:\n            return n * (n + 1) // 2\n        res = i + 2\n        for j in range(n - 1, -1, -1):\n            if j < n - 1 and A[j] >= A[j + 1]:\n                break\n            while i >= 0 and A[i] >= A[j]:\n                i -= 1\n            res += i + 2\n        return res", "entry_point": "incremovableSubarrayCount", "test_list": ["assert incremovableSubarrayCount([1,2,3,4]) == 10", "assert incremovableSubarrayCount([6,5,7,8]) == 7", "assert incremovableSubarrayCount([8,7,6,6]) == 3"]}
{"Contest id": "Bi120/2971", "text_name": "Find Polygon With the Largest Perimeter", "text": "You are given an array of positive integers nums of length n.\nA polygon is a closed plane figure that has at least 3 sides. The longest side of a polygon is smaller than the sum of its other sides.\nConversely, if you have k (k >= 3) positive real numbers a1, a2, a3, ..., ak where a1 <= a2 <= a3 <= ... <= ak and a1 + a2 + a3 + ... + ak-1 > ak, then there always exists a polygon with k sides whose lengths are a1, a2, a3, ..., ak.\nThe perimeter of a polygon is the sum of lengths of its sides.\nReturn the largest possible perimeter of a polygon whose sides can be formed from nums, or -1 if it is not possible to create a polygon.", "canonical_solution": "def largestPerimeter(A):\n        A.sort()\n        cur = sum(A)\n        while A and cur <= A[-1] * 2:\n            cur -= A.pop()\n        return sum(A) if len(A) > 2 else -1", "entry_point": "largestPerimeter", "test_list": ["assert largestPerimeter([5,5,5]) == 15", "assert largestPerimeter([1,12,1,2,5,50,3]) == 12", "assert largestPerimeter([5,5,50]) == -1"]}
{"Contest id": "Bi120/2970", "text_name": "Count the Number of Incremovable Subarrays I", "text": "You are given a 0-indexed array of positive integers nums.\nA subarray of nums is called incremovable if nums becomes strictly increasing on removing the subarray. For example, the subarray [3, 4] is an incremovable subarray of [5, 3, 4, 6, 7] because removing this subarray changes the array [5, 3, 4, 6, 7] to [5, 6, 7] which is strictly increasing.\nReturn the total number of incremovable subarrays of nums.\nNote that an empty array is considered strictly increasing.\nA subarray is a contiguous non-empty sequence of elements within an array.", "canonical_solution": "def incremovableSubarrayCount(nums):\n    def ss(arr):\n        for i in range(len(arr)-1):\n            if(arr[i]>=arr[i+1]):\n                return 0\n        return 1\n    p=0\n    for i in range(len(nums)):\n        for j in range(i+1,len(nums)+1):\n            temp=nums[:]\n            del temp[i:j]\n            if ss(temp)==1:\n                p+=1\n    return p", "entry_point": "incremovableSubarrayCount", "test_list": ["assert incremovableSubarrayCount([1,2,3,4]) == 10", "assert incremovableSubarrayCount([6,5,7,8]) == 7", "assert incremovableSubarrayCount([8,7,6,6]) == 3"]}
{"Contest id": "376/2968", "text_name": "Apply Operations to Maximize Frequency Score", "text": "You are given a 0-indexed integer array nums and an integer k.\nYou can perform the following operation on the array at most k times:\nChoose any index i from the array and increase or decrease nums[i] by 1.\nThe score of the final array is the frequency of the most frequent element in the array.\nReturn the maximum score you can achieve.\nThe frequency of an element is the number of occurences of that element in the array.", "canonical_solution": "def maxFrequencyScore(nums, k):\n    nums.sort()\n    n = len(nums)\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + nums[i]\n    start = 0\n    end = 1\n    max_score = 1\n    while end < n:\n        end += 1\n        mid = (start + end) // 2\n        target = nums[mid]       \n        cost = (target * (mid - start) - (prefix_sum[mid] - prefix_sum[start])) + (prefix_sum[end] - prefix_sum[mid] - target * (end - mid))\n        while start < end and cost > k:\n            start += 1\n            mid = (start + end) // 2\n            target = nums[mid]\n            cost = (target * (mid - start) - (prefix_sum[mid] - prefix_sum[start])) +(prefix_sum[end] - prefix_sum[mid] - target * (end - mid))\n        max_score = max(max_score, end - start)\n    return max_score", "entry_point": "maxFrequencyScore", "test_list": ["assert maxFrequencyScore(nums = [1,2,6,4], k = 3) == 3", "assert maxFrequencyScore(nums = [1,4,4,2,4], k = 0) == 3"]}
{"Contest id": "376/2967", "text_name": "Minimum Cost to Make Array Equalindromic", "text": "You are given a 0-indexed integer array nums having length n.\nYou are allowed to perform a special move any number of times (including zero) on nums. In one special move you perform the following steps in order:\nChoose an index i in the range [0, n - 1], and a positive integer x.\nAdd |nums[i] - x| to the total cost.\nChange the value of nums[i] to x.\nA palindromic number is a positive integer that remains the same when its digits are reversed. For example, 121, 2552 and 65756 are palindromic numbers whereas 24, 46, 235 are not palindromic numbers.\nAn array is considered equalindromic if all the elements in the array are equal to an integer y, where y is a palindromic number less than 109.\nReturn an integer denoting the minimum possible total cost to make nums equalindromic by performing any number of special moves.", "canonical_solution": "def minimumCost(nums):\n        nums.sort()\n        midIndex = len(nums) // 2\n        def check_palindrome(x):\n            x = str(x)\n            return x == x[::-1]       \n        def add(nums, target):\n            result = 0\n            for elem in nums:\n                result += abs(elem - target)\n            return result\n        if len(nums) % 2 == 1:\n            mid = nums[midIndex]\n            if check_palindrome(mid):\n                return add(nums, mid)\n        else:\n            mid = (nums[midIndex] + nums[midIndex - 1]) // 2\n            if check_palindrome(mid):\n                return add(nums, mid)\n        p_1 = mid + 1\n        p_2 = mid - 1\n        while not (check_palindrome(p_1) and check_palindrome(p_2)):\n            if not check_palindrome(p_1):\n                p_1 += 1\n            if not check_palindrome(p_2):\n                p_2 -= 1\n        return min(add(nums, p_1), add(nums, p_2))", "entry_point": "minimumCost", "test_list": ["assert minimumCost([1,2,3,4,5]) == 6", "assert minimumCost([10,12,13,14,15]) == 11", "assert minimumCost([22,33,22,33,22]) == 22"]}
{"Contest id": "376/2966", "text_name": "Divide Array Into Arrays With Max Difference", "text": "You are given an integer array nums of size n and a positive integer k.\nDivide the array into one or more arrays of size 3 satisfying the following conditions:\nEach element of nums should be in exactly one array.\nThe difference between any two elements in one array is less than or equal to k.\nReturn a 2D array containing all the arrays. If it is impossible to satisfy the conditions, return an empty array. And if there are multiple answers, return any of them.", "canonical_solution": "def divideArray(nums, k):\n    nums.sort()\n    flag = True\n    ans = []\n    count = 0\n    s = []\n    for i in range(0, len(nums) - 2, 3):\n        if (\n            nums[i + 2] - nums[i + 1] <= k\n            and nums[i + 1] - nums[i] <= k\n            and nums[i + 2] - nums[i] <= k\n        ):\n            s.extend([nums[i], nums[i + 1], nums[i + 2]])\n            count += len(s)\n            ans.append(s[:])\n            s.clear()\n        else:\n            flag = False\n            break\n    if len(nums) != count:\n        flag = False\n    if not flag:\n        ans.clear()\n    return ans", "entry_point": "divideArray", "test_list": ["assert divideArray(nums = [1,3,4,8,7,9,3,5,1], k = 2) == [[1,1,3],[3,4,5],[7,8,9]]", "assert divideArray(nums = [1,3,3,2,7,3], k = 3) == []"]}
{"Contest id": "376/2965", "text_name": "Find Missing and Repeated Values", "text": "You are given a 0-indexed 2D integer matrix grid of size n * n with values in the range [1, n2]. Each integer appears exactly once except a which appears twice and b which is missing. The task is to find the repeating and missing numbers a and b.\nReturn a 0-indexed integer array ans of size 2 where ans[0] equals to a and ans[1] equals to b.", "canonical_solution": "def findMissingAndRepeatedValues(grid):\n    arr=[element for sublist in grid for element in sublist]\n    arr.sort()\n    n=[]\n    for i in range(len(arr)-1):\n        if arr[i]==arr[i+1]:\n            n.append(arr[i])\n            arr.remove(arr[i])\n            break\n    arr.append(1000000)\n    for i in range(len(arr)):\n        if i+1!=arr[i]:\n            n.append(i+1)\n            break\n    return n", "entry_point": "findMissingAndRepeatedValues", "test_list": ["assert findMissingAndRepeatedValues([[1,3],[2,2]]) == [2,4]", "assert findMissingAndRepeatedValues([[9,1,7],[8,9,2],[3,4,6]]) == [9,5]"]}
{"Contest id": "375/2963", "text_name": "Count the Number of Good Partitions", "text": "You are given a 0-indexed array nums consisting of positive integers.\nA partition of an array into one or more contiguous subarrays is called good if no two subarrays contain the same number.\nReturn the total number of good partitions of nums.\nSince the answer may be large, return it modulo 109 + 7.", "canonical_solution": "def numberOfGoodPartitions(A):\n        last = {a: i for i,a in enumerate(A)}\n        res = 1\n        mod = 10 ** 9 + 7\n        j = 0\n        for i,a in enumerate(A):\n            if i > j:\n                res = res * 2 % mod\n            j = max(j, last[a])\n        return res", "entry_point": "numberOfGoodPartitions", "test_list": ["assert numberOfGoodPartitions([1,2,3,4]) == 8", "assert numberOfGoodPartitions([1,1,1,1]) == 1", "assert numberOfGoodPartitions([1,2,1,3]) == 2"]}
{"Contest id": "375/2962", "text_name": "Count Subarrays Where Max Element Appears at Least K Times", "text": "You are given an integer array nums and a positive integer k.\nReturn the number of subarrays where the maximum element of nums appears at least k times in that subarray.\nA subarray is a contiguous sequence of elements within an array.", "canonical_solution": "def countSubarrays(A, k):\n        ma = max(A)\n        res = cur = i = 0\n        for j in range(len(A)):\n            cur += A[j] == ma\n            while cur >= k:\n                cur -= A[i] == ma\n                i += 1\n            res += i\n        return res", "entry_point": "countSubarrays", "test_list": ["assert countSubarrays([1,3,2,3,3],2) == 6", "assert countSubarrays([1,4,2,1],3) == 0"]}
{"Contest id": "375/2961", "text_name": "Double Modular Exponentiation", "text": "You are given a 0-indexed 2D array variables where variables[i] = [ai, bi, ci, mi], and an integer target.\nAn index i is good if the following formula holds:\n0 <= i < variables.length\n((aibi % 10)ci) % mi == target\nReturn an array consisting of good indices in any order.", "canonical_solution": "def getGoodIndices(A, target):\n        return [i for i,(a,b,c,m) in enumerate(A) if pow(pow(a, b, 10), c, m) == target]", "entry_point": "getGoodIndices", "test_list": ["assert getGoodIndices([[2,3,3,10],[3,3,3,1],[6,1,1,4]],2) == [0,2]", "assert getGoodIndices([[39,3,1000,1000]],17) == []"]}
{"Contest id": "375/2960", "text_name": "Count Tested Devices After Test Operations", "text": "You are given a 0-indexed integer array batteryPercentages having length n, denoting the battery percentages of n 0-indexed devices.\nYour task is to test each device i in order from 0 to n - 1, by performing the following test operations:\nIf batteryPercentages[i] is greater than 0:\nIncrement the count of tested devices.\nDecrease the battery percentage of all devices with indices j in the range [i + 1, n - 1] by 1, ensuring their battery percentage never goes below 0, i.e, batteryPercentages[j] = max(0, batteryPercentages[j] - 1).\nMove to the next device.\nOtherwise, move to the next device without performing any test.\nReturn an integer denoting the number of devices that will be tested after performing the test operations in order.", "canonical_solution": "def countTestedDevices(A):\n    k = 0\n    for a in A:\n        k += a > k\n    return k", "entry_point": "countTestedDevices", "test_list": ["assert countTestedDevices([1,1,2,1,3]) == 3", "assert countTestedDevices([0,1,2]) == 2"]}
{"Contest id": "Bi119/2958", "text_name": "Length of Longest Subarray With at Most K Frequency", "text": "You are given an integer array nums and an integer k.\nThe frequency of an element x is the number of times it occurs in an array.\nAn array is called good if the frequency of each element in this array is less than or equal to k.\nReturn the length of the longest good subarray of nums.\nA subarray is a contiguous non-empty sequence of elements within an array.", "canonical_solution": "def maxSubarrayLength(nums, k):\n    n = len(nums)\n    l, r, ans = 0, 0, 0\n    freq = {}\n    while r < n:\n        freq[nums[r]] = freq.get(nums[r], 0) + 1\n        while l <= r and freq[nums[r]] > k:\n            freq[nums[l]] -= 1\n            if freq[nums[l]] == 0:\n                del freq[nums[l]]\n            l += 1\n        ans = max(ans, r - l + 1)\n        r += 1\n    return ans", "entry_point": "maxSubarrayLength", "test_list": ["assert maxSubarrayLength(nums = [1,2,3,1,2,3,1,2], k = 2) == 6", "assert maxSubarrayLength(nums = [1,2,1,2,1,2,1,2], k = 1) == 2", "assert maxSubarrayLength(nums = [5,5,5,5,5,5,5], k = 4) == 4"]}
{"Contest id": "Bi119/2957", "text_name": "Remove Adjacent Almost-Equal Characters", "text": "You are given a 0-indexed string word.\nIn one operation, you can pick any index i of word and change word[i] to any lowercase English letter.\nReturn the minimum number of operations needed to remove all adjacent almost-equal characters from word.\nTwo characters a and b are almost-equal if a == b or a and b are adjacent in the alphabet.", "canonical_solution": "def removeAlmostEqualCharacters(s):\n    i, k = 1, 0\n    while i + k < len(s):\n        k += abs(ord(s[i + k]) - ord(s[i + k - 1])) < 2\n        i += 1\n    return k", "entry_point": "removeAlmostEqualCharacters", "test_list": ["assert removeAlmostEqualCharacters(\"aaaaa\") == 2", "assert removeAlmostEqualCharacters(\"abddez\") == 2", "assert removeAlmostEqualCharacters(\"zyxyxyz\") == 3"]}
{"Contest id": "Bi119/2956", "text_name": "Find Common Elements Between Two Arrays", "text": "You are given two 0-indexed integer arrays nums1 and nums2 of sizes n and m, respectively.\nConsider calculating the following values:\nThe number of indices i such that 0 <= i < n and nums1[i] occurs at least once in nums2.\nThe number of indices i such that 0 <= i < m and nums2[i] occurs at least once in nums1.\nReturn an integer array answer of size 2 containing the two values in the above order.", "canonical_solution": "def findIntersectionValues(nums1, nums2):\n    set1 = set(nums1)\n    set2 = set(nums2)\n\n    count1 = sum(1 for num in nums1 if num in set2)\n    count2 = sum(1 for num in nums2 if num in set1)\n\n    return [count1, count2]", "entry_point": "findIntersectionValues", "test_list": ["assert findIntersectionValues(nums1 = [4,3,2,3,1], nums2 = [2,2,5,2,3,6]) == [3,4]", "assert findIntersectionValues(nums1 = [3,4,2,3], nums2 = [1,5]) == [0,0]"]}
{"Contest id": "374/2954", "text_name": "Count the Number of Infection Sequences", "text": "You are given an integer n and a 0-indexed integer array sick which is sorted in increasing order.\nThere are n children standing in a queue with positions 0 to n - 1 assigned to them. The array sick contains the positions of the children who are infected with an infectious disease. An infected child at position i can spread the disease to either of its immediate neighboring children at positions i - 1 and i + 1 if they exist and are currently not infected. At most one child who was previously not infected can get infected with the disease in one second.\nIt can be shown that after a finite number of seconds, all the children in the queue will get infected with the disease. An infection sequence is the sequential order of positions in which all of the non-infected children get infected with the disease. Return the total number of possible infection sequences.\nSince the answer may be large, return it modulo 109 + 7.\nNote that an infection sequence does not contain positions of children who were already infected with the disease in the beginning.", "canonical_solution": "def numberOfSequence(n, sick):\n    M = 10 ** 9 + 7\n    f = [1] * (n + 1)\n    for i in range(1, n + 1):\n        f[i] = i * f[i - 1]\n        f[i] %= M\n    count = lambda m, n: (f[m + n] * pow(f[m], M - 2, M) * pow(f[n], M - 2, M)) % M\n    gaps = []\n    if sick[0] > 0:\n        gaps.append((sick[0], True))\n    for i in range(len(sick) - 1):\n        if sick[i + 1] - sick[i] > 1:\n            gaps.append((sick[i + 1] - sick[i] - 1, False))\n    if sick[-1] < n - 1:\n        gaps.append((n - sick[-1] - 1, True))\n    res = 1\n    l = 0\n    for g, once in gaps:\n        res *= (pow(2, g - 1, M) if not once else 1) * count(l, g)\n        res %= M\n        l += g\n    return res", "entry_point": "numberOfSequence", "test_list": ["assert numberOfSequence(n = 5, sick = [0,4]) == 4", "assert numberOfSequence(n = 4, sick = [1]) == 3"]}
{"Contest id": "374/2953", "text_name": "Count Complete Substrings", "text": "You are given a string word and an integer k.\nA substring s of word is complete if:\nEach character in s occurs exactly k times.\nThe difference between two adjacent characters is at most 2. That is, for any two adjacent characters c1 and c2 in s, the absolute difference in their positions in the alphabet is at most 2.\nReturn the number of complete substrings of word.\nA substring is a non-empty contiguous sequence of characters in a string.", "canonical_solution": "def countCompleteSubstrings(word, k):\n    def calc(left, right):\n        sub = 0\n        for m in range(1, 27):\n            if m * k > right - left: break\n            cnt = [0] * 26\n            meet = 0\n            for r in range(left, right):\n                x = ord(word[r]) - ord('a')\n                cnt[x] += 1\n                if cnt[x] == k: meet += 1\n                L = r - m * k + 1\n                if L >= left:\n                    if meet == m: sub += 1\n                    if cnt[ord(word[L]) - ord('a')] == k: meet -= 1\n                    cnt[ord(word[L]) - ord('a')] -= 1\n        return sub\n    n = len(word)\n    i = 0\n    ans = 0\n    while i < n:\n        start = i\n        i += 1\n        while i < n and abs(ord(word[i]) - ord(word[i-1])) <= 2: i+=1\n        ans += calc(start, i)\n    return ans", "entry_point": "countCompleteSubstrings", "test_list": ["assert countCompleteSubstrings(word = \"igigee\", k = 2) == 3", "assert countCompleteSubstrings(word = \"aaabbbccc\", k = 3) == 6"]}
{"Contest id": "374/2952", "text_name": "Minimum Number of Coins to be Added", "text": "You are given a 0-indexed integer array coins, representing the values of the coins available, and an integer target.\nAn integer x is obtainable if there exists a subsequence of coins that sums to x.\nReturn the minimum number of coins of any value that need to be added to the array so that every integer in the range [1, target] is obtainable.\nA subsequence of an array is a new non-empty array that is formed from the original array by deleting some (possibly none) of the elements without disturbing the relative positions of the remaining elements.", "canonical_solution": "def minimumAddedCoins(coins, target):\n    ans = 0\n    coins = sorted(coins)\n    tmpp= 1  \n    for i in coins:\n        while i > tmpp:\n            ans += 1\n            tmpp *= 2    \n        tmpp += i\n        if tmpp > target:\n            break  \n    while tmpp <= target:\n        ans += 1\n        tmpp *= 2\n    return ans", "entry_point": "minimumAddedCoins", "test_list": ["assert minimumAddedCoins(coins = [1,4,10], target = 19) == 2", "assert minimumAddedCoins(coins = [1,4,10,5,7,19], target = 19) == 1", "assert minimumAddedCoins(coins = [1,1,1], target = 20) == 3"]}
{"Contest id": "374/2951", "text_name": "Find the Peaks", "text": "You are given a 0-indexed array mountain. Your task is to find all the peaks in the mountain array.\nReturn an array that consists of indices of peaks in the given array in any order.\nNotes:\nA peak is defined as an element that is strictly greater than its neighboring elements.\nThe first and last elements of the array are not a peak.", "canonical_solution": "def findPeaks(mountain):\n    peaks = []\n    n = len(mountain)\n    for i in range(1, n - 1):\n        if mountain[i] > mountain[i - 1] and mountain[i] > mountain[i + 1]:\n            peaks.append(i)\n    return peaks", "entry_point": "findPeaks", "test_list": ["assert findPeaks([2,4,4]) == []", "assert findPeaks([1,4,3,8,5]) == [1,3]"]}
{"Contest id": "373/2949", "text_name": "Count Beautiful Substrings II", "text": "You are given a string s and a positive integer k.\nLet vowels and consonants be the number of vowels and consonants in a string.\nA string is beautiful if:\nvowels == consonants.\n(vowels * consonants) % k == 0, in other terms the multiplication of vowels and consonants is divisible by k.\nReturn the number of non-empty beautiful substrings in the given string s.\nA substring is a contiguous sequence of characters in a string.\nVowel letters in English are 'a', 'e', 'i', 'o', and 'u'.\nConsonant letters in English are every letter except vowels.", "canonical_solution": "from collections import Counter\nfrom itertools import count\ndef beautifulSubstrings(s, k):\n    n = len(s)\n    l = next(i for i in count(1) if i * i % k == 0) * 2\n    vowels = set(list('aeiou'))\n    seen = [Counter() for i in range(l)]\n    seen[-1][0] = 1\n    res = 0\n    v = 0\n    for i,c in enumerate(s):\n        v += 1 if s[i] in vowels else -1\n        res += seen[i % l][v]\n        seen[i % l][v] += 1\n    return res", "entry_point": "beautifulSubstrings", "test_list": ["assert beautifulSubstrings(s = \"baeyh\", k = 2) == 2", "assert beautifulSubstrings(s = \"abba\", k = 1) == 3", "assert beautifulSubstrings(s = \"bcdf\", k = 1) == 0"]}
{"Contest id": "373/2948", "text_name": "Make Lexicographically Smallest Array by Swapping Elements", "text": "You are given a 0-indexed array of positive integers nums and a positive integer limit.\nIn one operation, you can choose any two indices i and j and swap nums[i] and nums[j] if |nums[i] - nums[j]| <= limit.\nReturn the lexicographically smallest array that can be obtained by performing the operation any number of times.\nAn array a is lexicographically smaller than an array b if in the first position where a and b differ, array a has an element that is less than the corresponding element in b. For example, the array [2,10,3] is lexicographically smaller than the array [10,2,3] because they differ at index 0 and 2 < 10.", "canonical_solution": "def lexicographicallySmallestArray(nums, limit):\n    size = len(nums)\n    pair = [[nums[i], i] for i in range(0, size)]\n    pair = sorted(pair, key=lambda x : x[0])\n    result = [0] * size\n    start = 0\n    for end in range(0, size):\n        if (end + 1 >= size or pair[end + 1][0] - pair[end][0] > limit):\n            temp = [pair[i][1] for i in range(start, end + 1)]\n            temp = sorted(temp)\n            j = start\n            for idx in temp:\n                result[idx] = pair[j][0]\n                j += 1\n            start = end + 1\n    return result", "entry_point": "lexicographicallySmallestArray", "test_list": ["assert lexicographicallySmallestArray(nums = [1,5,3,9,8], limit = 2) == [1,3,5,8,9]", "assert lexicographicallySmallestArray(nums = [1,7,6,18,2,1], limit = 3) == [1,6,7,18,1,2]", "assert lexicographicallySmallestArray(nums = [1,7,28,19,10], limit = 3) == [1,7,28,19,10]"]}
{"Contest id": "373/2947", "text_name": "Count Beautiful Substrings I", "text": "You are given a string s and a positive integer k.\nLet vowels and consonants be the number of vowels and consonants in a string.\nA string is beautiful if:\nvowels == consonants.\n(vowels * consonants) % k == 0, in other terms the multiplication of vowels and consonants is divisible by k.\nReturn the number of non-empty beautiful substrings in the given string s.\nA substring is a contiguous sequence of characters in a string.\nVowel letters in English are 'a', 'e', 'i', 'o', and 'u'.\nConsonant letters in English are every letter except vowels.", "canonical_solution": "def beautifulSubstrings(s, k):\n    n = len(s)\n    res = 0\n    cc = ['a','e','i','o','u']\n    for j in range(n):\n        c,v=0,0\n        for i in range(j,n):\n            if s[i] in cc:\n                v += 1\n            else:\n                c += 1\n            if c==v and (c*v)%k==0:\n                res += 1\n    return res", "entry_point": "beautifulSubstrings", "test_list": ["assert beautifulSubstrings(s = \"baeyh\", k = 2) == 2", "assert beautifulSubstrings(s = \"abba\", k = 1) == 3", "assert beautifulSubstrings(s = \"bcdf\", k = 1) == 0"]}
{"Contest id": "373/2946", "text_name": "Matrix Similarity After Cyclic Shifts", "text": "You are given a 0-indexed m x n integer matrix mat and an integer k. You have to cyclically right shift odd indexed rows k times and cyclically left shift even indexed rows k times.\nReturn true if the initial and final matrix are exactly the same and false otherwise.", "canonical_solution": "def areSimilar(mat, k):\n    for l in mat:\n        n = len(l)\n    for i in range(n):\n        if l[i] != l[(i + k) % n]:\n            return False\n    return True", "entry_point": "areSimilar", "test_list": ["assert areSimilar(mat = [[1,2,1,2],[5,5,5,5],[6,3,6,3]], k = 2) == True", "assert areSimilar(mat = [[2,2],[2,2]], k = 3) == True", "assert areSimilar(mat = [[1,2]], k = 1) == False"]}
{"Contest id": "Bi118/2945", "text_name": "Find Maximum Non-decreasing Array Length", "text": "You are given a 0-indexed integer array nums.\nYou can perform any number of operations, where each operation involves selecting a subarray of the array and replacing it with the sum of its elements. For example, if the given array is [1,3,5,6] and you select subarray [3,5] the array will convert to [1,8,6].\nReturn the maximum length of a non-decreasing array that can be made after applying operations.\nA subarray is a contiguous non-empty sequence of elements within an array.", "canonical_solution": "from math import inf\ndef findMaximumLength(A):\n    n = len(A)\n    last = [0] + [inf] * n\n    acc = [0]\n    dp = [0] + [0] * n\n    for j in range(n):\n        a = A[j]\n        acc.append(a + acc[-1])\n        i = j\n        while last[i] > acc[-1] - acc[i]:\n            i -= 1\n        last[j + 1] = acc[-1] - acc[i]\n        dp[j + 1] = dp[i] + 1\n    return dp[-1]", "entry_point": "findMaximumLength", "test_list": ["assert findMaximumLength([5,2,2]) == 1", "assert findMaximumLength([1,2,3,4]) == 4", "assert findMaximumLength([4,3,2,6]) == 3"]}
{"Contest id": "Bi118/2944", "text_name": "Minimum Number of Coins for Fruits", "text": "You are at a fruit market with different types of exotic fruits on display.\nYou are given a 1-indexed array prices, where prices[i] denotes the number of coins needed to purchase the ith fruit.\nThe fruit market has the following offer:\nIf you purchase the ith fruit at prices[i] coins, you can get the next i fruits for free.\nNote that even if you can take fruit j for free, you can still purchase it for prices[j] coins to receive a new offer.\nReturn the minimum number of coins needed to acquire all the fruits.", "canonical_solution": "def minimumCoins(prices):\n    def dp(i, f):\n        if i >= len(prices):\n            return 0\n        m = dp(i + 1, i + 1) + prices[i]  # buy\n        for j in range(f):\n            m = min(m, dp(i + j + 1, 0))  # get free\n        return m\n    return dp(0, 0)", "entry_point": " minimumCoins", "test_list": ["assert  minimumCoins([3,1,2]) == 4", "assert  minimumCoins([1,10,1,1]) == 2"]}
{"Contest id": "Bi118/2943", "text_name": "Maximize Area of Square Hole in Grid", "text": "There is a grid with n + 2 horizontal bars and m + 2 vertical bars, and initially containing 1 x 1 unit cells.\nThe bars are 1-indexed.\nYou are given the two integers, n and m.\nYou are also given two integer arrays: hBars and vBars.\nhBars contains distinct horizontal bars in the range [2, n + 1].\nvBars contains distinct vertical bars in the range [2, m + 1].\nYou are allowed to remove bars that satisfy any of the following conditions:\nIf it is a horizontal bar, it must correspond to a value in hBars.\nIf it is a vertical bar, it must correspond to a value in vBars.\nReturn an integer denoting the maximum area of a square-shaped hole in the grid after removing some bars (possibly none).\n", "canonical_solution": "def maximizeSquareHoleArea(n, m, hBars, vBars):\n    hBars.sort()\n    vBars.sort()\n    mh, mv, c = 1, 1, 1       \n    for i in range(1, len(hBars)):\n        if hBars[i] == hBars[i - 1] + 1:\n            c += 1\n        else:\n            c = 1\n        mh = max(mh, c)       \n    c = 1\n    for i in range(1, len(vBars)):\n        if vBars[i] == vBars[i - 1] + 1:\n            c += 1\n        else:\n            c = 1\n        mv = max(mv, c)       \n    x = min(mh + 1, mv + 1)\n    return x * x", "entry_point": "maximizeSquareHoleArea", "test_list": ["assert maximizeSquareHoleArea(n = 2, m = 1, hBars = [2,3], vBars = [2]) == 4", "assert maximizeSquareHoleArea(n = 1, m = 1, hBars = [2], vBars = [2]) == 4", "assert maximizeSquareHoleArea(n = 2, m = 3, hBars = [2,3], vBars = [2,3,4]) == 9"]}
{"Contest id": "Bi118/2942", "text_name": "Find Words Containing Character", "text": "You are given a 0-indexed array of strings words and a character x.\nReturn an array of indices representing the words that contain the character x.\nNote that the returned array may be in any order.", "canonical_solution": "def findWordsContaining(words, x):\n    ans = []\n    for i, word in enumerate(words):\n        if x in word:\n            ans.append(i)\n    return ans", "entry_point": "findWordsContaining", "test_list": ["assert findWordsContaining(words = [\"leet\",\"code\"], x = \"e\") == [0,1]", "assert findWordsContaining([\"abc\",\"bcd\",\"aaaa\",\"cbc\"], x = \"a\") == [0,2]", "assert findWordsContaining(words = [\"abc\",\"bcd\",\"aaaa\",\"cbc\"], x = \"z\") == []"]}
{"Contest id": "372/2940", "text_name": "Find Building Where Alice and Bob Can Meet", "text": "You are given a 0-indexed array heights of positive integers, where heights[i] represents the height of the ith building.\nIf a person is in building i, they can move to any other building j if and only if i < j and heights[i] < heights[j].\nYou are also given another array queries where queries[i] = [ai, bi]. On the ith query, Alice is in building ai while Bob is in building bi.\nReturn an array ans where ans[i] is the index of the leftmost building where Alice and Bob can meet on the ith query. If Alice and Bob cannot move to a common building on query i, set ans[i] to -1.", "canonical_solution": "from bisect import bisect_right\nfrom collections import deque\nfrom operator import itemgetter\ndef leftmostBuildingQueries(heights, queries):\n    res, idx = [0] * len(queries), []\n    for i, q in enumerate(queries):\n        a, b = sorted(q)\n        if a == b or heights[a] < heights[b]:\n            res[i] = b\n        else:\n            idx.append((a, b, i))\n    j, mono = len(heights) - 1, deque()\n    for a, b, i in sorted(idx, key=itemgetter(1), reverse=True):\n        while j > b:\n            while mono and heights[mono[0]] < heights[j]:\n                mono.popleft()\n            mono.appendleft(j)\n            j -= 1\n        k = bisect_right(mono, heights[a], key=lambda x: heights[x])\n        res[i] = -1 if k == len(mono) else mono[k]\n    return res", "entry_point": "leftmostBuildingQueries", "test_list": ["assert leftmostBuildingQueries([6,4,8,5,2,7], [[0,1],[0,3],[2,4],[3,4],[2,2]]) == [2,5,-1,5,2]", "assert leftmostBuildingQueries([5,3,8,2,6,1,4,6],[[0,7],[3,5],[5,2],[3,0],[1,6]]) == [7,6,-1,4,6]"]}
{"Contest id": "372/2939", "text_name": "Maximum Xor Product", "text": "Given three integers a, b, and n, return the maximum value of (a XOR x) * (b XOR x) where 0 <= x < 2n.\nSince the answer may be too large, return it modulo 109 + 7.\nNote that XOR is the bitwise XOR operation.\n", "canonical_solution": "def maximumXorProduct(a, b, n):\n        mask = (1 << n) - 1\n        d = (a ^ b) & mask\n        mod = 10 ** 9 + 7\n        a = (a | mask) & ~d\n        b = (b | mask) & ~d\n        if d == 0:\n            return a * b % mod\n        h = 1 << (d.bit_length() - 1)\n        return max((a ^ d) * b, a * (b ^ d), (a ^ d ^ h) * (b ^ h), (a  ^ h) * (b ^ d ^ h)) % mod", "entry_point": "maximumXorProduct", "test_list": ["assert maximumXorProduct(a = 12, b = 5, n = 4) == 98", "assert maximumXorProduct(a = 6, b = 7 , n = 5) == 930", "assert maximumXorProduct(a = 1, b = 6, n = 3) == 12"]}
{"Contest id": "372/2938", "text_name": "Separate Black and White Balls", "text": "There are n balls on a table, each ball has a color black or white.\nYou are given a 0-indexed binary string s of length n, where 1 and 0 represent black and white balls, respectively.\nIn each step, you can choose two adjacent balls and swap them.\nReturn the minimum number of steps to group all the black balls to the right and all the white balls to the left.", "canonical_solution": "def minimumSteps(s):\n    cnt = 0\n    ans = 0\n    for i in range(len(s) - 1, -1, -1):\n        if s[i] == '1':\n            ans += cnt\n        else:\n            cnt += 1\n    return ans", "entry_point": "minimumSteps", "test_list": ["assert minimumSteps(\"101\") == 1", "assert minimumSteps(\"100\") == 2", "assert minimumSteps(\"0111\") == 0"]}
{"Contest id": "372/2937", "text_name": "Make Three Strings Equal", "text": "You are given three strings s1, s2, and s3. You have to perform the following operation on these three strings as many times as you want.\nIn one operation you can choose one of these three strings such that its length is at least 2 and delete the rightmost character of it.\nReturn the minimum number of operations you need to perform to make the three strings equal if there is a way to make them equal, otherwise, return -1.", "canonical_solution": "def findMinimumOperations(s1, s2, s3):\n    size, l1, l2, l3 = 0, len(s1), len(s2), len(s3)\n    for a, b, c in zip(s1, s2, s3):\n        if a == b == c:\n            size += 1\n        else: break       \n    return (l1 + l2 + l3) - 3 * size if size > 0 else -1", "entry_point": "findMinimumOperations", "test_list": ["assert findMinimumOperations(s1 = \"abc\", s2 = \"abb\", s3 = \"ab\") == 2", "assert findMinimumOperations(s1 = \"dac\", s2 = \"bac\", s3 = \"cac\") == -1"]}
{"Contest id": "371/2935", "text_name": "Maximum Strong Pair XOR II", "text": "You are given a 0-indexed integer array nums. A pair of integers x and y is called a strong pair if it satisfies the condition:\n|x - y| <= min(x, y)\nYou need to select two integers from nums such that they form a strong pair and their bitwise XOR is the maximum among all strong pairs in the array.\nReturn the maximum XOR value out of all possible strong pairs in the array nums.\nNote that you can pick the same integer twice to form a pair.", "canonical_solution": "def maximumStrongPairXor(A):\n    res = 0\n    for i in range(20, -1, -1):\n        res <<= 1\n        pref, pref2 = {}, {}\n        for a in A:\n            p = a >> i\n            if p not in pref:\n                pref[p] = pref2[p] = a\n            pref[p] = min(pref[p], a)\n            pref2[p] = max(pref2[p], a)\n        for x in pref:\n            y = res ^ 1 ^ x\n            if x >= y and y in pref and pref[x] <= pref2[y] * 2:\n                res |= 1\n                break\n    return res", "entry_point": "maximumStrongPairXor", "test_list": ["assert maximumStrongPairXor([1,2,3,4,5]) == 7", "assert maximumStrongPairXor([10,100]) == 0", "assert maximumStrongPairXor([500,520,2500,3000]) == 1020"]}
{"Contest id": "371/2934", "text_name": "Minimum Operations to Maximize Last Elements in Arrays", "text": "You are given two 0-indexed integer arrays, nums1 and nums2, both having length n.\nYou are allowed to perform a series of operations (possibly none).\nIn an operation, you select an index i in the range [0, n - 1] and swap the values of nums1[i] and nums2[i].\nYour task is to find the minimum number of operations required to satisfy the following conditions:\nnums1[n - 1] is equal to the maximum value among all elements of nums1, i.e., nums1[n - 1] = max(nums1[0], nums1[1], ..., nums1[n - 1]).\nnums2[n - 1] is equal to the maximum value among all elements of nums2, i.e., nums2[n - 1] = max(nums2[0], nums2[1], ..., nums2[n - 1]).\nReturn an integer denoting the minimum number of operations needed to meet both conditions, or -1 if it is impossible to satisfy both conditions.", "canonical_solution": "def minOperations(nums1, nums2):\n    swaps = 0\n    n = len(nums1)\n    nums1Last, nums2Last = nums1[-1], nums2[-1]\n    for i in range(n-2,-1,-1):\n        if nums1[i] > nums1Last or nums2[i] > nums2Last:\n            if not nums2[i] > nums1Last and not nums1[i] > nums2Last:\n                swaps += 1\n            else:\n                swaps = -1\n                break\n    swapsSECOND = 1\n    nums1Last, nums2Last = nums2[-1], nums1[-1]\n    for i in range(n-2,-1,-1):\n        if nums1[i] > nums1Last or nums2[i] > nums2Last:\n            if not nums2[i] > nums1Last and not nums1[i] > nums2Last:\n                swapsSECOND += 1\n            else:\n                swapsSECOND = -1\n                break\n    return min(swaps, swapsSECOND)", "entry_point": "minOperations", "test_list": ["assert minOperations(nums1 = [1,2,7], nums2 = [4,5,3]) == 1", "assert minOperations(nums1 = [2,3,4,5,9], nums2 = [8,8,4,4,4]) == 2", "assert minOperations(nums1 = [1,5,4], nums2 = [2,5,3]) == -1"]}
{"Contest id": "371/2933", "text_name": "High-Access Employees", "text": "You are given a 2D 0-indexed array of strings, access_times, with size n. For each i where 0 <= i <= n - 1, access_times[i][0] represents the name of an employee, and access_times[i][1] represents the access time of that employee. All entries in access_times are within the same day.\nThe access time is represented as four digits using a 24-hour time format, for example, \"0800\" or \"2250\".\nAn employee is said to be high-access if he has accessed the system three or more times within a one-hour period.\nTimes with exactly one hour of difference are not considered part of the same one-hour period. For example, \"0815\" and \"0915\" are not part of the same one-hour period.\nAccess times at the start and end of the day are not counted within the same one-hour period. For example, \"0005\" and \"2350\" are not part of the same one-hour period.\nReturn a list that contains the names of high-access employees with any order you want.", "canonical_solution": "from collections import defaultdict\ndef findHighAccessEmployees(access_times):\n        when = defaultdict(list)\n\n        for v in access_times:\n            a, b = v\n            when[a].append(int(b))\n\n        ret = []\n\n        for x, lst in when.items():\n            lst.sort()\n\n            k = len(lst)\n\n            flag = False\n\n            for i in range(k - 2):\n                flag |= lst[i + 2] < lst[i] + 100\n\n            if flag:\n                ret.append(x)\n\n        return ret", "entry_point": "findHighAccessEmployees", "test_list": ["assert findHighAccessEmployees([[\"a\",\"0549\"],[\"b\",\"0457\"],[\"a\",\"0532\"],[\"a\",\"0621\"],[\"b\",\"0540\"]]) == [\"a\"]", "assert findHighAccessEmployees([[\"d\",\"0002\"],[\"c\",\"0808\"],[\"c\",\"0829\"],[\"e\",\"0215\"],[\"d\",\"1508\"],[\"d\",\"1444\"],[\"d\",\"1410\"],[\"c\",\"0809\"]]) == [\"c\",\"d\"]", "assert findHighAccessEmployees([[\"cd\",\"1025\"],[\"ab\",\"1025\"],[\"cd\",\"1046\"],[\"cd\",\"1055\"],[\"ab\",\"1124\"],[\"ab\",\"1120\"]]) == [\"ab\",\"cd\"]"]}
{"Contest id": "371/2932", "text_name": "Maximum Strong Pair XOR I", "text": "You are given a 0-indexed integer array nums. A pair of integers x and y is called a strong pair if it satisfies the condition:\n|x - y| <= min(x, y)\nYou need to select two integers from nums such that they form a strong pair and their bitwise XOR is the maximum among all strong pairs in the array.\nReturn the maximum XOR value out of all possible strong pairs in the array nums.\nNote that you can pick the same integer twice to form a pair.", "canonical_solution": "def maximumStrongPairXor(nums):\n    top = 0\n    for i in range(len(nums)):\n        for j in range(i, len(nums)):\n            if abs(nums[i] - nums[j]) <= min(nums[i], nums[j]):\n                top = max(top, nums[i] ^ nums[j])\n    return top", "entry_point": "maximumStrongPairXor", "test_list": ["assert maximumStrongPairXor([1,2,3,4,5]) == 7", "assert maximumStrongPairXor([10,100]) == 0", "assert maximumStrongPairXor([5,6,25,30]) == 7"]}
{"Contest id": "Bi117/2931", "text_name": "Maximum Spending After Buying Items", "text": "You are given a 0-indexed m * n integer matrix values, representing the values of m * n different items in m different shops. Each shop has n items where the jth item in the ith shop has a value of values[i][j]. Additionally, the items in the ith shop are sorted in non-increasing order of value. That is, values[i][j] >= values[i][j + 1] for all 0 <= j < n - 1.\nOn each day, you would like to buy a single item from one of the shops. Specifically, On the dth day you can:\nPick any shop i.\nBuy the rightmost available item j for the price of values[i][j] * d. That is, find the greatest index j such that item j was never bought before, and buy it for the price of values[i][j] * d.\nNote that all items are pairwise different. For example, if you have bought item 0 from shop 1, you can still buy item 0 from any other shop.\nReturn the maximum amount of money that can be spent on buying all m * n products.", "canonical_solution": "def maxSpending(values):\n    a = sorted([n for row in values for n in row])\n    t = 0\n    for d, v in enumerate(a, start=1):\n        t += d*v\n    return t", "entry_point": "maxSpending", "test_list": ["assert maxSpending([[8,5,2],[6,4,1],[9,7,3]]) == 285", "assert maxSpending([[10,8,6,4,2],[9,7,5,3,2]]) == 386"]}
{"Contest id": "Bi117/2930", "text_name": "Number of Strings Which Can Be Rearranged to Contain Substring", "text": "You are given an integer n.\nA string s is called good if it contains only lowercase English characters and it is possible to rearrange the characters of s such that the new string contains \"leet\" as a substring.\nFor example:\nThe string \"lteer\" is good because we can rearrange it to form \"leetr\" .\n\"letl\" is not good because we cannot rearrange it to contain \"leet\" as a substring.\nReturn the total number of good strings of length n.\nSince the answer may be large, return it modulo 109 + 7.\nA substring is a contiguous sequence of characters within a string.", "canonical_solution": "def stringCount(n):\n        l_0 = 25 ** n\n        e_0 = 25 ** n\n        t_0 = 25 ** n\n        e_1 = n * 25 ** (n-1)\n        e_2 = e_0 + e_1\n        l_0_t_0 = 24 ** n\n        l_0_e_2 = 24 ** n + n * 24 ** (n-1)\n        t_0_e_2 = 24 ** n + n * 24 ** (n-1)\n        l_0_t_0_e_2 = 23 ** n + n * 23 ** (n-1)\n        return (26 ** n - (l_0 + e_2 + t_0 - l_0_t_0 - l_0_e_2 - t_0_e_2 + l_0_t_0_e_2)) % (10 ** 9 + 7)", "entry_point": "stringCount", "test_list": ["assert stringCount(4) == 12", "assert stringCount(10) == 83943898"]}
{"Contest id": "Bi117/2929", "text_name": "Distribute Candies Among Children II", "text": "You are given two positive integers n and limit.\nReturn the total number of ways to distribute n candies among 3 children such that no child gets more than limit candies.", "canonical_solution": "def distributeCandies(n, limit):\n    res = 0\n    for f in range(min(n, limit) + 1):\n        rem = n - f\n        a = max(rem - limit, 0)\n        b = min(rem, limit)\n        if a <= b:\n            res += b - a + 1\n    return res", "entry_point": "distributeCandies", "test_list": ["assert distributeCandies(n = 5, limit = 2) == 3", "assert distributeCandies(n = 3, limit = 3) == 10"]}
{"Contest id": "Bi117/2928", "text_name": "Distribute Candies Among Children I", "text": "You are given two positive integers n and limit.\nReturn the total number of ways to distribute n candies among 3 children such that no child gets more than limit candies.", "canonical_solution": "def distributeCandies(n, limit):\n    res=[]\n    for i in range(0,limit+1):\n        for j in range(0,limit+1):\n            for k in range(0,limit+1):\n                if i+j+k==n and (i,j,k) not in res:\n                    res.append((i,j,k))\n    return len(res)", "entry_point": "distributeCandies", "test_list": ["assert distributeCandies(n = 5, limit = 2) == 3", "assert distributeCandies(n = 3, limit = 3) == 10"]}
{"Contest id": "370/2925", "text_name": "Maximum Score After Applying Operations on a Tree", "text": "There is an undirected tree with n nodes labeled from 0 to n - 1, and rooted at node 0. You are given a 2D integer array edges of length n - 1, where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nYou are also given a 0-indexed integer array values of length n, where values[i] is the value associated with the ith node.\nYou start with a score of 0. In one operation, you can:\nPick any node i.\nAdd values[i] to your score.\nSet values[i] to 0.\nA tree is healthy if the sum of values on the path from the root to any leaf node is different than zero.\nReturn the maximum score you can obtain after performing these operations on the tree any number of times so that it remains healthy.", "canonical_solution": "def maximumScoreAfterOperations(edges, values):\n    def dfs(i, adj, v, vis):\n        if len(adj[i]) == 1 and i != 0:\n            return v[i]\n        s = 0\n        vis[i] = 1\n        for j in adj[i]:\n            if vis[j] == 1:\n                continue\n            s += dfs(j, adj, v, vis)\n        return min(v[i], s)\n    n = len(values)\n    adj = [[] for _ in range(n)]\n    for t in range(n - 1):\n        adj[edges[t][0]].append(edges[t][1])\n        adj[edges[t][1]].append(edges[t][0])\n    s = 0\n    for t in values:\n        s += t\n    vis = [0] * n\n    k = dfs(0, adj, values, vis)\n    return s - k", "entry_point": "maximumScoreAfterOperations", "test_list": ["assert maximumScoreAfterOperations(edges = [[0,1],[0,2],[0,3],[2,4],[4,5]], values = [5,2,5,2,1,1]) == 11", "assert maximumScoreAfterOperations(edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]], values = [20,10,9,7,4,3,5]) == 40"]}
{"Contest id": "370/2924", "text_name": " Find Champion II", "text": "There are n teams numbered from 0 to n - 1 in a tournament; each team is also a node in a DAG.\nYou are given the integer n and a 0-indexed 2D integer array edges of length m representing the DAG, where edges[i] = [ui, vi] indicates that there is a directed edge from team ui to team vi in the graph.\nA directed edge from a to b in the graph means that team a is stronger than team b and team b is weaker than team a.\nTeam a will be the champion of the tournament if there is no team b that is stronger than team a.\nReturn the team that will be the champion of the tournament if there is a unique champion, otherwise, return -1.\nNotes\nA cycle is a series of nodes a1, a2, ..., an, an+1 such that node a1 is the same node as node an+1, the nodes a1, a2, ..., an are distinct, and there is a directed edge from the node ai to node ai+1 for every i in the range [1, n].\nA DAG is a directed graph that does not have any cycle.", "canonical_solution": "def findChampion(n, edges):\n    m = len(edges)\n    in_count = [0] * n\n    for i in range(m):\n        in_count[edges[i][1]] += 1\n    ans = []\n    for i in range(n):\n        if in_count[i] == 0:\n            ans.append(i)\n    if len(ans) > 1:\n        return -1\n    return ans[0]", "entry_point": " findChampion", "test_list": ["assert findChampion(n = 4, edges = [[0,2],[1,3],[1,2]]) == -1", "assert findChampion(n = 3, edges = [[0,1],[1,2]]) == 0"]}
{"Contest id": "370/2923", "text_name": "Find Champion I", "text": "There are n teams numbered from 0 to n - 1 in a tournament.\nGiven a 0-indexed 2D boolean matrix grid of size n * n. For all i, j that 0 <= i, j <= n - 1 and i != j team i is stronger than team j if grid[i][j] == 1, otherwise, team j is stronger than team i.\nTeam a will be the champion of the tournament if there is no team b that is stronger than team a.\nReturn the team that will be the champion of the tournament.", "canonical_solution": "def findChampion(grid):\n    n = len(grid)\n    for i in range(n):\n        if sum(grid[i]) == n - 1:\n            return i", "entry_point": "findChampion", "test_list": ["assert findChampion([[0,1],[0,0]]) == 0", "assert findChampion([[0,0,1],[1,0,1],[0,0,0]]) == 1\n\n\n\n\n\n\n\n\n\n\n\n\n"]}
{"Contest id": "369/2920", "text_name": "Maximum Points After Collecting Coins From All Nodes", "text": "There exists an undirected tree rooted at node 0 with n nodes labeled from 0 to n - 1. You are given a 2D integer array edges of length n - 1, where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree. You are also given a 0-indexed array coins of size n where coins[i] indicates the number of coins in the vertex i, and an integer k.\nStarting from the root, you have to collect all the coins such that the coins at a node can only be collected if the coins of its ancestors have been already collected.\nCoins at nodei can be collected in one of the following ways:\nCollect all the coins, but you will get coins[i] - k points. If coins[i] - k is negative then you will lose abs(coins[i] - k) points.\nCollect all the coins, but you will get floor(coins[i] / 2) points. If this way is used, then for all the nodej present in the subtree of nodei, coins[j] will get reduced to floor(coins[j] / 2).\nReturn the maximum points you can get after collecting the coins from all the tree nodes.", "canonical_solution": "def maximumPoints(edges, coins, k):\n    n = len(edges) + 1\n    G = [set() for i in range(n)]\n    for i,j in edges:\n        G[i].add(j)\n        G[j].add(i)\n    def dp(i, pre, v):\n        if v > 13:\n            return 0\n        a = coins[i] >> v\n        op1 = a - k + sum(dp(j, i, v) for j in G[i] if j != pre)\n        if a >= k + k:\n            return op1\n        op2 = (a >> 1) + sum(dp(j, i, v + 1) for j in G[i] if j != pre)\n        return max(op1, op2)\n    return dp(0, -1, 0)", "entry_point": "maximumPoints", "test_list": ["assert maximumPoints([[0,1],[1,2],[2,3]],[10,10,3,3],5)==11", "assert maximumPoints([[0,1],[0,2]],[8,4,4],0)==16"]}
{"Contest id": "369/2919", "text_name": "Minimum Increment Operations to Make Array Beautiful", "text": "You are given a 0-indexed integer array nums having length n, and an integer k.\nYou can perform the following increment operation any number of times (including zero):\nChoose an index i in the range [0, n - 1], and increase nums[i] by 1.\nAn array is considered beautiful if, for any subarray with a size of 3 or more, its maximum element is greater than or equal to k.\nReturn an integer denoting the minimum number of increment operations needed to make nums beautiful.\nA subarray is a contiguous non-empty sequence of elements within an array.", "canonical_solution": "def minIncrementOperations(nums, k):\n    dp1, dp2, dp3 = 0,0,0\n    for a in nums:\n        dp1, dp2, dp3 = dp2, dp3, min(dp1, dp2, dp3) + max(k - a, 0)\n    return min(dp1, dp2, dp3)", "entry_point": "minIncrementOperations", "test_list": ["assert minIncrementOperations([2,3,0,0,2],4)==3", "assert minIncrementOperations([0,1,3,3],5)==2", "assert minIncrementOperations([1,1,2],1)==0"]}
{"Contest id": "369/2918", "text_name": "Minimum Equal Sum of Two Arrays After Replacing Zeros", "text": "You are given two arrays nums1 and nums2 consisting of positive integers.\nYou have to replace all the 0's in both arrays with strictly positive integers such that the sum of elements of both arrays becomes equal.\nReturn the minimum equal sum you can obtain, or -1 if it is impossible.", "canonical_solution": "def minSum(nums1, nums2):\n    sa = sum(max(a, 1) for a in nums1)\n    sb = sum(max(b, 1) for b in nums2)\n    if sa < sb and nums1.count(0) == 0: return -1\n    if sa > sb and nums2.count(0) == 0: return -1\n    return max(sa, sb)", "entry_point": "minSum", "test_list": ["assert minSum([3,2,0,1,0],[6,5,0])==12", "assert minSum([2,0,2,0],[1,4])==-1"]}
{"Contest id": "369/2917", "text_name": "Find the K-or of an Array", "text": "You are given a 0-indexed integer array nums, and an integer k.\nThe K-or of nums is a non-negative integer that satisfies the following:\nThe ith bit is set in the K-or if and only if there are at least k elements of nums in which bit i is set.\nReturn the K-or of nums.\nNote that a bit i is set in x if (2i AND x) == 2i, where AND is the bitwise AND operator.", "canonical_solution": "def findKOr(nums, k):\n    ans = 0\n    for i in range(32):\n        count = 0\n        for num in nums:\n            if 2 ** i & num == 2 ** i:\n                count += 1\n        if count >= k:\n            ans |= 2 ** i\n    return ans", "entry_point": "findKOr", "test_list": ["assert findKOr([7,12,9,8,9,15],4)==9", "assert findKOr([2,12,1,11,4,5],6)==0", "assert findKOr([10,8,5,9,11,6,8],1)==15"]}
{"Contest id": "Bi116/2916", "text_name": "Subarrays Distinct Element Sum of Squares II", "text": "You are given a 0-indexed integer array nums.\nThe distinct count of a subarray of nums is defined as:\nLet nums[i..j] be a subarray of nums consisting of all the indices from i to j such that 0 <= i <= j < nums.length. Then the number of distinct values in nums[i..j] is called the distinct count of nums[i..j].\nReturn the sum of the squares of distinct counts of all subarrays of nums.\nSince the answer may be very large, return it modulo 10^9 + 7.\nA subarray is a contiguous non-empty sequence of elements within an array.", "canonical_solution": "def sumCounts(nums):\n    import collections\n    n = len(nums)\n    tree = [0]*(4*n)\n    lazy = [0]*(4*n)\n    def build(tree, arr, v, lo, hi):\n        if lo == hi:\n            tree[v] = arr[lo]\n            return\n        m = (lo + hi)//2\n        build(tree, arr, 2*v + 1, lo, m)\n        build(tree, arr, 2*v + 2, m + 1, hi)\n        tree[v] = tree[2*v + 1] + tree[2*v + 2]\n    def update(tree, v, lo, hi, i, j, val):\n        if lazy[v]:\n            tree[v] += (hi - lo + 1) * lazy[v]\n            if lo < hi:\n                lazy[2*v + 1] += lazy[v]\n                lazy[2*v + 2] += lazy[v]\n            lazy[v] = 0\n        if lo > j or hi < i: \n            return \n        if i <= lo and hi <= j:\n            tree[v] += (hi - lo + 1)*val\n            if lo < hi:\n                lazy[2*v + 1] += val \n                lazy[2*v + 2] += val\n            return\n        m = (lo + hi)//2\n        update(tree, 2*v + 1, lo, m, i, j, val) \n        update(tree, 2*v + 2, m+1, hi, i, j, val)\n        tree[v] = tree[2*v + 1] + tree[2*v + 2]\n    def query(tree, v, lo, hi, i, j):\n        if j < lo or hi < i:\n            return 0\n        if lazy[v]:\n            tree[v] += (hi - lo + 1)*lazy[v]\n            if lo < hi:\n                lazy[2*v + 1] += lazy[v]\n                lazy[2*v + 2] += lazy[v]\n            lazy[v] = 0\n        if i <= lo and hi <= j:\n            return tree[v]\n        m = (lo + hi)//2\n        if i > m:\n            return query(tree, 2*v + 2, m + 1, hi, i, j)\n        elif j <= m:\n            return query(tree, 2*v + 1, lo, m, i, j)\n        return query(tree, 2*v + 1, lo, m, i, m) + query(tree, 2*v + 2, m+1, hi, m+1, j)\n    squares = 1\n    update(tree, 0, 0, n-1, n-1, n-1, 1)\n    index = collections.defaultdict(lambda:n)\n    index[nums[-1]] = n - 1\n    res = 1\n    for i in range(n-2,-1,-1):\n        j = index[nums[i]]\n        squares += (j-i) + 2*query(tree,0,0,n-1,i+1,j-1)\n        res += squares\n        update(tree, 0, 0, n-1, i, j-1, 1)\n        index[nums[i]] = i\n    return res%(10**9 + 7)", "entry_point": "sumCounts", "test_list": ["assert sumCounts([1,2,1])==15", "assert sumCounts([2,2])==3"]}
{"Contest id": "Bi116/2915", "text_name": "Length of the Longest Subsequence That Sums to Target", "text": "You are given a 0-indexed array of integers nums, and an integer target.\nReturn the length of the longest subsequence of nums that sums up to target. If no such subsequence exists, return -1.\nA subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.", "canonical_solution": "def lengthOfLongestSubsequence(nums, sum):\n    n = len(nums)\n    dp = [[-1] * (sum + 1) for _ in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = 0\n    for i in range(1, n + 1):\n        for j in range(1, sum + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j >= nums[i - 1] and dp[i - 1][j - nums[i - 1]] != -1:\n                dp[i][j] = max(1 + dp[i - 1][j - nums[i - 1]], dp[i][j])\n    return dp[n][sum]", "entry_point": "lengthOfLongestSubsequence", "test_list": ["assert lengthOfLongestSubsequence([1,2,3,4,5],9)==3", "assert lengthOfLongestSubsequence([4,1,3,2,1,5],7)==4", "assert lengthOfLongestSubsequence([1,1,5,4,5],3)==-1"]}
{"Contest id": "Bi116/2914", "text_name": "Minimum Number of Changes to Make Binary String Beautiful", "text": "You are given a 0-indexed binary string s having an even length.\nA string is beautiful if it's possible to partition it into one or more substrings such that:\nEach substring has an even length.\nEach substring contains only 1's or only 0's.\nYou can change any character in s to 0 or 1.\nReturn the minimum number of changes required to make the string s beautiful.", "canonical_solution": "def minChanges(s):\n    n = len(s)\n    ans = 0\n    for i in range(0, n, 2):\n        if s[i] != s[i + 1]:\n            ans += 1\n    return ans", "entry_point": "minChanges", "test_list": ["assert minChanges(\"1001\")==2", "assert minChanges(\"10\")==1", "assert minChanges(\"0000\")==0"]}
{"Contest id": "Bi116/2913", "text_name": "Subarrays Distinct Element Sum of Squares ", "text": "You are given a 0-indexed integer array nums.\nThe distinct count of a subarray of nums is defined as:\nLet nums[i..j] be a subarray of nums consisting of all the indices from i to j such that 0 <= i <= j < nums.length. Then the number of distinct values in nums[i..j] is called the distinct count of nums[i..j].\nReturn the sum of the squares of distinct counts of all subarrays of nums.\nA subarray is a contiguous non-empty sequence of elements within an array.", "canonical_solution": "def sumCounts(nums):\n    ans=[]\n    for i in range(len(nums)):\n        for j in range(i,len(nums)+1):\n            ans.append(len(set(nums[i:j]))**2)\n    return sum(ans)", "entry_point": "sumCounts", "test_list": ["assert sumCounts([1,2,1])==15", "assert sumCounts([1,1])==3"]}
{"Contest id": "368/2911", "text_name": "Minimum Changes to Make K Semi-palindromes", "text": "Given a string s and an integer k, partition s into k substrings such that the sum of the number of letter changes required to turn each substring into a semi-palindrome is minimized.\nReturn an integer denoting the minimum number of letter changes required.\nNotes\nA string is a palindrome if it can be read the same way from left to right and right to left.\nA string with a length of len is considered a semi-palindrome if there exists a positive integer d such that 1 <= d < len and len % d == 0, and if we take indices that have the same modulo by d, they form a palindrome. For example, \"aa\", \"aba\", \"adbgad\", and, \"abab\" are semi-palindrome and \"a\", \"ab\", and, \"abca\" are not.\nA substring is a contiguous sequence of characters within a string.", "canonical_solution": "def minimumChanges(s, k):\n    import collections\n    div = collections.defaultdict(lambda: [1])\n    n = len(s)\n    for d in range(2, n):\n            for v in range(d + d, n + 1, d):\n                div[v].append(d)\n    def change(i, j):\n        return min(semi(i, j, d) for d in div[j - i])\n    def semi(i, j, d):\n        if i >= j: return 0\n        return semi(i + d, j - d, d) + sum(s[i + ii] != s[j - d + ii] for ii in range(d))\n    def dp(i, k):\n        if k == 1:\n            return change(0, i)\n        return min(dp(j, k - 1) + change(j, i) for j in range((k - 1) * 2, i - 1))\n    return dp(n, k)", "entry_point": "minimumChanges", "test_list": ["assert minimumChanges(\"abcac\",2)==1", "assert minimumChanges(\"abcdef\",2)==2", "assert minimumChanges(\"aabbaa\",3)==0"]}
{"Contest id": "368/2910", "text_name": "Minimum Number of Groups to Create a Valid Assignment", "text": "You are given a 0-indexed integer array nums of length n.\nWe want to group the indices so for each index i in the range [0, n - 1], it is assigned to exactly one group.\nA group assignment is valid if the following conditions hold:\nFor every group g, all indices i assigned to group g have the same value in nums.\nFor any two groups g1 and g2, the difference between the number of indices assigned to g1 and g2 should not exceed 1.\nReturn an integer denoting the minimum number of groups needed to create a valid group assignment.", "canonical_solution": "def minGroupsForValidAssignment(nums):\n    import math\n    def partition(guessed_partition_size, frequencies):\n        result = 0\n        for frequency in frequencies:\n            num_groups = frequency // guessed_partition_size\n            remainder = frequency % guessed_partition_size\n            if remainder > num_groups:\n                return float(\"inf\")\n            result += math.ceil(frequency / (guessed_partition_size + 1))\n        return result\n    counts = {}\n    for num in nums:\n        counts[num] = counts.get(num, 0) + 1\n    frequencies = counts.values()\n    if len(frequencies) == 1:\n        return 1\n    result = len(nums)\n    least_frequent = min(frequencies)\n    for partition_size in range(1, least_frequent + 1):\n        result = min(result, partition(partition_size, frequencies))\n    return int(result)", "entry_point": "minGroupsForValidAssignment", "test_list": ["assert minGroupsForValidAssignment([3,2,3,2,3])==2", "assert minGroupsForValidAssignment([10,10,10,3,1,1])==4"]}
{"Contest id": "368/2909", "text_name": "Minimum Sum of Mountain Triplets II", "text": "You are given a 0-indexed array nums of integers.\nA triplet of indices (i, j, k) is a mountain if:\ni < j < k\nnums[i] < nums[j] and nums[k] < nums[j]\nReturn the minimum possible sum of a mountain triplet of nums. If no such triplet exists, return -1.", "canonical_solution": "def minimumSum(nums):\n    n = len(nums)\n    prefix, suffix = [float('inf')] * n, [float('inf')] * n\n    result = float('inf')\n    for i in range(1, n - 1):\n        prefix[i] = min(nums[i - 1], prefix[i - 1])\n    for i in range(n - 2, 0, -1):\n        suffix[i] = min(nums[i + 1], suffix[i + 1])\n    for i in range(1, n - 1):\n        if prefix[i] < nums[i] and suffix[i] < nums[i]:\n            result = min(result, prefix[i] + nums[i] + suffix[i])\n    return -1 if result == float('inf') else result", "entry_point": "minimumSum", "test_list": ["assert minimumSum([8,6,1,5,3])==9", "assert minimumSum([5,4,8,7,10,2])==13", "assert minimumSum([6,5,4,3,4,5])==-1"]}
{"Contest id": "368/2908", "text_name": "Minimum Sum of Mountain Triplets I", "text": "You are given a 0-indexed array nums of integers.\nA triplet of indices (i, j, k) is a mountain if:\ni < j < k\nnums[i] < nums[j] and nums[k] < nums[j]\nReturn the minimum possible sum of a mountain triplet of nums. If no such triplet exists, return -1.", "canonical_solution": "def minimumSum(nums):\n    ans=float('inf')\n    for i in range(len(nums)):\n        for j in range(i+1,len(nums)):\n            for k in range(j+1,len(nums)):\n                if nums[i]<nums[j] and nums[k]<nums[j]:\n                    ans=min(ans,nums[i]+nums[j]+nums[k])\n    return ans if ans!=float('inf') else -1", "entry_point": "minimumSum", "test_list": ["assert minimumSum([8,6,1,5,3])==9", "assert minimumSum([5,4,8,7,10,2])==13", "assert minimumSum([6,5,4,3,4,5])==-1"]}
{"Contest id": "367/2906", "text_name": "Construct Product Matrix", "text": "Given a 0-indexed 2D integer matrix grid of size n * m, we define a 0-indexed 2D matrix p of size n * m as the product matrix of grid if the following condition is met:\nEach element p[i][j] is calculated as the product of all elements in grid except for the element grid[i][j]. This product is then taken modulo 12345.\nReturn the product matrix of grid.", "canonical_solution": "def constructProductMatrix(grid):\n    n, m = len(grid), len(grid[0])\n    A = [[1] * m for r in grid]\n    pre, suf, mod = 1, 1, 12345\n    for i in range(n):\n        for j in range(m):\n            A[i][j] = A[i][j] * pre % mod\n            A[~i][~j] = A[~i][~j] * suf % mod\n            pre = pre * grid[i][j] % mod\n            suf = suf * grid[~i][~j] % mod\n    return A", "entry_point": "constructProductMatrix", "test_list": ["assert constructProductMatrix([[1,2],[3,4]])==[[24,12],[8,6]]", "assert constructProductMatrix([[12345],[2],[1]])==[[2],[0],[0]]"]}
{"Contest id": "367/2905", "text_name": "Find Indices With Index and Value Difference II", "text": "You are given a 0-indexed integer array nums having length n, an integer indexDifference, and an integer valueDifference.\nYour task is to find two indices i and j, both in the range [0, n - 1], that satisfy the following conditions:\nabs(i - j) >= indexDifference, and\nabs(nums[i] - nums[j]) >= valueDifference\nReturn an integer array answer, where answer = [i, j] if there are two such indices, and answer = [-1, -1] otherwise. If there are multiple choices for the two indices, return any of them.\nNote: i and j may be equal.", "canonical_solution": "def findIndices(nums, indexDifference, valueDifference):\n    min_index = 0\n    max_index = 0\n    for i in range(indexDifference, len(nums)):\n        if nums[i - indexDifference] < nums[min_index]:\n            min_index = i - indexDifference\n        if nums[i - indexDifference] > nums[max_index]:\n            max_index = i - indexDifference\n        if abs(nums[i] - nums[min_index]) >= valueDifference:\n            return [min_index, i]\n        if abs(nums[i] - nums[max_index]) >= valueDifference:\n            return [max_index, i]\n    return [-1, -1]", "entry_point": "findIndices", "test_list": ["assert findIndices([5,1,4,1],2,4)==[0,3]", "assert findIndices([2,1],0,0)==[0,0]", "assert findIndices([1,2,3],2,4)==[-1,-1]"]}
{"Contest id": "367/2904", "text_name": "Shortest and Lexicographically Smallest Beautiful String", "text": "You are given a binary string s and a positive integer k.\nA substring of s is beautiful if the number of 1's in it is exactly k.\nLet len be the length of the shortest beautiful substring.\nReturn the lexicographically smallest beautiful substring of string s with length equal to len. If s doesn't contain a beautiful substring, return an empty string.\nA string a is lexicographically larger than a string b (of the same length) if in the first position where a and b differ, a has a character strictly larger than the corresponding character in b.\nFor example, \"abcd\" is lexicographically larger than \"abcc\" because the first position they differ is at the fourth character, and d is greater than c.", "canonical_solution": "def shortestBeautifulSubstring(s, k):\n    n = len(s)\n    ans = \"\"\n    i = 0\n    j = 0\n    c = 0\n    while j < n:\n        if s[j] == '1':\n            c += 1\n        if c == k:\n            while i < n and c == k:\n                s1 = s[i:j + 1]\n                if not ans or len(s1) < len(ans):\n                    ans = s1\n                elif len(s1) == len(ans):\n                    ans = min(ans, s1)\n                if s[i] == '1':\n                    c -= 1\n                i += 1\n        j += 1\n    return ans", "entry_point": "shortestBeautifulSubstring", "test_list": ["assert shortestBeautifulSubstring(\"100011001\",3)==\"11001\"", "assert shortestBeautifulSubstring(\"1011\",2)==\"11\"", "assert shortestBeautifulSubstring(\"000\",1)==\"\""]}
{"Contest id": "367/2903", "text_name": "Find Indices With Index and Value Difference I", "text": "You are given a 0-indexed integer array nums having length n, an integer indexDifference, and an integer valueDifference.\nYour task is to find two indices i and j, both in the range [0, n - 1], that satisfy the following conditions:\nabs(i - j) >= indexDifference, and\nabs(nums[i] - nums[j]) >= valueDifference\nReturn an integer array answer, where answer = [i, j] if there are two such indices, and answer = [-1, -1] otherwise. If there are multiple choices for the two indices, return any of them.\nNote: i and j may be equal.", "canonical_solution": "def findIndices(nums, indexDifference, valueDifference):\n    mini = maxi = 0\n    for i in range(indexDifference, len(nums)):\n        if nums[i - indexDifference] < nums[mini]: mini = i - indexDifference\n        if nums[i - indexDifference] > nums[maxi]: maxi = i - indexDifference\n        if nums[i] - nums[mini] >= valueDifference: return [mini, i]\n        if nums[maxi] - nums[i] >= valueDifference: return [maxi, i]\n    return [-1, -1]", "entry_point": "findIndices", "test_list": ["assert findIndices([5,1,4,1],2,4)==[0,3]", "assert findIndices([2,1],0,0)==[0,0]", "assert findIndices([1,2,3],2,4)==[-1,-1]"]}
{"Contest id": "Bi115/2902", "text_name": "Count of Sub-Multisets With Bounded Sum", "text": "You are given a 0-indexed array nums of non-negative integers, and two integers l and r.\nReturn the count of sub-multisets within nums where the sum of elements in each subset falls within the inclusive range of [l, r].\nSince the answer may be large, return it modulo 10^9 + 7.\nA sub-multiset is an unordered collection of elements of the array in which a given value x can occur 0, 1, ..., occ[x] times, where occ[x] is the number of occurrences of x in the array.\nNote that:\nTwo sub-multisets are the same if sorting both sub-multisets results in identical multisets.\nThe sum of an empty multiset is 0.", "canonical_solution": "def countSubMultisets(nums, l, r):\n    import collections\n    dp = [1] + [0] * r\n    counts = collections.Counter(nums)\n    zeros = counts.pop(0, 0) + 1\n    for a, c in counts.items():\n        stride_sums = dp[:]\n        for i in range(a, r + 1):\n            stride_sums[i] += stride_sums[i - a]\n        for k in range(r, 0, -1):\n            dp[k] = stride_sums[k] - stride_sums[k - a * c - a] if k >= a * c + a else stride_sums[k]\n    return zeros * sum(dp[l:r+1]) % (10 ** 9 + 7)", "entry_point": "countSubMultisets", "test_list": ["assert countSubMultisets([1,2,2,3],6,6)==1", "assert countSubMultisets([2,1,4,2,7],1,5)==7", "assert countSubMultisets([1,2,1,3,5,2],3,5)==9"]}
{"Contest id": "Bi115/2901", "text_name": "Longest Unequal Adjacent Groups Subsequence II", "text": "You are given an integer n, a 0-indexed string array words, and a 0-indexed array groups, both arrays having length n.\nThe hamming distance between two strings of equal length is the number of positions at which the corresponding characters are different.\nYou need to select the longest subsequence from an array of indices [0, 1, ..., n - 1], such that for the subsequence denoted as [i0, i1, ..., ik - 1] having length k, the following holds:\nFor adjacent indices in the subsequence, their corresponding groups are unequal, i.e., groups[ij] != groups[ij + 1], for each j where 0 < j + 1 < k.\nwords[ij] and words[ij + 1] are equal in length, and the hamming distance between them is 1, where 0 < j + 1 < k, for all indices in the subsequence.\nReturn a string array containing the words corresponding to the indices (in order) in the selected subsequence. If there are multiple answers, return any of them.\nA subsequence of an array is a new array that is formed from the original array by deleting some (possibly none) of the elements without disturbing the relative positions of the remaining elements.\nNote: strings in words may be unequal in length.", "canonical_solution": "def getWordsInLongestSubsequence(n, words, groups):\n        dp = [1] * len(groups)\n        pv = [-1] * len(groups)\n\n        for i in range(1, len(groups)):\n            for j in range(i):\n                if groups[i] == groups[j]:\n                    continue\n                if len(words[i]) != len(words[j]):\n                    continue\n\n                diff = sum(1 for k in range(len(words[i])) if words[i][k] != words[j][k])\n\n                if diff != 1:\n                    continue\n\n                if dp[j] + 1 > dp[i]:\n                    dp[i] = dp[j] + 1\n                    pv[i] = j\n\n        wi = dp.index(max(dp))\n        ans = []\n\n        while wi != -1:\n            ans.append(words[wi])\n            wi = pv[wi]\n\n        ans.reverse()\n        return ans\n", "entry_point": "getWordsInLongestSubsequence", "test_list": ["assert getWordsInLongestSubsequence(3,[\"bab\",\"dab\",\"cab\"],[1,2,2])==[\"bab\",\"cab\"]", "assert getWordsInLongestSubsequence(4,[\"a\",\"b\",\"c\",\"d\"],[1,2,3,4])==[\"a\",\"b\",\"c\",\"d\"]"]}
{"Contest id": "Bi115/2900", "text_name": "Longest Unequal Adjacent Groups Subsequence I", "text": "You are given an integer n, a 0-indexed string array words, and a 0-indexed binary array groups, both arrays having length n.\nYou need to select the longest subsequence from an array of indices [0, 1, ..., n - 1], such that for the subsequence denoted as [i0, i1, ..., ik - 1] having length k, groups[ij] != groups[ij + 1], for each j where 0 < j + 1 < k.\nReturn a string array containing the words corresponding to the indices (in order) in the selected subsequence. If there are multiple answers, return any of them.\nA subsequence of an array is a new array that is formed from the original array by deleting some (possibly none) of the elements without disturbing the relative positions of the remaining elements.\nNote: strings in words may be unequal in length.", "canonical_solution": "def getWordsInLongestSubsequence(n, words, groups):\n    from typing import List\n    ls,c_g,sl=0,-1,[]\n    for i in range(n):\n        if groups[i]!=c_g:\n            c_g=groups[i]\n            sl.append(words[i])\n            ls+=1\n    return sl", "entry_point": "getWordsInLongestSubsequence", "test_list": ["assert getWordsInLongestSubsequence(3,[\"e\",\"a\",\"b\"],[0,0,1])==[\"e\",\"b\"]", "assert getWordsInLongestSubsequence(4, [\"a\",\"b\",\"c\",\"d\"],[1,0,1,1])==[\"a\",\"b\",\"c\"]"]}
{"Contest id": "Bi115/2899", "text_name": "Last Visited Integers", "text": "Given a 0-indexed array of strings words where words[i] is either a positive integer represented as a string or the string \"prev\".\nStart iterating from the beginning of the array; for every \"prev\" string seen in words, find the last visited integer in words which is defined as follows:\nLet k be the number of consecutive \"prev\" strings seen so far (containing the current string). Let nums be the 0-indexed array of integers seen so far and nums_reverse be the reverse of nums, then the integer at (k - 1)th index of nums_reverse will be the last visited integer for this \"prev\".\nIf k is greater than the total visited integers, then the last visited integer will be -1.\nReturn an integer array containing the last visited integers.", "canonical_solution": "def lastVisitedIntegers(words):\n    k,li,ans=0,[],[]\n    for i in words:\n        if i=='prev':\n            k+=1\n            if k>len(li):\n                ans.append(-1)\n            else:\n                ans.append(li[-k])\n        else:\n            k=0\n            li.append(int(i))\n    return ans", "entry_point": "lastVisitedIntegers", "test_list": ["assert lastVisitedIntegers([\"1\",\"2\",\"prev\",\"prev\",\"prev\"])==[2,1,-1]", "assert lastVisitedIntegers([\"1\",\"prev\",\"2\",\"prev\",\"prev\"])==[1,2,1]"]}
{"Contest id": "366/2897", "text_name": "Apply Operations on Array to Maximize Sum of Squares", "text": "You are given a 0-indexed integer array nums and a positive integer k.\nYou can do the following operation on the array any number of times:\nChoose any two distinct indices i and j and simultaneously update the values of nums[i] to (nums[i] AND nums[j]) and nums[j] to (nums[i] OR nums[j]). Here, OR denotes the bitwise OR operation, and AND denotes the bitwise AND operation.\nYou have to choose k elements from the final array and calculate the sum of their squares.\nReturn the maximum sum of squares you can achieve.\nSince the answer can be very large, return it modulo 10^9 + 7.", "canonical_solution": "def maxSum(nums, k):\n    count = [0] * 35\n    for a in nums:\n        for i in range(35):\n            if a & (1 << i):\n                count[i] += 1\n    res = 0\n    mod = 10 ** 9 + 7\n    for j in range(k):\n        cur = 0\n        for i in range(35):\n            if count[i]:\n                count[i] -= 1\n                cur += 1 << i\n        res += cur * cur % mod\n    return res % mod", "entry_point": "maxSum", "test_list": ["assert maxSum([2,6,5,8],2)==261", "assert maxSum([4,5,4,7],3)==90"]}
{"Contest id": "366/2896", "text_name": "Apply Operations to Make Two Strings Equal", "text": "You are given two 0-indexed binary strings s1 and s2, both of length n, and a positive integer x.\nYou can perform any of the following operations on the string s1 any number of times:\nChoose two indices i and j, and flip both s1[i] and s1[j]. The cost of this operation is x.\nChoose an index i such that i < n - 1 and flip both s1[i] and s1[i + 1]. The cost of this operation is 1.\nReturn the minimum cost needed to make the strings s1 and s2 equal, or return -1 if it is impossible.\nNote that flipping a character means changing it from 0 to 1 or vice-versa.", "canonical_solution": "def minOperations(s1, s2, x):\n    diffs = [i for i in range(len(s1)) if s1[i] != s2[i]]\n    if len(diffs) % 2 == 1:\n        return -1\n    if len(diffs) == 0:\n        return 0\n    dp = [float(\"inf\") for _ in range(len(diffs) + 1)]\n    dp[-1] = 0\n    dp[-2] = x / 2\n    for idx in reversed(range(len(diffs) - 1)):\n        dp[idx] = min(\n                dp[idx + 1] + x / 2,\n                dp[idx + 2] + diffs[idx + 1] - diffs[idx]\n            )\n    return int(dp[0])", "entry_point": "minOperations", "test_list": ["assert minOperations(\"1100011000\",\"0101001010\",2)==4", "assert minOperations(\"10110\",\"00011\",4)==-1"]}
{"Contest id": "366/2895", "text_name": "Minimum Processing Time", "text": "You have n processors each having 4 cores and n * 4 tasks that need to be executed such that each core should perform only one task.\nGiven a 0-indexed integer array processorTime representing the time at which each processor becomes available for the first time and a 0-indexed integer array tasks representing the time it takes to execute each task, return the minimum time when all of the tasks have been executed by the processors.\nNote: Each core executes the task independently of the others.", "canonical_solution": "def minProcessingTime(processorTime, tasks):\n    n = len(tasks)\n    processorTime.sort()\n    tasks.sort()\n    j = n - 1\n    m = len(processorTime)\n    ans = 0\n    for i in range(m):\n        c = 0\n        while c < 4:\n            ans = max(ans, processorTime[i] + tasks[j])\n            c += 1\n            j -= 1\n    return ans", "entry_point": "minProcessingTime", "test_list": ["assert minProcessingTime([8,10],[2,2,3,1,8,7,4,5])==16", "assert minProcessingTime([10,20],[2,3,1,2,5,8,4,3])==23"]}
{"Contest id": "366/2894", "text_name": "Divisible and Non-divisible Sums Difference", "text": "You are given positive integers n and m.\nDefine two integers, num1 and num2, as follows:\nnum1: The sum of all integers in the range [1, n] that are not divisible by m.\nnum2: The sum of all integers in the range [1, n] that are divisible by m.\nReturn the integer num1 - num2.", "canonical_solution": "def differenceOfSums(n, m):\n    return (1 + n) * n // 2 - (1 + n // m) * (n // m) * m", "entry_point": "differenceOfSums", "test_list": ["assert differenceOfSums(10,3)==19", "assert differenceOfSums(5,6)==15", "assert differenceOfSums(5,1)==-15"]}
{"Contest id": "365/2876", "text_name": "Count Visited Nodes in a Directed Graph", "text": "There is a directed graph consisting of n nodes numbered from 0 to n - 1 and n directed edges.\nYou are given a 0-indexed array edges where edges[i] indicates that there is an edge from node i to node edges[i].\nConsider the following process on the graph:\nYou start from a node x and keep visiting other nodes through edges until you reach a node that you have already visited before on this same process.\nReturn an array answer where answer[i] is the number of different nodes that you will visit if you perform the process starting from node i.", "canonical_solution": "def countVisitedNodes(edges):\n    import collections\n    n = len(edges)\n    res = [0] * n\n    for i in range(n):\n        seen = collections.OrderedDict()\n        j = i\n        while (j not in seen) and (res[j] == 0):\n            seen[j] = len(seen)\n            j = edges[j]\n        if j in seen:\n            k = len(seen) - seen[j]\n            for _ in range(k):\n                res[seen.popitem()[0]] = k\n        while seen:\n            j = seen.popitem()[0]\n            res[j] = res[edges[j]] + 1\n    return res", "entry_point": "countVisitedNodes", "test_list": ["assert countVisitedNodes([1,2,0,0])==[3,3,3,4]", "assert countVisitedNodes([1,2,3,4,0])==[5,5,5,5,5]"]}
{"Contest id": "365/2875", "text_name": "Minimum Size Subarray in Infinite Array", "text": "You are given a 0-indexed array nums and an integer target.\nA 0-indexed array infinite_nums is generated by infinitely appending the elements of nums to itself.\nReturn the length of the shortest subarray of the array infinite_nums with a sum equal to target. If there is no such subarray return -1.", "canonical_solution": "def minSizeSubarray(A,target):\n    from numpy import inf\n    sumA = sum(A)\n    n = len(A)\n    k = target // sumA\n    target %= sumA\n    if target == 0:\n        return k * n\n    dp = {0: -1}\n    su = 0\n    res = inf\n    for i,a in enumerate(A + A):\n        su += a\n        if su - target in dp:\n            res = min(res, i - dp.get(su - target))\n        dp[su] = i\n    return res + k * n if res < inf else -1", "entry_point": "minSizeSubarray", "test_list": ["assert minSizeSubarray([1,2,3],5)==2", "assert minSizeSubarray([1,1,1,2,3],4)==2", "assert minSizeSubarray([2,4,6,8],3)==-1"]}
{"Contest id": "365/2874", "text_name": "Maximum Value of an Ordered Triplet II", "text": "You are given a 0-indexed integer array nums.\nReturn the maximum value over all triplets of indices (i, j, k) such that i < j < k. If all such triplets have a negative value, return 0.\nThe value of a triplet of indices (i, j, k) is equal to (nums[i] - nums[j]) * nums[k].", "canonical_solution": "def maximumTripletValue(nums):\n    res = maxa = maxab = 0\n    for a in nums:\n        res = max(res, maxab * a)\n        maxab = max(maxab, maxa - a)\n        maxa = max(maxa, a)\n    return res", "entry_point": "maximumTripletValue", "test_list": ["assert maximumTripletValue([12,6,1,2,7])==77", "assert maximumTripletValue([1,10,3,4,19])==133", "assert maximumTripletValue([1,2,3])==0"]}
{"Contest id": "365/2873", "text_name": "Maximum Value of an Ordered Triplet I", "text": "You are given a 0-indexed integer array nums.\nReturn the maximum value over all triplets of indices (i, j, k) such that i < j < k. If all such triplets have a negative value, return 0.\nThe value of a triplet of indices (i, j, k) is equal to (nums[i] - nums[j]) * nums[k].", "canonical_solution": "def maximumTripletValue(nums):\n    res = maxa = maxab = 0\n    for a in nums:\n        res = max(res, maxab * a)\n        maxab = max(maxab, maxa - a)\n        maxa = max(maxa, a)\n    return res", "entry_point": "maximumTripletValue", "test_list": ["assert maximumTripletValue([12,6,1,2,7])==77", "assert maximumTripletValue([1,10,3,4,19])==133", "assert maximumTripletValue([1,2,3])==0"]}
{"Contest id": "Bi114/2872", "text_name": "Maximum Number of K-Divisible Components", "text": "There is an undirected tree with n nodes labeled from 0 to n - 1. You are given the integer n and a 2D integer array edges of length n - 1, where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nYou are also given a 0-indexed integer array values of length n, where values[i] is the value associated with the ith node, and an integer k.\nA valid split of the tree is obtained by removing any set of edges, possibly empty, from the tree such that the resulting components all have values that are divisible by k, where the value of a connected component is the sum of the values of its nodes.\nReturn the maximum number of components in any valid split.", "canonical_solution": "def maxKDivisibleComponents(n, edges, values, k):\n    adj = [[] for _ in range(n + 1)]\n    for edge in edges:\n        adj[edge[0]].append(edge[1])\n        adj[edge[1]].append(edge[0])\n    res = [0]  \n    vis = [0] * n\n    vis[0] = 1\n    def dfs(node):\n        leaf = values[node]\n        vis[node] = 1\n        for it in adj[node]:\n            if vis[it] == 0:\n                leaf += dfs(it)\n        if leaf % k == 0:\n            res[0] += 1\n            leaf = 0\n        return leaf\n    dfs(0)\n    if res[0] == 0:\n        return 1\n    return res[0]", "entry_point": "maxKDivisibleComponents", "test_list": ["assert maxKDivisibleComponents(5,[[0,2],[1,2],[1,3],[2,4]],[1,8,1,4,4],6)==2", "assert maxKDivisibleComponents(7,[[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]],[3,0,6,1,5,2,1],3)==3"]}
{"Contest id": "Bi114/2871", "text_name": "Split Array Into Maximum Number of Subarrays", "text": "You are given an array nums consisting of non-negative integers.\nWe define the score of subarray nums[l..r] such that l <= r as nums[l] AND nums[l + 1] AND ... AND nums[r] where AND is the bitwise AND operation.\nConsider splitting the array into one or more subarrays such that the following conditions are satisfied:\nEach element of the array belongs to exactly one subarray.\nThe sum of scores of the subarrays is the minimum possible.\nReturn the maximum number of subarrays in a split that satisfies the conditions above.\nA subarray is a contiguous part of an array.", "canonical_solution": "def maxSubarrays(nums):\n    v = -1\n    res = 0\n    for a in nums:\n        v &= a\n        if v == 0:\n            v = -1\n            res += 1\n    return max(1, res)", "entry_point": "maxSubarrays", "test_list": ["assert maxSubarrays([1,0,2,0,1,2])==3", "assert maxSubarrays([5,7,1,3])==1"]}
{"Contest id": "Bi114/2870", "text_name": "Minimum Number of Operations to Make Array Empty", "text": "You are given a 0-indexed array nums consisting of positive integers.\nThere are two types of operations that you can apply on the array any number of times:\nChoose two elements with equal values and delete them from the array.\nChoose three elements with equal values and delete them from the array.\nReturn the minimum number of operations required to make the array empty, or -1 if it is not possible.", "canonical_solution": "def minOperations(nums):\n    from collections import Counter\n    mp = Counter(nums)\n    count = 0\n    for t in mp.values():\n        if t == 1:\n            return -1\n        count += t // 3\n        if t % 3:\n            count += 1  \n    return count", "entry_point": "minOperations", "test_list": ["assert minOperations([2,3,3,2,2,4,2,3,4])==4", "assert minOperations([2,1,2,2,3,3])==-1"]}
{"Contest id": "Bi114/2869", "text_name": "Minimum Operations to Collect Elements", "text": "You are given an array nums of positive integers and an integer k.\nIn one operation, you can remove the last element of the array and add it to your collection.\nReturn the minimum number of operations needed to collect elements 1, 2, ..., k.\n ", "canonical_solution": "def minOperations(nums, k):\n    l = []\n    for i in range(1,k+1):\n        l.append(i)\n    c = 0\n    i = len(nums) - 1\n    while l:\n        if nums[i] in l:\n            l.remove(nums[i])\n        i -= 1\n        c += 1\n    return c", "entry_point": "minOperations", "test_list": ["assert minOperations([3,1,5,4,2],2)==4", "assert minOperations([3,1,5,4,2],5)==5", "assert minOperations([3,2,5,3,1],3)==4"]}
{"Contest id": "364/2867", "text_name": "Count Valid Paths in a Tree", "text": "There is an undirected tree with n nodes labeled from 1 to n. You are given the integer n and a 2D integer array edges of length n - 1, where edges[i] = [ui, vi] indicates that there is an edge between nodes ui and vi in the tree.\nReturn the number of valid paths in the tree.\nA path (a, b) is valid if there exists exactly one prime number among the node labels in the path from a to b.\nNote that:\nThe path (a, b) is a sequence of distinct nodes starting with node a and ending with node b such that every two adjacent nodes in the sequence share an edge in the tree.\nPath (a, b) and path (b, a) are considered the same and counted only once.", "canonical_solution": "def countPaths(n, edges):\n    def mul(x, y):\n        return x * y\n    def dfs(x, f, con, prime, r):\n        v = [1 - prime[x], prime[x]]\n        for y in con[x]:\n            if y == f:\n                continue\n            p = dfs(y, x, con, prime, r)\n            r[0] += mul(p[0], v[1]) + mul(p[1], v[0])\n            if prime[x]:\n                v[1] += p[0]\n            else:\n                v[0] += p[0]\n                v[1] += p[1]\n        return v\n    prime = [True] * (n + 1)\n    prime[1] = False\n    all_primes = []\n    for i in range(2, n + 1):\n        if prime[i]:\n            all_primes.append(i)\n        for x in all_primes:\n            temp = i * x\n            if temp > n:\n                break\n            prime[temp] = False\n            if i % x == 0:\n                break\n    con = [[] for _ in range(n + 1)]\n    for e in edges:\n        con[e[0]].append(e[1])\n        con[e[1]].append(e[0])\n    r = [0]\n    dfs(1, 0, con, prime, r)\n    return r[0]", "entry_point": "countPaths", "test_list": ["assert countPaths(5,[[1,2],[1,3],[2,4],[2,5]])==4", "assert countPaths(6,[[1,2],[1,3],[2,4],[3,5],[3,6]])==6"]}
{"Contest id": "364/2866", "text_name": "Beautiful Towers II", "text": "You are given a 0-indexed array maxHeights of n integers.\nYou are tasked with building n towers in the coordinate line. The ith tower is built at coordinate i and has a height of heights[i].\nA configuration of towers is beautiful if the following conditions hold:\n1 <= heights[i] <= maxHeights[i]\nheights is a mountain array.\nArray heights is a mountain if there exists an index i such that:\nFor all 0 < j <= i, heights[j - 1] <= heights[j]\nFor all i <= k < n - 1, heights[k + 1] <= heights[k]\nReturn the maximum possible sum of heights of a beautiful configuration of towers.", "canonical_solution": "def maximumSumOfHeights(maxHeights):\n    n = len(maxHeights)\n    left = [0] * n\n    stack = [-1]\n    cur = 0\n    for i in range(n):\n        while len(stack) > 1 and maxHeights[stack[-1]] > maxHeights[i]:\n            j = stack.pop()\n            cur -= (j - stack[-1]) * maxHeights[j]\n        cur += (i - stack[-1]) * maxHeights[i]\n        stack.append(i)\n        left[i] = cur\n    stack = [n]\n    res = cur = 0\n    for i in range(n - 1, -1, -1):\n        while len(stack) > 1 and maxHeights[stack[-1]] > maxHeights[i]:\n            j = stack.pop()\n            cur -= -(j - stack[-1]) * maxHeights[j]\n        cur += -(i - stack[-1]) * maxHeights[i]\n        stack.append(i)\n        res = max(res, left[i] + cur - maxHeights[i])\n    return res", "entry_point": "maximumSumOfHeights", "test_list": ["assert maximumSumOfHeights([5,3,4,1,1])==13", "assert maximumSumOfHeights([6,5,3,9,2,7])==22", "assert maximumSumOfHeights([3,2,5,5,2,3])==18"]}
{"Contest id": "364/2865", "text_name": "Beautiful Towers I", "text": "You are given a 0-indexed array maxHeights of n integers.\nYou are tasked with building n towers in the coordinate line. The ith tower is built at coordinate i and has a height of heights[i].\nA configuration of towers is beautiful if the following conditions hold:\n1 <= heights[i] <= maxHeights[i]\nheights is a mountain array.\nArray heights is a mountain if there exists an index i such that:\nFor all 0 < j <= i, heights[j - 1] <= heights[j]\nFor all i <= k < n - 1, heights[k + 1] <= heights[k]\nReturn the maximum possible sum of heights of a beautiful configuration of towers.", "canonical_solution": "def maximumSumOfHeights(maxHeights):\n    res = 0\n    n = len(maxHeights)\n    for i in range(n):\n        cur = v = maxHeights[i]\n        for j in range(i - 1, -1, -1):\n            v = min(v, maxHeights[j])\n            cur += v\n        v = maxHeights[i]\n        for j in range(i + 1, n):\n            v = min(v, maxHeights[j])\n            cur += v\n        res = max(res, cur)\n    return res", "entry_point": "maximumSumOfHeights", "test_list": ["assert maximumSumOfHeights([5,3,4,1,1])==13", "assert maximumSumOfHeights([6,5,3,9,2,7])==22", "assert maximumSumOfHeights([3,2,5,5,2,3])==18"]}
{"Contest id": "364/2864", "text_name": "Maximum Odd Binary Number", "text": "You are given a binary string s that contains at least one '1'.\nYou have to rearrange the bits in such a way that the resulting binary number is the maximum odd binary number that can be created from this combination.\nReturn a string representing the maximum odd binary number that can be created from the given combination.\nNote that the resulting string can have leading zeros.", "canonical_solution": "def maximumOddBinaryNumber(s):\n    ones = s.count('1')\n    return '1' * (ones - 1) + '0' * (len(s) - ones) + '1'", "entry_point": "maximumOddBinaryNumber", "test_list": ["assert maximumOddBinaryNumber(\"010\")==\"001\"", "assert maximumOddBinaryNumber(\"0101\")==\"1001\""]}
{"Contest id": "363/2862", "text_name": "Maximum Element-Sum of a Complete Subset of Indices", "text": "You are given a 1-indexed array nums of n integers.\nA set of numbers is complete if the product of every pair of its elements is a perfect square.\nFor a subset of the indices set {1, 2, ..., n} represented as {i1, i2, ..., ik}, we define its element-sum as: nums[i1] + nums[i2] + ... + nums[ik].\nReturn the maximum element-sum of a complete subset of the indices set {1, 2, ..., n}.\nA perfect square is a number that can be expressed as the product of an integer by itself.", "canonical_solution": "def maximumSum(nums):\n    import collections\n    count = collections.Counter()\n    for i in range(len(nums)):\n        x, v = i + 1, 2\n        while x >= v * v:\n            while x % (v * v) == 0:\n                x //= v * v\n            v += 1\n        count[x] += nums[i]\n    return max(count.values())", "entry_point": "maximumSum", "test_list": ["assert maximumSum([8,7,3,5,7,2,4,9])==16", "assert maximumSum([5,10,3,10,1,13,7,9,4])==19"]}
{"Contest id": "363/2861", "text_name": "Maximum Number of Alloys", "text": "You are the owner of a company that creates alloys using various types of metals. There are n different types of metals available, and you have access to k machines that can be used to create alloys. Each machine requires a specific amount of each metal type to create an alloy.\nFor the ith machine to create an alloy, it needs composition[i][j] units of metal of type j. Initially, you have stock[i] units of metal type i, and purchasing one unit of metal type i costs cost[i] coins.\nGiven integers n, k, budget, a 1-indexed 2D array composition, and 1-indexed arrays stock and cost, your goal is to maximize the number of alloys the company can create while staying within the budget of budget coins.\nAll alloys must be created with the same machine.\nReturn the maximum number of alloys that the company can create.", "canonical_solution": "def maxNumberOfAlloys(n, k, budget, composition, stock, cost):\n    def func(mid, budget, composition, stock, cost):\n        minCost = float('inf')\n        for i in range(len(composition)):\n            currCost = 0\n            for j in range(len(composition[i])):\n                curr = mid * composition[i][j]\n                if stock[j] >= curr:\n                    continue\n                else:\n                    extra = (curr - stock[j]) * cost[j]\n                    currCost += extra\n            minCost = min(currCost, minCost)\n        return minCost <= budget\n    low = 0\n    high = int(1e9)\n    ans = 0\n    while low <= high:\n        mid = low + (high - low) // 2\n        if func(mid, budget, composition, stock, cost):\n            ans = mid\n            low = mid + 1\n        else:\n            high = mid - 1\n    return ans", "entry_point": "maxNumberOfAlloys", "test_list": ["assert maxNumberOfAlloys(3,2,15,[[1,1,1],[1,1,10]],[0,0,0],[1,2,3])==2", "assert maxNumberOfAlloys(3,2,15,[[1,1,1],[1,1,10]],[0,0,100],[1,2,3])==5", "assert maxNumberOfAlloys(2,3,10,[[2,1],[1,2],[1,1]],[1,1],[5,5])==2"]}
{"Contest id": "363/2860", "text_name": "Happy Students", "text": "You are given a 0-indexed integer array nums of length n where n is the total number of students in the class. The class teacher tries to select a group of students so that all the students remain happy.\nThe ith student will become happy if one of these two conditions is met:\nThe student is selected and the total number of selected students is strictly greater than nums[i].\nThe student is not selected and the total number of selected students is strictly less than nums[i].\nReturn the number of ways to select a group of students so that everyone remains happy.", "canonical_solution": "def countWays(nums):\n        nums.sort()\n        res = int(nums[0] != 0)\n        nums.append(float('inf'))\n        for i in range(len(nums) - 1):\n            if nums[i] < i + 1 < nums[i + 1]:\n                res += 1\n        return res", "entry_point": "countWays", "test_list": ["assert countWays([1,1])==2", "assert countWays([6,0,3,3,6,7,2,7])==3"]}
{"Contest id": "363/2859", "text_name": "Sum of Values at Indices With K Set Bits", "text": "You are given a 0-indexed integer array nums and an integer k.\nReturn an integer that denotes the sum of elements in nums whose corresponding indices have exactly k set bits in their binary representation.\nThe set bits in an integer are the 1's present when it is written in binary.\nFor example, the binary representation of 21 is 10101, which has 3 set bits.", "canonical_solution": "def sumIndicesWithKSetBits(nums, k):\n    return sum(x for i, x in enumerate(nums) if bin(i).count('1') == k)", "entry_point": "sumIndicesWithKSetBits", "test_list": ["assert sumIndicesWithKSetBits([5,10,1,5,2],1)==13", "assert sumIndicesWithKSetBits([4,3,2,1],2)==1"]}
{"Contest id": "Bi113/2858", "text_name": "Minimum Edge Reversals So Every Node Is Reachable", "text": "There is a simple directed graph with n nodes labeled from 0 to n - 1. The graph would form a tree if its edges were bi-directional.\nYou are given an integer n and a 2D integer array edges, where edges[i] = [ui, vi] represents a directed edge going from node ui to node vi.\nAn edge reversal changes the direction of an edge, i.e., a directed edge going from node ui to node vi becomes a directed edge going from node vi to node ui.\nFor every node i in the range [0, n - 1], your task is to independently calculate the minimum number of edge reversals required so it is possible to reach any other node starting from node i through a sequence of directed edges.\nReturn an integer array answer, where answer[i] is the minimum number of edge reversals required so it is possible to reach any other node starting from node i through a sequence of directed edges.", "canonical_solution": "def minEdgeReversals(n, edges):\n        G = defaultdict(dict)\n        for i,j in edges:\n            G[i][j], G[j][i] = 0, 1\n        def dp(i, j):\n            return sum(dp(j, k) + G[j][k] for k in G[j] if k != i)\n        return [dp(-1, i) for i in range(n)]", "entry_point": "minEdgeReversals", "test_list": ["assert minEdgeReversals(4, [[2,0],[2,1],[1,3]])==[1,1,0,2]", "assert minEdgeReversals(3,[[1,2],[2,0]])==[2,0,1]"]}
{"Contest id": "Bi113/2857", "text_name": "Count Pairs of Points With Distance k", "text": "You are given a 2D integer array coordinates and an integer k, where coordinates[i] = [xi, yi] are the coordinates of the ith point in a 2D plane.\nWe define the distance between two points (x1, y1) and (x2, y2) as (x1 XOR x2) + (y1 XOR y2) where XOR is the bitwise XOR operation.\nReturn the number of pairs (i, j) such that i < j and the distance between points i and j is equal to k.", "canonical_solution": "from collections import Counter\ndef countPairs(coordinates, k):\n        count = Counter()\n        res = 0\n        for x1, y1 in coordinates:\n            for x in range(k + 1):\n                res += count[x1 ^ x, y1 ^ (k - x)]\n            count[x1, y1] += 1\n        return res", "entry_point": "countPairs", "test_list": ["assert countPairs([[1,2],[4,2],[1,3],[5,2]],5)==2", "assert countPairs([[1,3],[1,3],[1,3],[1,3],[1,3]],0)==10"]}
{"Contest id": "Bi113/2856", "text_name": "Minimum Array Length After Pair Removals", "text": "You are given a 0-indexed sorted array of integers nums.\nYou can perform the following operation any number of times:\nChoose two indices, i and j, where i < j, such that nums[i] < nums[j].\nThen, remove the elements at indices i and j from nums. The remaining elements retain their original order, and the array is re-indexed.\nReturn an integer that denotes the minimum length of nums after performing the operation any number of times (including zero).\nNote that nums is sorted in non-decreasing order.", "canonical_solution": "def minLengthAfterRemovals(nums):\n        import heapq\n        from collections import Counter\n        counts = [-x for x in Counter(nums).values()]\n        heapq.heapify(counts)\n        while len(counts) > 1:\n            a = -heapq.heappop(counts)\n            b = -heapq.heappop(counts)\n            if a > 1:\n                heapq.heappush(counts, -a + 1)\n            if b > 1:\n                heapq.heappush(counts, -b + 1)\n        return -sum(counts)", "entry_point": "minLengthAfterRemovals", "test_list": ["assert minLengthAfterRemovals([1,3,4,9])==0", "assert minLengthAfterRemovals([2,3,6,9])==0", "assert minLengthAfterRemovals([1,1,2])==1"]}
{"Contest id": "Bi113/2855", "text_name": "Minimum Right Shifts to Sort the Array", "text": "You are given a 0-indexed array nums of length n containing distinct positive integers. Return the minimum number of right shifts required to sort nums and -1 if this is not possible.\nA right shift is defined as shifting the element at index i to index (i + 1) % n, for all indices.", "canonical_solution": "def minimumRightShifts(nums):\n    sorted_nums = sorted(nums)\n    result = 0\n    while result < len(nums):\n        if nums == sorted_nums:\n            return result\n        result = result + 1\n        last_element = nums.pop()\n        nums.insert(0, last_element)\n        return -1", "entry_point": "minimumRightShifts", "test_list": ["assert minimumRightShifts([3,4,5,1,2])==2", "assert minimumRightShifts([1,3,5])==0", "assert minimumRightShifts([2,1,4])==-1"]}
{"Contest id": "362/2850", "text_name": "Minimum Moves to Spread Stones Over Grid", "text": "You are given a 0-indexed 2D integer matrix grid of size 3 * 3, representing the number of stones in each cell. The grid contains exactly 9 stones, and there can be multiple stones in a single cell.\nIn one move, you can move a single stone from its current cell to any other cell if the two cells share a side.\nReturn the minimum number of moves required to place one stone in each cell.", "canonical_solution": "def minimumMoves(grid):\n        def f(z, o, ind):\n            n = len(z)\n            if ind == n:\n                return 0\n            ans = float('inf')\n            for j in range(len(o)):\n                curZ = z[ind]\n                curO = o[j]\n                cur = abs(curZ[0] - curO[0]) + abs(curZ[1] - curO[1])\n                o[j] = (-1, -1)\n                ans = min(ans, cur + f(z, o, ind + 1))\n                o[j] = curO\n            return ans\n        if grid[0][0] == 9 or grid[0][2] == 9 or grid[2][0] == 9 or grid[2][2] == 9:\n            return 18\n        if grid[0][1] == 9 or grid[1][0] == 9 or grid[1][2] == 9 or grid[2][1] == 9:\n            return 15\n        if grid[1][1] == 9:\n            return 12\n        z = []\n        o = []\n        for i in range(3):\n            for j in range(3):\n                if grid[i][j] == 0:\n                    z.append((i, j))\n                while grid[i][j] > 1:\n                    grid[i][j] -= 1\n                    o.append((i, j))\n        return f(z, o, 0)", "entry_point": "minimumMoves", "test_list": ["assert minimumMoves([[1,1,0],[1,1,1],[1,2,1]])==3", "assert minimumMoves([[1,3,0],[1,0,0],[1,0,3]])==4"]}
{"Contest id": "362/2849", "text_name": "Determine if a Cell Is Reachable at a Given Time", "text": "You are given four integers sx, sy, fx, fy, and a non-negative integer t.\nIn an infinite 2D grid, you start at the cell (sx, sy). Each second, you must move to any of its adjacent cells.\nReturn true if you can reach cell (fx, fy) after exactly t seconds, or false otherwise.\nA cell's adjacent cells are the 8 cells around it that share at least one corner with it. You can visit the same cell several times.", "canonical_solution": "def isReachableAtTime(sx, sy, fx, fy, t):\n        if sx == fx and sy == fy:\n            return t > 1 or t == 0\n        height_difference = abs(sy - fy)\n        width_difference = abs(sx - fx)\n        extra_time = abs(height_difference - width_difference)\n        return (min(height_difference, width_difference) + extra_time) <= t", "entry_point": "isReachableAtTime", "test_list": ["assert isReachableAtTime(2,4,7,7,6)==True", "assert isReachableAtTime(3,1,7,3,3)==False"]}
{"Contest id": "362/2848", "text_name": "Points That Intersect With Cars", "text": "You are given a 0-indexed 2D integer array nums representing the coordinates of the cars parking on a number line. For any index i, nums[i] = [starti, endi] where starti is the starting point of the ith car and endi is the ending point of the ith car.\nReturn the number of integer points on the line that are covered with any part of a car.", "canonical_solution": "def numberOfPoints(nums):\n        return len(set(j for i in nums for j in range(i[0], i[1] + 1)))", "entry_point": "numberOfPoints", "test_list": ["assert numberOfPoints([[3,6],[1,5],[4,7]])==7", "assert numberOfPoints([[1,3],[5,8]])==7"]}
{"Contest id": "361/2846", "text_name": "Minimum Edge Weight Equilibrium Queries in a Tree", "text": "There is an undirected tree with n nodes labeled from 0 to n - 1. You are given the integer n and a 2D integer array edges of length n - 1, where edges[i] = [ui, vi, wi] indicates that there is an edge between nodes ui and vi with weight wi in the tree.\nYou are also given a 2D integer array queries of length m, where queries[i] = [ai, bi]. For each query, find the minimum number of operations required to make the weight of every edge on the path from ai to bi equal. In one operation, you can choose any edge of the tree and change its weight to any value.\nNote that:\nQueries are independent of each other, meaning that the tree returns to its initial state on each new query.\nThe path from ai to bi is a sequence of distinct nodes starting with node ai and ending with node bi such that every two adjacent nodes in the sequence share an edge in the tree.\nReturn an array answer of length m where answer[i] is the answer to the ith query.", "canonical_solution": "def minOperationsQueries(n, edges, queries):\n        def dfs(x, p, b, e, f, t, all, w):\n            all[x] = w[:]\n            f[x][0] = p\n            b[x] = t[0] = t[0] + 1\n            for v in con[x]:\n                if v[0] != p:\n                    w[v[1]] += 1\n                    dfs(v[0], x, b, e, f, t, all, w)\n                    w[v[1]] -= 1\n            e[x] = t[0]\n        def isAncestor(b, e, x, y):\n            return b[x] <= b[y] and e[x] >= e[y]\n        def lca(f, b, e, x, y):\n            if isAncestor(b, e, x, y):\n                return x\n            if isAncestor(b, e, y, x):\n                return y\n            r = 0\n            for i in range(19, -1, -1):\n                temp = f[x][i]\n                if isAncestor(b, e, temp, y):\n                    r = temp\n                else:\n                    x = temp\n            return r\n        con = [[] for _ in range(n)]\n        for e in edges:\n            con[e[0]].append((e[1], e[2] - 1))\n            con[e[1]].append((e[0], e[2] - 1))\n        all = [[0] * 26 for _ in range(n)]\n        f = [[0] * 20 for _ in range(n)]\n        b = [0] * n\n        e = [0] * n\n        w = [0] * 26\n        t = [0]\n        dfs(0, -1, b, e, f, t, all, w)\n        f[0][0] = 0\n        for i in range(1, 20):\n            for j in range(n):\n                f[j][i] = f[f[j][i - 1]][i - 1]\n        result = []\n        for q in queries:\n            if q[0] == q[1]:\n                result.append(0)\n                continue\n            tLca = lca(f, b, e, q[0], q[1])\n            _sum, m = 0, 0\n            for i in range(26):\n                temp = all[q[0]][i] + all[q[1]][i] - (all[tLca][i] << 1)\n                _sum += temp\n                m = max(m, temp)\n            result.append(_sum - m)\n        return result", "entry_point": "minOperationsQueries", "test_list": ["assert minOperationsQueries(7,[[0,1,1],[1,2,1],[2,3,1],[3,4,2],[4,5,2],[5,6,2]],[[0,3],[3,6],[2,6],[0,6]])==[0,0,1,3]", "assert minOperationsQueries(8,[[1,2,6],[1,3,4],[2,4,6],[2,5,3],[3,6,6],[3,0,8],[7,0,2]],[[4,6],[0,4],[6,5],[7,4]])==[1,2,2,3]"]}
{"Contest id": "361/2845", "text_name": "Count of Interesting Subarrays", "text": "You are given a 0-indexed integer array nums, an integer modulo, and an integer k.\nYour task is to find the count of subarrays that are interesting.\nA subarray nums[l..r] is interesting if the following condition holds:\nLet cnt be the number of indices i in the range [l, r] such that nums[i] % modulo == k. Then, cnt % modulo == k.\nReturn an integer denoting the count of interesting subarrays.\nNote: A subarray is a contiguous non-empty sequence of elements within an array.", "canonical_solution": "def countInterestingSubarrays(nums, mod, k):\n        res = acc = 0\n        count = Counter({0: 1})\n        for a in nums:\n            acc = (acc + (1 if a % mod == k else 0)) % mod\n            res += count[(acc - k) % mod]\n            count[acc] += 1\n        return res", "entry_point": "countInterestingSubarrays", "test_list": ["assert countInterestingSubarrays([3,2,4],2,1)==3", "assert countInterestingSubarrays([3,1,9,6],3,0)==2"]}
{"Contest id": "361/2844", "text_name": "Minimum Operations to Make a Special Number", "text": "You are given a 0-indexed string num representing a non-negative integer.\nIn one operation, you can pick any digit of num and delete it. Note that if you delete all the digits of num, num becomes 0.\nReturn the minimum number of operations required to make num special.\nAn integer x is considered special if it is divisible by 25.", "canonical_solution": "def minimumOperations(num):\n        min_count, count = len(num), 0\n        if num.endswith(('00', '25', '50', '75')):\n            return 0\n        for i in range(len(num) - 1, -1, -1):\n            if num[i] == '0':\n                if len(num) == 2:\n                    return 1\n                five_idx = [match.start() for match in re.finditer('5', num[:i][::-1])]\n                zero_idx = [match.start() for match in re.finditer('0', num[:i][::-1])]\n                count = min(min(five_idx) if five_idx else len(num), min(zero_idx) if zero_idx else len(num))\n                min_count = min(min_count, len(num) - 1 - i + count)  \n            elif num[i] == '5':\n                two_idx = [match.start() for match in re.finditer('2', num[:i][::-1])]\n                seven_idx = [match.start() for match in re.finditer('7', num[:i][::-1])]\n                \n                count = min(min(two_idx) if two_idx else len(num), min(seven_idx) if seven_idx else len(num))\n                min_count = min(min_count, len(num) - 1 - i + count)\n        return min_count - num.count('0') if min_count == len(num) and '0' in num else min_count", "entry_point": "minimumOperations", "test_list": ["assert minimumOperations(\"2245047\")==2", "assert minimumOperations(\"2908305\")==3", "assert minimumOperations(\"10\")==1"]}
{"Contest id": "361/2843", "text_name": "Count Symmetric Integers", "text": "You are given two positive integers low and high.\nAn integer x consisting of 2 * n digits is symmetric if the sum of the first n digits of x is equal to the sum of the last n digits of x. Numbers with an odd number of digits are never symmetric.\nReturn the number of symmetric integers in the range [low, high].", "canonical_solution": "def countSymmetricIntegers(l, h):\n        ans = 0\n        for i in range(l, h + 1):\n            c = 0\n            j = i\n            while j > 0:\n                c += 1\n                j = j // 10\n            if c % 2 != 0:\n                continue\n            j = i\n            s = 0\n            a = 0\n            b = 0\n            while s < (c // 2):\n                a += j % 10\n                j = j // 10\n                s += 1\n            while s < c:\n                b += j % 10\n                j = j // 10\n                s += 1\n            if a == b:\n                ans += 1\n        return ans", "entry_point": "countSymmetricIntegers", "test_list": ["assert countSymmetricIntegers(1,100)==9", "assert countSymmetricIntegers(1200,1230)==4"]}
{"Contest id": "Bi112/2842", "text_name": "Count K-Subsequences of a String With Maximum Beauty", "text": "You are given a string s and an integer k.\nA k-subsequence is a subsequence of s, having length k, and all its characters are unique, i.e., every character occurs once.\nLet f(c) denote the number of times the character c occurs in s.\nThe beauty of a k-subsequence is the sum of f(c) for every character c in the k-subsequence.\nFor example, consider s = \"abbbdd\" and k = 2:\nf('a') = 1, f('b') = 3, f('d') = 2\nSome k-subsequences of s are:\n\"abbbdd\" -> \"ab\" having a beauty of f('a') + f('b') = 4\n\"abbbdd\" -> \"ad\" having a beauty of f('a') + f('d') = 3\n\"abbbdd\" -> \"bd\" having a beauty of f('b') + f('d') = 5\nReturn an integer denoting the number of k-subsequences whose beauty is the maximum among all k-subsequences. Since the answer may be too large, return it modulo 109 + 7.\nA subsequence of a string is a new string formed from the original string by deleting some (possibly none) of the characters without disturbing the relative positions of the remaining characters.\nNotes\nf(c) is the number of times a character c occurs in s, not a k-subsequence.\nTwo k-subsequences are considered different if one is formed by an index that is not present in the other. So, two k-subsequences may form the same string.", "canonical_solution": "def countKSubsequencesWithMaxBeauty(s, k):\n        from scipy.special import comb\n        from collections import Counter\n        mod = 10**9 + 7\n        counter = Counter(s)\n        if len(counter) < k: return 0\n        freq = Counter(counter.values())\n        pairs = list(sorted(freq.items(), reverse=True))\n        res = 1\n        for fc, occ in pairs:\n            if occ <= k:\n                res = (res * pow(fc, occ, mod)) % mod\n                k -= occ\n            else:\n                res = (res * comb(occ, k) * pow(fc, k, mod)) % mod\n                break\n        return res % mod", "entry_point": "countKSubsequencesWithMaxBeauty", "test_list": ["assert countKSubsequencesWithMaxBeauty(\"bcca\",2)==4", "assert countKSubsequencesWithMaxBeauty(\"abbcd\",4)==2"]}
{"Contest id": "Bi112/2841", "text_name": "Maximum Sum of Almost Unique Subarray", "text": "You are given an integer array nums and two positive integers m and k.\nReturn the maximum sum out of all almost unique subarrays of length k of nums. If no such subarray exists, return 0.\nA subarray of nums is almost unique if it contains at least m distinct elements.\nA subarray is a contiguous non-empty sequence of elements within an array.", "canonical_solution": "def maxSum(nums, m, k):\n                result = 0\n                sub_array = nums[:k-1]\n                for index in range(k-1 , len(nums)):\n                        sub_array.append(nums[index])\n                        if len(set(sub_array)) >= m:\n                                result = max(result , sum(sub_array))\n                        sub_array.pop(0)\n                return result", "entry_point": "maxSum", "test_list": ["assert maxSum([2,6,7,3,1,7],3,4)==18", "assert maxSum([5,9,9,2,4,5,4],1,3)==23", "assert maxSum([1,2,1,2,1,2,1],3,3)==0"]}
{"Contest id": "Bi112/2840", "text_name": "Check if Strings Can be Made Equal With Operations II", "text": "You are given two strings s1 and s2, both of length n, consisting of lowercase English letters.\nYou can apply the following operation on any of the two strings any number of times:\nChoose any two indices i and j such that i < j and the difference j - i is even, then swap the two characters at those indices in the string.\nReturn true if you can make the strings s1 and s2 equal, and false otherwise.", "canonical_solution": "def checkStrings(s1, s2):\n        n = len(s1)\n        if len(s2) != n:\n            return False\n        d2 = {}\n        for i in range(n):\n            if s2[i] in d2:\n                d2[s2[i]][i&1] += 1\n            else:\n                d2[s2[i]] = [0, 0]\n                d2[s2[i]][i&1] += 1\n        for i in range(n):\n            if s1[i] not in d2:\n                return False\n            d2[s1[i]][i&1] -= 1\n            if d2[s1[i]][i&1] < 0:\n                return False\n            elif d2[s1[i]] == [0, 0]:\n                del d2[s1[i]]\n        return True", "entry_point": "checkStrings", "test_list": ["assert checkStrings(\"abcdba\",\"cabdab\")==True", "assert checkStrings(\"abe\",\"bea\")==False"]}
{"Contest id": "Bi112/2839", "text_name": "Check if Strings Can be Made Equal With Operations I", "text": "You are given two strings s1 and s2, both of length 4, consisting of lowercase English letters.\nYou can apply the following operation on any of the two strings any number of times:\nChoose any two indices i and j such that j - i = 2, then swap the two characters at those indices in the string.\nReturn true if you can make the strings s1 and s2 equal, and false otherwise.", "canonical_solution": "def canBeEqual(s1, s2):\n                if s1 == s2:\n                        return True\n                s3 = list(s1)\n                s3[0] , s3[2] = s3[2], s3[0]\n                s5 = s3\n                s3 = ''.join(s3)\n                if s3 == s2:\n                        return True\n                s4 = list(s1)\n                s4[1] , s4[3] = s4[3], s4[1]\n                s4 = ''.join(s4)\n                if s4 == s2:\n                        return True\n                s5[1] , s5[3] = s5[3], s5[1]\n                s5 = ''.join(s5)\n                if s5 == s2:\n                        return True\n                return False", "entry_point": "canBeEqual", "test_list": ["assert canBeEqual(\"abcd\",\"cdab\")==True", "assert canBeEqual(\"abcd\",\"dacb\")==False"]}
{"Contest id": "360/2836", "text_name": "Maximize Value of Function in a Ball Passing Game", "text": "You are given a 0-indexed integer array receiver of length n and an integer k.\nThere are n players having a unique id in the range [0, n - 1] who will play a ball passing game, and receiver[i] is the id of the player who receives passes from the player with id i. Players can pass to themselves, i.e. receiver[i] may be equal to i.\nYou must choose one of the n players as the starting player for the game, and the ball will be passed exactly k times starting from the chosen player.\nFor a chosen starting player having id x, we define a function f(x) that denotes the sum of x and the ids of all players who receive the ball during the k passes, including repetitions. In other words, f(x) = x + receiver[x] + receiver[receiver[x]] + ... + receiver(k)[x].\nYour task is to choose a starting player having id x that maximizes the value of f(x).\nReturn an integer denoting the maximum value of the function.\nNote: receiver may contain duplicates.", "canonical_solution": "def getMaxFunctionValue(receiver, k):\n        n = len(receiver)\n        parent, pathSum = [[0] * 35 for _ in range(n)], [[0] * 35 for _ in range(n)]\n        for start in range(n):\n            parent[start][0] = pathSum[start][0] = receiver[start]\n        for power in range(1, 35):\n            for start in range(n):\n                parent[start][power] = parent[parent[start][power - 1]][power - 1]\n                pathSum[start][power] = pathSum[start][power - 1] + pathSum[parent[start][power - 1]][power - 1]\n        res = 0\n        for start in range(n):\n            i = start\n            runningSum = 0\n            for power in range(35):\n                if k & (1 << power) != 0:\n                    runningSum += pathSum[i][power]\n                    i = parent[i][power]\n            res = max(start + runningSum, res)\n        return res", "entry_point": "getMaxFunctionValue", "test_list": ["assert getMaxFunctionValue([2,0,1],4)==6", "assert getMaxFunctionValue([1,1,1,2,3],3)==10"]}
{"Contest id": "360/2835", "text_name": "Minimum Operations to Form Subsequence With Target Sum", "text": "You are given a 0-indexed array nums consisting of non-negative powers of 2, and an integer target.\nIn one operation, you must apply the following changes to the array:\nChoose any element of the array nums[i] such that nums[i] > 1.\nRemove nums[i] from the array.\nAdd two occurrences of nums[i] / 2 to the end of nums.\nReturn the minimum number of operations you need to perform so that nums contains a subsequence whose elements sum to target. If it is impossible to obtain such a subsequence, return -1.\nA subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.", "canonical_solution": "def minOperations(nums, target):\n        tot = sum(nums)\n        if tot < target:\n            return -1\n        nums.sort()\n        res = 0\n        while target:\n            a = nums.pop()\n            if tot - a >= target:\n                tot -= a\n            elif a <= target:\n                tot -= a\n                target -= a\n            else:\n                nums.append(a // 2)\n                nums.append(a // 2)\n                res += 1\n        return res", "entry_point": "minOperations", "test_list": ["assert minOperations([1,2,8],7)==1", "assert minOperations([1,32,1,2],12)==2", "assert minOperations([1,32,1],35)==-1"]}
{"Contest id": "360/2834", "text_name": "Find the Minimum Possible Sum of a Beautiful Array", "text": "You are given positive integers n and target.\nAn array nums is beautiful if it meets the following conditions:\nnums.length == n.\nnums consists of pairwise distinct positive integers.\nThere doesn't exist two distinct indices, i and j, in the range [0, n - 1], such that nums[i] + nums[j] == target.\nReturn the minimum possible sum that a beautiful array could have modulo 10^9 + 7.", "canonical_solution": "def minimumPossibleSum(n, target):\n        k = target // 2\n        if n <= k:\n            return n * (n + 1) // 2\n        return k * (k + 1) // 2 + (target + target + n - k - 1) * (n - k) // 2", "entry_point": "minimumPossibleSum", "test_list": ["assert minimumPossibleSum(2,3)==4", "assert minimumPossibleSum(3,3)==8", "assert minimumPossibleSum(1,1)==1"]}
{"Contest id": "360/2833", "text_name": "Furthest Point From Origin", "text": "You are given a string moves of length n consisting only of characters 'L', 'R', and '_'. The string represents your movement on a number line starting from the origin 0.\nIn the ith move, you can choose one of the following directions:\nmove to the left if moves[i] = 'L' or moves[i] = '_'\nmove to the right if moves[i] = 'R' or moves[i] = '_'\nReturn the distance from the origin of the furthest point you can get to after n moves.", "canonical_solution": "def furthestDistanceFromOrigin(moves):\n        return abs(moves.count('R') - moves.count('L')) + moves.count('_')", "entry_point": "furthestDistanceFromOrigin", "test_list": ["assert furthestDistanceFromOrigin(\"L_RL__R\")==3", "assert furthestDistanceFromOrigin(\"_R__LL_\")==5", "assert furthestDistanceFromOrigin(\"_______\")==7"]}
{"Contest id": "359/2831", "text_name": "Find the Longest Equal Subarray", "text": "You are given a 0-indexed integer array nums and an integer k.\nA subarray is called equal if all of its elements are equal. Note that the empty subarray is an equal subarray.\nReturn the length of the longest possible equal subarray after deleting at most k elements from nums.\nA subarray is a contiguous, possibly empty sequence of elements within an array.", "canonical_solution": "def longestEqualSubarray(nums, k):\n        maxf = i = 0\n        count = Counter()\n        for j in range(len(nums)):\n            count[nums[j]] += 1\n            maxf = max(maxf, count[nums[j]])\n            if j - i + 1 - maxf > k:\n                count[nums[i]] -= 1\n                i += 1\n        return maxf", "entry_point": "longestEqualSubarray", "test_list": ["assert longestEqualSubarray([1,3,2,3,1,3],3)==3", "assert longestEqualSubarray([1,1,2,2,1,1],2)==4"]}
{"Contest id": "359/2830", "text_name": "Maximize the Profit as the Salesman", "text": "You are given an integer n representing the number of houses on a number line, numbered from 0 to n - 1.\nAdditionally, you are given a 2D integer array offers where offers[i] = [starti, endi, goldi], indicating that ith buyer wants to buy all the houses from starti to endi for goldi amount of gold.\nAs a salesman, your goal is to maximize your earnings by strategically selecting and selling houses to buyers.\nReturn the maximum amount of gold you can earn.\nNote that different buyers can't buy the same house, and some houses may remain unsold.", "canonical_solution": "def maximizeTheProfit(n, offers):\n        dp = [0] * (n + 1)\n        m = [[] for _ in range(n)]\n        for s,e,g in offers:\n            m[e].append([s,g])\n        for e in range(1, n + 1):\n            dp[e] = dp[e - 1]\n            for s, g in m[e - 1]:\n                dp[e] = max(dp[e], dp[s] + g)\n        return dp[-1]", "entry_point": "maximizeTheProfit", "test_list": ["assert maximizeTheProfit(5,[[0,0,1],[0,2,2],[1,3,2]])==3", "assert maximizeTheProfit(5,[[0,0,1],[0,2,10],[1,3,2]])==10"]}
{"Contest id": "359/2829", "text_name": "Determine the Minimum Sum of a k-avoiding Array", "text": "You are given two integers, n and k.\nAn array of distinct positive integers is called a k-avoiding array if there does not exist any pair of distinct elements that sum to k.\nReturn the minimum possible sum of a k-avoiding array of length n.", "canonical_solution": "def minimumSum(n, k):\n        a = min(k // 2, n)\n        b = n - a\n        return (1 + a) * a // 2 + (k + k + b - 1) * b // 2", "entry_point": "minimumSum", "test_list": ["assert minimumSum(5,4)==18", "assert minimumSum(2,6)==3"]}
{"Contest id": "359/2828", "text_name": "Check if a String Is an Acronym of Words", "text": "Given an array of strings words and a string s, determine if s is an acronym of words.\nThe string s is considered an acronym of words if it can be formed by concatenating the first character of each string in words in order. For example, \"ab\" can be formed from [\"apple\", \"banana\"], but it can't be formed from [\"bear\", \"aardvark\"].\nReturn true if s is an acronym of words, and false otherwise.", "canonical_solution": "def isAcronym(words, s):\n        ans=\"\"\n        for word in words:\n            ans+=word[0]\n        return ans==s  \n        ", "entry_point": "isAcronym", "test_list": ["assert isAcronym([\"alice\",\"bob\",\"charlie\"],\"abc\")==True", "assert isAcronym([\"an\",\"apple\"],\"a\")==False", "assert isAcronym([\"never\",\"gonna\",\"give\",\"up\",\"on\",\"you\"],\"ngguoy\")==True"]}
{"Contest id": "Bi111/2827", "text_name": "Number of Beautiful Integers in the Range", "text": "You are given positive integers low, high, and k.\nA number is beautiful if it meets both of the following conditions:\nThe count of even digits in the number is equal to the count of odd digits.\nThe number is divisible by k.\nReturn the number of beautiful integers in the range [low, high].", "canonical_solution": "def numberOfBeautifulIntegers(low, high, k):\n        def dp(i, diff, is_limit, is_zero, s, m):\n            if i == len(s):\n                return int(is_zero) & (diff == 0) & (m == 0)\n            res = 0\n            if not is_zero:\n                res = dp(i + 1, diff, False, False, s, m)\n            bound = int(s[i]) if is_limit else 9\n            for d in range(1 - int(is_zero), bound + 1):\n                if d & 1:\n                    res += dp(i + 1, diff + 1, is_limit and d == bound, True, s, (m + d * 10 ** (len(s) - i - 1)) % k)\n                else:\n                    res += dp(i + 1, diff - 1, is_limit and d == bound, True, s, (m + d * 10 ** (len(s) - i - 1)) % k)\n            return res\n        return dp(0, 0, True, False, str(high), 0) - dp(0, 0, True, False, str(low - 1), 0)", "entry_point": "numberOfBeautifulIntegers", "test_list": ["assert numberOfBeautifulIntegers(10,20,3)==2", "assert numberOfBeautifulIntegers(1,10,1)==1", "assert numberOfBeautifulIntegers(5,5,2)==0"]}
{"Contest id": "Bi111/2826", "text_name": "Sorting Three Groups", "text": "You are given a 0-indexed integer array nums of length n.\nThe numbers from 0 to n - 1 are divided into three groups numbered from 1 to 3, where number i belongs to group nums[i]. Notice that some groups may be empty.\nYou are allowed to perform this operation any number of times:\nPick number x and change its group. More formally, change nums[x] to any number from 1 to 3.\nA new array res is constructed using the following procedure:\nSort the numbers in each group independently.\nAppend the elements of groups 1, 2, and 3 to res in this order.\nArray nums is called a beautiful array if the constructed array res is sorted in non-decreasing order.\nReturn the minimum number of operations to make nums a beautiful array.", "canonical_solution": "def minimumOperations(nums):\n        a, b, c = 0, 0, 0\n        for x in nums:\n            a += x != 1\n            b = min(a, b + (x != 2))\n            c = min(b, c + (x != 3))\n        return c", "entry_point": "minimumOperations", "test_list": ["assert minimumOperations([2,1,3,2,1])==3", "assert minimumOperations([1,3,2,1,3,3])==2", "assert minimumOperations([2,2,2,2,3,3])==0"]}
{"Contest id": "Bi111/2825", "text_name": "Make String a Subsequence Using Cyclic Increments", "text": "You are given two 0-indexed strings str1 and str2.\nIn an operation, you select a set of indices in str1, and for each index i in the set, increment str1[i] to the next character cyclically. That is 'a' becomes 'b', 'b' becomes 'c', and so on, and 'z' becomes 'a'.\nReturn true if it is possible to make str2 a subsequence of str1 by performing the operation at most once, and false otherwise.\nNote: A subsequence of a string is a new string that is formed from the original string by deleting some (possibly none) of the characters without disturbing the relative positions of the remaining characters.", "canonical_solution": "def canMakeSubsequence(str1, str2):\n        j, n, m = 0, len(str1), len(str2)\n        for i in range(n):\n            if j < m and (ord(str2[j]) - ord(str1[i])) % 26 <= 1:\n                j += 1\n        return j == m", "entry_point": "canMakeSubsequence", "test_list": ["assert canMakeSubsequence(\"abc\",\"ad\")==True", "assert canMakeSubsequence(\"zc\",\"ad\")==True", "assert canMakeSubsequence(\"ab\",\"d\")==False"]}
{"Contest id": "Bi111/2824", "text_name": "Count Pairs Whose Sum is Less than Target", "text": "Given a 0-indexed integer array nums of length n and an integer target, return the number of pairs (i, j) where 0 <= i < j < n and nums[i] + nums[j] < target.", "canonical_solution": "def countPairs(nums, target):\n        nums.sort()\n        count = 0\n        left = 0\n        right = len(nums)-1\n        while(left < right):\n            if(nums[left] + nums[right] < target):\n                count += right-left\n                left += 1\n            else:\n                right -= 1\n        return count", "entry_point": "countPairs", "test_list": ["assert countPairs([-1,1,2,3,1],2)==3", "assert countPairs([-6,2,5,-2,-7,-1,3],-2)==10"]}
{"Contest id": "358/2818", "text_name": "Apply Operations to Maximize Score", "text": "You are given an array nums of n positive integers and an integer k.\nInitially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:\nChoose any non-empty subarray nums[l, ..., r] that you haven't chosen previously.\nChoose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.\nMultiply your score by x.\nHere, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.\nThe prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.\nReturn the maximum possible score after applying at most k operations.\nSince the answer may be large, return it modulo 10^9 + 7.", "canonical_solution": "def maximumScore(nums, k):\n        def isqrt(n):\n            x = n\n            y = (x + 1) // 2\n            while y < x:\n                x = y\n                y = (x + n // x) // 2\n            return x\n        def getPrimeFactors(n):\n            res = set()\n            for i in range(2, isqrt(n) + 1):\n                while n % i == 0:\n                    res.add(i)\n                    n //= i\n            if n > 1: res.add(n)\n            return len(res)\n        arr = [getPrimeFactors(i) for i in nums]\n        f = [len(arr) - i - 1 for i in range(len(arr))]\n        st = []\n        for i in range(len(arr)):\n            while st and arr[st[-1]] < arr[i]:\n                t = st.pop()\n                f[t] = i - t - 1\n            st.append(i)\n        b = [len(arr) - i - 1 for i in range(len(arr) - 1, -1, -1)]\n        st = []\n        for i in range(len(arr) - 1, -1, -1):\n            while st and arr[st[-1]] <= arr[i]:\n                t = st.pop()\n                b[t] = t - i - 1\n            st.append(i)\n        hp = []\n        for i in range(len(arr)):\n            t1 = f[i] + 1\n            t2 = b[i] + 1\n            hp.append( (t1 * t2, nums[i]) )\n        hp.sort(key = lambda x: (-x[1], -x[0]))\n        res = 1\n        mod = pow(10, 9) + 7\n        for i, j in hp:\n            t = min(i, k)\n            k -= t\n            res = (res * pow(j, t, mod)) % mod\n            if k == 0:\n                break \n        return res", "entry_point": "maximumScore", "test_list": ["assert maximumScore([8,3,9,3,8],2)==81", "assert maximumScore([19,12,14,6,10,18],3)==4788"]}
{"Contest id": "358/2817", "text_name": "Minimum Absolute Difference Between Elements With Constraint", "text": "You are given a 0-indexed integer array nums and an integer x.\nFind the minimum absolute difference between two elements in the array that are at least x indices apart.\nIn other words, find two indices i and j such that abs(i - j) >= x and abs(nums[i] - nums[j]) is minimized.\nReturn an integer denoting the minimum absolute difference between two elements that are at least x indices apart.", "canonical_solution": "import heapq\ndef minAbsoluteDifference(nums, x):\n        sortedNums = sorted((nums[i], i) for i in range(len(nums)))\n        heapLeft, heapRight = [], []\n        minDiff = float('inf')\n\n        for i in range(len(sortedNums)):\n            val, index = sortedNums[i]\n            heapq.heappush(heapLeft, (index, val)) \n            heapq.heappush(heapRight, (-index, val)) \n \n            while heapLeft and heapLeft[0][0] + x <= index:\n                minDiff = min(minDiff, val - heapq.heappop(heapLeft)[1])\n            while heapRight and heapRight[0][0] + x <= -index: \n                minDiff = min(minDiff, val - heapq.heappop(heapRight)[1])\n         \n        return minDiff", "entry_point": "minAbsoluteDifference", "test_list": ["assert minAbsoluteDifference([4,3,2,4],2)==0", "assert minAbsoluteDifference([5,3,2,10,15],1)==1", "assert minAbsoluteDifference([1,2,3,4],3)==3"]}
{"Contest id": "358/2815", "text_name": "Max Pair Sum in an Array", "text": "You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.\nReturn the maximum sum or -1 if no such pair exists.", "canonical_solution": "def maxSum(nums):\n        max_by_digit = defaultdict(int)\n        max_sum = -1\n        for num in nums:\n            digit = max(str(num))\n            if digit in max_by_digit:\n                max_sum = max(max_sum, max_by_digit[digit] + num)\n            max_by_digit[digit] = max(max_by_digit[digit], num)\n        return max_sum", "entry_point": "maxSum", "test_list": ["assert maxSum([51,71,17,24,42])==88", "assert maxSum([1,2,3,4])==-1"]}
{"Contest id": "357/2813", "text_name": "Maximum Elegance of a K-Length Subsequence\n", "text": "You are given a 0-indexed 2D integer array items of length n and an integer k.\nitems[i] = [profiti, categoryi], where profiti and categoryi denote the profit and category of the ith item respectively.\nLet's define the elegance of a subsequence of items as total_profit + distinct_categories2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.\nYour task is to find the maximum elegance from all subsequences of size k in items.\nReturn an integer denoting the maximum elegance of a subsequence of items with size exactly k.\nNote: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order.", "canonical_solution": "def findMaximumElegance(items, k):\n    items = sorted(items, key=lambda v: -v[0])\n    res = cur = 0\n    A = []\n    seen = set()\n    for i, (p, c) in enumerate(items):\n        if i < k:\n            if c in seen:\n                A.append(p)\n            cur += p\n        elif c not in seen:\n            if not A:\n                break\n            cur += p - A.pop()\n        seen.add(c)\n        res = max(res, cur + len(seen) * len(seen))\n    return res", "entry_point": "findMaximumElegance", "test_list": ["assert findMaximumElegance(items = [[3,2],[5,1],[10,1]], k = 2) == 17", "assert findMaximumElegance(items = [[3,1],[3,1],[2,2],[5,3]], k = 3) == 19", "assert findMaximumElegance(items = [[1,1],[2,1],[3,1]], k = 3) == 7"]}
{"Contest id": "357/2812", "text_name": "Find the Safest Path in a Grid", "text": "You are given a 0-indexed 2D matrix grid of size n x n, where (r, c) represents:\nA cell containing a thief if grid[r][c] = 1\nAn empty cell if grid[r][c] = 0\nYou are initially positioned at cell (0, 0). In one move, you can move to any adjacent cell in the grid, including cells containing thieves.\nThe safeness factor of a path on the grid is defined as the minimum manhattan distance from any cell in the path to any thief in the grid.\nReturn the maximum safeness factor of all paths leading to cell (n - 1, n - 1).\nAn adjacent cell of cell (r, c), is one of the cells (r, c + 1), (r, c - 1), (r + 1, c) and (r - 1, c) if it exists.\nThe Manhattan distance between two cells (a, b) and (x, y) is equal to |a - x| + |b - y|, where |val| denotes the absolute value of val.", "canonical_solution": "def maximumSafenessFactor(grid):\n    n = len(grid)\n    q = []\n    dis = [[-1] * n for _ in range(n)]\n    for i, row in enumerate(grid):\n        for j, x in enumerate(row):\n            if x:\n                q.append((i, j))\n                dis[i][j] = 0\n    groups = [q]\n    while q:\n        tmp = q\n        q = []\n        for i, j in tmp:\n            for x, y in (i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1):\n                if 0 <= x < n and 0 <= y < n and dis[x][y] < 0:\n                    q.append((x, y))\n                    dis[x][y] = len(groups)\n        groups.append(q) \n    fa = list(range(n * n))\n    def find(x: int) -> int:\n        if fa[x] != x:\n            fa[x] = find(fa[x])\n        return fa[x]\n    for d in range(len(groups) - 2, 0, -1):\n        for i, j in groups[d]:\n            for x, y in (i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1):\n                if 0 <= x < n and 0 <= y < n and dis[x][y] >= dis[i][j]:\n                    fa[find(x * n + y)] = find(i * n + j)\n        if find(0) == find(n * n - 1):\n            return d\n    return 0", "entry_point": "maximumSafenessFactor", "test_list": ["assert maximumSafenessFactor([[1,0,0],[0,0,0],[0,0,1]]) == 0", "assert maximumSafenessFactor([[0,0,1],[0,0,0],[0,0,0]]) == 2", "assert maximumSafenessFactor([[0,0,0,1],[0,0,0,0],[0,0,0,0],[1,0,0,0]]) == 2"]}
{"Contest id": "357/2811", "text_name": "Check if it is Possible to Split Array", "text": "You are given an array nums of length n and an integer m. You need to determine if it is possible to split the array into n non-empty arrays by performing a series of steps.\nIn each step, you can select an existing array (which may be the result of previous steps) with a length of at least two and split it into two subarrays, if, for each resulting subarray, at least one of the following holds:\nThe length of the subarray is one, or\nThe sum of elements of the subarray is greater than or equal to m.\nReturn true if you can split the given array into n arrays, otherwise return false.\nNote: A subarray is a contiguous non-empty sequence of elements within an array.", "canonical_solution": "def canSplitArray(nums, m):\n    n = len(nums)\n    if n <= 2:\n        return True\n    if nums[0] + nums[1] >= m or nums[n - 1] + nums[n - 2] >= m:\n        return True\n    for i in range(1, n - 1):\n        if nums[i] + nums[i + 1] >= m:\n            return True\n    return False", "entry_point": "canSplitArray", "test_list": ["assert canSplitArray(nums = [2, 2, 1], m = 4) == True", "assert canSplitArray(nums = [2, 1, 3], m = 5) == False", "assert canSplitArray(nums = [2, 3, 3, 2, 3], m = 6) == True"]}
{"Contest id": "357/2810", "text_name": "Faulty Keyboard", "text": "Your laptop keyboard is faulty, and whenever you type a character 'i' on it, it reverses the string that you have written. Typing other characters works as expected.\nYou are given a 0-indexed string s, and you type each character of s using your faulty keyboard.\nReturn the final string that will be present on your laptop screen.\n", "canonical_solution": "def finalString(s):\n    import collections\n    d = collections.deque()\n    cnt = s.count('i') % 2\n    for c in s:\n        if c == 'i':\n            cnt ^= 1\n        else:\n            d.appendleft(c) if cnt else d.append(c)\n    return \"\".join(d)", "entry_point": "finalString", "test_list": ["assert finalString(\"string\") == \"rtsng\"", "assert finalString(\"poiinter\") == \"ponter\""]}
{"Contest id": "Bi110/2809", "text_name": "Minimum Time to Make Array Sum At Most x\n", "text": "You are given two 0-indexed integer arrays nums1 and nums2 of equal length. Every second, for all indices 0 <= i < nums1.length, value of nums1[i] is incremented by nums2[i]. After this is done, you can do the following operation:\nChoose an index 0 <= i < nums1.length and make nums1[i] = 0.\nYou are also given an integer x.\nReturn the minimum time in which you can make the sum of all elements of nums1 to be less than or equal to x, or -1 if this is not possible.", "canonical_solution": "def minimumTime(A, B, x):\n    n = len(A)\n    dp = [0] * (n + 1)\n    for j, (b, a) in enumerate(sorted(zip(B, A)), 1):\n        for i in range(j, 0, -1):\n            dp[i] = max(dp[i], dp[i - 1] + i * b + a)\n    sa, sb = sum(A), sum(B)\n    for i in range(0, n + 1):\n        if sb * i + sa - dp[i] <= x:\n            return i\n    return -1", "entry_point": "minimumTime", "test_list": ["assert minimumTime([1,2,3], [1,2,3], 4) == 3", "assert minimumTime([1,2,3], [3,3,3], 4) == -1"]}
{"Contest id": "Bi110/2808", "text_name": "Minimum Seconds to Equalize a Circular Array\n", "text": "You are given a 0-indexed array nums containing n integers.\nAt each second, you perform the following operation on the array:\nFor every index i in the range [0, n - 1], replace nums[i] with either nums[i], nums[(i - 1 + n) % n], or nums[(i + 1) % n].\nNote that all the elements get replaced simultaneously.\nReturn the minimum number of seconds needed to make all elements in the array nums equal.", "canonical_solution": "def minimumSeconds(nums):\n   data = defaultdict(list)\n   for i, v in enumerate(nums):\n       data[v].append(i)\n   res = len(nums) + 1\n   for k, v in data.items():\n       curr_max = (v[0] + len(nums) - v[-1]) // 2;\n       for i in range(1, len(v)):\n           curr_max = max(curr_max, (v[i] - v[i - 1]) // 2)\n       res = min(res, curr_max)\n   return res", "entry_point": "minimumSeconds", "test_list": ["assert minimumSeconds([1,2,1,2]) == 1", "assert minimumSeconds([2,1,3,3,2]) == 2", "assert minimumSeconds([5,5,5,5]) == 0"]}
{"Contest id": "Bi110/2806", "text_name": "Account Balance After Rounded Purchase\n", "text": "Initially, you have a bank account balance of 100 dollars.\nYou are given an integer purchaseAmount representing the amount you will spend on a purchase in dollars.\nAt the store where you will make the purchase, the purchase amount is rounded to the nearest multiple of 10. In other words, you pay a non-negative amount, roundedAmount, such that roundedAmount is a multiple of 10 and abs(roundedAmount - purchaseAmount) is minimized.\nIf there is more than one nearest multiple of 10, the largest multiple is chosen.\nReturn an integer denoting your account balance after making a purchase worth purchaseAmount dollars from the store.\nNote: 0 is considered to be a multiple of 10 in this problem.", "canonical_solution": "def accountBalanceAfterPurchase(purchaseAmount):\n    purchaseAmount = ((purchaseAmount - 5) // 10 ) * 10 + 10\n    result = 100 - purchaseAmount\n    return result", "entry_point": "accountBalanceAfterPurchase", "test_list": ["assert accountBalanceAfterPurchase(9) == 90", "assert accountBalanceAfterPurchase(15) == 80"]}
{"Contest id": "356/2801", "text_name": "Count Stepping Numbers in Range", "text": "Given two positive integers low and high represented as strings, find the count of stepping numbers in the inclusive range [low, high].\nA stepping number is an integer such that all of its adjacent digits have an absolute difference of exactly 1.\nReturn an integer denoting the count of stepping numbers in the inclusive range [low, high].\nSince the answer may be very large, return it modulo 109 + 7.\nNote: A stepping number should not have a leading zero.", "canonical_solution": "def countSteppingNumbers(low, high):\n   mod = 10**9 + 7\n   def solve(high):\n       def dp(idx, tight, last, nz):\n           if idx == len(high): return 1\n           ans = 0\n           h = 10 if not tight else int(high[idx]) + 1\n           for i in range(h):\n               if not nz or abs(i - last) == 1:\n                  ans += dp(idx + 1, 1 if (tight and i == int(high[idx])) else 0, i, nz | (i != 0))\n                  ans %= mod\n               ans %= mod\n           return ans\n       return dp(0, 1, 0, 0)\n   return (solve(high) - solve(str(int(low) - 1))) % mod", "entry_point": "countSteppingNumbers", "test_list": ["assert countSteppingNumbers(low = \"1\", high = \"11\") == 10", "assert countSteppingNumbers(low = \"90\", high = \"101\") == 2"]}
{"Contest id": "356/2800", "text_name": "Shortest String That Contains Three Strings\n", "text": "Given three strings a, b, and c, your task is to find a string that has the minimum length and contains all three strings as substrings.\nIf there are multiple such strings, return the lexicographically smallest one.\nReturn a string denoting the answer to the problem.\nNotes\nA string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b.\nA substring is a contiguous sequence of characters within a string.\n", "canonical_solution": "def minimumString(a, b, c):\n   from itertools import permutations\n   def f(a, b):\n       if b in a: return a\n       for k in range(len(a), -1, -1):\n           if a.endswith(b[:k]):\n               return a + b[k:]\n   return min((f(f(a,b), c) for a,b,c in permutations((a,b,c))), key=lambda a: (len(a), a))", "entry_point": "minimumString", "test_list": ["assert minimumString(a = \"abc\", b = \"bca\", c = \"aaa\") == \"aaabca\"", "assert minimumString(a = \"ab\", b = \"ba\", c = \"aba\") == \"aba\""]}
{"Contest id": "356/2799", "text_name": "Count Complete Subarrays in an Array", "text": "You are given an array nums consisting of positive integers.\nWe call a subarray of an array complete if the following condition is satisfied:\nThe number of distinct elements in the subarray is equal to the number of distinct elements in the whole array.\nReturn the number of complete subarrays.\nA subarray is a contiguous non-empty part of an array.", "canonical_solution": "def countCompleteSubarrays(A):\n   from collections import Counter\n   n, k = len(A), len(set(A))\n   res = i = 0\n   count = Counter()\n   for j in range(n):\n       count[A[j]] += 1\n       while len(count) == k:\n           count[A[i]] -= 1\n           if count[A[i]] == 0:\n               del count[A[i]]\n           i += 1\n       res += i\n   return res", "entry_point": "countCompleteSubarrays", "test_list": ["assert countCompleteSubarrays([1,3,1,2,2]) == 4", "assert countCompleteSubarrays([5,5,5,5]) == 10"]}
{"Contest id": "356/2798", "text_name": "Number of Employees Who Met the Target", "text": "There are n employees in a company, numbered from 0 to n - 1. Each employee i has worked for hours[i] hours in the company.\nThe company requires each employee to work for at least target hours.\nYou are given a 0-indexed array of non-negative integers hours of length n and a non-negative integer target.\nReturn the integer denoting the number of employees who worked at least target hours.", "canonical_solution": "def numberOfEmployeesWhoMetTarget(hours, target):\n  ans = 0\n  for h in hours:\n      if h >= target:\n          ans += 1\n  return ans", "entry_point": "numberOfEmployeesWhoMetTarget", "test_list": ["assert numberOfEmployeesWhoMetTarget(hours = [0,1,2,3,4], target = 2) == 3", "assert numberOfEmployeesWhoMetTarget(hours = [5,1,4,2,2], target = 6) == 0"]}
{"Contest id": "355/2791", "text_name": "Count Paths That Can Form a Palindrome in a Tree\n", "text": "You are given a tree (i.e. a connected, undirected graph that has no cycles) rooted at node 0 consisting of n nodes numbered from 0 to n - 1. The tree is represented by a 0-indexed array parent of size n, where parent[i] is the parent of node i. Since node 0 is the root, parent[0] == -1.\nYou are also given a string s of length n, where s[i] is the character assigned to the edge between i and parent[i]. s[0] can be ignored.\nReturn the number of pairs of nodes (u, v) such that u < v and the characters assigned to edges on the path from u to v can be rearranged to form a palindrome.\nA string is a palindrome when it reads the same backwards as forwards.", "canonical_solution": "def countPalindromePaths(parent, s):\n   from collections import Counter\n   def f(i):\n       return f(parent[i]) ^ (1 << (ord(s[i]) - ord('a'))) if i else 0\n   count = Counter()\n   res = 0\n   for i in range(len(parent)):\n       v = f(i)\n       res += count[v] + sum(count[v ^ (1 << j)] for j in range(26))\n       count[v] += 1\n   return res", "entry_point": "countPalindromePaths", "test_list": ["assert countPalindromePaths(parent = [-1,0,0,1,1,2], s = \"acaabc\") == 8", "assert countPalindromePaths(parent = [-1,0,0,0,0], s = \"aaaaa\") == 10"]}
{"Contest id": "355/2790", "text_name": "Maximum Number of Groups With Increasing Length", "text": "You are given a 0-indexed array usageLimits of length n.\nYour task is to create groups using numbers from 0 to n - 1, ensuring that each number, i, is used no more than usageLimits[i] times in total across all groups. You must also satisfy the following conditions:\nEach group must consist of distinct numbers, meaning that no duplicate numbers are allowed within a single group.\nEach group (except the first one) must have a length strictly greater than the previous group.\nReturn an integer denoting the maximum number of groups you can create while satisfying these conditions.\n", "canonical_solution": "def maxIncreasingGroups(A):\n   A.sort()\n   total = k = 0\n   for a in A:\n       total += a\n       if total >= (k + 1) * (k + 2) // 2:\n           k += 1\n   return k", "entry_point": "maxIncreasingGroups", "test_list": ["assert maxIncreasingGroups([1,2,5]) == 3", "assert maxIncreasingGroups([2,1,2]) == 2", "assert maxIncreasingGroups([1,1]) == 1"]}
{"Contest id": "355/2789", "text_name": "Largest Element in an Array after Merge Operations", "text": "You are given a 0-indexed array nums consisting of positive integers.\nYou can do the following operation on the array any number of times:\nChoose an integer i such that 0 <= i < nums.length - 1 and nums[i] <= nums[i + 1]. Replace the element nums[i + 1] with nums[i] + nums[i + 1] and delete the element nums[i] from the array.\nReturn the value of the largest element that you can possibly obtain in the final array.", "canonical_solution": "def maxArrayValue(nums):\n   stack = []\n   for n in reversed(nums):\n       while stack and stack[-1] >= n:\n           n += stack.pop()\n       stack.append(n)\n   return stack[-1]", "entry_point": "maxArrayValue", "test_list": ["assert maxArrayValue([2,3,7,9,3]) == 21", "assert maxArrayValue([5,3,3]) == 11"]}
{"Contest id": "355/2788", "text_name": "Split Strings by Separator", "text": "Given an array of strings words and a character separator, split each string in words by separator.\nReturn an array of strings containing the new strings formed after the splits, excluding empty strings.\nNotes\nseparator is used to determine where the split should occur, but it is not included as part of the resulting strings.\nA split may result in more than two strings.\nThe resulting strings must maintain the same order as they were initially given.\n", "canonical_solution": "def splitWordsBySeparator(words, separator):\n   ans = []\n   for word in words:\n       for i in word.split(separator):\n           if i:\n               ans.append(i)\n   return ans", "entry_point": "splitWordsBySeparator", "test_list": ["assert splitWordsBySeparator(words = [\"one.two.three\",\"four.five\",\"six\"], separator = \".\") == [\"one\",\"two\",\"three\",\"four\",\"five\",\"six\"]", "assert splitWordsBySeparator(words = [\"$easy$\",\"$problem$\"], separator = \"$\") == [\"easy\",\"problem\"]", "assert splitWordsBySeparator(words = [\"|||\"], separator = \"|\") == []"]}
{"Contest id": "Bi109/2787", "text_name": "Ways to Express an Integer as Sum of Powers", "text": "Given two positive integers n and x.\nReturn the number of ways n can be expressed as the sum of the xth power of unique positive integers, in other words, the number of sets of unique integers [n1, n2, ..., nk] where n = n1x + n2x + ... + nkx.\nSince the result can be very large, return it modulo 109 + 7.\nFor example, if n = 160 and x = 3, one way to express n is n = 23 + 33 + 53.", "canonical_solution": "def numberOfWays(n, x):\n   nums = []\n   n1, num = 1, 1\n   while num <= n:\n       nums.append(num)\n       n1 += 1\n       num = n1 ** x\n   def findSum(i, currentSum, memo):\n       if (i, currentSum) in memo:\n           return memo[(i, currentSum)]\n       if currentSum == n:\n           return 1\n       if currentSum > n or i >= len(nums):\n           return 0\n       take = findSum(i+1, currentSum + nums[i], memo)\n       dontTake = findSum(i+1, currentSum, memo)\n       memo[(i, currentSum)] = take + dontTake\n       return memo[(i, currentSum)]\n   return findSum(0, 0, {}) % (10 ** 9 + 7)", "entry_point": "numberOfWays", "test_list": ["assert numberOfWays(n = 10, x = 2) == 1", "assert numberOfWays(n = 4, x = 1) == 2"]}
{"Contest id": "Bi109/2786", "text_name": "Visit Array Positions to Maximize Score\n", "text": "You are given a 0-indexed integer array nums and a positive integer x.\nYou are initially at position 0 in the array and you can visit other positions according to the following rules:\nIf you are currently in position i, then you can move to any position j such that i < j.\nFor each position i that you visit, you get a score of nums[i].\nIf you move from a position i to a position j and the parities of nums[i] and nums[j] differ, then you lose a score of x.\nReturn the maximum total score you can get.\nNote that initially you have nums[0] points.", "canonical_solution": "def maxScore(nums, x):\n  dp = [-x, -x]\n  dp[nums[0] & 1] = nums[0]\n  for i in range(1, len(nums)):\n      dp[nums[i] & 1] = max(dp[nums[i] & 1], dp[nums[i] & 1 ^ 1] - x) + nums[i]\n  return max(dp)", "entry_point": "maxScore", "test_list": ["assert maxScore(nums = [2,3,6,1,9,2], x = 5) == 13", "assert maxScore(nums = [2,4,6,8], x = 3) == 20"]}
{"Contest id": "Bi109/2785", "text_name": "Sort Vowels in a String", "text": "Given a 0-indexed string s, permute s to get a new string t such that:\nAll consonants remain in their original places. More formally, if there is an index i with 0 <= i < s.length such that s[i] is a consonant, then t[i] = s[i].\nThe vowels must be sorted in the nondecreasing order of their ASCII values. More formally, for pairs of indices i, j with 0 <= i < j < s.length such that s[i] and s[j] are vowels, then t[i] must not have a higher ASCII value than t[j].\nReturn the resulting string.\nThe vowels are 'a', 'e', 'i', 'o', and 'u', and they can appear in lowercase or uppercase. Consonants comprise all letters that are not vowels.", "canonical_solution": "def sortVowels(s):\n   vow = []\n   pos = []\n   for i, ch in enumerate(s):\n       if ch.lower() in {'a', 'e', 'i', 'o', 'u'}:\n           vow.append(ch)\n           pos.append(i)\n   vow.sort()\n   answer = list(s)\n   for i, v in zip(pos, vow):\n       answer[i] = v\n   return ''.join(answer)", "entry_point": "sortVowels", "test_list": ["assert sortVowels(\"lEetcOde\") == \"lEOtcede\"", "assert sortVowels(\"lYmpH\") == \"lYmpH\""]}
{"Contest id": "Bi109/2784", "text_name": "Check if Array is Good", "text": "You are given an integer array nums. We consider an array good if it is a permutation of an array base[n].\nbase[n] = [1, 2, ..., n - 1, n, n] (in other words, it is an array of length n + 1 which contains 1 to n - 1 exactly once, plus two occurrences of n). For example, base[1] = [1, 1] and base[3] = [1, 2, 3, 3].\nReturn true if the given array is good, otherwise return false.\nNote: A permutation of integers represents an arrangement of these numbers.", "canonical_solution": "def isGood(v):\n  n = len(v)\n  mx = max(v)\n  s = set(v)\n  flag = True\n  k = 1\n  for x in s:\n      if x == k:\n          k += 1\n      else:\n          flag = False\n          break\n  ct = v.count(mx)\n  if n == mx + 1 and ct == 2 and flag:\n      return True\n  else:\n      return False", "entry_point": "isGood", "test_list": ["assert isGood([2, 1, 3]) == False", "assert isGood([1, 3, 3, 2]) == True", "assert isGood([1, 1]) == True", "assert isGood([3, 4, 4, 1, 2, 1]) == False"]}
{"Contest id": "354/2781", "text_name": "Length of the Longest Valid Substring", "text": "You are given a string word and an array of strings forbidden.\nA string is called valid if none of its substrings are present in forbidden.\nReturn the length of the longest valid substring of the string word.\nA substring is a contiguous sequence of characters in a string, possibly empty.", "canonical_solution": "def longestValidSubstring(word, forbidden):\n   length = 0\n   all = set()\n   for s in forbidden:\n       all.add(s)\n       length = max(length, len(s))\n   n = len(word)\n   r = 0\n   right = n\n   for i in range(n - 1, -1, -1):\n       if right <= r:\n           break\n       now = 0\n       temp = ''\n       for j in range(i, min(right, i + length)):\n           temp += word[j]\n           if temp in all:\n               right = j\n               break\n       r = max(r, right - i)\n   return r", "entry_point": "longestValidSubstring", "test_list": ["assert longestValidSubstring(word = \"cbaaaabc\", forbidden = [\"aaa\",\"cb\"]) == 4", "assert longestValidSubstring(word = \"leetcode\", forbidden = [\"de\",\"le\",\"e\"]) == 4"]}
{"Contest id": "354/2780", "text_name": "Minimum Index of a Valid Split", "text": "An element x of an integer array arr of length m is dominant if freq(x) * 2 > m, where freq(x) is the number of occurrences of x in arr. Note that this definition implies that arr can have at most one dominant element.\nYou are given a 0-indexed integer array nums of length n with one dominant element.\nYou can split nums at an index i into two arrays nums[0, ..., i] and nums[i + 1, ..., n - 1], but the split is only valid if:\n0 <= i < n - 1\nnums[0, ..., i], and nums[i + 1, ..., n - 1] have the same dominant element.\nHere, nums[i, ..., j] denotes the subarray of nums starting at index i and ending at index j, both ends being inclusive. Particularly, if j < i then nums[i, ..., j] denotes an empty subarray.\nReturn the minimum index of a valid split. If no valid split exists, return -1.", "canonical_solution": "def minimumIndex(nums):\n   l = dict()\n   r = dict()\n   n = len(nums)\n   for i in range(n):\n       r[nums[i]] = r.get(nums[i], 0) + 1\n   ans = -1\n   for i in range(n-1):\n       l[nums[i]] = l.get(nums[i], 0) + 1\n       r[nums[i]] = r[nums[i]] - 1\n       if l[nums[i]]*2>(i+1) and r[nums[i]]*2>(n-(i+1)):\n           ans = i\n           break\n   return ans", "entry_point": "minimumIndex", "test_list": ["assert minimumIndex([1,2,2,2]) == 2", "assert minimumIndex([2,1,3,1,1,1,7,1,2,1]) == 4", "assert minimumIndex([3,3,3,3,7,2,2]) == -1"]}
{"Contest id": "354/2779", "text_name": "Maximum Beauty of an Array After Applying Operation", "text": "You are given a 0-indexed array nums and a non-negative integer k.\nIn one operation, you can do the following:\nChoose an index i that hasn't been chosen before from the range [0, nums.length - 1].\nReplace nums[i] with any integer from the range [nums[i] - k, nums[i] + k].\nThe beauty of the array is the length of the longest subsequence consisting of equal elements.\nReturn the maximum possible beauty of the array nums after applying the operation any number of times.\nNote that you can apply the operation to each index only once.\nA subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the order of the remaining elements.", "canonical_solution": "def maximumBeauty(A, k):\n  A.sort()\n  i = 0\n  for j in range(len(A)):\n      if A[j] - A[i] > k * 2:\n          i += 1\n  return j - i + 1", "entry_point": "maximumBeauty", "test_list": ["assert maximumBeauty([4,6,1,2], 2) == 3", "assert maximumBeauty([1,1,1,1], 10) == 4"]}
{"Contest id": "354/2778", "text_name": "Sum of Squares of Special Elements", "text": "You are given a 1-indexed integer array nums of length n.\nAn element nums[i] of nums is called special if i divides n, i.e. n % i == 0.\nReturn the sum of the squares of all special elements of nums.", "canonical_solution": "def sumOfSquares(nums):\n   n = len(nums)\n   cound = []\n   for l  in range(2): \n       for i in range(1, n + 1):\n           if n % i == 0: \n               cound.append(nums[i-1])\n   sorted_list = sorted(cound) \n   return sum([sorted_list[i] * sorted_list[i+1] for i in range(0, len(sorted_list)-1, 2)])", "entry_point": "sumOfSquares", "test_list": ["assert sumOfSquares([1,2,3,4]) == 21", "assert sumOfSquares([2,7,1,19,18,3]) == 63"]}
{"Contest id": "353/2772", "text_name": "Apply Operations to Make All Array Elements Equal to Zero", "text": "You are given a 0-indexed integer array nums and a positive integer k.\nYou can apply the following operation on the array any number of times:\nChoose any subarray of size k from the array and decrease all its elements by 1.\nReturn true if you can make all the array elements equal to 0, or false otherwise.\nA subarray is a contiguous non-empty part of an array.\n", "canonical_solution": "def checkArray(A, k):\n   cur = 0\n   for i, a in enumerate(A):\n       if cur > a:\n           return False\n       A[i], cur = a - cur, a\n       if i >= k - 1:\n           cur -= A[i - k + 1]\n   return cur == 0", "entry_point": "checkArray", "test_list": ["assert checkArray(A = [2,2,3,1,1,0], k = 3) == True", "assert checkArray(A = [1,3,1,1], k = 2) == False"]}
{"Contest id": "353/2771", "text_name": "Longest Non-decreasing Subarray From Two Arrays", "text": "You are given two 0-indexed integer arrays nums1 and nums2 of length n.\nLet's define another 0-indexed integer array, nums3, of length n. For each index i in the range [0, n - 1], you can assign either nums1[i] or nums2[i] to nums3[i].\nYour task is to maximize the length of the longest non-decreasing subarray in nums3 by choosing its values optimally.\nReturn an integer representing the length of the longest non-decreasing subarray in nums3.\nNote: A subarray is a contiguous non-empty sequence of elements within an array.", "canonical_solution": "def maxNonDecreasingLength(A, B):\n   res = dp1 = dp2 = 1\n   for i in range(1, len(A)):\n       t11 = dp1 + 1 if A[i - 1] <= A[i] else 1\n       t12 = dp1 + 1 if A[i - 1] <= B[i] else 1\n       t21 = dp2 + 1 if B[i - 1] <= A[i] else 1\n       t22 = dp2 + 1 if B[i - 1] <= B[i] else 1\n       dp1 = max(t11, t21)\n       dp2 = max(t12, t22)\n       res = max(res, dp1, dp2)\n   return res", "entry_point": "maxNonDecreasingLength", "test_list": ["assert maxNonDecreasingLength([2,3,1], [1,2,1]) == 2", "assert maxNonDecreasingLength([1,3,2,1], [2,2,3,4]) == 4", "assert maxNonDecreasingLength([1,1], [2,2]) == 2"]}
{"Contest id": "353/2770", "text_name": "Maximum Number of Jumps to Reach the Last Index", "text": "You are given a 0-indexed array nums of n integers and an integer target.\nYou are initially positioned at index 0. In one step, you can jump from index i to any index j such that:\n0 <= i < j < n\n-target <= nums[j] - nums[i] <= target\nReturn the maximum number of jumps you can make to reach index n - 1.\nIf there is no way to reach index n - 1, return -1.", "canonical_solution": "def maximumJumps(nums, target):\n   n = len(nums)\n   dp = [-1] * n\n   dp[-1] = 0\n   for i in range(n-2, -1, -1):\n       for j in range(i+1, n):\n           if abs(nums[i]-nums[j]) <= target and dp[j] != -1:\n               dp[i] = max(dp[i], 1+dp[j])\n   return dp[0]", "entry_point": "maximumJumps", "test_list": ["assert maximumJumps(nums = [1,3,6,4,1,2], target = 2) == 3", "assert maximumJumps(nums = [1,3,6,4,1,2], target = 3) == 5", "assert maximumJumps(nums = [1,3,6,4,1,2], target = 0) == -1"]}
{"Contest id": "353/2769", "text_name": "Find the Maximum Achievable Number\n", "text": "You are given two integers, num and t.\nAn integer x is called achievable if it can become equal to num after applying the following operation no more than t times:\nIncrease or decrease x by 1, and simultaneously increase or decrease num by 1.\nReturn the maximum possible achievable number. It can be proven that there exists at least one achievable number.", "canonical_solution": "def theMaximumAchievableX(num, t):\n    return num+2*t", "entry_point": "theMaximumAchievableX", "test_list": ["assert theMaximumAchievableX(num = 4, t = 1) == 6", "assert theMaximumAchievableX(num = 3, t = 2) == 7"]}
{"Contest id": "Bi108/2768", "text_name": "Number of Black Blocks", "text": "You are given two integers m and n representing the dimensions of a 0-indexed m x n grid.\nYou are also given a 0-indexed 2D integer matrix coordinates, where coordinates[i] = [x, y] indicates that the cell with coordinates [x, y] is colored black. All cells in the grid that do not appear in coordinates are white.\nA block is defined as a 2 x 2 submatrix of the grid. More formally, a block with cell [x, y] as its top-left corner where 0 <= x < m - 1 and 0 <= y < n - 1 contains the coordinates [x, y], [x + 1, y], [x, y + 1], and [x + 1, y + 1].\nReturn a 0-indexed integer array arr of size 5 such that arr[i] is the number of blocks that contains exactly i black cells.\n", "canonical_solution": "def countBlackBlocks(m, n, coordinates):\n   from collections import Counter\n   from itertools import product\n   cnt = Counter()\n   res = [(n - 1) * (m - 1), 0, 0, 0, 0]\n   for i, j in coordinates:\n       for i, j in product([i, i + 1], [j, j + 1]):\n           res[cnt[i, j]] -= 1\n           cnt[i, j] += 0 < i < m and 0 < j < n\n           res[cnt[i, j]] += 1\n   return res", "entry_point": "countBlackBlocks", "test_list": ["assert countBlackBlocks(m = 3, n = 3, coordinates = [[0,0]]) == [3,1,0,0,0]", "assert countBlackBlocks(m = 3, n = 3, coordinates = [[0,0],[1,1],[0,2]]) == [0,2,2,0,0]"]}
{"Contest id": "Bi108/2767", "text_name": "Partition String Into Minimum Beautiful Substrings", "text": "Given a binary string s, partition the string into one or more substrings such that each substring is beautiful.\nA string is beautiful if:\nIt doesn't contain leading zeros.\nIt's the binary representation of a number that is a power of 5.\nReturn the minimum number of substrings in such partition. If it is impossible to partition the string s into beautiful substrings, return -1.\nA substring is a contiguous sequence of characters in a string.\n", "canonical_solution": "def minimumBeautifulSubstrings(s):\n  n = len(s)\n  dp = [0] + [float('inf')] * n\n  for i in range(n):\n      if s[i] == '1':\n          cur = 0\n          for j in range(i, n):\n              cur = cur * 2 + int(s[j])\n              if 15625 % cur == 0:\n                 dp[j + 1] = min(dp[j + 1], dp[i] + 1)\n  return dp[n] if dp[n] < float('inf') else -1", "entry_point": "minimumBeautifulSubstrings", "test_list": ["assert minimumBeautifulSubstrings(\"1011\") == 2", "assert minimumBeautifulSubstrings(\"111\") == 3", "assert minimumBeautifulSubstrings(\"0\") == -1"]}
{"Contest id": "Bi108/2766", "text_name": "Relocate Marbles", "text": "You are given a 0-indexed integer array nums representing the initial positions of some marbles. You are also given two 0-indexed integer arrays moveFrom and moveTo of equal length.\nThroughout moveFrom.length steps, you will change the positions of the marbles. On the ith step, you will move all marbles at position moveFrom[i] to position moveTo[i].\nAfter completing all the steps, return the sorted list of occupied positions.\nNotes:\nWe call a position occupied if there is at least one marble in that position.\nThere may be multiple marbles in a single position.", "canonical_solution": "def relocateMarbles(nums, moveFrom, moveTo):\n   nums = set(nums)\n   for start, end in zip(moveFrom, moveTo):\n       nums.discard(start)\n       nums.add(end)\n   return sorted(nums)", "entry_point": "relocateMarbles", "test_list": ["assert relocateMarbles(nums = [1,6,7,8], moveFrom = [1,7,2], moveTo = [2,9,5]) == [5,6,8,9]", "assert relocateMarbles(nums = [1,1,3,3], moveFrom = [1,3], moveTo = [2,2]) == [2]"]}
{"Contest id": "Bi108/2765", "text_name": "Longest Alternating Subarray", "text": "You are given a 0-indexed integer array nums. A subarray s of length m is called alternating if:\nm is greater than 1.\ns1 = s0 + 1.\nThe 0-indexed subarray s looks like [s0, s1, s0, s1,...,s(m-1) % 2]. In other words, s1 - s0 = 1, s2 - s1 = -1, s3 - s2 = 1, s4 - s3 = -1, and so on up to s[m - 1] - s[m - 2] = (-1)m.\nReturn the maximum length of all alternating subarrays present in nums or -1 if no such subarray exists.\nA subarray is a contiguous non-empty sequence of elements within an array.", "canonical_solution": "def alternatingSubarray(A):\n  n = len(A)\n  res = dp = -1\n  for i in range(1, n):\n      if dp > 0 and A[i] == A[i - 2]:\n          dp += 1\n      else:\n          dp = 2 if A[i] == A[i - 1] + 1 else -1\n      res = max(res, dp)\n  return res", "entry_point": "alternatingSubarray", "test_list": ["assert alternatingSubarray([2,3,4,3,4]) == 4", "assert alternatingSubarray([4,5,6]) == 2"]}
{"Contest id": "352/2763", "text_name": "Sum of Imbalance Numbers of All Subarrays", "text": "The imbalance number of a 0-indexed integer array arr of length n is defined as the number of indices in sarr = sorted(arr) such that:\n0 <= i < n - 1, and\nsarr[i+1] - sarr[i] > 1\nHere, sorted(arr) is the function that returns the sorted version of arr.\nGiven a 0-indexed integer array nums, return the sum of imbalance numbers of all its subarrays.\nA subarray is a contiguous non-empty sequence of elements within an array.\n", "canonical_solution": "def sumImbalanceNumbers(nums):\n   n = len(nums)\n   res = 0\n   for i in range(n):\n       s = set()\n       cur = -1\n       for j in range(i, n):\n           cur += 0 if nums[j] in s else 1 - (nums[j] + 1 in s) - (nums[j] - 1 in s)\n           s.add(nums[j])\n           res += cur\n   return res", "entry_point": "sumImbalanceNumbers", "test_list": ["assert sumImbalanceNumbers([2,3,1,4]) == 3", "assert sumImbalanceNumbers([1,3,3,3,5]) == 8"]}
{"Contest id": "352/2762", "text_name": "Continuous Subarrays", "text": "You are given a 0-indexed integer array nums. A subarray of nums is called continuous if:\nLet i, i + 1, ..., j be the indices in the subarray. Then, for each pair of indices i <= i1, i2 <= j, 0 <= |nums[i1] - nums[i2]| <= 2.\nReturn the total number of continuous subarrays.\nA subarray is a contiguous non-empty sequence of elements within an array.", "canonical_solution": "def continuousSubarrays(nums):\n   from collections import deque\n   maxQ = deque()\n   minQ = deque()\n   left = 0\n   res = 0\n   for right in range(len(nums)):\n       while maxQ and nums[maxQ[-1]] < nums[right]:\n           maxQ.pop()\n       maxQ.append(right)\n       while minQ and nums[minQ[-1]] > nums[right]:\n           minQ.pop()\n       minQ.append(right)\n       while nums[maxQ[0]] - nums[minQ[0]] > 2:\n           if maxQ[0] < minQ[0]:\n               left = maxQ[0] + 1\n               maxQ.popleft()\n           else:\n               left = minQ[0] + 1\n               minQ.popleft()\n       res += right - left + 1\n   return res", "entry_point": "continuousSubarrays", "test_list": ["assert continuousSubarrays([5,4,2,4]) == 8", "assert continuousSubarrays([1,2,3]) == 6"]}
{"Contest id": "352/2761", "text_name": "Prime Pairs With Target Sum", "text": "You are given an integer n. We say that two integers x and y form a prime number pair if:\n1 <= x <= y <= n\nx + y == n\nx and y are prime numbers\nReturn the 2D sorted list of prime number pairs [xi, yi]. The list should be sorted in increasing order of xi. If there are no prime number pairs at all, return an empty array.\nNote: A prime number is a natural number greater than 1 with only two factors, itself and 1.", "canonical_solution": "def findPrimePairs(n):\n        prime = [True] * (n + 1) \n        ans = []\n        \n        for i in range(2, n + 1):\n            prime[i] = True\n        \n        prime[1] = False \n        prime[0] = False\n        \n        p = 2\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p * p, n + 1, p):\n                    prime[i] = False\n            p += 1\n        \n        for i in range(2, n):\n            j = n - i \n            if prime[i] and prime[j] and i <= j:\n                temp = [i, j]  \n                ans.append(temp) \n        return ans\n", "entry_point": "findPrimePairs", "test_list": ["assert findPrimePairs(10) == [[3,7],[5,5]]", "assert findPrimePairs(2) == []"]}
{"Contest id": "351/2751", "text_name": "Robot Collisions", "text": "There are n 1-indexed robots, each having a position on a line, health, and movement direction.\nYou are given 0-indexed integer arrays positions, healths, and a string directions (directions[i] is either 'L' for left or 'R' for right). All integers in positions are unique.\nAll robots start moving on the line simultaneously at the same speed in their given directions. If two robots ever share the same position while moving, they will collide.\nIf two robots collide, the robot with lower health is removed from the line, and the health of the other robot decreases by one. The surviving robot continues in the same direction it was going. If both robots have the same health, they are both removed from the line.\nYour task is to determine the health of the robots that survive the collisions, in the same order that the robots were given, i.e. final heath of robot 1 (if survived), final health of robot 2 (if survived), and so on. If there are no survivors, return an empty array.\nReturn an array containing the health of the remaining robots (in the order they were given in the input), after no further collisions can occur.\nNote: The positions may be unsorted.", "canonical_solution": "def survivedRobotsHealths(positions, h, directions):\n  n = len(positions)\n  ind = sorted(range(n), key=positions.__getitem__)\n  stack = []\n  for i in ind:\n     if directions[i] == 'R':\n         stack.append(i)\n         continue\n     while stack and h[i] > 0:\n         if h[stack[-1]] < h[i]:\n             h[stack.pop()] = 0\n             h[i] -= 1\n         elif h[stack[-1]] > h[i]:\n             h[stack[-1]] -= 1\n             h[i] = 0\n         else:\n             h[stack.pop()] = 0\n             h[i] = 0\n  return [v for v in h if v > 0]", "entry_point": "survivedRobotsHealths", "test_list": ["assert survivedRobotsHealths([5,4,3,2,1], [2,17,9,15,10], \"RRRRR\") == [2,17,9,15,10]", "assert survivedRobotsHealths([3,5,2,6], [10,10,15,12], \"RLRL\") == [14]", "assert survivedRobotsHealths([1,2,5,6],  [10,10,11,11], \"RLRL\") == []"]}
{"Contest id": "351/2750", "text_name": "Ways to Split Array Into Good Subarrays", "text": "You are given a binary array nums.\nA subarray of an array is good if it contains exactly one element with the value 1.\nReturn an integer denoting the number of ways to split the array nums into good subarrays. As the number may be too large, return it modulo 109 + 7.\nA subarray is a contiguous non-empty sequence of elements within an array.", "canonical_solution": "def numberOfGoodSubarraySplits(nums):\n  prev = count = 0\n  for i, num in enumerate(nums):\n      if num == 1:\n          count = max((count * (i - prev)), 1) % (10 ** 9 + 7)\n          prev = i\n  return count", "entry_point": "numberOfGoodSubarraySplits", "test_list": ["assert numberOfGoodSubarraySplits([0,1,0,0,1]) == 3", "assert numberOfGoodSubarraySplits([0,1,0]) == 1"]}
{"Contest id": "351/2749", "text_name": "Minimum Operations to Make the Integer Zero", "text": "You are given two integers num1 and num2.\nIn one operation, you can choose integer i in the range [0, 60] and subtract 2i + num2 from num1.\nReturn the integer denoting the minimum number of operations needed to make num1 equal to 0.\nIf it is impossible to make num1 equal to 0, return -1.", "canonical_solution": "def makeTheIntegerZero(num1, num2):\n   for x in range(1, 101):\n       tmp = num1 - x * num2\n       if tmp < 0:\n           continue\n       arr = []\n       for i in range(62):\n           if (1 << i) & tmp != 0:\n               arr.append(1 << i)\n       if len(arr) <= x and sum(arr) >= x:\n           return x\n   return -1", "entry_point": "makeTheIntegerZero", "test_list": ["assert makeTheIntegerZero(num1 = 3, num2 = -2) == 3", "assert makeTheIntegerZero(num1 = 5, num2 = 7) == -1"]}
{"Contest id": "Bi107/2747", "text_name": "Count Zero Request Servers", "text": "You are given an integer n denoting the total number of servers and a 2D 0-indexed integer array logs, where logs[i] = [server_id, time] denotes that the server with id server_id received a request at time time.\nYou are also given an integer x and a 0-indexed integer array queries.\nReturn a 0-indexed integer array arr of length queries.length where arr[i] represents the number of servers that did not receive any requests during the time interval [queries[i] - x, queries[i]].\nNote that the time intervals are inclusive.", "canonical_solution": "def countServers(n, logs, x, queries):\n  from collections import Counter\n  res, cnt = [0] * len(queries), Counter()\n  i, j, used = 0, 0, 0\n  logs.sort(key=lambda l: l[1])\n  for [t, id] in sorted([t, id] for id, t in enumerate(queries)):\n      while i < len(logs) and logs[i][1] <= t:\n          cnt[logs[i][0]] += 1\n          used += cnt[logs[i][0]] == 1\n          i += 1\n      while j < i and logs[j][1] < t - x:\n          cnt[logs[j][0]] -= 1\n          used -= cnt[logs[j][0]] == 0\n          j += 1\n      res[id] = n - used\n  return res", "entry_point": "countServers", "test_list": ["assert countServers(n = 3, logs = [[1,3],[2,6],[1,5]], x = 5, queries = [10,11]) == [1,2]", "assert countServers(n = 3, logs = [[2,4],[2,1],[1,2],[3,1]], x = 2, queries = [3,4]) == [0,1]"]}
{"Contest id": "Bi107/2746", "text_name": "Decremental String Concatenation", "text": "You are given a 0-indexed array words containing n strings.\nLet's define a join operation join(x, y) between two strings x and y as concatenating them into xy. However, if the last character of x is equal to the first character of y, one of them is deleted.\nFor example join(\"ab\", \"ba\") = \"aba\" and join(\"ab\", \"cde\") = \"abcde\".\nYou are to perform n - 1 join operations. Let str0 = words[0]. Starting from i = 1 up to i = n - 1, for the ith operation, you can do one of the following:\nMake stri = join(stri - 1, words[i])\nMake stri = join(words[i], stri - 1)\nYour task is to minimize the length of strn - 1.\nReturn an integer denoting the minimum possible length of strn - 1.", "canonical_solution": "def minimizeConcatenatedLength(words):\n   n = len(words)\n   def dp(i, last1, first2):\n       if i == n:\n           return 0\n       len1 = len(words[i]) - (last1 == words[i][0])\n       res1 = len1 + dp(i + 1, words[i][-1], first2)\n       len2 = len(words[i]) - (first2 == words[i][-1])\n       res2 = len2 + dp(i + 1, last1, words[i][0])\n       return min(res1, res2)\n   return len(words[0]) + dp(1, words[0][-1], words[0][0])", "entry_point": "minimizeConcatenatedLength", "test_list": ["assert minimizeConcatenatedLength([\"aa\",\"ab\",\"bc\"]) == 4", "assert minimizeConcatenatedLength([\"ab\",\"b\"]) == 2", "assert minimizeConcatenatedLength([\"aaa\",\"c\",\"aba\"]) == 6"]}
{"Contest id": "Bi107/2745", "text_name": "Construct the Longest New String", "text": "You are given three integers x, y, and z.\nYou have x strings equal to \"AA\", y strings equal to \"BB\", and z strings equal to \"AB\". You want to choose some (possibly all or none) of these strings and concatenate them in some order to form a new string. This new string must not contain \"AAA\" or \"BBB\" as a substring.\nReturn the maximum possible length of the new string.\nA substring is a contiguous non-empty sequence of characters within a string.", "canonical_solution": "def longestString(x, y, z):\n   mn = min(x, y)\n   if x == y:\n       return 4 * x + 2 * z\n   else:\n       return 2 * mn + (mn + 1) * 2 + 2 * z", "entry_point": "longestString", "test_list": ["assert longestString(x = 2, y = 5, z = 1) == 12", "assert longestString(x = 3, y = 2, z = 2)  == 14"]}
{"Contest id": "Bi107/2744", "text_name": "Find Maximum Number of String Pairs", "text": "You are given a 0-indexed array words consisting of distinct strings.\nThe string words[i] can be paired with the string words[j] if:\nThe string words[i] is equal to the reversed string of words[j].\n0 <= i < j < words.length.\nReturn the maximum number of pairs that can be formed from the array words.\nNote that each string can belong in at most one pair.", "canonical_solution": "def maximumNumberOfStringPairs(words):\n  pairs = 0\n  reverse_dict = {}\n  for word in words:\n      reverse_word = word[::-1]\n      if reverse_word in reverse_dict:\n          pairs += reverse_dict[reverse_word]\n          reverse_dict[reverse_word] += 1\n      else:\n          reverse_dict[word] = 1\n  return pairs", "entry_point": "maximumNumberOfStringPairs", "test_list": ["assert maximumNumberOfStringPairs([\"cd\",\"ac\",\"dc\",\"ca\",\"zz\"]) == 2", "assert maximumNumberOfStringPairs([\"ab\",\"ba\",\"cc\"]) == 1", "assert maximumNumberOfStringPairs([\"aa\",\"ab\"]) == 0"]}
{"Contest id": "350/2742", "text_name": "Painting the Walls", "text": "You are given two 0-indexed integer arrays, cost and time, of size n representing the costs and the time taken to paint n different walls respectively. There are two painters available:\nA paid painter that paints the ith wall in time[i] units of time and takes cost[i] units of money.\nA free painter that paints any wall in 1 unit of time at a cost of 0. But the free painter can only be used if the paid painter is already occupied.\nReturn the minimum amount of money required to paint the n walls.", "canonical_solution": "def paintWalls(cost, time):\n   from math import inf\n   n = len(cost)\n   dp = [0] + [inf] * n\n   for c, t in zip(cost, time):\n       for j in range(n, 0, -1):\n           dp[j] = min(dp[j], dp[max(j - t - 1, 0)] + c)\n   return dp[n]", "entry_point": "paintWalls", "test_list": ["assert paintWalls(cost = [1,2,3,2], time = [1,2,3,2]) == 3", "assert paintWalls(cost = [2,3,4,2], time = [1,1,1,1]) == 4"]}
{"Contest id": "350/2741", "text_name": "Special Permutations", "text": "You are given a 0-indexed integer array nums containing n distinct positive integers. A permutation of nums is called special if:\nFor all indexes 0 <= i < n - 1, either nums[i] % nums[i+1] == 0 or nums[i+1] % nums[i] == 0.\nReturn the total number of special permutations. As the answer could be large, return it modulo 109 + 7.\n", "canonical_solution": "def specialPerm(nums):\n    n, MOD = len(nums), 10**9 + 7\n    def dfs(prev, mask):\n        if mask == (1 << n) - 1: return 1\n        count = 0\n        for i in range(n):\n            if not (mask & (1 << i)) and (nums[i] % prev == 0 or prev % nums[i] == 0):\n                count += dfs(nums[i], mask | (1 << i))\n        return count % MOD\n    return dfs(1, 0)", "entry_point": "specialPerm", "test_list": ["assert specialPerm([2,3,6]) == 2", "assert specialPerm([1,4,3]) == 2"]}
{"Contest id": "350/2740", "text_name": "Find the Value of the Partition", "text": "You are given a positive integer array nums.\nPartition nums into two arrays, nums1 and nums2, such that:\nEach element of the array nums belongs to either the array nums1 or the array nums2.\nBoth arrays are non-empty.\nThe value of the partition is minimized.\nThe value of the partition is |max(nums1) - min(nums2)|.\nHere, max(nums1) denotes the maximum element of the array nums1, and min(nums2) denotes the minimum element of the array nums2.\nReturn the integer denoting the value of such partition.", "canonical_solution": "def findValueOfPartition(A):\n    A.sort()\n    return min(A[i] - A[i - 1] for i in range(1, len(A)))", "entry_point": "findValueOfPartition", "test_list": ["assert findValueOfPartition([1,3,2,4]) == 1", "assert findValueOfPartition([100,1,10]) == 9"]}
{"Contest id": "350/2739", "text_name": "Total Distance Traveled", "text": "A truck has two fuel tanks. You are given two integers, mainTank representing the fuel present in the main tank in liters and additionalTank representing the fuel present in the additional tank in liters.\nThe truck has a mileage of 10 km per liter. Whenever 5 liters of fuel get used up in the main tank, if the additional tank has at least 1 liters of fuel, 1 liters of fuel will be transferred from the additional tank to the main tank.\nReturn the maximum distance which can be traveled.\nNote: Injection from the additional tank is not continuous. It happens suddenly and immediately for every 5 liters consumed.", "canonical_solution": "def distanceTraveled(a, b):\n    return (a + min((a - 1) // 4, b)) * 10", "entry_point": "distanceTraveled", "test_list": ["assert distanceTraveled(a = 5, b = 10) == 60", "assert distanceTraveled(a = 1, b = 2) == 10"]}
{"Contest id": "349/2735", "text_name": "Collecting Chocolates", "text": "You are given a 0-indexed integer array nums of size n representing the cost of collecting different chocolates. The cost of collecting the chocolate at the index i is nums[i]. Each chocolate is of a different type, and initially, the chocolate at the index i is of ith type.\nIn one operation, you can do the following with an incurred cost of x:\nSimultaneously change the chocolate of ith type to ((i + 1) mod n)th type for all chocolates.\nReturn the minimum cost to collect chocolates of all types, given that you can perform as many operations as you would like.", "canonical_solution": "def minCost(A, x):\n  n = len(A)\n  res = [x * k for k in range(n)]\n  for i in range(n):\n      cur = A[i]\n      for k in range(n):\n          cur = min(cur, A[i - k])\n          res[k] += cur\n  return min(res)", "entry_point": "minCost", "test_list": ["assert minCost(A = [20,1,15], x = 5) == 13", "assert minCost(A = [1,2,3], x = 4) == 6"]}
{"Contest id": "349/2734", "text_name": "Lexicographically Smallest String After Substring Operation", "text": "You are given a string s consisting of only lowercase English letters. In one operation, you can do the following:\nSelect any non-empty substring of s, possibly the entire string, then replace each one of its characters with the previous character of the English alphabet. For example, 'b' is converted to 'a', and 'a' is converted to 'z'.\nReturn the lexicographically smallest string you can obtain after performing the above operation exactly once.\nA substring is a contiguous sequence of characters in a string.\nA string x is lexicographically smaller than a string y of the same length if x[i] comes before y[i] in alphabetic order for the first position i such that x[i] != y[i].", "canonical_solution": "def smallestString(s):\n   i = 0\n   n = len(s)\n   s = list(s)\n   while i < n and s[i] == 'a':\n       i += 1\n   if i == n:\n       s[-1] = 'z'\n   while i < n and s[i] != 'a':\n       s[i] = chr(ord(s[i]) - 1)\n       i += 1\n   return ''.join(s)", "entry_point": "smallestString", "test_list": ["assert smallestString(\"cbabc\") == \"baabc\"", "assert smallestString(\"acbbc\") == \"abaab\"", "assert smallestString(\"leetcode\") == \"kddsbncd\""]}
{"Contest id": "349/2733", "text_name": "Neither Minimum nor Maximum", "text": "Given an integer array nums containing distinct positive integers, find and return any number from the array that is neither the minimum nor the maximum value in the array, or -1 if there is no such number.\nReturn the selected integer.", "canonical_solution": "def findNonMinOrMax(A):\n    return -1 if len(A) < 3 else sum(A[:3]) - min(A[:3]) - max(A[:3])", "entry_point": "findNonMinOrMax", "test_list": ["assert findNonMinOrMax([3,2,1,4]) == 2", "assert findNonMinOrMax([1,2]) == -1", "assert findNonMinOrMax([2,1,3]) == 2"]}
{"Contest id": "Bi106/2732", "text_name": "Find a Good Subset of the Matrix", "text": "You are given a 0-indexed m x n binary matrix grid.\nLet us call a non-empty subset of rows good if the sum of each column of the subset is at most half of the length of the subset.\nMore formally, if the length of the chosen subset of rows is k, then the sum of each column should be at most floor(k / 2).\nReturn an integer array that contains row indices of a good subset sorted in ascending order.\nIf there are multiple good subsets, you can return any of them. If there are no good subsets, return an empty array.\nA subset of rows of the matrix grid is any matrix that can be obtained by deleting some (possibly none or all) rows from grid.", "canonical_solution": "def goodSubsetofBinaryMatrix(grid):\n    idx = {}\n    for i, row in enumerate(grid):\n        mask = 0\n        for j, x in enumerate(row):\n            mask |= x << j\n        idx[mask] = i\n    if 0 in idx:\n        return [idx[0]]\n    for x, i in idx.items():\n        for y, j in idx.items():\n            if (x & y) == 0:\n                return sorted((i, j))\n    return []", "entry_point": "goodSubsetofBinaryMatrix", "test_list": ["assert goodSubsetofBinaryMatrix([[0,1,1,0],[0,0,0,1],[1,1,1,1]]) == [0,1]", "assert goodSubsetofBinaryMatrix([[0]]) == [0]"]}
{"Contest id": "Bi106/2731", "text_name": "Movement of Robots", "text": "Some robots are standing on an infinite number line with their initial coordinates given by a 0-indexed integer array nums and will start moving once given the command to move. The robots will move a unit distance each second.\nYou are given a string s denoting the direction in which robots will move on command. 'L' means the robot will move towards the left side or negative side of the number line, whereas 'R' means the robot will move towards the right side or positive side of the number line.\nIf two robots collide, they will start moving in opposite directions.\nReturn the sum of distances between all the pairs of robots d seconds after the command. Since the sum can be very large, return it modulo 109 + 7.", "canonical_solution": "def sumDistance(A, s, d):\n    n = len(A)\n    B = sorted(A[i] + (d if s[i] == 'R' else -d) for i in range(n))\n    return sum((i + i + 1 - n) * a for i,a in enumerate(B)) % (10 ** 9 + 7)", "entry_point": "sumDistance", "test_list": ["assert sumDistance(A = [-2,0,2], s = \"RLL\", d = 3) == 8", "assert sumDistance(A = [1,0], s = \"RL\", d = 2) == 5"]}
{"Contest id": "Bi106/2730", "text_name": "Find the Longest Semi-Repetitive Substring", "text": "You are given a 0-indexed string s that consists of digits from 0 to 9.\nA string t is called a semi-repetitive if there is at most one consecutive pair of the same digits inside t. For example, 0010, 002020, 0123, 2002, and 54944 are semi-repetitive while 00101022, and 1101234883 are not.\nReturn the length of the longest semi-repetitive substring inside s.\nA substring is a contiguous non-empty sequence of characters within a string.", "canonical_solution": "def longestSemiRepetitiveSubstring(s):\n  i = cur = 0\n  for j in range(1, len(s)):\n      cur += s[j] == s[j - 1]\n      if cur > 1:\n          i += 1\n          cur -= s[i] == s[i - 1]\n  return len(s) - i", "entry_point": "longestSemiRepetitiveSubstring", "test_list": ["assert longestSemiRepetitiveSubstring(\"52233\") == 4", "assert longestSemiRepetitiveSubstring(\"5494\") == 4", "assert longestSemiRepetitiveSubstring(\"1111111\") == 2"]}
{"Contest id": "Bi106/2729", "text_name": "Check if The Number is Fascinating", "text": "You are given an integer n that consists of exactly 3 digits.\nWe call the number n fascinating if, after the following modification, the resulting number contains all the digits from 1 to 9 exactly once and does not contain any 0's:\nConcatenate n with the numbers 2 * n and 3 * n.\nReturn true if n is fascinating, or false otherwise.\nConcatenating two numbers means joining them together. For example, the concatenation of 121 and 371 is 121371.", "canonical_solution": "def isFascinating(n):\n    from collections import Counter\n    DIGITS = Counter('123456789')\n    return Counter(str(n) + str(2 * n) + str(3 * n)) == DIGITS", "entry_point": "isFascinating", "test_list": ["assert isFascinating(192) == True", "assert isFascinating(100) == False"]}
{"Contest id": "348/2719", "text_name": "Count of Integers", "text": "You are given two numeric strings num1 and num2 and two integers max_sum and min_sum. We denote an integer x to be good if:\nnum1 <= x <= num2\nmin_sum <= digit_sum(x) <= max_sum.\nReturn the number of good integers. Since the answer may be large, return it modulo 109 + 7.\nNote that digit_sum(x) denotes the sum of the digits of x.", "canonical_solution": "def count(num1, num2, min_sum, max_sum):\n   def f(size, sm):\n       def dp(i, curr, lower):\n           if curr > sm:\n               return 0\n           if i == len(size):\n               return 1\n           ans = 0\n           if lower:\n               for num in range(10):\n                  ans += dp(i + 1, curr + num, lower)\n           else:\n               for num in range(1 + int(size[i])):\n                  ans += dp(i + 1, curr + num, num < int(size[i]))\n           return ans % (10**9+7)\n       size = str(size)\n       return dp(0, 0, False)\n   num1 = int(num1)\n   num2 = int(num2)\n   return (f(num2, max_sum) - f(num1 - 1, max_sum) - f(num2, min_sum - 1) + f(num1 - 1, min_sum - 1)) % (10**9+7)", "entry_point": "count", "test_list": ["assert count(num1 = \"1\", num2 = \"12\", min_sum = 1, max_sum = 8) == 11", "assert count(num1 = \"1\", num2 = \"5\", min_sum = 1, max_sum = 5) == 5"]}
{"Contest id": "348/2718", "text_name": "Sum of Matrix After Queries", "text": "You are given an integer n and a 0-indexed 2D array queries where queries[i] = [typei, indexi, vali].\nInitially, there is a 0-indexed n x n matrix filled with 0's. For each query, you must apply one of the following changes:\nif typei == 0, set the values in the row with indexi to vali, overwriting any previous values.\nif typei == 1, set the values in the column with indexi to vali, overwriting any previous values.\nReturn the sum of integers in the matrix after all queries are applied.", "canonical_solution": "def matrixSumQueries(n, queries):\n   col, row = {}, {}\n   res = 0\n   for t, i, v in queries[::-1]:\n       if t == 0 and i not in row:\n           row[i] = v\n           res += v * (n - len(col))\n       if t == 1 and i not in col:\n           col[i] = v\n           res += v * (n - len(row))\n   return res", "entry_point": "matrixSumQueries", "test_list": ["assert matrixSumQueries(n = 3, queries = [[0,0,1],[1,2,2],[0,2,3],[1,0,4]]) == 23", "assert matrixSumQueries(n = 3, queries = [[0,0,4],[0,1,2],[1,0,1],[0,2,3],[1,2,1]]) == 17"]}
{"Contest id": "348/2717", "text_name": "Semi-Ordered Permutation", "text": "You are given a 0-indexed permutation of n integers nums.\nA permutation is called semi-ordered if the first number equals 1 and the last number equals n. You can perform the below operation as many times as you want until you make nums a semi-ordered permutation:\nPick two adjacent elements in nums, then swap them.\nReturn the minimum number of operations to make nums a semi-ordered permutation.\nA permutation is a sequence of integers from 1 to n of length n containing each number exactly once.", "canonical_solution": "def semiOrderedPermutation(A):\n    n = len(A)\n    i, j = A.index(1), A.index(n)\n    return i + n - 1 - j - (i > j)", "entry_point": "semiOrderedPermutation", "test_list": ["assert semiOrderedPermutation([2,1,4,3]) == 2", "assert semiOrderedPermutation([2,4,1,3]) == 3", "assert semiOrderedPermutation([1,3,4,2,5]) == 0"]}
{"Contest id": "348/2716", "text_name": "Minimize String Length", "text": "Given a 0-indexed string s, repeatedly perform the following operation any number of times:\nChoose an index i in the string, and let c be the character in position i. Delete the closest occurrence of c to the left of i (if any) and the closest occurrence of c to the right of i (if any).\nYour task is to minimize the length of s by performing the above operation any number of times.\nReturn an integer denoting the length of the minimized string.", "canonical_solution": "def minimizedStringLength(s):\n    return len(set(s))", "entry_point": "minimizedStringLength", "test_list": ["assert minimizedStringLength(\"aaabc\") == 3", "assert minimizedStringLength(\"cbbd\") == 3", "assert minimizedStringLength(\"dddaaa\") == 2"]}
{"Contest id": "347/2713", "text_name": "Maximum Strictly Increasing Cells in a Matrix", "text": "Given a 1-indexed m x n integer matrix mat, you can select any cell in the matrix as your starting cell.\nFrom the starting cell, you can move to any other cell in the same row or column, but only if the value of the destination cell is strictly greater than the value of the current cell. You can repeat this process as many times as possible, moving from cell to cell until you can no longer make any moves.\nYour task is to find the maximum number of cells that you can visit in the matrix by starting from some cell.\nReturn an integer denoting the maximum number of cells that can be visited.", "canonical_solution": "def maxIncreasingCells(M):\n   m, n = len(M), len(M[0])\n   A = defaultdict(list)\n   for i in range(m):\n       for j in range(n):\n           A[M[i][j]].append([i, j])\n   dp = [[0] * n for i in range(m)]\n   res = [0] * (n + m)\n   for a in sorted(A):\n       for i, j in A[a]:\n           dp[i][j] = max(res[i], res[~j]) + 1\n       for i, j in A[a]:\n           res[~j] = max(res[~j], dp[i][j])\n           res[i] = max(res[i], dp[i][j])\n   return max(res)", "entry_point": "maxIncreasingCells", "test_list": ["assert maxIncreasingCells([[3,1],[3,4]]) == 2", "assert maxIncreasingCells([[1,1],[1,1]]) == 1", "assert maxIncreasingCells([[3,1,6],[-9,5,7]]) == 4"]}
{"Contest id": "347/2712", "text_name": "Minimum Cost to Make All Characters Equal", "text": "You are given a 0-indexed binary string s of length n on which you can apply two types of operations:\nChoose an index i and invert all characters from index 0 to index i (both inclusive), with a cost of i + 1\nChoose an index i and invert all characters from index i to index n - 1 (both inclusive), with a cost of n - i\nReturn the minimum cost to make all characters of the string equal.\nInvert a character means if its value is '0' it becomes '1' and vice-versa.\n", "canonical_solution": "def minimumCost(s):\n    n = len(s)\n    return sum(min(i, n - i) for i in range(1, n) if s[i] != s[i - 1])", "entry_point": "minimumCost", "test_list": ["assert minimumCost(\"0011\") == 2", "assert minimumCost(\"010101\") == 9"]}
{"Contest id": "347/2711", "text_name": "Difference of Number of Distinct Values on Diagonals", "text": "Given a 0-indexed 2D grid of size m x n, you should find the matrix answer of size m x n.\nThe value of each cell (r, c) of the matrix answer is calculated in the following way:\nLet topLeft[r][c] be the number of distinct values in the top-left diagonal of the cell (r, c) in the matrix grid.\nLet bottomRight[r][c] be the number of distinct values in the bottom-right diagonal of the cell (r, c) in the matrix grid.\nThen answer[r][c] = |topLeft[r][c] - bottomRight[r][c]|.\nReturn the matrix answer.\nA matrix diagonal is a diagonal line of cells starting from some cell in either the topmost row or leftmost column and going in the bottom-right direction until reaching the matrix's end.\nA cell (r1, c1) belongs to the top-left diagonal of the cell (r, c), if both belong to the same diagonal and r1 < r. Similarly is defined bottom-right diagonal.", "canonical_solution": "def differenceOfDistinctValues(grid):\n   ar = []\n   ro = len(grid)\n   co = len(grid[0])\n   for i in range(len(grid)):\n       ls = []\n       for j in range(len(grid[i])):\n           le = set()\n           re = set()\n           x = i - 1\n           y = j - 1\n           while x >= 0 and y >= 0:\n               le.add(grid[x][y])\n               x -= 1\n               y -= 1\n           x = i + 1\n           y = j + 1\n           while x < ro and y < co:\n               re.add(grid[x][y])\n               x += 1\n               y += 1\n           ls.append(abs(len(le) - len(re)))\n       ar.append(ls)\n   return ar", "entry_point": "differenceOfDistinctValues", "test_list": ["assert differenceOfDistinctValues([[1,2,3],[3,1,5],[3,2,1]]) == [[1,1,0],[1,0,1],[0,1,1]]", "assert differenceOfDistinctValues([[1]]) == [[0]]"]}
{"Contest id": "347/2710", "text_name": "Remove Trailing Zeros From a String", "text": "Given a positive integer num represented as a string, return the integer num without trailing zeros as a string.", "canonical_solution": "def removeTrailingZeros(num):\n    return num.rstrip('0')", "entry_point": "removeTrailingZeros", "test_list": ["assert removeTrailingZeros(\"51230100\") == \"512301\"", "assert removeTrailingZeros(\"123\") == \"123\""]}
{"Contest id": "Bi105/2709", "text_name": "Greatest Common Divisor Traversal", "text": "You are given a 0-indexed integer array nums, and you are allowed to traverse between its indices. You can traverse between index i and index j, i != j, if and only if gcd(nums[i], nums[j]) > 1, where gcd is the greatest common divisor.\nYour task is to determine if for every pair of indices i and j in nums, where i < j, there exists a sequence of traversals that can take us from i to j.\nReturn true if it is possible to traverse between all such pairs of indices, or false otherwise.", "canonical_solution": "def canTraverseAllPairs(nums):\n   n = len(nums)\n   if n == 1:\n       return True\n   f = [_ for _ in range(0, n)]\n   num = [1] * n    \n   def getf(x):\n       if f[x] == x:\n           return x\n       f[x] = getf(f[x])\n       return f[x]\n   def merge(x, y):\n       x, y = getf(x), getf(y)\n       if x == y:\n           return\n       if num[x] < num[y]:\n           x, y = y, x\n       f[y] = x\n       num[x] += num[y]\n   have = {}\n   for i in range(0, n):\n       x = nums[i]\n       if x == 1:\n           return False\n       d = 2\n       while d * d <= x:\n           if x % d == 0:\n               if d in have:\n                  merge(i, have[d])\n               else:\n                  have[d] = i\n               while x % d == 0:\n                  x //= d\n           d += 1\n       if x > 1:\n           if x in have:\n               merge(i, have[x])\n           else:\n               have[x] = i\n   return num[getf(0)] == n", "entry_point": "canTraverseAllPairs", "test_list": ["assert canTraverseAllPairs([2,3,6]) == True", "assert canTraverseAllPairs([3,9,5]) == False", "assert canTraverseAllPairs([4,3,12,8]) == True"]}
{"Contest id": "Bi105/2708", "text_name": "Maximum Strength of a Group", "text": "You are given a 0-indexed integer array nums representing the score of students in an exam. The teacher would like to form one non-empty group of students with maximal strength, where the strength of a group of students of indices i0, i1, i2, ... , ik is defined as nums[i0] * nums[i1] * nums[i2] * ... * nums[ik].\nReturn the maximum strength of a group the teacher can create.", "canonical_solution": "import math\ndef maxStrength(nums):\n    negs = []\n    pos = []   \n    for num in nums:\n        if num < 0:\n            negs.append(num)\n        elif num > 0:\n            pos.append(num)\n    prod = 1\n    x = nums.count(0)\n    negs.sort()\n    if len(negs) <= 1 and len(pos) == 0:\n        return max(nums)\n    if len(negs) % 2 == 0:\n        for num in negs:\n            prod *= num\n        for num in pos:\n            prod *= num\n        return prod\n    else:\n        for i in range(len(negs) - 1):\n            prod *= negs[i]\n        for num in pos:\n            prod *= num\n        return prod", "entry_point": "maxStrength", "test_list": ["assert maxStrength([3,-1,-5,2,5,-9]) == 1350", "assert maxStrength([-4,-5,-4]) == 20"]}
{"Contest id": "Bi105/2707", "text_name": "Extra Characters in a String", "text": "You are given a 0-indexed string s and a dictionary of words dictionary. You have to break s into one or more non-overlapping substrings such that each substring is present in dictionary. There may be some extra characters in s which are not present in any of the substrings.\nReturn the minimum number of extra characters left over if you break up s optimally.", "canonical_solution": "from collections import defaultdict\ndef minExtraChar(s, dictionary):\n    n = len(s)\n    word_dict = defaultdict(list)\n    for word in dictionary:\n        word_dict[word[0]].append(word)\n    result = [0] * (n + 1)\n    for i in range(n - 1, -1, -1):\n        result[i] = result[i + 1] + 1\n        if s[i] in word_dict:\n            for word in word_dict[s[i]]:\n                if s[i:i + len(word)] == word:\n                    result[i] = min(result[i], result[i + len(word)])\n    return result[0]\n", "entry_point": "minExtraChar", "test_list": ["assert minExtraChar(s = \"leetscode\", dictionary = [\"leet\",\"code\",\"leetcode\"]) == 1", "assert minExtraChar(s = \"sayhelloworld\", dictionary = [\"hello\",\"world\"]) == 3"]}
{"Contest id": "Bi105/2706", "text_name": "Buy Two Chocolates", "text": "You are given an integer array prices representing the prices of various chocolates in a store. You are also given a single integer money, which represents your initial amount of money.\nYou must buy exactly two chocolates in such a way that you still have some non-negative leftover money. You would like to minimize the sum of the prices of the two chocolates you buy.\nReturn the amount of money you will have leftover after buying the two chocolates. If there is no way for you to buy two chocolates without ending up in debt, return money. Note that the leftover must be non-negative.", "canonical_solution": "def buyChoco(arr, key):\n    ans = float('inf')\n    for i in range(len(arr)):\n        for j in range(len(arr)):\n            if i != j:\n                total = arr[i] + arr[j]\n                ans = min(ans, total)\n    fin = key - ans\n    if(fin>=0):\n        return fin\n    else:\n        return key\n        ", "entry_point": "buyChoco", "test_list": ["assert buyChoco([1,2,2], 3) == 0", "assert buyChoco([3,2,3], 3) == 3"]}
{"Contest id": "346/2699", "text_name": "Modify Graph Edge Weights", "text": "You are given an undirected weighted connected graph containing n nodes labeled from 0 to n - 1, and an integer array edges where edges[i] = [ai, bi, wi] indicates that there is an edge between nodes ai and bi with weight wi.\nSome edges have a weight of -1 (wi = -1), while others have a positive weight (wi > 0).\nYour task is to modify all edges with a weight of -1 by assigning them positive integer values in the range [1, 2 * 109] so that the shortest distance between the nodes source and destination becomes equal to an integer target. If there are multiple modifications that make the shortest distance between source and destination equal to target, any of them will be considered correct.\nReturn an array containing all edges (even unmodified ones) in any order if it is possible to make the shortest distance from source to destination equal to target, or an empty array if it's impossible.\nNote: You are not allowed to modify the weights of edges with initial positive weights.", "canonical_solution": "def modifiedGraphEdges(n, edges, source, destination, target):\n    def dijkstra(adj_matrix):\n        dist = [float(\"inf\")] * n\n        used = set()\n        dist[source] = 0\n        for round in range(n - 1):\n            u = -1\n            for i in range(n):\n                if i not in used and (u == -1 or dist[i] < dist[u]):\n                    u = i\n            used.add(u)\n            for v in range(n):\n                if v not in used and adj_matrix[u][v] != -1:\n                    dist[v] = min(dist[v], dist[u] + adj_matrix[u][v])\n        return dist[destination]\n    def construct(idx) :\n        adj_matrix = [[-1] * n for _ in range(n)]\n        for u, v, w in edges:\n            if w != -1:\n                adj_matrix[u][v] = adj_matrix[v][u] = w\n            else:\n                if idx >= target - 1:\n                    adj_matrix[u][v] = adj_matrix[v][u] = target\n                    idx -= (target - 1)\n                else:\n                    adj_matrix[u][v] = adj_matrix[v][u] = 1 + idx\n                    idx = 0\n        return adj_matrix\n    k = sum(1 for e in edges if e[2] == -1)\n    if dijkstra(construct(0)) > target:\n        return []\n    if dijkstra(construct(k * (target - 1))) < target:\n        return []\n    left, right, ans = 0, k * (target - 1), 0\n    while left <= right:\n        mid = (left + right) // 2\n        if dijkstra(construct(mid)) >= target:\n            ans = mid\n            right = mid - 1\n        else:\n            left = mid + 1\n    for i, e in enumerate(edges):\n        if e[2] == -1:\n            if ans >= target - 1:\n                edges[i][2] = target\n                ans -= (target - 1)\n            else:\n                edges[i][2] = 1 + ans\n                ans = 0\n    return edges", "entry_point": "modifiedGraphEdges", "test_list": ["assert modifiedGraphEdges(n = 5, edges = [[4,1,-1],[2,0,-1],[0,3,-1],[4,3,-1]], source = 0, destination = 1, target = 5) == [[4,1,3],[2,0,1],[0,3,1],[4,3,1]]", "assert modifiedGraphEdges(n = 3, edges = [[0,1,-1],[0,2,5]], source = 0, destination = 2, target = 6) == []", "assert modifiedGraphEdges(n = 4, edges = [[1,0,4],[1,2,3],[2,3,5],[0,3,-1]], source = 0, destination = 2, target = 6) == [[1,0,4],[1,2,3],[2,3,5],[0,3,1]]"]}
{"Contest id": "346/2698", "text_name": "Find the Punishment Number of an Integer", "text": "Given a positive integer n, return the punishment number of n.\nThe punishment number of n is defined as the sum of the squares of all integers i such that:\n1 <= i <= n\nThe decimal representation of i * i can be partitioned into contiguous substrings such that the sum of the integer values of these substrings equals i.", "canonical_solution": "def punishmentNumber(n):\n    def possible(sum_added,cache_sum, n, target):    \n        if not n:\n            return target == sum_added+cache_sum\n        num = int(n[0])\n        cas = cache_sum\n        return possible(sum_added,cas*10+num, n[1:], target) or possible(sum_added+cas,num, n[1:], target)\n    ans = 0\n    for i in range(1, n+1):\n           \n        if possible(0,0,str(i*i), i):\n            ans += i*i\n    return ans", "entry_point": "punishmentNumber", "test_list": ["assert punishmentNumber(10) == 182", "assert punishmentNumber(37) == 1478"]}
{"Contest id": "346/2697", "text_name": "Lexicographically Smallest Palindrome", "text": "You are given a string s consisting of lowercase English letters, and you are allowed to perform operations on it. In one operation, you can replace a character in s with another lowercase English letter.\nYour task is to make s a palindrome with the minimum number of operations possible. If there are multiple palindromes that can be made using the minimum number of operations, make the lexicographically smallest one.\nA string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b.\nReturn the resulting palindrome string.", "canonical_solution": "def makeSmallestPalindrome(s):\n    return ''.join(map(min, zip(s, s[::-1])))", "entry_point": "makeSmallestPalindrome", "test_list": ["assert makeSmallestPalindrome(\"egcfe\") == \"efcfe\"", "assert makeSmallestPalindrome(\"abcd\") == \"abba\"", "assert makeSmallestPalindrome(\"seven\") == \"neven\""]}
{"Contest id": "346/2696", "text_name": "Minimum String Length After Removing Substrings", "text": "You are given a string s consisting only of uppercase English letters.\nYou can apply some operations to this string where, in one operation, you can remove any occurrence of one of the substrings \"AB\" or \"CD\" from s.\nReturn the minimum possible length of the resulting string that you can obtain.\nNote that the string concatenates after removing the substring and could produce new \"AB\" or \"CD\" substrings.\n", "canonical_solution": "def minLength(s):\n    stack = []\n    for c in s:\n        if stack and stack[-1] + c in ('AB', 'CD'):\n            stack.pop()\n        else:\n            stack.append(c)\n\n    return len(stack)", "entry_point": "minLength", "test_list": ["assert minLength(\"ABFCACDB\") == 2", "assert minLength(\"ACBBD\") == 5"]}
{"Contest id": "345/2685", "text_name": "Count the Number of Complete Components", "text": "You are given an integer n. There is an undirected graph with n vertices, numbered from 0 to n - 1. You are given a 2D integer array edges where edges[i] = [ai, bi] denotes that there exists an undirected edge connecting vertices ai and bi.\nReturn the number of complete connected components of the graph.\nA connected component is a subgraph of a graph in which there exists a path between any two vertices, and no vertex of the subgraph shares an edge with a vertex outside of the subgraph.\nA connected component is said to be complete if there exists an edge between every pair of its vertices.", "canonical_solution": "def countCompleteComponents(n,edges):\n        adj=defaultdict(list)\n        for a,b in edges:\n            adj[a].append(b)\n            adj[b].append(a)   \n        def dfs(i):\n            component.add(i)\n            for child in adj[i]:\n                if child not in visited:\n                    visited.add(child)\n                    dfs(child)\n        ans=0\n        visited=set()\n        for i in range(n):\n            if i not in visited:\n                component=set()\n                visited.add(i)\n                dfs(i)\n                if all(len(adj[node]) == len(component)-1 for node in component):\n                    ans+=1\n        return ans", "entry_point": "countCompleteComponents", "test_list": ["assert countCompleteComponents(6,[[0,1],[0,2],[1,2],[3,4]])==3", "assert countCompleteComponents(6,[[0,1],[0,2],[1,2],[3,4],[3,5]])==1"]}
{"Contest id": "345/2684", "text_name": "Maximum Number of Moves in a Grid", "text": "You are given a 0-indexed m x n matrix grid consisting of positive integers.\nYou can start at any cell in the first column of the matrix, and traverse the grid in the following way:\nFrom a cell (row, col), you can move to any of the cells: (row - 1, col + 1), (row, col + 1) and (row + 1, col + 1) such that the value of the cell you move to, should be strictly bigger than the value of the current cell.\nReturn the maximum number of moves that you can perform.", "canonical_solution": "def maxMoves(grid):\n        def helper(row,col) :\n            if row < 0 or row >= m or col >= n:\n                return 0\n            if dp[row][col] != -1:\n                return dp[row][col]\n            directions = [(row - 1, col + 1), (row, col + 1), (row + 1, col + 1)]\n            max_moves = 0\n            for x,y in directions :\n                if x>=0 and x < m and (y < n) and grid[x][y] > grid[row][col] :\n                    if dp[x][y] != -1:\n                        max_moves = max(max_moves , 1+dp[x][y])\n                    else :\n                        max_moves = max(max_moves , 1+helper(x,y)) \n            dp[row][col] = max_moves\n            return dp[row][col]         \n        m = len(grid)\n        n = len(grid[0])  \n        ans = 0\n        dp = [[-1 for i in range(n)]for j in range(m)]\n        dp[m-1][n-1] = 0\n        for i in range(m):\n            ans = max(ans , helper(i,0))   \n        return ans", "entry_point": "maxMoves", "test_list": ["assert maxMoves([[2,4,3,5],[5,4,9,3],[3,4,2,11],[10,9,13,15]])==3", "assert maxMoves([[3,2,4],[2,1,9],[1,1,7]])==0"]}
{"Contest id": "345/2683", "text_name": "Neighboring Bitwise XOR", "text": "A 0-indexed array derived with length n is derived by computing the bitwise XOR (\u2295) of adjacent values in a binary array original of length n.\nSpecifically, for each index i in the range [0, n - 1]:\nIf i = n - 1, then derived[i] = original[i] \u2295 original[0].\nOtherwise, derived[i] = original[i] \u2295 original[i + 1].\nGiven an array derived, your task is to determine whether there exists a valid binary array original that could have formed derived.\nReturn true if such an array exists or false otherwise.\nA binary array is an array containing only 0's and 1's.", "canonical_solution": "def doesValidArrayExist(derived):\n    n = len(derived)\n    A = [0] * n\n    for i in range(n - 1):\n        A[i + 1] = A[i] ^ derived[i]\n    for i in range(n):\n        ni = (i + 1) % n\n        if (A[i] ^ A[ni]) != derived[i]:\n            return False\n    return True", "entry_point": "doesValidArrayExist", "test_list": ["assert doesValidArrayExist([1,1,0])==True", "assert doesValidArrayExist([1,1])==True", "assert doesValidArrayExist([1,0])==False"]}
{"Contest id": "345/2682", "text_name": "Find the Losers of the Circular Game", "text": "There are n friends that are playing a game. The friends are sitting in a circle and are numbered from 1 to n in clockwise order. More formally, moving clockwise from the ith friend brings you to the (i+1)th friend for 1 <= i < n, and moving clockwise from the nth friend brings you to the 1st friend.\nThe rules of the game are as follows:\n1st friend receives the ball.\nAfter that, 1st friend passes it to the friend who is k steps away from them in the clockwise direction.\nAfter that, the friend who receives the ball should pass it to the friend who is 2 * k steps away from them in the clockwise direction.\nAfter that, the friend who receives the ball should pass it to the friend who is 3 * k steps away from them in the clockwise direction, and so on and so forth.\nIn other words, on the ith turn, the friend holding the ball should pass it to the friend who is i * k steps away from them in the clockwise direction.\nThe game is finished when some friend receives the ball for the second time.\nThe losers of the game are friends who did not receive the ball in the entire game.\nGiven the number of friends, n, and an integer k, return the array answer, which contains the losers of the game in the ascending order.", "canonical_solution": "def circularGameLosers(n,k):\n    visited = [0] * n\n    count = 1\n    pos = 0\n    visited[pos] = 1\n    while (visited[pos]!=2):\n        pos = (pos+(count*k))%n\n        visited[pos]+=1\n        count+=1\n    res = []\n    for i in range(n):\n        if not visited[i]:\n            res.append(i+1)\n    return res", "entry_point": "circularGameLosers", "test_list": ["assert circularGameLosers(5,2)==[4,5]", "assert circularGameLosers(4,4)==[2,3,4]"]}
{"Contest id": "Bi104/2681", "text_name": "Power of Heroes", "text": "You are given a 0-indexed integer array nums representing the strength of some heroes. The power of a group of heroes is defined as follows:\nLet i0, i1, ... ,ik be the indices of the heroes in a group. Then, the power of this group is max(nums[i0], nums[i1], ... ,nums[ik])2 * min(nums[i0], nums[i1], ... ,nums[ik]).\nReturn the sum of the power of all non-empty groups of heroes possible. Since the sum could be very large, return it modulo 109 + 7.", "canonical_solution": "def sumOfPower(nums):\n        M = 10 ** 9 + 7\n        nums.sort()\n        res, s = 0, 0\n        for x in nums:\n            res += (x + s) * (x * x) \n            res %= M\n            s = (s * 2 + x) % M\n        return res", "entry_point": "sumOfPower", "test_list": ["assert sumOfPower([2,1,4])==141", "assert sumOfPower([1,1,1])==7"]}
{"Contest id": "Bi104/2680", "text_name": "Maximum OR", "text": "You are given a 0-indexed integer array nums of length n and an integer k. In an operation, you can choose an element and multiply it by 2.\nReturn the maximum possible value of nums[0] | nums[1] | ... | nums[n - 1] that can be obtained after applying the operation on nums at most k times.\nNote that a | b denotes the bitwise or between two integers a and b.", "canonical_solution": "def maximumOr(nums, k):\n        res, left, n = 0, 0, len(nums)\n        right = [0] * n\n        for i in range(n - 2, -1, -1):\n            right[i] = right[i + 1] | nums[i + 1]\n        for i in range(n):\n            res = max(res, left | nums[i] << k | right[i])\n            left |= nums[i]\n        return res", "entry_point": "maximumOr", "test_list": ["assert maximumOr([12,9],1)==30", "assert maximumOr([8,1,2],2)==35"]}
{"Contest id": "Bi104/2679", "text_name": "Sum in a Matrix", "text": "You are given a 0-indexed 2D integer array nums. Initially, your score is 0. Perform the following operations until the matrix becomes empty:\nFrom each row in the matrix, select the largest number and remove it. In the case of a tie, it does not matter which number is chosen.\nIdentify the highest number amongst all those removed in step 1. Add that number to your score.\nReturn the final score.", "canonical_solution": "def matrixSum(nums):\n        m, n = len(nums), len(nums[0])\n        res = 0\n        for num in nums: num.sort()\n        for j in range(n):\n            mx = 0\n            for i in range(m): mx = max(mx, nums[i][j])\n            res += mx\n        return res", "entry_point": "matrixSum", "test_list": ["assert matrixSum([[7,2,1],[6,4,2],[6,5,3],[3,2,1]])==15", "assert matrixSum([[1]])==1"]}
{"Contest id": "Bi104/2678", "text_name": "Number of Senior Citizens", "text": "You are given a 0-indexed array of strings details. Each element of details provides information about a given passenger compressed into a string of length 15. The system is such that:\nThe first ten characters consist of the phone number of passengers.\nThe next character denotes the gender of the person.\nThe following two characters are used to indicate the age of the person.\nThe last two characters determine the seat allotted to that person.\nReturn the number of passengers who are strictly more than 60 years old.", "canonical_solution": "def countSeniors(details):\n        count = 0\n        for item in details:\n            age = int(item[11]+item[12])\n            if age > 60:\n                count +=1\n        return count", "entry_point": "countSeniors", "test_list": ["assert countSeniors([\"7868190130M7522\",\"5303914400F9211\",\"9273338290F4010\"])==2", "assert countSeniors([\"1313579440F2036\",\"2921522980M5644\"])==0"]}
{"Contest id": "344/2673", "text_name": "Make Costs of Paths Equal in a Binary Tree", "text": "You are given an integer n representing the number of nodes in a perfect binary tree consisting of nodes numbered from 1 to n. The root of the tree is node 1 and each node i in the tree has two children where the left child is the node 2 * i and the right child is 2 * i + 1.\nEach node in the tree also has a cost represented by a given 0-indexed integer array cost of size n where cost[i] is the cost of node i + 1. You are allowed to increment the cost of any node by 1 any number of times.\nReturn the minimum number of increments you need to make the cost of paths from the root to each leaf node equal.\nNote:\nA perfect binary tree is a tree where each node, except the leaf nodes, has exactly 2 children.\nThe cost of a path is the sum of costs of nodes in the path.", "canonical_solution": "def minIncrements(n, cost):\n        res = 0\n        for i in range(n // 2 - 1, -1, -1):\n            l, r = i * 2 + 1, i * 2 + 2\n            res += abs(cost[l] - cost[r])\n            cost[i] += max(cost[l], cost[r])\n        return res", "entry_point": "minIncrements", "test_list": ["assert minIncrements(7,[1,5,2,2,3,3,1])==6", "assert minIncrements(3,[5,3,3])==0"]}
{"Contest id": "344/2672", "text_name": "Number of Adjacent Elements With the Same Color", "text": "There is a 0-indexed array nums of length n. Initially, all elements are uncolored (has a value of 0).\nYou are given a 2D integer array queries where queries[i] = [indexi, colori].\nFor each query, you color the index indexi with the color colori in the array nums.\nReturn an array answer of the same length as queries where answer[i] is the number of adjacent elements with the same color after the ith query.\nMore formally, answer[i] is the number of indices j, such that 0 <= j < n - 1 and nums[j] == nums[j + 1] and nums[j] != 0 after the ith query.", "canonical_solution": "def colorTheArray(n, queries):\n        count = 0\n        nums = [0] * n\n        result = []\n        for q in queries:\n            idx, val = q\n            \n            if idx > 0:\n                if nums[idx-1] == 0:\n                    pass\n                elif nums[idx] == nums[idx-1]:\n                    if nums[idx] != val and count > 0:\n                        count -= 1\n                else:\n                    if val == nums[idx-1]:\n                        count += 1\n            if idx+1 < n:\n                if nums[idx+1] == 0:\n                    pass\n                elif nums[idx] == nums[idx+1]:\n                    if nums[idx] != val and count > 0:\n                        count -= 1\n                else:\n                    if val == nums[idx+1]:\n                        count += 1\n            nums[idx] = val\n            result.append(count)\n        return result", "entry_point": "colorTheArray", "test_list": ["assert colorTheArray(4,[[0,2],[1,2],[3,1],[1,1],[2,1]])==[0,1,1,0,2]", "assert colorTheArray(1,[[0,100000]])==[0]"]}
{"Contest id": "344/2670", "text_name": "Find the Distinct Difference Array", "text": "You are given a 0-indexed array nums of length n.\nThe distinct difference array of nums is an array diff of length n such that diff[i] is equal to the number of distinct elements in the suffix nums[i + 1, ..., n - 1] subtracted from the number of distinct elements in the prefix nums[0, ..., i].\nReturn the distinct difference array of nums.\nNote that nums[i, ..., j] denotes the subarray of nums starting at index i and ending at index j inclusive. Particularly, if i > j then nums[i, ..., j] denotes an empty subarray.", "canonical_solution": "def distinctDifferenceArray(nums):\n        pre, suf = [], []\n        ps, ss = set(), set()\n        n = len(nums)\n        for i in range(n):\n            ps.add(nums[i])\n            pre.append(len(ps))\n        for i in range(n - 1, -1, -1):\n            suf.insert(0, len(ss))\n            ss.add(nums[i])\n        return [pre[i] - suf[i] for i in range(n)]", "entry_point": "distinctDifferenceArray", "test_list": ["assert distinctDifferenceArray([1,2,3,4,5])==[-3,-1,1,3,5]", "assert distinctDifferenceArray([3,2,3,4,2])==[-2,-1,0,2,3]"]}
{"Contest id": "343/2663", "text_name": "Lexicographically Smallest Beautiful String", "text": "A string is beautiful if:\nIt consists of the first k letters of the English lowercase alphabet.\nIt does not contain any substring of length 2 or more which is a palindrome.\nYou are given a beautiful string s of length n and a positive integer k.\nReturn the lexicographically smallest string of length n, which is larger than s and is beautiful. If there is no such string, return an empty string.\nA string a is lexicographically larger than a string b (of the same length) if in the first position where a and b differ, a has a character strictly larger than the corresponding character in b.\nFor example, \"abcd\" is lexicographically larger than \"abcc\" because the first position they differ is at the fourth character, and d is greater than c.", "canonical_solution": "def smallestBeautifulString(s, k):\n        i, n = len(s) - 1, len(s)\n        s = s[:i] + chr(ord(s[i]) + 1)\n        while i >= 0 and i < n:\n            if ord(s[i]) >= ord('a') + k:\n                s = s[:i] + 'a' + s[i + 1:]\n                i -= 1\n                if i >= 0:\n                    s = s[:i] + chr(ord(s[i]) + 1) + s[i + 1:]\n                else:\n                    break\n            elif (i - 1 >= 0 and s[i] == s[i - 1]) or (i - 2 >= 0 and s[i] == s[i - 2]):\n                s = s[:i] + chr(ord(s[i]) + 1) + s[i + 1:]\n            else:\n                i += 1\n        if i == -1:\n            s = \"\"\n        return s", "entry_point": "smallestBeautifulString", "test_list": ["assert smallestBeautifulString(\"abcz\",26)==\"abda\"", "assert smallestBeautifulString(\"dc\",4)==\"\""]}
{"Contest id": "343/2662", "text_name": "Minimum Cost of a Path With Special Roads", "text": "You are given an array start where start = [startX, startY] represents your initial position (startX, startY) in a 2D space. You are also given the array target where target = [targetX, targetY] represents your target position (targetX, targetY).\nThe cost of going from a position (x1, y1) to any other position in the space (x2, y2) is |x2 - x1| + |y2 - y1|.\nThere are also some special roads. You are given a 2D array specialRoads where specialRoads[i] = [x1i, y1i, x2i, y2i, costi] indicates that the ith special road can take you from (x1i, y1i) to (x2i, y2i) with a cost equal to costi. You can use each special road any number of times.\nReturn the minimum cost required to go from (startX, startY) to (targetX, targetY).", "canonical_solution": "def minimumCost(start, target, specialRoads):\n        specialRoads = [[a, b, c, d, x] for a, b, c, d, x in specialRoads if x < abs(a - c) + abs(b - d)]\n        dist = {(start[0], start[1]): 0}\n        heap = [(0, start[0], start[1])]\n        while len(heap) > 0:\n            currdist, x, y = heapq.heappop(heap)\n            for a, b, c, d, cost in specialRoads:\n                if dist.get((c, d), float('inf')) > currdist + abs(x - a) + abs(y - b) + cost:\n                    dist[(c, d)] = currdist + abs(x - a) + abs(y - b) + cost\n                    heapq.heappush(heap, (dist[(c, d)], c, d))\n        res = abs(target[0] - start[0]) + abs(target[1] - start[1])\n        for a, b, c, d, cost in specialRoads:\n            res = min(res, dist.get((c, d), float('inf')) + abs(target[0] - c) + abs(target[1] - d))\n        return res", "entry_point": "minimumCost", "test_list": ["assert minimumCost([1,1],[4,5],[[1,2,3,3,2],[3,4,4,5,1]])==5", "assert minimumCost([3,2],[5,7],[[3,2,3,4,4],[3,3,5,5,5],[3,4,5,6,6]])==7"]}
{"Contest id": "343/2661", "text_name": "First Completely Painted Row or Column", "text": "You are given a 0-indexed integer array arr, and an m x n integer matrix mat. arr and mat both contain all the integers in the range [1, m * n].\nGo through each index i in arr starting from index 0 and paint the cell in mat containing the integer arr[i].\nReturn the smallest index i at which either a row or a column will be completely painted in mat.", "canonical_solution": "def firstCompleteIndex(arr, mat):\n        m = len(mat)\n        n = len(mat[0])\n        map = {}\n        for i in range(m):\n            for j in range(n):\n                map[mat[i][j]] = [i, j]\n        row = [0] * m\n        col = [0] * n\n        for i in range(len(arr)):\n            x = map[arr[i]]\n            row[x[0]] += 1\n            col[x[1]] += 1\n            if row[x[0]] == n or col[x[1]] == m:\n                return i\n        return -1", "entry_point": "firstCompleteIndex", "test_list": ["assert firstCompleteIndex([1,3,4,2],[[1,4],[2,3]])==2", "assert firstCompleteIndex([2,8,7,4,1,3,5,6,9],[[3,2,5],[1,4,6],[8,7,9]])==3"]}
{"Contest id": "343/2660", "text_name": "Determine the Winner of a Bowling Game", "text": "You are given two 0-indexed integer arrays player1 and player2, that represent the number of pins that player 1 and player 2 hit in a bowling game, respectively.\nThe bowling game consists of n turns, and the number of pins in each turn is exactly 10.\nAssume a player hit xi pins in the ith turn. The value of the ith turn for the player is:\n2xi if the player hit 10 pins in any of the previous two turns.\nOtherwise, It is xi.\nThe score of the player is the sum of the values of their n turns.\nReturn\n1 if the score of player 1 is more than the score of player 2,\n2 if the score of player 2 is more than the score of player 1, and\n0 in case of a draw.", "canonical_solution": "def isWinner(p1, p2):\n        ans, s1, s2 = 0, 0, 0\n        n = len(p1)\n        for i in range(n):\n            s1 += p1[i]\n            s2 += p2[i]\n        if n > 1:\n            for i in range(1, n):\n                if p1[i - 1] == 10 or ((i >= 2) and p1[i - 2] == 10):\n                    s1 += p1[i]\n                if p2[i - 1] == 10 or ((i >= 2) and p2[i - 2] == 10):\n                    s2 += p2[i]\n        if s1 == s2:\n            ans = 0\n        elif s1 > s2:\n            ans = 1\n        else:\n            ans = 2\n        return ans", "entry_point": "isWinner", "test_list": ["assert isWinner([4,10,7,9],[6,5,2,3])==1", "assert isWinner([3,5,7,6],[8,10,10,2])==2", "assert isWinner([2,3],[4,1])==0"]}
{"Contest id": "Bi103/2659", "text_name": "Make Array Empty", "text": "You are given an integer array nums containing distinct numbers, and you can perform the following operations until the array is empty:\nIf the first element has the smallest value, remove it\nOtherwise, put the first element at the end of the array.\nReturn an integer denoting the number of operations it takes to make nums empty.", "canonical_solution": "def countOperationsToEmptyArray(A):\n        pos = {a: i for i, a in enumerate(A)}\n        res = n = len(A)\n        A.sort()\n        for i in range(1, n):\n            if pos[A[i]] < pos[A[i - 1]]:\n                res += n - i\n        return res", "entry_point": "countOperationsToEmptyArray", "test_list": ["assert countOperationsToEmptyArray([3,4,-1])==5", "assert countOperationsToEmptyArray([1,2,4,3])==5", "assert countOperationsToEmptyArray([1,2,3])==3"]}
{"Contest id": "Bi103/2658", "text_name": "Maximum Number of Fish in a Grid", "text": "You are given a 0-indexed 2D matrix grid of size m x n, where (r, c) represents:\nA land cell if grid[r][c] = 0, or\nA water cell containing grid[r][c] fish, if grid[r][c] > 0.\nA fisher can start at any water cell (r, c) and can do the following operations any number of times:\nCatch all the fish at cell (r, c), or\nMove to any adjacent water cell.\nReturn the maximum number of fish the fisher can catch if he chooses his starting cell optimally, or 0 if no water cell exists.\nAn adjacent cell of the cell (r, c), is one of the cells (r, c + 1), (r, c - 1), (r + 1, c) or (r - 1, c) if it exists.", "canonical_solution": "def findMaxFish(grid):\n        def dfs(i,j,grid,n,m):\n            f = grid[i][j]\n            grid[i][j] = 0\n            dr = [0, 1, 0, -1, 0]\n            for k in range(4):\n                nr = i + dr[k]\n                nc = j + dr[k + 1]\n                if nr >= 0 and nr < n and nc >= 0 and nc < m and grid[nr][nc] > 0:\n                    f += dfs(nr, nc, grid, n, m)\n            return f\n        n = len(grid)\n        m = len(grid[0])\n        ans = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > 0:\n                    ans = max(ans, dfs(i, j, grid, n, m))\n        return ans", "entry_point": "findMaxFish", "test_list": ["assert findMaxFish([[0,2,1,0],[4,0,0,3],[1,0,0,4],[0,3,2,0]])==7", "assert findMaxFish([[1,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,1]])==1"]}
{"Contest id": "Bi103/2657", "text_name": "Find the Prefix Common Array of Two Arrays", "text": "You are given two 0-indexed integer permutations A and B of length n.\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\nReturn the prefix common array of A and B.\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "canonical_solution": "def findThePrefixCommonArray(A, B):\n        n = len(A)\n        m1, m2 = {}, {}\n        for i in range(n):\n            m1[A[i]] = i\n            m2[B[i]] = i\n        c = [0] * n\n        for i in range(n):\n            cnt = 0\n            for j in range(i + 1):\n                if m1[A[j]] <= i and m2[A[j]] <= i:\n                    cnt += 1\n            c[i] = cnt\n        return c", "entry_point": "findThePrefixCommonArray", "test_list": ["assert findThePrefixCommonArray([1,3,2,4],[3,1,2,4])==[0,2,3,4]", "assert findThePrefixCommonArray([2,3,1],[3,1,2])==[0,1,3]"]}
{"Contest id": "Bi103/2656", "text_name": "Maximum Sum With Exactly K Elements", "text": "You are given a 0-indexed integer array nums and an integer k. Your task is to perform the following operation exactly k times in order to maximize your score:\nSelect an element m from nums.\nRemove the selected element m from the array.\nAdd a new element with a value of m + 1 to the array.\nIncrease your score by m.\nReturn the maximum score you can achieve after performing the operation exactly k times.", "canonical_solution": "def maximizeSum(nums, k):\n        return (max(nums))*k + (k-1)*k/2", "entry_point": "maximizeSum", "test_list": ["assert maximizeSum([1,2,3,4,5],3)==18", "assert maximizeSum([5,5,5],2)==11"]}
{"Contest id": "342/2654", "text_name": "Minimum Number of Operations to Make All Array Elements Equal to 1", "text": "You are given a 0-indexed array nums consisiting of positive integers. You can do the following operation on the array any number of times:\nSelect an index i such that 0 <= i < n - 1 and replace either of nums[i] or nums[i+1] with their gcd value.\nReturn the minimum number of operations to make all elements of nums equal to 1. If it is impossible, return -1.\nThe gcd of two integers is the greatest common divisor of the two integers.", "canonical_solution": "from math import inf, gcd\ndef minOperations(nums):\n        n = len(nums)\n        ones = nums.count(1)\n        if ones: return n - ones\n        res = inf\n        for i in range(n):\n            g = nums[i]\n            for j in range(i + 1, n):\n                g = gcd(g, nums[j])\n                if g == 1:\n                    res = min(res, j - i)\n        if res == inf: return -1\n        return res + n - 1", "entry_point": "minOperations", "test_list": ["assert minOperations([2,6,3,4])==4", "assert minOperations([2,10,6,14])==-1"]}
{"Contest id": "342/2652", "text_name": "Sum Multiples", "text": "Given a positive integer n, find the sum of all integers in the range [1, n] inclusive that are divisible by 3, 5, or 7.\nReturn an integer denoting the sum of all numbers in the given range satisfying the constraint.", "canonical_solution": "def sumOfMultiples(n):\n        mul = 0\n        for i in range(1, n+1):\n            if i%3==0 or i%5==0 or i%7==0:\n                mul+=i\n        return mul", "entry_point": "sumOfMultiples", "test_list": ["assert sumOfMultiples(7)==21", "assert sumOfMultiples(10)==40", "assert sumOfMultiples(9)==30"]}
{"Contest id": "342/2651", "text_name": "Calculate Delayed Arrival Time", "text": "You are given a positive integer arrivalTime denoting the arrival time of a train in hours, and another positive integer delayedTime denoting the amount of delay in hours.\nReturn the time when the train will arrive at the station.\nNote that the time in this problem is in 24-hours format.", "canonical_solution": "def findDelayedArrivalTime(at,dt):\n        arrive = at + dt\n        if arrive >= 24:\n            return arrive - 24\n        return arrive", "entry_point": "findDelayedArrivalTime", "test_list": ["assert findDelayedArrivalTime(15,5)==20", "assert findDelayedArrivalTime(13,11)==0"]}
{"Contest id": "341/2646", "text_name": "Minimize the Total Price of the Trips", "text": "There exists an undirected and unrooted tree with n nodes indexed from 0 to n - 1. You are given the integer n and a 2D integer array edges of length n - 1, where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nEach node has an associated price. You are given an integer array price, where price[i] is the price of the ith node.\nThe price sum of a given path is the sum of the prices of all nodes lying on that path.\nAdditionally, you are given a 2D integer array trips, where trips[i] = [starti, endi] indicates that you start the ith trip from the node starti and travel to the node endi by any path you like.\nBefore performing your first trip, you can choose some non-adjacent nodes and halve the prices.\nReturn the minimum total price sum to perform all the given trips.", "canonical_solution": "from collections import deque\ndef minimumTotalPrice(n, edges, price, trips):\n    tree = [[] for _ in range(n)]\n    for u, v in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    freq = [0] * n\n    for s, e in trips:\n        queue = deque([(s, -1)])\n        parent = {s: -1}\n        while queue:\n            u, p = queue.popleft()\n            if u == e: break\n            for v in tree[u]:\n                if v != p:\n                    queue.append((v, u))\n                    parent[v] = u\n        u = e\n        while u >= 0:\n            freq[u] += 1\n            u = parent[u]\n\n    def dfs(u, p):\n        full = half = 0\n        for v in tree[u]:\n            if v != p:\n                ff, hh = dfs(v, u)\n                full += ff\n                half += min(ff, hh)\n        return price[u] * freq[u] + half, price[u] * freq[u] // 2 + full\n\n    return min(dfs(0, -1))", "entry_point": "minimumTotalPrice", "test_list": ["assert minimumTotalPrice(4,[[0,1],[1,2],[1,3]],[2,2,10,6],[[0,3],[2,1],[2,3]])==23", "assert minimumTotalPrice(2,[[0,1]],[2,2],[[0,0]])==1"]}
{"Contest id": "341/2645", "text_name": "Minimum Additions to Make Valid String", "text": "Given a string word to which you can insert letters \"a\", \"b\" or \"c\" anywhere and any number of times, return the minimum number of letters that must be inserted so that word becomes valid.\nA string is called valid if it can be formed by concatenating the string \"abc\" several times.", "canonical_solution": "def addMinimum(word):\n        k, prev = 0, 'z'\n        for c in word:\n            k += c <= prev\n            prev = c\n        return k * 3 - len(word)", "entry_point": "addMinimum", "test_list": ["assert addMinimum(\"b\")==2", "assert addMinimum(\"aaa\")==6", "assert addMinimum(\"abc\")==0"]}
{"Contest id": "341/2644", "text_name": "Find the Maximum Divisibility Score", "text": "You are given two 0-indexed integer arrays nums and divisors.\nThe divisibility score of divisors[i] is the number of indices j such that nums[j] is divisible by divisors[i].\nReturn the integer divisors[i] with the maximum divisibility score. If there is more than one integer with the maximum score, return the minimum of them.", "canonical_solution": "def maxDivScore(nums, divisors):\n        res = -1\n        mx_cnt = -1\n        for d in divisors:\n            cnt = 0\n            for x in nums:\n                if x % d == 0:\n                    cnt += 1\n            if cnt > mx_cnt:\n                mx_cnt = cnt\n                res = d\n            elif cnt == mx_cnt:\n                res = min(res, d)\n        return res", "entry_point": "maxDivScore", "test_list": ["assert maxDivScore([4,7,9,3,9],[5,2,3])==3", "assert maxDivScore([20,14,21,10],[5,7,5])==5", "assert maxDivScore([12],[10,16])==10"]}
{"Contest id": "341/2643", "text_name": "Row With Maximum Ones", "text": "Given a m x n binary matrix mat, find the 0-indexed position of the row that contains the maximum count of ones, and the number of ones in that row.\nIn case there are multiple rows that have the maximum count of ones, the row with the smallest row number should be selected.\nReturn an array containing the index of the row, and the number of ones in it.", "canonical_solution": "def rowAndMaximumOnes(mat):\n        output = [0,0]\n        for index, item in enumerate(mat):\n            one_count = item.count(1)\n            if one_count > output[1]:\n                output[0] = index\n                output[1] = one_count\n        return output", "entry_point": "rowAndMaximumOnes", "test_list": ["assert rowAndMaximumOnes([[0,1],[1,0]])==[0,1]", "assert rowAndMaximumOnes([[0,0,0],[0,1,1]])==[1,2]", "assert rowAndMaximumOnes([[0,0],[1,1],[0,0]])==[1,2]"]}
{"Contest id": "Bi102/2640", "text_name": "Find the Score of All Prefixes of an Array", "text": "We define the conversion array conver of an array arr as follows:\nconver[i] = arr[i] + max(arr[0..i]) where max(arr[0..i]) is the maximum value of arr[j] over 0 <= j <= i.\nWe also define the score of an array arr as the sum of the values of the conversion array of arr.\nGiven a 0-indexed integer array nums of length n, return an array ans of length n where ans[i] is the score of the prefix nums[0..i].", "canonical_solution": "import heapq\nfrom heapq import heappush\ndef findPrefixScore(nums):\n    heap = [-nums[0]]\n    result = []\n    runningSum = 0\n    for num in nums:\n        maxSum = max(num, -1 * heapq.heappop(heap))\n        result.append(runningSum + num + maxSum)\n        runningSum += maxSum + num\n        heappush(heap, -maxSum)\n    return result", "entry_point": "findPrefixScore", "test_list": ["assert findPrefixScore([2,3,7,5,10])==[4,10,24,36,56]", "assert findPrefixScore([1,1,2,4,8,16])==[2,4,8,16,32,64]"]}
{"Contest id": "Bi102/2639", "text_name": "Find the Width of Columns of a Grid", "text": "You are given a 0-indexed m x n integer matrix grid. The width of a column is the maximum length of its integers.\nFor example, if grid = [[-10], [3], [12]], the width of the only column is 3 since -10 is of length 3.\nReturn an integer array ans of size n where ans[i] is the width of the ith column.\nThe length of an integer x with len digits is equal to len if x is non-negative, and len + 1 otherwise.", "canonical_solution": "def findColumnWidth(grid):\n        def cal(x):\n            res = 0\n            if x == 0:\n                res += 1\n            if x < 0:\n                res += 1\n                x = -x\n            while x > 0:\n                x //= 10\n                res += 1\n            return res\n        return [max(cal(y) for y in x) for x in zip(*grid)]", "entry_point": "findColumnWidth", "test_list": ["assert findColumnWidth([[1],[22],[333]])==[3]", "assert findColumnWidth([[-15,1,3],[15,7,12],[5,6,-2]])==[3,1,2]"]}
{"Contest id": "340/2617", "text_name": "Minimum Number of Visited Cells in a Grid", "text": "You are given a 0-indexed m x n integer matrix grid. Your initial position is at the top-left cell (0, 0).\nStarting from the cell (i, j), you can move to one of the following cells:\nCells (i, k) with j < k <= grid[i][j] + j (rightward movement), or\nCells (k, j) with i < k <= grid[i][j] + i (downward movement).\nReturn the minimum number of cells you need to visit to reach the bottom-right cell (m - 1, n - 1). If there is no valid path, return -1.", "canonical_solution": "def minimumVisitedCells(grid):\n        from collections import deque\n        from sortedcontainers import SortedList\n        m, n = len(grid), len(grid[0])\n        s0 = [SortedList(range(n)) for _ in range(m)]\n        s1 = [SortedList(range(m)) for _ in range(n)]\n        q = deque([(0, 0, 1)])\n        while q:\n            i, j, d = q.popleft()\n            if (i, j) == (m-1, n-1):\n                return d\n            for k in list(s0[i].irange(j+1, min(j+1+grid[i][j], n) - 1)):\n                q.append((i, k, d+1))\n                s0[i].remove(k)\n                s1[k].remove(i)\n            for k in list(s1[j].irange(i+1, min(i+1+grid[i][j], m) - 1)):\n                q.append((k, j, d+1))\n                s1[j].remove(k)\n                s0[k].remove(j)\n        return -1", "entry_point": "minimumVisitedCells", "test_list": ["assert minimumVisitedCells([[3,4,2,1],[4,2,3,1],[2,1,0,0],[2,4,0,0]])==4", "assert minimumVisitedCells([[3,4,2,1],[4,2,1,1],[2,1,1,0],[3,4,1,0]])==3", "assert minimumVisitedCells([[2,1,0],[1,0,0]])==-1"]}
{"Contest id": "340/2616", "text_name": "Minimize the Maximum Difference of Pairs", "text": "You are given a 0-indexed integer array nums and an integer p. Find p pairs of indices of nums such that the maximum difference amongst all the pairs is minimized. Also, ensure no index appears more than once amongst the p pairs.\nNote that for a pair of elements at the index i and j, the difference of this pair is |nums[i] - nums[j]|, where |x| represents the absolute value of x.\nReturn the minimum maximum difference among all p pairs. We define the maximum of an empty set to be zero.", "canonical_solution": "def minimizeMax(nums, p):\n    def can_form_pairs(mid):\n        count = 0\n        i = 0\n        while i < len(nums) - 1 and count < p:\n            if nums[i + 1] - nums[i] <= mid:\n                count += 1\n                i += 2\n            else:\n                i += 1\n        return count >= p\n\n    nums.sort()\n    left, right = 0, nums[-1] - nums[0]\n\n    while left < right:\n        mid = (left + right) // 2\n        if can_form_pairs(mid):\n            right = mid\n        else:\n            left = mid + 1\n\n    return left", "entry_point": "minimizeMax", "test_list": ["assert minimizeMax([10,1,2,7,1,3],2)==1", "assert minimizeMax([4,2,1,2],1)==0"]}
{"Contest id": "340/2615", "text_name": "Sum of Distances", "text": "You are given a 0-indexed integer array nums. There exists an array arr of length nums.length, where arr[i] is the sum of |i - j| over all j such that nums[j] == nums[i] and j != i. If there is no such j, set arr[i] to be 0.\nReturn the array arr.", "canonical_solution": "def distance(nums):\n        vals = defaultdict(lambda: [0])\n        for i, x in enumerate(nums):\n            vals[x].append(vals[x][-1] + i)\n        cnts = defaultdict(int)\n        ans = []\n        for i, x in enumerate(nums):\n            c = cnts[x]\n            sz = len(vals[x]) - 1\n            cur = c * i - vals[x][c] + (vals[x][-1] - vals[x][c]) - i * (sz - c)\n            cnts[x] += 1\n            ans.append(cur)\n        return ans", "entry_point": "distance", "test_list": ["assert distance([1,3,1,1,2])==[5,0,3,4,0]", "assert distance([0,5,3])==[0,0,0]"]}
{"Contest id": "340/2614", "text_name": "Prime In Diagonal", "text": "You are given a 0-indexed two-dimensional integer array nums.\nReturn the largest prime number that lies on at least one of the diagonals of nums. In case, no prime is present on any of the diagonals, return 0.\nNote that:\nAn integer is prime if it is greater than 1 and has no positive integer divisors other than 1 and itself.\nAn integer val is on one of the diagonals of nums if there exists an integer i for which nums[i][i] = val or an i for which nums[i][nums.length - i - 1] = val.", "canonical_solution": "def diagonalPrime(nums):\n        def is_prime(num):\n            if num <= 1:\n                return False\n            for i in range(2, int(num ** 0.5) + 1):\n                if num % i == 0:\n                    return False\n            return True\n        largest_prime = 0\n        n = len(nums)\n        for i in range(n):\n            if is_prime(nums[i][i]):\n                largest_prime = max(largest_prime, nums[i][i])\n            if is_prime(nums[i][n-i-1]):\n                largest_prime = max(largest_prime, nums[i][n-i-1])\n        return largest_prime", "entry_point": "diagonalPrime", "test_list": ["assert diagonalPrime([[1,2,3],[5,6,7],[9,10,11]])==11", "assert diagonalPrime([[1,2,3],[5,17,7],[9,11,10]])==17"]}
{"Contest id": "339/2612", "text_name": "Minimum Reverse Operations", "text": "You are given an integer n and an integer p in the range [0, n - 1]. Representing a 0-indexed array arr of length n where all positions are set to 0's, except position p which is set to 1.\nYou are also given an integer array banned containing some positions from the array. For the ith position in banned, arr[banned[i]] = 0, and banned[i] != p.\nYou can perform multiple operations on arr. In an operation, you can choose a subarray with size k and reverse the subarray. However, the 1 in arr should never go to any of the positions in banned. In other words, after each operation arr[banned[i]] remains 0.\nReturn an array ans where for each i from [0, n - 1], ans[i] is the minimum number of reverse operations needed to bring the 1 to position i in arr, or -1 if it is impossible.\nA subarray is a contiguous non-empty sequence of elements within an array.\nThe values of ans[i] are independent for all i's.\nThe reverse of an array is an array containing the values in reverse order.", "canonical_solution": "def minReverseOperations(n, p, banned, k):\n    from bisect import bisect_left\n    s = set(banned) | {p}\n    not_banned = [[], []]\n    for i in range(n):\n        if i not in s:\n            not_banned[i % 2].append(i)\n    not_banned[0].append(n)\n    not_banned[1].append(n)  # \u54e8\u5175\n    fa = [list(range(len(not_banned[0]))), list(range(len(not_banned[1])))]\n    def find(i, x) :\n        f = fa[i]\n        if f[x] != x:\n            f[x] = find(i, f[x])\n        return f[x]\n    def merge(i, from_, to) :\n        x, y = find(i, from_), find(i, to)\n        fa[i][x] = y\n    ans = [-1] * n\n    q = [p]\n    step = 0\n    while q:\n        tmp = q\n        q = []\n        for i in tmp:\n            ans[i] = step\n            mn = max(i - k + 1, k - i - 1)\n            mx = min(i + k - 1, n * 2 - k - i - 1)\n            a = not_banned[mn % 2]\n            j = find(mn % 2, bisect_left(a, mn))\n            while a[j] <= mx:\n                q.append(a[j])\n                merge(mn % 2, j, j + 1)  # \u5220\u9664 j\n                j = find(mn % 2, j + 1)\n        step += 1\n    return ans", "entry_point": "minReverseOperations", "test_list": ["assert minReverseOperations(4,0,[1,2],4)==[0,-1,-1,1]", "assert minReverseOperations(5,0,[2,4],3)==[0,-1,-1,-1,-1]", "assert minReverseOperations(4,2,[0,1,3],1)==[-1,-1,0,-1]"]}
{"Contest id": "339/2611", "text_name": "Mice and Cheese", "text": "There are two mice and n different types of cheese, each type of cheese should be eaten by exactly one mouse.\nA point of the cheese with index i (0-indexed) is:\nreward1[i] if the first mouse eats it.\nreward2[i] if the second mouse eats it.\nYou are given a positive integer array reward1, a positive integer array reward2, and a non-negative integer k.\nReturn the maximum points the mice can achieve if the first mouse eats exactly k types of cheese.", "canonical_solution": "def miceAndCheese(reward1, reward2, k):\n    a = sorted(zip(reward1, reward2), key=lambda p: p[1] - p[0])\n    return sum(x for x, _ in a[:k]) + sum(y for _, y in a[k:])", "entry_point": "miceAndCheese", "test_list": ["assert miceAndCheese(reward1 = [1,1,3,4], reward2 = [4,4,1,1], k = 2)==15", "assert miceAndCheese(reward1 = [1,1], reward2 = [1,1], k = 2)==2"]}
{"Contest id": "339/2610", "text_name": "Convert an Array Into a 2D Array With Conditions", "text": "You are given an integer array nums. You need to create a 2D array from nums satisfying the following conditions:\nThe 2D array should contain only the elements of the array nums.\nEach row in the 2D array contains distinct integers.\nThe number of rows in the 2D array should be minimal.\nReturn the resulting array. If there are multiple answers, return any of them.\nNote that the 2D array can have a different number of elements on each row.", "canonical_solution": "def findMatrix(nums):\n    from collections import Counter\n    ans = []\n    cnt = Counter(nums)\n    while cnt:\n        ans.append(list(cnt))\n        for x in ans[-1]:\n            cnt[x] -= 1\n            if cnt[x] == 0:\n                del cnt[x]\n    return ans", "entry_point": "findMatrix", "test_list": ["assert findMatrix([1,3,4,1,2,3,1])==[[1,3,4,2],[1,3],[1]]", "assert findMatrix([2,1,1])==[[2,1],[1]]"]}
{"Contest id": "339/2609", "text_name": "Find the Longest Balanced Substring of a Binary String", "text": "You are given a binary string s consisting only of zeroes and ones.\nA substring of s is considered balanced if all zeroes are before ones and the number of zeroes is equal to the number of ones inside the substring. Notice that the empty substring is considered a balanced substring.\nReturn the length of the longest balanced substring of s.\nA substring is a contiguous sequence of characters within a string.", "canonical_solution": "def findTheLongestBalancedSubstring(s):\n        temp = '01'\n        while temp in s:\n            temp = '0' + temp + '1'\n        return len(temp) - 2", "entry_point": "findTheLongestBalancedSubstring", "test_list": ["assert findTheLongestBalancedSubstring(\"01000111\")==6", "assert findTheLongestBalancedSubstring(\"00111\")==4", "assert findTheLongestBalancedSubstring(\"111\")==0"]}
{"Contest id": "Bi101/2608", "text_name": "Shortest Cycle in a Graph", "text": "There is a bi-directional graph with n vertices, where each vertex is labeled from 0 to n - 1. The edges in the graph are represented by a given 2D integer array edges, where edges[i] = [ui, vi] denotes an edge between vertex ui and vertex vi. Every vertex pair is connected by at most one edge, and no vertex has an edge to itself.\nReturn the length of the shortest cycle in the graph. If no cycle exists, return -1.\nA cycle is a path that starts and ends at the same node, and each edge in the path is used only once.", "canonical_solution": "from math import inf\ndef findShortestCycle(n, edges):\n        G = [[] for _ in range(n)]\n        for i, j in edges:\n            G[i].append(j)\n            G[j].append(i)\n        def root(i):\n            dis = [inf] * n\n            dis[i] = 0\n            bfs = [i]\n            for i in bfs:\n                for j in G[i]:\n                    if dis[j] == inf:\n                        dis[j] = 1 + dis[i]\n                        bfs.append(j)\n                    elif dis[i] <= dis[j]:\n                        return dis[i] + dis[j] + 1\n            return inf\n        res = min(map(root, range(n)))\n        return res if res < inf else -1", "entry_point": "findShortestCycle", "test_list": ["assert findShortestCycle(7,[[0,1],[1,2],[2,0],[3,4],[4,5],[5,6],[6,3]])==3", "assert findShortestCycle(4,[[0,1],[0,2]])==-1"]}
{"Contest id": "Bi101/2607", "text_name": "Make K-Subarray Sums Equal", "text": "You are given a 0-indexed integer array arr and an integer k. The array arr is circular. In other words, the first element of the array is the next element of the last element, and the last element of the array is the previous element of the first element.\nYou can do the following operation any number of times:\nPick any element from arr and increase or decrease it by 1.\nReturn the minimum number of operations such that the sum of each subarray of length k is equal.\nA subarray is a contiguous part of the array.", "canonical_solution": "def makeSubKSumEqual(arr, k):\n        def gcd(a, b):\n            if b == 0:\n                return a\n            return gcd(b, a % b)\n        n = len(arr)\n        v = [[] for i in range(n + 1)]\n        k = gcd(n, k)\n        for i in range(n):\n            v[i % k].append(arr[i])\n        ans = 0\n        for i in range(k):\n            v[i].sort()\n            x = v[i][len(v[i]) // 2]\n            for j in v[i]:\n                ans += abs(x - j)\n        return ans", "entry_point": "makeSubKSumEqual", "test_list": ["assert makeSubKSumEqual([1,4,1,3],2)==1", "assert makeSubKSumEqual([2,5,5,7],3)==5"]}
{"Contest id": "Bi101/2606", "text_name": "Find the Substring With Maximum Cost", "text": "You are given a string s, a string chars of distinct characters and an integer array vals of the same length as chars.\nThe cost of the substring is the sum of the values of each character in the substring. The cost of an empty string is considered 0.\nThe value of the character is defined in the following way:\nIf the character is not in the string chars, then its value is its corresponding position (1-indexed) in the alphabet.\nFor example, the value of 'a' is 1, the value of 'b' is 2, and so on. The value of 'z' is 26.\nOtherwise, assuming i is the index where the character occurs in the string chars, then its value is vals[i].\nReturn the maximum cost among all substrings of the string s.", "canonical_solution": "def maximumCostSubstring(s, chars, vals):\n        m = dict(zip(chars, vals))\n        res = cur = 0\n        for c in s:\n            cur = max(cur + m.get(c, ord(c) - ord('a') + 1), 0)\n            res = max(res, cur)\n        return res", "entry_point": "maximumCostSubstring", "test_list": ["assert maximumCostSubstring(\"adaa\",\"d\",[-1000])==2", "assert maximumCostSubstring(\"abc\",\"abc\",[-1,-1,-1])==0"]}
{"Contest id": "Bi101/2605", "text_name": "Form Smallest Number From Two Digit Arrays", "text": "Given two arrays of unique digits nums1 and nums2, return the smallest number that contains at least one digit from each array.", "canonical_solution": "def minNumber(nums1, nums2):\n        small1, small2, common = min(nums1), min(nums2), set(nums1) & set(nums2)\n        output1, output2 = int(f\"{small1}{small2}\"), int(f\"{small2}{small1}\")\n        if common:\n            common = min(common)\n            if common < output1 and common < output2:\n                return common\n        if small1 < small2:\n            return output1\n        return output2", "entry_point": "minNumber", "test_list": ["assert minNumber([4,1,3],[5,7])==15", "assert minNumber([3,5,2,6],[3,1,7])==3"]}
{"Contest id": "338/2603", "text_name": "Collect Coins in a Tree", "text": "There exists an undirected and unrooted tree with n nodes indexed from 0 to n - 1. You are given an integer n and a 2D integer array edges of length n - 1, where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree. You are also given an array coins of size n where coins[i] can be either 0 or 1, where 1 indicates the presence of a coin in the vertex i.\nInitially, you choose to start at any vertex in the tree. Then, you can perform the following operations any number of times: \nCollect all the coins that are at a distance of at most 2 from the current vertex, or\nMove to any adjacent vertex in the tree.\nFind the minimum number of edges you need to go through to collect all the coins and go back to the initial vertex.\nNote that if you pass an edge several times, you need to count it into the answer several times.", "canonical_solution": "def collectTheCoins(coins, edges):\n        n = len(coins)\n        tree = [set() for _ in range(n)]\n        for e in edges:\n            tree[e[0]].add(e[1])\n            tree[e[1]].add(e[0])\n        leaf = []\n        for i in range(n):\n            u = i\n            while len(tree[u]) == 1 and coins[u] == 0:\n                v = tree[u].pop()\n                tree[v].remove(u)\n                u = v\n            if len(tree[u]) == 1:\n                leaf.append(u)\n        for sz in range(2, 0, -1):\n            temp = []\n            for u in leaf:\n                if len(tree[u]) == 1:\n                    v = tree[u].pop()\n                    tree[v].remove(u)\n                    if len(tree[v]) == 1:\n                        temp.append(v)\n            leaf = temp\n        ans = 0\n        for i in range(n):\n            ans += len(tree[i])\n        return ans", "entry_point": "collectTheCoins", "test_list": ["assert collectTheCoins([1,0,0,0,0,1],[[0,1],[1,2],[2,3],[3,4],[4,5]])==2", "assert collectTheCoins([0,0,0,1,1,0,0,1],[[0,1],[0,2],[1,3],[1,4],[2,5],[5,6],[5,7]])==2"]}
{"Contest id": "338/2602", "text_name": "Minimum Operations to Make All Array Elements Equal", "text": "You are given an array nums consisting of positive integers.\nYou are also given an integer array queries of size m. For the ith query, you want to make all of the elements of nums equal to queries[i]. You can perform the following operation on the array any number of times:\nIncrease or decrease an element of the array by 1.\nReturn an array answer of size m where answer[i] is the minimum number of operations to make all elements of nums equal to queries[i].\nNote that after each query the array is reset to its original state.", "canonical_solution": "def minOperations(nums, queries):\n        nums.sort()\n        aug = [(q, i) for i, q in enumerate(queries)]\n        aug.sort()\n        total = sum(nums)\n        prefix = 0\n        k = 0\n        ans = [0] * len(queries)\n        for q, i in aug:\n            while k < len(nums) and nums[k] < q:\n                prefix += nums[k]\n                k += 1\n            ans[i] = total - 2 * prefix + q * (2 * k - len(nums))\n        return ans", "entry_point": "minOperations", "test_list": ["assert minOperations([3,1,6,8],[1,5])==[14,10]", "assert minOperations([2,9,6,3],[10])==[20]"]}
{"Contest id": "338/2601", "text_name": "Prime Subtraction Operation", "text": "You are given a 0-indexed integer array nums of length n.\nYou can perform the following operation as many times as you want:\nPick an index i that you haven\u2019t picked before, and pick a prime p strictly less than nums[i], then subtract p from nums[i].\nReturn true if you can make nums a strictly increasing array using the above operation and false otherwise.\nA strictly increasing array is an array whose each element is strictly greater than its preceding element.", "canonical_solution": "def primeSubOperation(nums):\n     def isPrime(x):\n        if x == 1:\n           return False\n        for i in range(2, int(x ** 0.5) + 1):\n            if x %i == 0:\n                return False\n        return True\n     p = 0\n     for x in nums:\n         if x <= p:\n             return False\n         prime = x - p - 1\n         while prime > 0 and not isPrime(prime):\n             prime -= 1\n         if prime == 0:\n             p = x\n         else:\n             p = x - prime\n     return True", "entry_point": "primeSubOperation", "test_list": ["assert primeSubOperation([4,9,6,10])==True", "assert primeSubOperation([6,8,11,12])==True", "assert primeSubOperation([5,8,3])==False"]}
{"Contest id": "338/2600", "text_name": "K Items With the Maximum Sum", "text": "There is a bag that consists of items, each item has a number 1, 0, or -1 written on it.\nYou are given four non-negative integers numOnes, numZeros, numNegOnes, and k.\nThe bag initially contains:\nnumOnes items with 1s written on them.\nnumZeroes items with 0s written on them.\nnumNegOnes items with -1s written on them.\nWe want to pick exactly k items among the available items. Return the maximum possible sum of numbers written on the items.", "canonical_solution": "def kItemsWithMaximumSum(numOnes, numZeros, numNegOnes, k):\n        return min(k, numOnes) - max(0, k - numZeros - numOnes)", "entry_point": "kItemsWithMaximumSum", "test_list": ["assert kItemsWithMaximumSum(3,2,0,2)==2", "assert kItemsWithMaximumSum(3,2,0,4)==3"]}
{"Contest id": "337/2598", "text_name": "Smallest Missing Non-negative Integer After Operations", "text": "You are given a 0-indexed integer array nums and an integer value.\nIn one operation, you can add or subtract value from any element of nums.\nFor example, if nums = [1,2,3] and value = 2, you can choose to subtract value from nums[0] to make nums = [-1,2,3].\nThe MEX (minimum excluded) of an array is the smallest missing non-negative integer in it.\nFor example, the MEX of [-1,2,3] is 0 while the MEX of [1,0,3] is 2.\nReturn the maximum MEX of nums after applying the mentioned operation any number of times.", "canonical_solution": "from collections import Counter\ndef findSmallestInteger(nums, value):\n    count = Counter(a % value for a in nums)\n    stop = 0\n    for i in range(value):\n        if count[i] < count[stop]:\n            stop = i\n    return value * count[stop] + stop", "entry_point": "findSmallestInteger", "test_list": ["assert findSmallestInteger([1,-10,7,13,6,8],5)==4", "assert findSmallestInteger([1,-10,7,13,6,8],7)==2"]}
{"Contest id": "337/2597", "text_name": "The Number of Beautiful Subsets", "text": "You are given an array nums of positive integers and a positive integer k.\nA subset of nums is beautiful if it does not contain two integers with an absolute difference equal to k.\nReturn the number of non-empty beautiful subsets of the array nums.\nA subset of nums is an array that can be obtained by deleting some (possibly none) elements from nums. Two subsets are different if and only if the chosen indices to delete are different.", "canonical_solution": "def beautifulSubsets(nums, k):\n    freq = {}\n\n    def f(i):\n        if i == len(nums):\n            return 1\n        result = f(i + 1)\n        if not nums[i] - k in freq and not nums[i] + k in freq:\n            freq[nums[i]] = freq[nums[i]] + 1 if nums[i] in freq else 1\n            result += f(i + 1)\n            freq[nums[i]] -= 1\n            if freq[nums[i]] == 0:\n                del freq[nums[i]]\n        return result\n\n    return f(0) - 1", "entry_point": "beautifulSubsets", "test_list": ["assert beautifulSubsets([2,4,6],2)==4", "assert beautifulSubsets([1],1)==1"]}
{"Contest id": "337/2596", "text_name": "Check Knight Tour Configuration", "text": "There is a knight on an n x n chessboard. In a valid configuration, the knight starts at the top-left cell of the board and visits every cell on the board exactly once.\nYou are given an n x n integer matrix grid consisting of distinct integers from the range [0, n * n - 1] where grid[row][col] indicates that the cell (row, col) is the grid[row][col]th cell that the knight visited. The moves are 0-indexed.\nReturn true if grid represents a valid configuration of the knight's movements or false otherwise.\nNote that a valid knight move consists of moving two squares vertically and one square horizontally, or two squares horizontally and one square vertically. The figure below illustrates all the possible eight moves of a knight from some cell.", "canonical_solution": "from collections import deque\ndef checkValidGrid(grid):\n        n = len(grid)\n        q = deque( [(0, 0)] )\n        res = 0\n        while q:\n            res += 1\n            x, y = q.popleft()\n            for i, j in [ (x + 1, y + 2), (x + 1, y - 2), (x - 1, y + 2), (x - 1, y - 2), (x + 2, y + 1), (x + 2, y - 1), (x - 2, y + 1), (x - 2, y - 1) ]:\n                if 0 <= i < n and 0 <= j < n and grid[i][j] == grid[x][y] + 1:\n                    q.append( (i, j) )\n        return res == pow(n, 2)", "entry_point": "checkValidGrid", "test_list": ["assert checkValidGrid([[0,11,16,5,20],[17,4,19,10,15],[12,1,8,21,6],[3,18,23,14,9],[24,13,2,7,22]])==True", "assert checkValidGrid([[0,3,6],[5,8,1],[2,7,4]])==False"]}
{"Contest id": "337/2595", "text_name": "Number of Even and Odd Bits", "text": "You are given a positive integer n.\nLet even denote the number of even indices in the binary representation of n (0-indexed) with value 1.\nLet odd denote the number of odd indices in the binary representation of n (0-indexed) with value 1.\nReturn an integer array answer where answer = [even, odd].", "canonical_solution": "def evenOddBit(n):\n        ans = [0, 0]\n        for idx, val in enumerate(bin(n)[2:][::-1]):\n            if idx % 2 == 0 and val == '1':\n                ans[0] += 1\n            elif idx % 2 == 1 and val == '1':\n                ans[1] += 1       \n        return ans", "entry_point": "evenOddBit", "test_list": ["assert evenOddBit(17)==[2,0]", "assert evenOddBit(2)==[0,1]"]}
{"Contest id": "Bi100/2594", "text_name": "Minimum Time to Repair Cars", "text": "You are given an integer array ranks representing the ranks of some mechanics. ranksi is the rank of the ith mechanic. A mechanic with a rank r can repair n cars in r * n2 minutes.\nYou are also given an integer cars representing the total number of cars waiting in the garage to be repaired.\nReturn the minimum time taken to repair all the cars.\nNote: All the mechanics can repair the cars simultaneously.", "canonical_solution": "from collections import Counter\nfrom math import isqrt\ndef repairCars(A, cars):\n    count = Counter(A)\n    left, right = 1, min(count) * cars * cars\n    while left < right:\n        mid = (left + right) // 2\n        if sum(isqrt(mid // a) * count[a] for a in count) < cars:\n            left = mid + 1\n        else:\n            right = mid\n    return left", "entry_point": "repairCars", "test_list": ["assert repairCars([4,2,3,1],10)==16", "assert repairCars([5,1,8],6)==16"]}
{"Contest id": "Bi100/2593", "text_name": "Find Score of an Array After Marking All Elements", "text": "You are given an array nums consisting of positive integers.\nStarting with score = 0, apply the following algorithm:\nChoose the smallest integer of the array that is not marked. If there is a tie, choose the one with the smallest index.\nAdd the value of the chosen integer to score.\nMark the chosen element and its two adjacent elements if they exist.\nRepeat until all the array elements are marked.\nReturn the score you get after applying the above algorithm.", "canonical_solution": "def findScore(nums):\n        seen = [0] * (len(nums) + 1)\n        res = 0\n        for a,i in sorted([a,i] for i,a in enumerate(nums)):\n            if seen[i]: continue\n            res += a\n            seen[i] = seen[i - 1] = seen[i + 1] = 1\n        return res", "entry_point": "findScore", "test_list": ["assert findScore([2,1,3,4,5,2])==7", "assert findScore([2,3,5,1,3,2])==5"]}
{"Contest id": "Bi100/2592", "text_name": "Maximize Greatness of an Array", "text": "You are given a 0-indexed integer array nums. You are allowed to permute nums into a new array perm of your choosing.\nWe define the greatness of nums be the number of indices 0 <= i < nums.length for which perm[i] > nums[i].\nReturn the maximum possible greatness you can achieve after permuting nums.", "canonical_solution": "def maximizeGreatness(nums):\n        nums.sort()\n        res = 0\n        for a in nums:\n            if a > nums[res]:\n                res += 1\n        return res", "entry_point": "maximizeGreatness", "test_list": ["assert maximizeGreatness([1,3,5,2,1,3,1])==4", "assert maximizeGreatness([1,2,3,4])==3"]}
{"Contest id": "Bi100/2591", "text_name": "Distribute Money to Maximum Children", "text": "You are given an integer money denoting the amount of money (in dollars) that you have and another integer children denoting the number of children that you must distribute the money to.\nYou have to distribute the money according to the following rules:\nAll money must be distributed.\nEveryone must receive at least 1 dollar.\nNobody receives 4 dollars.\nReturn the maximum number of children who may receive exactly 8 dollars if you distribute the money according to the aforementioned rules. If there is no way to distribute the money, return -1.", "canonical_solution": "def distMoney(money, children):\n        if children>money:\n            return -1\n        if money>8*children:\n            return children-1\n        money-=children\n        if children-money//7==1 and money%7==3:\n            return money//7-1\n        return money//7", "entry_point": "distMoney", "test_list": ["assert distMoney(20,3)==1", "assert distMoney(16,2)==2"]}
{"Contest id": "336/2589", "text_name": "Minimum Time to Complete All Tasks", "text": "There is a computer that can run an unlimited number of tasks at the same time. You are given a 2D integer array tasks where tasks[i] = [starti, endi, durationi] indicates that the ith task should run for a total of durationi seconds (not necessarily continuous) within the inclusive time range [starti, endi].\nYou may turn on the computer only when it needs to run a task. You can also turn it off if it is idle.\nReturn the minimum time during which the computer should be turned on to complete all tasks.", "canonical_solution": "from heapq import heappop, heappush\ndef findMinimumTime(tasks):\n    tasks.append([10 ** 9 + 1, 10 ** 9 + 1, 1])\n    res, q = 0, []\n    for s, e, d in sorted(tasks):\n        while q and q[0][0] + res < s:\n            if q[0][0] + res >= q[0][1]:\n                heappop(q)\n            else:\n                res += min(q[0][1], s) - (q[0][0] + res)\n        heappush(q, [e - d + 1 - res, e + 1])\n    return res", "entry_point": "findMinimumTime", "test_list": ["assert findMinimumTime([[2,3,1],[4,5,1],[1,5,2]])==2", "assert findMinimumTime([[1,3,2],[2,5,3],[5,6,2]])==4"]}
{"Contest id": "336/2588", "text_name": "Count the Number of Beautiful Subarrays", "text": "You are given a 0-indexed integer array nums. In one operation, you can:\nChoose two different indices i and j such that 0 <= i, j < nums.length.\nChoose a non-negative integer k such that the kth bit (0-indexed) in the binary representation of nums[i] and nums[j] is 1.\nSubtract 2k from nums[i] and nums[j].\nA subarray is beautiful if it is possible to make all of its elements equal to 0 after applying the above operation any number of times.\nReturn the number of beautiful subarrays in the array nums.\nA subarray is a contiguous non-empty sequence of elements within an array.", "canonical_solution": "def beautifulSubarrays(nums):\n        dp = Counter({0: 1})\n        res = pre = 0\n        for a in nums:\n            pre ^= a\n            res += dp[pre]\n            dp[pre] += 1\n        return res", "entry_point": "beautifulSubarrays", "test_list": ["assert beautifulSubarrays([4,3,1,2,4])==2", "assert beautifulSubarrays([1,10,4])==0"]}
{"Contest id": "336/2587", "text_name": "Rearrange Array to Maximize Prefix Score", "text": "You are given a 0-indexed integer array nums. You can rearrange the elements of nums to any order (including the given order).\nLet prefix be the array containing the prefix sums of nums after rearranging it. In other words, prefix[i] is the sum of the elements from 0 to i in nums after rearranging it. The score of nums is the number of positive integers in the array prefix.\nReturn the maximum score you can achieve.", "canonical_solution": "def maxScore(nums):\n        nums.sort(reverse=True)\n        prefix_sums = [0]\n        for num in nums:\n            prefix_sums.append(prefix_sums[-1] + num)\n        max_score = 0\n        for i in range(1, len(prefix_sums)):\n            if prefix_sums[i] > 0:\n                max_score = i\n        return max_score", "entry_point": "maxScore", "test_list": ["assert maxScore([2,-1,0,1,-3,3,-3])==6", "assert maxScore([-2,-3,0])==0"]}
{"Contest id": "336/2586", "text_name": "Count the Number of Vowel Strings in Range", "text": "You are given a 0-indexed array of string words and two integers left and right.\nA string is called a vowel string if it starts with a vowel character and ends with a vowel character where vowel characters are 'a', 'e', 'i', 'o', and 'u'.\nReturn the number of vowel strings words[i] where i belongs to the inclusive range [left, right].", "canonical_solution": "def vowelStrings(words, left, right):\n    vowels = 'aeiouAEIOU'\n    count = 0\n    for i in range(left, right + 1):\n        if words[i][0] in vowels and words[i][-1] in vowels:\n            count += 1\n    return count", "entry_point": "vowelStrings", "test_list": ["assert vowelStrings([\"are\",\"amy\",\"u\"],0,2)==2", "assert vowelStrings([\"hey\",\"aeo\",\"mu\",\"ooo\",\"artro\"],1,4)==3"]}
{"Contest id": "335/2585", "text_name": "Number of Ways to Earn Points", "text": "There is a test that has n types of questions. You are given an integer target and a 0-indexed 2D integer array types where types[i] = [counti, marksi] indicates that there are counti questions of the ith type, and each one of them is worth marksi points.\nReturn the number of ways you can earn exactly target points in the exam. Since the answer may be too large, return it modulo 109 + 7.\nNote that questions of the same type are indistinguishable.\nFor example, if there are 3 questions of the same type, then solving the 1st and 2nd questions is the same as solving the 1st and 3rd questions, or the 2nd and 3rd questions.", "canonical_solution": "def waysToReachTarget(target, types):\n        dp = [1] + [0] * target\n        mod = 10 ** 9 + 7\n        for c,m in types:\n            for i in range(target,-1,-1):\n                for k in range(1, min(c, i // m) + 1):\n                    dp[i] = (dp[i] + dp[i - m * k]) % mod\n        return dp[-1]", "entry_point": "waysToReachTarget", "test_list": ["assert waysToReachTarget(6,[[6,1],[3,2],[2,3]])==7", "assert waysToReachTarget(5,[[50,1],[50,2],[50,5]])==4", "assert waysToReachTarget(18,[[6,1],[3,2],[2,3]])==1"]}
{"Contest id": "335/2584", "text_name": "Split the Array to Make Coprime Products", "text": "You are given a 0-indexed integer array nums of length n.\nA split at an index i where 0 <= i <= n - 2 is called valid if the product of the first i + 1 elements and the product of the remaining elements are coprime.\nFor example, if nums = [2, 3, 3], then a split at the index i = 0 is valid because 2 and 9 are coprime, while a split at the index i = 1 is not valid because 6 and 3 are not coprime. A split at the index i = 2 is not valid because i == n - 1.\nReturn the smallest index i at which the array can be split validly or -1 if there is no such split.\nTwo values val1 and val2 are coprime if gcd(val1, val2) == 1 where gcd(val1, val2) is the greatest common divisor of val1 and val2.", "canonical_solution": "def findValidSplit(nums):\n        def yieldprime(n):\n            while n % 2 == 0:\n                n >>= 1\n                yield 2\n            p = 3\n            while p * p <= n:\n                while n % p == 0:\n                    n //= p\n                    yield p\n                p += 2\n            if n > 1:\n                yield n           \n        lastp = {}\n        for i, n in enumerate(nums):\n            for p in yieldprime(n):\n                lastp[p] = i\n        l = 0\n        maxl = 0\n        while l <= maxl:\n            n = nums[l]\n            for p in yieldprime(nums[l]):\n                maxl = max(maxl, lastp[p])\n            l += 1\n        return maxl if maxl != len(nums) - 1 else -1", "entry_point": "findValidSplit", "test_list": ["assert findValidSplit([4,7,8,15,3,5])==2", "assert findValidSplit([4,7,15,8,3,5])==-1"]}
{"Contest id": "335/2582", "text_name": "Pass the Pillow", "text": "There are n people standing in a line labeled from 1 to n. The first person in the line is holding a pillow initially. Every second, the person holding the pillow passes it to the next person standing in the line. Once the pillow reaches the end of the line, the direction changes, and people continue passing the pillow in the opposite direction.\nFor example, once the pillow reaches the nth person they pass it to the n - 1th person, then to the n - 2th person and so on.\nGiven the two positive integers n and time, return the index of the person holding the pillow after time seconds.", "canonical_solution": "def passThePillow(n, time):\n        return n - abs(n - 1 - time % (n * 2 - 2))", "entry_point": "passThePillow", "test_list": ["assert passThePillow(4,5)==2", "assert passThePillow(3,2)==3"]}
{"Contest id": "Bi99/2581", "text_name": "Count Number of Possible Root Nodes", "text": "Alice has an undirected tree with n nodes labeled from 0 to n - 1. The tree is represented as a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nAlice wants Bob to find the root of the tree. She allows Bob to make several guesses about her tree. In one guess, he does the following:\nChooses two distinct integers u and v such that there exists an edge [u, v] in the tree.\nHe tells Alice that u is the parent of v in the tree.\nBob's guesses are represented by a 2D integer array guesses where guesses[j] = [uj, vj] indicates Bob guessed uj to be the parent of vj.\nAlice being lazy, does not reply to each of Bob's guesses, but just says that at least k of his guesses are true.\nGiven the 2D integer arrays edges, guesses and the integer k, return the number of possible nodes that can be the root of Alice's tree. If there is no such tree, return 0.", "canonical_solution": "from collections import defaultdict\ndef rootCount(edges, guesses, k):\n    graph = defaultdict(list)\n    for i, j in edges:\n        graph[i].append(j)\n        graph[j].append(i)\n\n    gt = set((i, j) for i, j in guesses)\n\n    def get_correct_pairs(i, parent):\n        next_nodes = graph[i]\n        n_correct = 0\n        for next_node in next_nodes:\n            if next_node == parent:\n                continue\n            if (i, next_node) in gt:\n                n_correct += 1\n            n_correct += get_correct_pairs(next_node, i)\n        return n_correct\n\n    ans = 0\n    for i in graph:\n        if get_correct_pairs(i, None) >= k:\n            ans += 1\n    return ans", "entry_point": "rootCount", "test_list": ["assert rootCount([[0,1],[1,2],[1,3],[4,2]],[[1,3],[0,1],[1,0],[2,4]],3)==3", "assert rootCount([[0,1],[1,2],[2,3],[3,4]],[[1,0],[3,4],[2,1],[3,2]],1)==5"]}
{"Contest id": "Bi99/2580", "text_name": "Count Ways to Group Overlapping Ranges", "text": "You are given a 2D integer array ranges where ranges[i] = [starti, endi] denotes that all integers between starti and endi (both inclusive) are contained in the ith range.\nYou are to split ranges into two (possibly empty) groups such that:\nEach range belongs to exactly one group.\nAny two overlapping ranges must belong to the same group.\nTwo ranges are said to be overlapping if there exists at least one integer that is present in both ranges.\nFor example, [1, 3] and [2, 5] are overlapping because 2 and 3 occur in both ranges.\nReturn the total number of ways to split ranges into two groups. Since the answer may be very large, return it modulo 109 + 7.", "canonical_solution": "def countWays(ranges):\n        pre = -1\n        res = 0\n        for a,b in sorted(ranges):\n            res += pre < a\n            pre = max(pre, b)\n        return pow(2, res, 10**9+7)", "entry_point": "countWays", "test_list": ["assert countWays([[6,10],[5,15]])==2", "assert countWays([[1,3],[10,20],[2,5],[4,8]])==4"]}
{"Contest id": "Bi99/2579", "text_name": "Count Total Number of Colored Cells", "text": "There exists an infinitely large two-dimensional grid of uncolored unit cells. You are given a positive integer n, indicating that you must do the following routine for n minutes:\nAt the first minute, color any arbitrary unit cell blue.\nEvery minute thereafter, color blue every uncolored cell that touches a blue cell.\nBelow is a pictorial representation of the state of the grid after minutes 1, 2, and 3.", "canonical_solution": "def coloredCells(n):\n        return n*n + (n-1)*(n-1)", "entry_point": "coloredCells", "test_list": ["assert coloredCells(1)==1", "assert coloredCells(2)==5"]}
{"Contest id": "Bi99/2578", "text_name": "Split With Minimum Sum", "text": "Given a positive integer num, split it into two non-negative integers num1 and num2 such that:\nThe concatenation of num1 and num2 is a permutation of num.\nIn other words, the sum of the number of occurrences of each digit in num1 and num2 is equal to the number of occurrences of that digit in num.\nnum1 and num2 can contain leading zeros.\nReturn the minimum possible sum of num1 and num2.\nNotes:\nIt is guaranteed that num does not contain any leading zeros.\nThe order of occurrence of the digits in num1 and num2 may differ from the order of occurrence of num.", "canonical_solution": "def splitNum(num):\n    num = ''.join(sorted(str(num)))\n    return sum(map(int, (num[::2], num[1::2])))", "entry_point": "splitNum", "test_list": ["assert splitNum(4325)==59", "assert splitNum(687)==75"]}
{"Contest id": "334/2577", "text_name": "Minimum Time to Visit a Cell In a Grid", "text": "You are given a m x n matrix grid consisting of non-negative integers where grid[row][col] represents the minimum time required to be able to visit the cell (row, col), which means you can visit the cell (row, col) only when the time you visit it is greater than or equal to grid[row][col].\nYou are standing in the top-left cell of the matrix in the 0th second, and you must move to any adjacent cell in the four directions: up, down, left, and right. Each move you make takes 1 second.\nReturn the minimum time required in which you can visit the bottom-right cell of the matrix. If you cannot visit the bottom-right cell, then return -1.", "canonical_solution": "import sys\nfrom heapq import heappush, heappop\ndef minimumTime(grid):\n        m,n=len(grid),len(grid[0])\n        directions=((0,1),(1,0),(-1,0),(0,-1))\n        i,j,flag=0,0,0\n        for di,dj in directions:\n            ni,nj=i+di,j+dj\n            if 0<=ni<m and 0<=nj<n and grid[ni][nj]<=1: flag=1;break;\n        if not flag: return -1\n        heap=[]\n        heappush(heap,(0,0,0))\n        dist=[[sys.maxsize]*n for _ in range(m)]\n        while heap:\n            cost,i,j=heappop(heap)\n            if i==m-1 and j==n-1: return cost\n            for di,dj in directions:\n                ni,nj=i+di,j+dj\n                if 0<=ni<m and 0<=nj<n:\n                    new_cost=cost+1\n                    if grid[ni][nj]>cost:\n                        if abs(cost-grid[ni][nj])%2==0:\n                            new_cost=grid[ni][nj]+1\n                        else:\n                            new_cost=grid[ni][nj]\n                    if new_cost<dist[ni][nj]:\n                        dist[ni][nj]=new_cost\n                        heappush(heap,(new_cost,ni,nj))", "entry_point": "minimumTime", "test_list": ["assert minimumTime([[0,1,3,2],[5,1,2,5],[4,3,8,6]])==7", "assert minimumTime([[0,2,4],[3,2,1],[1,0,4]])==-1"]}
{"Contest id": "334/2576", "text_name": "Find the Maximum Number of Marked Indices", "text": "You are given a 0-indexed integer array nums.\nInitially, all of the indices are unmarked. You are allowed to make this operation any number of times:\nPick two different unmarked indices i and j such that 2 * nums[i] <= nums[j], then mark i and j.\nReturn the maximum possible number of marked indices in nums using the above operation any number of times.", "canonical_solution": "def maxNumOfMarkedIndices(nums):\n        n=len(nums)\n        i=0\n        nums.sort()\n        for j in range(n//2,n):\n            i+= nums[j]>=nums[i]*2\n        return i*2", "entry_point": "maxNumOfMarkedIndices", "test_list": ["assert maxNumOfMarkedIndices([3,5,2,4])==2", "assert maxNumOfMarkedIndices([9,2,5,4])==4", "assert maxNumOfMarkedIndices([7,6,8])==0"]}
{"Contest id": "334/2575", "text_name": "Find the Divisibility Array of a String", "text": "You are given a 0-indexed string word of length n consisting of digits, and a positive integer m.\nThe divisibility array div of word is an integer array of length n such that:\ndiv[i] = 1 if the numeric value of word[0,...,i] is divisible by m, or\ndiv[i] = 0 otherwise.\nReturn the divisibility array of word.", "canonical_solution": "def divisibilityArray(word, m):\n        temp = 0\n        res = [0] * len(word)\n        for i in range(len(word)):\n            temp = (temp * 10 + int(word[i])) % m\n            if temp == 0:\n                res[i] = 1             \n        return res", "entry_point": "divisibilityArray", "test_list": ["assert divisibilityArray(\"998244353\",3)==[1,1,0,0,0,1,1,0,0]", "assert divisibilityArray(\"1010\",10)==[0,1,0,1]"]}
{"Contest id": "334/2574", "text_name": "Left and Right Sum Differences", "text": "Given a 0-indexed integer array nums, find a 0-indexed integer array answer where:\nanswer.length == nums.length.\nanswer[i] = |leftSum[i] - rightSum[i]|.\nWhere:\nleftSum[i] is the sum of elements to the left of the index i in the array nums. If there is no such element, leftSum[i] = 0.\nrightSum[i] is the sum of elements to the right of the index i in the array nums. If there is no such element, rightSum[i] = 0.\nReturn the array answer.", "canonical_solution": "def leftRightDifference(nums):\n        result = []\n        left_sum = [0]\n        right_sum = [0]\n        for num in nums[:-1]:\n            left_sum.append(left_sum[-1] + num)\n        for num in nums[::-1][:-1]:\n            right_sum.insert(0, right_sum[0] + num)\n        for index in range(len(nums)):\n            result.append(abs(left_sum[index] - right_sum[index]))\n        return result", "entry_point": "leftRightDifference", "test_list": ["assert leftRightDifference([10,4,8,3])==[15,1,11,22]", "assert leftRightDifference([1])==[0]"]}
{"Contest id": "333/2573", "text_name": "Find the String with LCP", "text": "We define the lcp matrix of any 0-indexed string word of n lowercase English letters as an n x n grid such that:\nlcp[i][j] is equal to the length of the longest common prefix between the substrings word[i,n-1] and word[j,n-1].\nGiven an n x n matrix lcp, return the alphabetically smallest string word that corresponds to lcp. If there is no such string, return an empty string.\nA string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b. For example, \"aabd\" is lexicographically smaller than \"aaca\" because the first position they differ is at the third letter, and 'b' comes before 'c'.", "canonical_solution": "def findTheString(lcp):\n        n = len(lcp)\n        A = [0] * n\n        c = 1\n        for i in range(n):\n            if A[i]: continue\n            if c > 26: return ''\n            for j in range(i, n):\n                if lcp[i][j]:\n                    A[j] = c\n            c += 1\n        for i in range(n):\n            for j in range(n):\n                v = lcp[i + 1][j + 1] if i + 1 < n and j + 1 < n else 0\n                v = v + 1 if A[i] == A[j] else 0\n                if lcp[i][j] != v:\n                    return ''\n        return ''.join(chr(ord('a') + i - 1) for i in A)", "entry_point": "findTheString", "test_list": ["assert findTheString([[4,0,2,0],[0,3,0,1],[2,0,2,0],[0,1,0,1]])==\"abab\"", "assert findTheString([[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,1]])==\"aaaa\"", "assert findTheString([[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,3]])==\"\""]}
{"Contest id": "333/2572", "text_name": "Count the Number of Square-Free Subsets", "text": "You are given a positive integer 0-indexed array nums.\nA subset of the array nums is square-free if the product of its elements is a square-free integer.\nA square-free integer is an integer that is divisible by no square number other than 1.\nReturn the number of square-free non-empty subsets of the array nums. Since the answer may be too large, return it modulo 10^9 + 7.\nA non-empty subset of nums is an array that can be obtained by deleting some (possibly none but not all) elements from nums. Two subsets are different if and only if the chosen indices to delete are different.", "canonical_solution": "def squareFreeSubsets(nums):\n        MOD = 10**9 + 7\n        primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n        dp = [0] * (1 << 10)\n        dp[0] = 1\n        for a in nums:\n            mask = 0\n            for i, x in enumerate(primes):\n                if a % (x * x) == 0:\n                    mask = -1\n                    break\n                if a % x == 0:\n                    mask |= 1 << i\n            if mask >= 0:\n                for i in range(1 << 10):\n                    if (i & mask) == 0:\n                        dp[i | mask] += dp[i]\n        return (sum(dp) - 1) % MOD", "entry_point": "squareFreeSubsets", "test_list": ["assert squareFreeSubsets([3,4,4,5])==3", "assert squareFreeSubsets([1])==1"]}
{"Contest id": "333/2571", "text_name": "Minimum Operations to Reduce an Integer to 0", "text": "You are given a positive integer n, you can do the following operation any number of times:\nAdd or subtract a power of 2 from n.\nReturn the minimum number of operations to make n equal to 0.\nA number x is power of 2 if x == 2i where i >= 0.", "canonical_solution": "def minOperations(n):\n        res = 0\n        while n > 0:\n            if n % 2 == 0:\n                n >>= 1\n            elif (n & 2) > 0:\n                n += 1\n                res += 1\n            else:\n                res += 1\n                n >>= 2\n        return res", "entry_point": "minOperations", "test_list": ["assert minOperations(54)==3", "assert minOperations(39)==3"]}
{"Contest id": "333/2570", "text_name": "Merge Two 2D Arrays by Summing Values", "text": "You are given two 2D integer arrays nums1 and nums2.\nnums1[i] = [idi, vali] indicate that the number with the id idi has a value equal to vali.\nnums2[i] = [idi, vali] indicate that the number with the id idi has a value equal to vali.\nEach array contains unique ids and is sorted in ascending order by id.\nMerge the two arrays into one array that is sorted in ascending order by id, respecting the following conditions:\nOnly ids that appear in at least one of the two arrays should be included in the resulting array.\nEach id should be included only once and its value should be the sum of the values of this id in the two arrays. If the id does not exist in one of the two arrays then its value in that array is considered to be 0.\nReturn the resulting array. The returned array must be sorted in ascending order by id.", "canonical_solution": "def mergeArrays(nums1, nums2):\n        arr = [0] * 1001\n        length = 0\n        for num in nums1:\n            if arr[num[0]] == 0:\n                length += 1\n            arr[num[0]] = num[1]\n        for num in nums2:\n            if arr[num[0]] == 0:\n                length += 1\n            arr[num[0]] += num[1]\n        res = [[0, 0] for _ in range(length)]\n        ind = 0\n        for i in range(len(arr)):\n            if arr[i] != 0:\n                res[ind][0] = i\n                res[ind][1] = arr[i]\n                ind += 1\n        return res", "entry_point": "mergeArrays", "test_list": ["assert mergeArrays([[1,2],[2,3],[4,5]],[[1,4],[3,2],[4,1]])==[[1,6],[2,3],[3,2],[4,6]]", "assert mergeArrays([[2,4],[3,6],[5,5]],[[1,3],[4,3]])==[[1,3],[2,4],[3,6],[4,3],[5,5]]"]}
{"Contest id": "Bi98/2569", "text_name": "Handling Sum Queries After Update", "text": "You are given two 0-indexed arrays nums1 and nums2 and a 2D array queries of queries. There are three types of queries:\nFor a query of type 1, queries[i] = [1, l, r]. Flip the values from 0 to 1 and from 1 to 0 in nums1 from index l to index r. Both l and r are 0-indexed.\nFor a query of type 2, queries[i] = [2, p, 0]. For every index 0 <= i < n, set nums2[i] = nums2[i] + nums1[i] * p.\nFor a query of type 3, queries[i] = [3, 0, 0]. Find the sum of the elements in nums2.\nReturn an array containing all the answers to the third type queries.", "canonical_solution": "def handleQuery(nums1, nums2, queries):\n    n = len(nums1)\n    cnt1 = [0] * (4 * n)\n    flip = [False] * (4 * n)\n    def maintain(o):\n        cnt1[o] = cnt1[o * 2] + cnt1[o * 2 + 1]\n    def do(o, l, r):\n        cnt1[o] = r - l + 1 - cnt1[o]\n        flip[o] = not flip[o]\n    def build(o, l, r) :\n        if l == r:\n            cnt1[o] = nums1[l - 1]\n            return\n        m = (l + r) // 2\n        build(o * 2, l, m)\n        build(o * 2 + 1, m + 1, r)\n        maintain(o)\n    def update(o, l, r, L, R) :\n        if L <= l and r <= R:\n            do(o, l, r)\n            return\n        m = (l + r) // 2\n        if flip[o]:\n            do(o * 2, l, m)\n            do(o * 2 + 1, m + 1, r)\n            flip[o] = False\n        if m >= L: update(o * 2, l, m, L, R)\n        if m < R: update(o * 2 + 1, m + 1, r, L, R)\n        maintain(o)\n    build(1, 1, n)\n    ans, s = [], sum(nums2)\n    for op, l, r in queries:\n        if op == 1: update(1, 1, n, l + 1, r + 1)\n        elif op == 2: s += l * cnt1[1]\n        else: ans.append(s)\n    return ans", "entry_point": "handleQuery", "test_list": ["assert handleQuery(nums1=[1,0,1],nums2=[0,0,0],queries=[[1,1,1],[2,1,0],[3,0,0]])==[3]", "assert handleQuery(nums1=[1],nums2=[5],queries=[[2,0,0],[3,0,0]])==[5]"]}
{"Contest id": "Bi98/2568", "text_name": "Minimum Impossible OR", "text": "You are given a 0-indexed integer array nums.\nWe say that an integer x is expressible from nums if there exist some integers 0 <= index1 < index2 < ... < indexk < nums.length for which nums[index1] | nums[index2] | ... | nums[indexk] = x. In other words, an integer is expressible if it can be written as the bitwise OR of some subsequence of nums.\nReturn the minimum positive non-zero integer that is not expressible from nums.", "canonical_solution": "def minImpossibleOR(nums):\n        nums = set(nums)\n        return next(1 << i for i in range(32) if (1 << i) not in nums)", "entry_point": "minImpossibleOR", "test_list": ["assert minImpossibleOR([2,1])==4", "assert minImpossibleOR([5,3,2])==1"]}
{"Contest id": "Bi98/2567", "text_name": "Minimum Score by Changing Two Elements", "text": "You are given a 0-indexed integer array nums.\nThe low score of nums is the minimum value of |nums[i] - nums[j]| over all 0 <= i < j < nums.length.\nThe high score of nums is the maximum value of |nums[i] - nums[j]| over all 0 <= i < j < nums.length.\nThe score of nums is the sum of the high and low scores of nums.\nTo minimize the score of nums, we can change the value of at most two elements of nums.\nReturn the minimum possible score after changing the value of at most two elements of nums.\nNote that |x| denotes the absolute value of x.", "canonical_solution": "def minimizeSum(A):\n        A.sort()\n        return min(A[-1] - A[2], A[-2] - A[1], A[-3] - A[0])", "entry_point": "minimizeSum", "test_list": ["assert minimizeSum([1,4,3])==0", "assert minimizeSum([1,4,7,8,5])==3"]}
{"Contest id": "Bi98/2566", "text_name": "Maximum Difference by Remapping a Digit", "text": "You are given an integer num. You know that Bob will sneakily remap one of the 10 possible digits (0 to 9) to another digit.\nReturn the difference between the maximum and minimum values Bob can make by remapping exactly one digit in num.\nNotes:\nWhen Bob remaps a digit d1 to another digit d2, Bob replaces all occurrences of d1 in num with d2.\nBob can remap a digit to itself, in which case num does not change.\nBob can remap different digits for obtaining minimum and maximum values respectively.\nThe resulting number after remapping can contain leading zeroes.", "canonical_solution": "def minMaxDifference(num):\n        s_num = str(num)\n        ch = s_num[0]\n        min_num = int(s_num.replace(ch, '0'))\n        ch = next((x for x in s_num if x != '9'), '0')\n        max_num = int(s_num.replace(ch, '9'))\n        return max_num - min_num", "entry_point": "minMaxDifference", "test_list": ["assert minMaxDifference(11891)==99009", "assert minMaxDifference(90)==99"]}
{"Contest id": "332/2565", "text_name": "Subsequence With the Minimum Score", "text": "You are given two strings s and t.\nYou are allowed to remove any number of characters from the string t.\nThe score of the string is 0 if no characters are removed from the string t, otherwise:\nLet left be the minimum index among all removed characters.\nLet right be the maximum index among all removed characters.\nThen the score of the string is right - left + 1.\nReturn the minimum possible score to make t a subsequence of s.\nA subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., \"ace\" is a subsequence of \"abcde\" while \"aec\" is not).", "canonical_solution": "def minimumScore(s, t):\n        sl = 0\n        sr = len(s) - 1\n        tl = 0\n        tr = len(t) - 1\n        k = {}\n        for tl in range(len(t)):\n            while sl < len(s) and s[sl] != t[tl]:\n                sl += 1\n            if sl == len(s):\n                tl -= 1\n                break\n            k[tl] = sl\n            sl += 1\n        k[-1] = -1\n        ans = tr - tl\n        for ntl in range(tl, -2, -1):\n            while tr > ntl and sr > k[ntl]:\n                if s[sr] != t[tr]:\n                    sr -= 1\n                elif s[sr] == t[tr]:\n                    sr -= 1\n                    tr -= 1\n            ans = min(tr - ntl, ans)\n        return ans", "entry_point": "minimumScore", "test_list": ["assert minimumScore(\"abacaba\",\"bzaa\")==1", "assert minimumScore(\"cde\",\"xyz\")==3"]}
{"Contest id": "332/2564", "text_name": "Substring XOR Queries", "text": "You are given a binary string s, and a 2D integer array queries where queries[i] = [firsti, secondi].\nFor the ith query, find the shortest substring of s whose decimal value, val, yields secondi when bitwise XORed with firsti. In other words, val ^ firsti == secondi.\nThe answer to the ith query is the endpoints (0-indexed) of the substring [lefti, righti] or [-1, -1] if no such substring exists. If there are multiple answers, choose the one with the minimum lefti.\nReturn an array ans where ans[i] = [lefti, righti] is the answer to the ith query.\nA substring is a contiguous non-empty sequence of characters within a string.", "canonical_solution": "def substringXorQueries(s, queries):\n        m = defaultdict(lambda: [-1, -1])\n        for i, ch in enumerate(s):\n            val = 0\n            for j in range(i, min(i + 30, len(s))):\n                val = val * 2 + ord(s[j]) - ord(\"0\")\n                if val not in m:\n                    m[val] = [i, j]\n                if ch == \"0\":\n                    break\n        return [m[f ^ s] for f, s in queries]", "entry_point": "substringXorQueries", "test_list": ["assert substringXorQueries(\"0101\",[[12,8]])==[[-1,-1]]", "assert substringXorQueries(\"1\",[[4,5]])==[[0,0]]"]}
{"Contest id": "332/2563", "text_name": "Count the Number of Fair Pairs", "text": "Given a 0-indexed integer array nums of size n and two integers lower and upper, return the number of fair pairs.\nA pair (i, j) is fair if:\n0 <= i < j < n, and\nlower <= nums[i] + nums[j] <= upper", "canonical_solution": "def countFairPairs(nums, lower, upper):\n        nums.sort()\n        result=0\n        start,end=len(nums)-1,len(nums)-1\n        for i in range(len(nums)):\n            while end >=0 and nums[i]+nums[end]>upper:\n                end-=1\n            while start>=0 and nums[i]+nums[start]>=lower:\n                start-=1\n            if(start < i and end >= i):\n                result+=end-start-1\n            else:\n                result+=end-start\n        return result/2", "entry_point": "countFairPairs", "test_list": ["assert countFairPairs([0,1,7,4,4,5],3,6)==6", "assert countFairPairs([1,7,9,2,5],11,11)==1"]}
{"Contest id": "332/2562", "text_name": "Find the Array Concatenation Value", "text": "You are given a 0-indexed integer array nums.\nThe concatenation of two numbers is the number formed by concatenating their numerals.\nFor example, the concatenation of 15, 49 is 1549.\nThe concatenation value of nums is initially equal to 0. Perform this operation until nums becomes empty:\nIf there exists more than one number in nums, pick the first element and last element in nums respectively and add the value of their concatenation to the concatenation value of nums, then delete the first and last element from nums.\nIf one element exists, add its value to the concatenation value of nums, then delete it.\nReturn the concatenation value of the nums.", "canonical_solution": "def findTheArrayConcVal(nums):\n        concatenation = 0\n        while len(nums)>0:\n            if len(nums)>1:\n                concatenation += int(str(nums[0])+str(nums[-1]))\n                del nums[-1]\n            else:\n                concatenation += nums[0]\n            del nums[0]\n        return concatenation", "entry_point": "findTheArrayConcVal", "test_list": ["assert findTheArrayConcVal([7,52,2,4])==596", "assert findTheArrayConcVal([5,14,13,8,12])==673"]}
{"Contest id": "331/2561", "text_name": "Rearranging Fruits", "text": "You have two fruit baskets containing n fruits each. You are given two 0-indexed integer arrays basket1 and basket2 representing the cost of fruit in each basket. You want to make both baskets equal. To do so, you can use the following operation as many times as you want:\nChose two indices i and j, and swap the ith fruit of basket1 with the jth fruit of basket2.\nThe cost of the swap is min(basket1[i],basket2[j]).\nTwo baskets are considered equal if sorting them according to the fruit cost makes them exactly the same baskets.\nReturn the minimum cost to make both the baskets equal or -1 if impossible.", "canonical_solution": "from collections import Counter\ndef minCost(A, B):\n    count = Counter(A + B)\n    for c in count:\n        if count[c] % 2:\n            return -1\n        count[c] >>= 1\n    A2 = list((Counter(A) - count).elements())\n    B2 = list((Counter(B) - count).elements())\n    small = min(count)\n    C = sorted(A2 + B2)\n    return sum(min(small * 2, C[i]) for i in range(len(A2)))", "entry_point": "minCost", "test_list": ["assert minCost([4,2,2,2],[1,4,1,2])==1", "assert minCost([2,3,4,1],[3,2,5,1])==-1"]}
{"Contest id": "331/2560", "text_name": "House Robber IV", "text": "There are several consecutive houses along a street, each of which has some money inside. There is also a robber, who wants to steal money from the homes, but he refuses to steal from adjacent homes.\nThe capability of the robber is the maximum amount of money he steals from one house of all the houses he robbed.\nYou are given an integer array nums representing how much money is stashed in each house. More formally, the ith house from the left has nums[i] dollars.\nYou are also given an integer k, representing the minimum number of houses the robber will steal from. It is always possible to steal at least k houses.\nReturn the minimum capability of the robber out of all the possible ways to steal at least k houses.", "canonical_solution": "def minCapability(A, k):\n        l, r = min(A), max(A)\n        while l < r:\n            m = (l + r) // 2\n            last = take = 0\n            for a in A:\n                if last:\n                    last = 0\n                    continue\n                if a <= m:\n                    take += 1\n                    last = 1\n            if take >= k:\n                r = m\n            else:\n                l = m + 1\n        return l", "entry_point": "minCapability", "test_list": ["assert minCapability([2,3,5,9],2)==5", "assert minCapability([2,7,9,3,1],2)==2"]}
{"Contest id": "331/2559", "text_name": "Count Vowel Strings in Ranges", "text": "You are given a 0-indexed array of strings words and a 2D array of integers queries.\nEach query queries[i] = [li, ri] asks us to find the number of strings present in the range li to ri (both inclusive) of words that start and end with a vowel.\nReturn an array ans of size queries.length, where ans[i] is the answer to the ith query.\nNote that the vowel letters are 'a', 'e', 'i', 'o', and 'u'.", "canonical_solution": "def vowelStrings(words, queries):\n        n = len(words)\n        A = [0] * (n + 1)\n        vowel = 'aeiou'\n        ans = []\n        for i in range(n):\n            A[i + 1] = A[i] + (1 if words[i][0] in vowel and words[i][-1] in vowel else 0)\n        for l, r in queries:\n            ans.append(A[r + 1] - A[l])\n        return ans", "entry_point": "vowelStrings", "test_list": ["assert vowelStrings([\"aba\",\"bcb\",\"ece\",\"aa\",\"e\"],[[0,2],[1,4],[1,1]])==[2,3,0]", "assert vowelStrings([\"a\",\"e\",\"i\"],[[0,2],[0,1],[2,2]])==[3,2,1]"]}
{"Contest id": "331/2558", "text_name": "Take Gifts From the Richest Pile", "text": "You are given an integer array gifts denoting the number of gifts in various piles. Every second, you do the following:\nChoose the pile with the maximum number of gifts.\nIf there is more than one pile with the maximum number of gifts, choose any.\nLeave behind the floor of the square root of the number of gifts in the pile. Take the rest of the gifts.\nReturn the number of gifts remaining after k seconds.", "canonical_solution": "import math\nfrom heapq import heapify, heappop, heappush\ndef pickGifts(gifts, k):\n    nums = [-num for num in gifts]\n    heapify(nums)\n    while k:\n        tmp = math.isqrt(-heappop(nums))\n        heappush(nums, -tmp)\n        k -= 1\n    return -sum(nums)", "entry_point": "pickGifts", "test_list": ["assert pickGifts([25,64,9,4,100],4)==29", "assert pickGifts([1,1,1,1],4)==4"]}
{"Contest id": "Bi97/2556", "text_name": "Disconnect Path in a Binary Matrix by at Most One Flip", "text": "You are given a 0-indexed m x n binary matrix grid. You can move from a cell (row, col) to any of the cells (row + 1, col) or (row, col + 1) that has the value 1. The matrix is disconnected if there is no path from (0, 0) to (m - 1, n - 1).\nYou can flip the value of at most one (possibly none) cell. You cannot flip the cells (0, 0) and (m - 1, n - 1).\nReturn true if it is possible to make the matrix disconnect or false otherwise.\nNote that flipping a cell changes its value from 0 to 1 or from 1 to 0.", "canonical_solution": "def isPossibleToCutPath(grid):\n        m, n = len(grid), len(grid[0])\n        if m == 1 and n == 2:\n            return False\n        def dfs(i=0,j=0):\n            if i == m-1 and j == n-1:\n                return True\n            if i >= m or j >= n or grid[i][j]==0:\n                return False\n            grid[i][j]=0\n            if (i, j) != (0, 0):\n                if dfs(i+1, j):\n                    return True\n                return dfs(i, j+1)\n            return not(dfs(i+1, j) and dfs(i, j+1))\n        return dfs()", "entry_point": "isPossibleToCutPath", "test_list": ["assert isPossibleToCutPath([[1,1,1],[1,0,0],[1,1,1]])==True", "assert isPossibleToCutPath([[1,1,1],[1,0,1],[1,1,1]])==False"]}
{"Contest id": "Bi97/2555", "text_name": "Maximize Win From Two Segments", "text": "There are some prizes on the X-axis. You are given an integer array prizePositions that is sorted in non-decreasing order, where prizePositions[i] is the position of the ith prize. There could be different prizes at the same position on the line. You are also given an integer k.\nYou are allowed to select two segments with integer endpoints. The length of each segment must be k. You will collect all prizes whose position falls within at least one of the two selected segments (including the endpoints of the segments). The two selected segments may intersect.\nFor example if k = 2, you can choose segments [1, 3] and [2, 4], and you will win any prize i that satisfies 1 <= prizePositions[i] <= 3 or 2 <= prizePositions[i] <= 4.\nReturn the maximum number of prizes you can win if you choose the two segments optimally.", "canonical_solution": "def maximizeWin(A, k):\n        dp = [0] * (len(A) + 1)\n        res = j = 0\n        for i, a in enumerate(A):\n            while A[j] < A[i] - k: j += 1\n            dp[i + 1] = max(dp[i], i - j + 1)\n            res = max(res, i - j + 1 + dp[j])\n        return res", "entry_point": "maximizeWin", "test_list": ["assert maximizeWin([1,1,2,2,3,3,5],2)==7", "assert maximizeWin([1,2,3,4],0)==2"]}
{"Contest id": "Bi97/2554", "text_name": "Maximum Number of Integers to Choose From a Range I", "text": "You are given an integer array banned and two integers n and maxSum. You are choosing some number of integers following the below rules:\nThe chosen integers have to be in the range [1, n].\nEach integer can be chosen at most once.\nThe chosen integers should not be in the array banned.\nThe sum of the chosen integers should not exceed maxSum.\nReturn the maximum number of integers you can choose following the mentioned rules.", "canonical_solution": "def maxCount(banned, n, maxSum):\n        banned = set(banned)\n        res, sum_, curr = 0, 0, 1\n        while curr <= n:\n            if curr not in banned:\n                if sum_ + curr <= maxSum:\n                    res += 1\n                    sum_ += curr\n                else: break\n            curr += 1\n        return res", "entry_point": "maxCount", "test_list": ["assert maxCount([1,6,5],5,6)==2", "assert maxCount([1,2,3,4,5,6,7],8,1)==0", "assert maxCount([11],7,50)==7"]}
{"Contest id": "Bi97/2553", "text_name": "Separate the Digits in an Array", "text": "Given an array of positive integers nums, return an array answer that consists of the digits of each integer in nums after separating them in the same order they appear in nums.\nTo separate the digits of an integer is to get all the digits it has in the same order.\nFor example, for the integer 10921, the separation of its digits is [1,0,9,2,1].", "canonical_solution": "def separateDigits(nums):\n        result = []\n        for num in nums:\n            current_result = []\n            while num > 0:\n                current_result.append(num % 10)\n                num = num // 10\n            result = result + current_result[::-1]\n        return result", "entry_point": "separateDigits", "test_list": ["assert separateDigits([13,25,83,77])==[1,3,2,5,8,3,7,7]", "assert separateDigits([7,1,3,9])==[7,1,3,9]"]}
{"Contest id": "330/2552", "text_name": "Count Increasing Quadruplets", "text": "Given a 0-indexed integer array nums of size n containing all numbers from 1 to n, return the number of increasing quadruplets.\nA quadruplet (i, j, k, l) is increasing if:\n0 <= i < j < k < l < n, and\nnums[i] < nums[k] < nums[j] < nums[l].", "canonical_solution": "def countQuadruplets(nums):\n        n=len(nums)\n        dp=[0]*n\n        cnt=0\n        for j in range(n):\n            prv_small=0\n            for i in range(j):\n                if nums[j]>nums[i]:\n                    prv_small+=1\n                    cnt+=dp[i]\n                else:\n                    if nums[j]<nums[i]:\n                        dp[i]+=prv_small\n        return cnt", "entry_point": "countQuadruplets", "test_list": ["assert countQuadruplets([1,3,2,4,5])==2", "assert countQuadruplets([1,2,3,4])==0"]}
{"Contest id": "330/2551", "text_name": "Put Marbles in Bags", "text": "You have k bags. You are given a 0-indexed integer array weights where weights[i] is the weight of the ith marble. You are also given the integer k.\nDivide the marbles into the k bags according to the following rules:\nNo bag is empty.\nIf the ith marble and jth marble are in a bag, then all marbles with an index between the ith and jth indices should also be in that same bag.\nIf a bag consists of all the marbles with an index from i to j inclusively, then the cost of the bag is weights[i] + weights[j].\nThe score after distributing the marbles is the sum of the costs of all the k bags.\nReturn the difference between the maximum and minimum scores among marble distributions.", "canonical_solution": "def putMarbles(weights, K):\n        n = len(weights)\n        min_dp = [[float('inf')] * n for _ in range(K + 1)]\n        max_dp = [[float('-inf')] * n for _ in range(K + 1)]\n        for i in range(n):\n            min_dp[1][i] = weights[0] + weights[i]\n            max_dp[1][i] = weights[0] + weights[i]\n        for i in range(2, K + 1):\n            for j in range(n):\n                for k in range(j):\n                    min_dp[i][j] = min(min_dp[i - 1][k] + weights[k + 1] + weights[j], min_dp[i][j])\n                    max_dp[i][j] = max(max_dp[i - 1][k] + weights[k + 1] + weights[j], max_dp[i][j])\n        return max_dp[K][n - 1] - min_dp[K][n - 1]", "entry_point": "putMarbles", "test_list": ["assert putMarbles([1,3,5,1],2)==4", "assert putMarbles([1, 3],2)==0"]}
{"Contest id": "330/2549", "text_name": "Count Distinct Numbers on Board", "text": "You are given a positive integer n, that is initially placed on a board. Every day, for 109 days, you perform the following procedure:\nFor each number x present on the board, find all numbers 1 <= i <= n such that x % i == 1.\nThen, place those numbers on the board.\nReturn the number of distinct integers present on the board after 109 days have elapsed.\nNote:\nOnce a number is placed on the board, it will remain on it until the end.\n% stands for the modulo operation. For example, 14 % 3 is 2.", "canonical_solution": "def distinctIntegers(n):\n        return n if n<=1 else n-1", "entry_point": "distinctIntegers", "test_list": ["assert distinctIntegers(5)==4", "assert distinctIntegers(3)==2"]}
{"Contest id": "329/2547", "text_name": "Minimum Cost to Split an Array", "text": "You are given an integer array nums and an integer k.\nSplit the array into some number of non-empty subarrays. The cost of a split is the sum of the importance value of each subarray in the split.\nLet trimmed(subarray) be the version of the subarray where all numbers which appear only once are removed.\nFor example, trimmed([3,1,2,4,3,4]) = [3,4,3,4].\nThe importance value of a subarray is k + trimmed(subarray).length.\nFor example, if a subarray is [1,2,3,3,3,4,4], then trimmed([1,2,3,3,3,4,4]) = [3,3,3,4,4].The importance value of this subarray will be k + 5.\nReturn the minimum possible cost of a split of nums.\nA subarray is a contiguous non-empty sequence of elements within an array.", "canonical_solution": "def minCost(nums, k):\n        dp=[0]\n        nums=[-1]+nums\n        def main(i):\n            mp=defaultdict(int)\n            s=0\n            ans=10000000000000\n            while i>0:\n                if mp[nums[i]]>0:\n                    s+=1\n                    if mp[nums[i]]==1:\n                        s+=1\n                mp[nums[i]]+=1\n                ans=min(dp[i-1]+s,ans)\n                i-=1\n            return ans+k\n        for i in range(1,len(nums)):\n            dp.append(main(i))\n        return dp[-1]", "entry_point": "minCost", "test_list": ["assert minCost([1,2,1,2,1,3,3],2)==8", "assert minCost([1,2,1,2,1],2)==6", "assert minCost([1,2,1,2,1],5)==10"]}
{"Contest id": "329/2546", "text_name": "Apply Bitwise Operations to Make Strings Equal", "text": "You are given two 0-indexed binary strings s and target of the same length n. You can do the following operation on s any number of times:\nChoose two different indices i and j where 0 <= i, j < n.\nSimultaneously, replace s[i] with (s[i] OR s[j]) and s[j] with (s[i] XOR s[j]).\nFor example, if s = \"0110\", you can choose i = 0 and j = 2, then simultaneously replace s[0] with (s[0] OR s[2] = 0 OR 1 = 1), and s[2] with (s[0] XOR s[2] = 0 XOR 1 = 1), so we will have s = \"1110\".\nReturn true if you can make the string s equal to target, or false otherwise.", "canonical_solution": "def makeStringsEqual(s, t):\n        return ('1' in s) == ('1' in t)", "entry_point": "makeStringsEqual", "test_list": ["assert makeStringsEqual(\"1010\",\"0110\")==True", "assert makeStringsEqual(\"11\",\"00\")==False"]}
{"Contest id": "329/2545", "text_name": "Sort the Students by Their Kth Score", "text": "There is a class with m students and n exams. You are given a 0-indexed m x n integer matrix score, where each row represents one student and score[i][j] denotes the score the ith student got in the jth exam. The matrix score contains distinct integers only.\nYou are also given an integer k. Sort the students (i.e., the rows of the matrix) by their scores in the kth (0-indexed) exam from the highest to the lowest.\nReturn the matrix after sorting it.", "canonical_solution": "def sortTheStudents(A, k):\n        return sorted(A, key=lambda a: -a[k])", "entry_point": "sortTheStudents", "test_list": ["assert sortTheStudents([[10,6,9,1],[7,5,11,2],[4,8,3,15]],2)==[[7,5,11,2],[10,6,9,1],[4,8,3,15]]", "assert sortTheStudents([[3,4],[5,6]],0)==[[5,6],[3,4]]"]}
{"Contest id": "329/2544", "text_name": "Alternating Digit Sum", "text": "You are given a positive integer n. Each digit of n has a sign according to the following rules:\nThe most significant digit is assigned a positive sign.\nEach other digit has an opposite sign to its adjacent digits.\nReturn the sum of all digits with their corresponding sign.", "canonical_solution": "def alternateDigitSum(n):\n        res = 0\n        while n:\n            res = n % 10 - res\n            n //= 10\n        return res", "entry_point": "alternateDigitSum", "test_list": ["assert alternateDigitSum(521)==4", "assert alternateDigitSum(111)==1", "assert alternateDigitSum(886996)==0"]}
{"Contest id": "Bi96/2543", "text_name": "Check if Point Is Reachable", "text": "There exists an infinitely large grid. You are currently at point (1, 1), and you need to reach the point (targetX, targetY) using a finite number of steps.\nIn one step, you can move from point (x, y) to any one of the following points:\n(x, y - x)\n(x - y, y)\n(2 * x, y)\n(x, 2 * y)\nGiven two integers targetX and targetY representing the X-coordinate and Y-coordinate of your final position, return true if you can reach the point from (1, 1) using some number of steps, and false otherwise.", "canonical_solution": "def isReachable(x, y):\n        return (\n            True if x == 1 and y == 1 else\n            isReachable(x / 2, y) if x % 2 == 0 else\n            isReachable(x, y / 2) if y % 2 == 0 else\n            isReachable(x - y, y) if x > y else\n            isReachable(x, y - x) if y > x else False\n        )", "entry_point": "isReachable", "test_list": ["assert isReachable(6,9)==False", "assert isReachable(4,7)==True"]}
{"Contest id": "Bi96/2542", "text_name": "Maximum Subsequence Score", "text": "You are given two 0-indexed integer arrays nums1 and nums2 of equal length n and a positive integer k. You must choose a subsequence of indices from nums1 of length k.\nFor chosen indices i0, i1, ..., ik - 1, your score is defined as:\nThe sum of the selected elements from nums1 multiplied with the minimum of the selected elements from nums2.\nIt can defined simply as: (nums1[i0] + nums1[i1] +...+ nums1[ik - 1]) * min(nums2[i0] , nums2[i1], ... ,nums2[ik - 1]).\nReturn the maximum possible score.\nA subsequence of indices of an array is a set that can be derived from the set {0, 1, ..., n-1} by deleting some or no elements.", "canonical_solution": "def maxScore(A, B, k):\n            import heapq\n            total = res = 0\n            h = []\n            for a,b in sorted(list(zip(A, B)), key=lambda ab: -ab[1]):\n                heapq.heappush(h, a)\n                total += a\n                if len(h) > k:\n                    total -= heapq.heappop(h)\n                if len(h) == k:\n                    res = max(res, total * b)\n            return res", "entry_point": "maxScore", "test_list": ["assert maxScore([1,3,3,2],[2,1,3,4],3)==12", "assert maxScore([4,2,3,1,1],[7,5,10,9,6],1)==30"]}
{"Contest id": "Bi96/2541", "text_name": "Minimum Operations to Make Array Equal II", "text": "You are given two integer arrays nums1 and nums2 of equal length n and an integer k. You can perform the following operation on nums1:\nChoose two indexes i and j and increment nums1[i] by k and decrement nums1[j] by k. In other words, nums1[i] = nums1[i] + k and nums1[j] = nums1[j] - k.\nnums1 is said to be equal to nums2 if for all indices i such that 0 <= i < n, nums1[i] == nums2[i].\nReturn the minimum number of operations required to make nums1 equal to nums2. If it is impossible to make them equal, return -1.", "canonical_solution": "def minOperations(nums1, nums2, k):\n        if nums1 == nums2:\n            return 0\n        if k == 0:\n            return -1\n        lo, hi = 0, 0\n        for a, b in zip(nums1, nums2):\n            d = a - b\n            if d % k != 0:\n                return -1\n            if d < 0:\n                lo += d\n            else:\n                hi += d\n        if lo + hi != 0:\n            return -1\n        return hi // k", "entry_point": "minOperations", "test_list": ["assert minOperations([4,3,1,4],[1,3,7,1],3)==2", "assert minOperations([3,8,5,2],[2,4,1,6],1)==-1"]}
{"Contest id": "Bi96/2540", "text_name": "Minimum Common Value", "text": "Given two integer arrays nums1 and nums2, sorted in non-decreasing order, return the minimum integer common to both arrays. If there is no common integer amongst nums1 and nums2, return -1.\nNote that an integer is said to be common to nums1 and nums2 if both arrays have at least one occurrence of that integer.", "canonical_solution": "def getCommon(nums1, nums2):\n        nums1, nums2 = set(nums1), set(nums2)\n        common = sorted(list(nums1.intersection(nums2)))\n        return -1 if not len(common) else common[0]", "entry_point": "getCommon", "test_list": ["assert getCommon([1,2,3],[2,4])==2", "assert getCommon([1,2,3,6],[2,3,4,5])==2"]}
{"Contest id": "328/2538", "text_name": "Difference Between Maximum and Minimum Price Sum", "text": "There exists an undirected and initially unrooted tree with n nodes indexed from 0 to n - 1. You are given the integer n and a 2D integer array edges of length n - 1, where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nEach node has an associated price. You are given an integer array price, where price[i] is the price of the ith node.\nThe price sum of a given path is the sum of the prices of all nodes lying on that path.\nThe tree can be rooted at any node root of your choice. The incurred cost after choosing root is the difference between the maximum and minimum price sum amongst all paths starting at root.\nReturn the maximum possible cost amongst all possible root choices.", "canonical_solution": "def maxOutput(n, edges, price):\n        g = defaultdict(set)       \n        for u, v in edges:\n            g[u].add(v)\n            g[v].add(u)\n        def dfs(node, parent):\n            curr_price = price[node]\n            m = 0 # find the max path from current node via dfs\n            for v in g[node]:\n                if v == parent: continue\n                m = max(m, dfs(v, node))\n            return curr_price + m # return current_price + max_price_path     \n        m = 0\n        for node in range(n):\n            max_price = dfs(node, -1)\n            min_price = price[node]\n            m = max(m, max_price - min_price)       \n        return m", "entry_point": "maxOutput", "test_list": ["assert maxOutput(6,[[0,1],[1,2],[1,3],[3,4],[3,5]],[9,8,7,6,10,5])==24", "assert maxOutput(3,[[0,1],[1,2]],[1,1,1])==2"]}
{"Contest id": "328/2537", "text_name": "Count the Number of Good Subarrays", "text": "Given an integer array nums and an integer k, return the number of good subarrays of nums.\nA subarray arr is good if it there are at least k pairs of indices (i, j) such that i < j and arr[i] == arr[j].\nA subarray is a contiguous non-empty sequence of elements within an array.", "canonical_solution": "def countGood(A,k):\n        from collections import Counter\n        res = cur = i = 0\n        count = Counter()\n        for j in range(len(A)):\n            k -= count[A[j]]\n            count[A[j]] += 1\n            while k <= 0:\n                count[A[i]] -= 1\n                k += count[A[i]]\n                i += 1\n            res += i\n        return res", "entry_point": "countGood", "test_list": ["assert countGood([1,1,1,1,1],10)==1", "assert countGood([3,1,4,3,2,2,4],2)==4"]}
{"Contest id": "328/2536", "text_name": "Increment Submatrices by One", "text": "You are given a positive integer n, indicating that we initially have an n x n 0-indexed integer matrix mat filled with zeroes.\nYou are also given a 2D integer array query. For each query[i] = [row1i, col1i, row2i, col2i], you should do the following operation:\nAdd 1 to every element in the submatrix with the top left corner (row1i, col1i) and the bottom right corner (row2i, col2i). That is, add 1 to mat[x][y] for all row1i <= x <= row2i and col1i <= y <= col2i.\nReturn the matrix mat after performing every query.", "canonical_solution": "def rangeAddQueries(n, queries):\n    diff = [[0] * (n + 2) for _ in range(n + 2)]\n    for r1, c1, r2, c2 in queries:\n        diff[r1 + 1][c1 + 1] += 1\n        diff[r1 + 1][c2 + 2] -= 1\n        diff[r2 + 2][c1 + 1] -= 1\n        diff[r2 + 2][c2 + 2] += 1\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            diff[i][j] += diff[i][j - 1] + diff[i - 1][j] - diff[i - 1][j - 1]\n    diff = diff[1:-1]\n    for i, row in enumerate(diff):\n        diff[i] = row[1:-1]\n    return diff", "entry_point": "rangeAddQueries", "test_list": ["assert rangeAddQueries(3,[[1,1,2,2],[0,0,1,1]])==[[1,1,0],[1,2,1],[0,1,1]]", "assert rangeAddQueries(2,[[0,0,1,1]])==[[1,1],[1,1]]"]}
{"Contest id": "328/2535", "text_name": "Difference Between Element Sum and Digit Sum of an Array", "text": "You are given a positive integer array nums.\nThe element sum is the sum of all the elements in nums.\nThe digit sum is the sum of all the digits (not necessarily distinct) that appear in nums.\nReturn the absolute difference between the element sum and digit sum of nums.\nNote that the absolute difference between two integers x and y is defined as |x - y|.", "canonical_solution": "def differenceOfSum(nums):\n        digit_sum =0\n        for i in nums:\n            if i >9:\n                while i!=0:\n                    rem = i%10\n                    digit_sum += rem\n                    i = i//10\n            else:\n                digit_sum += i\n        return abs(sum(nums)-digit_sum)", "entry_point": "differenceOfSum", "test_list": ["assert differenceOfSum([1,15,6,3])==9", "assert differenceOfSum([1,2,3,4])==0"]}
{"Contest id": "327/2532", "text_name": "Time to Cross a Bridge", "text": "There are k workers who want to move n boxes from an old warehouse to a new one. You are given the two integers n and k, and a 2D integer array time of size k x 4 where time[i] = [leftToRighti, pickOldi, rightToLefti, putNewi].\nThe warehouses are separated by a river and connected by a bridge. The old warehouse is on the right bank of the river, and the new warehouse is on the left bank of the river. Initially, all k workers are waiting on the left side of the bridge. To move the boxes, the ith worker (0-indexed) can :\nCross the bridge from the left bank (new warehouse) to the right bank (old warehouse) in leftToRighti minutes.\nPick a box from the old warehouse and return to the bridge in pickOldi minutes. Different workers can pick up their boxes simultaneously.\nCross the bridge from the right bank (old warehouse) to the left bank (new warehouse) in rightToLefti minutes.\nPut the box in the new warehouse and return to the bridge in putNewi minutes. Different workers can put their boxes simultaneously.\nA worker i is less efficient than a worker j if either condition is met:\nleftToRighti + rightToLefti > leftToRightj + rightToLeftj\nleftToRighti + rightToLefti == leftToRightj + rightToLeftj and i > j\nThe following rules regulate the movement of the workers through the bridge :\nIf a worker x reaches the bridge while another worker y is crossing the bridge, x waits at their side of the bridge.\nIf the bridge is free, the worker waiting on the right side of the bridge gets to cross the bridge. If more than one worker is waiting on the right side, the one with the lowest efficiency crosses first.\nIf the bridge is free and no worker is waiting on the right side, and at least one box remains at the old warehouse, the worker on the left side of the river gets to cross the bridge. If more than one worker is waiting on the left side, the one with the lowest efficiency crosses first.\nReturn the instance of time at which the last worker reaches the left bank of the river after all n boxes have been put in the new warehouse.", "canonical_solution": "def findCrossingTime(n, k, time):\n        import heapq\n        ql = []\n        qr = []\n        qt = []\n        for x in range(k):\n            heappush(ql, (-(time[x][0] + time[x][2]), -x))\n        ct = 0\n        ans = 0\n        b = 1\n        i = -heappop(ql)[1]\n        heappush(qt, (time[i][0], 0, i))\n        while qt:\n            ct = qt[0][0]\n            def chkgo():\n                nonlocal b\n                if qr:\n                    j = -heappop(qr)[1]\n                    heappush(qt, (ct + time[j][2], 1, j))\n                elif ql:\n                    if n:\n                        j = -heappop(ql)[1]\n                        heappush(qt, (ct + time[j][0], 0, j))\n                    else:\n                        b = 0\n                else:\n                    b = 0  \n            while qt and qt[0][0] == ct:\n                t, st, i = heappop(qt)\n                assert(t == ct)\n                if st == 0:\n                    n -= 1\n                    heappush(qt, (t + time[i][1], 2, i))\n                    b = 0\n                elif st == 1:\n                    heappush(qt, (t + time[i][3], 3, i))\n                    b = 0\n                    ans = ct\n                elif st == 2:\n                    heappush(qr, (-(time[i][0] + time[i][2]), -i))\n                elif st == 3:\n                    heappush(ql, (-(time[i][0] + time[i][2]), -i))\n            if not b:\n                b = 1\n                chkgo()           \n        return ans", "entry_point": "findCrossingTime", "test_list": ["assert findCrossingTime(1,3,[[1,1,2,1],[1,1,3,1],[1,1,4,1]])==6", "assert findCrossingTime(3,2,[[1,9,1,8],[10,10,10,10]])==50"]}
{"Contest id": "327/2531", "text_name": "Make Number of Distinct Characters Equal", "text": "You are given two 0-indexed strings word1 and word2.\nA move consists of choosing two indices i and j such that 0 <= i < word1.length and 0 <= j < word2.length and swapping word1[i] with word2[j].\nReturn true if it is possible to get the number of distinct characters in word1 and word2 to be equal with exactly one move. Return false otherwise.", "canonical_solution": "def isItPossible(word1, word2):\n        from collections import Counter\n        d1 = Counter(word1)\n        d2 = Counter(word2)\n        for c in \"abcdefghijklmnopqrstuvwxyz\":\n            d1[c] = d1.get(c, 0)\n            d2[c] = d2.get(c, 0)\n        for c1 in d1:\n            if d1[c1] > 0:\n                d1[c1] -= 1\n                for c2 in d2:\n                    if d2[c2] > 0:\n                        d2[c1] += 1\n                        d2[c2] -= 1\n                        d1[c2] += 1\n                        if len([1 for c in d1.values() if c > 0]) == len([1 for c in d2.values() if c > 0]):\n                            return True\n                        d2[c1] -= 1\n                        d2[c2] += 1\n                        d1[c2] -= 1\n                d1[c1] += 1\n        return False", "entry_point": "isItPossible", "test_list": ["assert isItPossible(\"ac\",\"b\")==False", "assert isItPossible(\"abcc\",\"aab\")==True", "assert isItPossible(\"abcde\",\"fghij\")==True"]}
{"Contest id": "327/2530", "text_name": "Maximal Score After Applying K Operations", "text": "You are given a 0-indexed integer array nums and an integer k. You have a starting score of 0.\nIn one operation:\nchoose an index i such that 0 <= i < nums.length,\nincrease your score by nums[i], and\nreplace nums[i] with ceil(nums[i] / 3).\nReturn the maximum possible score you can attain after applying exactly k operations.\nThe ceiling function ceil(val) is the least integer greater than or equal to val.", "canonical_solution": "def maxKelements(nums, k):\n        from heapq import heapify,heappop,heappush\n        from math import floor\n        ans = 0\n        nums = [-num for num in nums]\n        heapify(nums)\n        while k:\n            tmp = heappop(nums)\n            ans -= tmp\n            heappush(nums, floor(tmp / 3))\n            k -= 1 \n        return ans", "entry_point": "maxKelements", "test_list": ["assert maxKelements([10,10,10,10,10],5)==50", "assert maxKelements([1,10,3,3,3],3)==17"]}
{"Contest id": "327/2529", "text_name": "Maximum Count of Positive Integer and Negative Integer", "text": "Given an array nums sorted in non-decreasing order, return the maximum between the number of positive integers and the number of negative integers.\nIn other words, if the number of positive integers in nums is pos and the number of negative integers is neg, then return the maximum of pos and neg.\nNote that 0 is neither positive nor negative.", "canonical_solution": "def maximumCount(nums):\n        neg=0\n        pos=0\n        for i in nums:\n            if i>0:\n                pos+=1\n            if i<0:\n                neg+=1\n        return pos if pos > neg else neg", "entry_point": "maximumCount", "test_list": ["assert maximumCount([-2,-1,-1,1,2,3])==3", "assert maximumCount([-3,-2,-1,0,0,1,2])==3", "assert maximumCount([5,20,66,1314])==4"]}
{"Contest id": "Bi95/2528", "text_name": "Maximize the Minimum Powered City", "text": "You are given a 0-indexed integer array stations of length n, where stations[i] represents the number of power stations in the ith city.\nEach power station can provide power to every city in a fixed range. In other words, if the range is denoted by r, then a power station at city i can provide power to all cities j such that |i - j| <= r and 0 <= i, j <= n - 1.\nNote that |x| denotes absolute value. For example, |7 - 5| = 2 and |3 - 10| = 7.\nThe power of a city is the total number of power stations it is being provided power from.\nThe government has sanctioned building k more power stations, each of which can be built in any city, and have the same range as the pre-existing ones.\nGiven the two integers r and k, return the maximum possible minimum power of a city, if the additional power stations are built optimally.\nNote that you can build the k power stations in multiple cities.", "canonical_solution": "def maxPower(stations, r, k) :\n        def isPossible(min_power,stations,r,k):\n            cur_power = 0\n            for i in range(r+1):\n                cur_power += stations[i]\n            left,right = 0,r\n            for i in range(0,len(stations)):\n                if i-left>r:\n                    cur_power -= stations[left]\n                    left+=1\n                if right-i<r and right<len(stations)-1:\n                    right+=1\n                    cur_power += stations[right]\n                if cur_power < min_power:\n                    power_needed = min_power-cur_power\n                    if k<power_needed: return False\n                    stations[right] += power_needed\n                    cur_power += power_needed\n                    k-=power_needed\n            return True\n        best = min(stations)\n        left,right = 0,10**12\n        while left<=right:\n            mid = (left+right)//2\n            if isPossible(mid,stations[:],r,k):\n                left = mid+1\n                best = mid\n            else:\n                right = mid - 1\n        return best", "entry_point": "maxPower", "test_list": ["assert maxPower([1,2,4,5,0],1,2)==5", "assert maxPower([4,4,4,4],0,3)==4"]}
{"Contest id": "Bi95/2527", "text_name": "Find Xor-Beauty of Array", "text": "You are given a 0-indexed integer array nums.\nThe effective value of three indices i, j, and k is defined as ((nums[i] | nums[j]) & nums[k]).\nThe xor-beauty of the array is the XORing of the effective values of all the possible triplets of indices (i, j, k) where 0 <= i, j, k < n.\nReturn the xor-beauty of nums.\nNote that:\nval1 | val2 is bitwise OR of val1 and val2.\nval1 & val2 is bitwise AND of val1 and val2.", "canonical_solution": "def xorBeauty(nums):\n        import math\n        import collections\n        import itertools\n        beauty = 0\n        for bit in range(math.floor(math.log2(max(nums))) + 1):\n            cnt = collections.Counter((num >> bit) & 1 for num in nums)\n            for i, j, k in itertools.product((0, 1), repeat=3):\n                if (cnt[i] * cnt[j] * cnt[k]) & 1:\n                    beauty ^= ((i | j) & k) << bit\n        return beauty", "entry_point": "xorBeauty", "test_list": ["assert xorBeauty([1,4])==5", "assert xorBeauty([15,45,20,2,34,35,5,44,32,30])==34"]}
{"Contest id": "Bi95/2525", "text_name": "Categorize Box According to Criteria", "text": "Given four integers length, width, height, and mass, representing the dimensions and mass of a box, respectively, return a string representing the category of the box.\nThe box is \"Bulky\" if:\nAny of the dimensions of the box is greater or equal to 104.\nOr, the volume of the box is greater or equal to 109.\nIf the mass of the box is greater or equal to 100, it is \"Heavy\".\nIf the box is both \"Bulky\" and \"Heavy\", then its category is \"Both\".\nIf the box is neither \"Bulky\" nor \"Heavy\", then its category is \"Neither\".\nIf the box is \"Bulky\" but not \"Heavy\", then its category is \"Bulky\".\nIf the box is \"Heavy\" but not \"Bulky\", then its category is \"Heavy\".\nNote that the volume of the box is the product of its length, width and height.", "canonical_solution": "def categorizeBox(length, width, height, mass):\n        volume = length * width * height\n        category = []\n        if length >= 10**4 or width >= 10**4 or height >= 10**4 or volume >= 10**9:\n            category.append(\"Bulky\")\n        if mass >= 100:\n            category.append(\"Heavy\")\n        if \"Bulky\" in category and \"Heavy\" in category:\n            return \"Both\"\n        if not category:\n            return \"Neither\"\n        return category[0]", "entry_point": "categorizeBox", "test_list": ["assert categorizeBox(1000,35,700,300)==\"Heavy\"", "assert categorizeBox(200,50,800,50)==\"Neither\""]}
{"Contest id": "326/2523", "text_name": "Closest Prime Numbers in Range", "text": "Given two positive integers left and right, find the two integers num1 and num2 such that:\nleft <= num1 < num2 <= right .\nnum1 and num2 are both prime numbers.\nnum2 - num1 is the minimum amongst all other pairs satisfying the above conditions.\nReturn the positive integer array ans = [num1, num2]. If there are multiple pairs satisfying these conditions, return the one with the minimum num1 value or [-1, -1] if such numbers do not exist.\nA number greater than 1 is called prime if it is only divisible by 1 and itself.", "canonical_solution": "def closestPrimes(left, right):\n        def isPrime(n):\n            if n < 2: return False\n            for x in range(2, int(n**0.5) + 1):\n                if n % x == 0:\n                    return False\n            return True\n        q = []\n        diff = float('inf')\n        pair = [-1,-1]\n        for i in range(left,right+1):\n            if isPrime(i): \n                q.append(i)\n            while len(q)>=2:\n                if abs(q[0]-q[1])<diff:\n                    pair=[q[0],q[1]]\n                    diff=abs(q[0]-q[1])  \n                    if diff<=2: return pair\n                q.pop(0)\n        return pair", "entry_point": "closestPrimes", "test_list": ["assert closestPrimes(10,19)==[11,13]", "assert closestPrimes(4,6)==[-1,-1]"]}
{"Contest id": "326/2522", "text_name": "Partition String Into Substrings With Values at Most K", "text": "You are given a string s consisting of digits from 1 to 9 and an integer k.\nA partition of a string s is called good if:\nEach digit of s is part of exactly one substring.\nThe value of each substring is less than or equal to k.\nReturn the minimum number of substrings in a good partition of s. If no good partition of s exists, return -1.\nNote that:\nThe value of a string is its result when interpreted as an integer. For example, the value of \"123\" is 123 and the value of \"1\" is 1.\nA substring is a contiguous sequence of characters within a string.", "canonical_solution": "def minimumPartition(s, k):\n        tmp = ''\n        cnt = 0\n        for c in s:\n            tmp += c\n            if int(tmp) > k:\n                tmp = c\n                if int(tmp) > k:\n                    return -1\n                cnt += 1\n        return cnt + 1", "entry_point": "minimumPartition", "test_list": ["assert minimumPartition(\"165462\",60)==4", "assert minimumPartition(\"238182\",5)==-1"]}
{"Contest id": "326/2521", "text_name": "Distinct Prime Factors of Product of Array", "text": "Given an array of positive integers nums, return the number of distinct prime factors in the product of the elements of nums.\nNote that:\nA number greater than 1 is called prime if it is divisible by only 1 and itself.\nAn integer val1 is a factor of another integer val2 if val2 / val1 is an integer.", "canonical_solution": "def distinctPrimeFactors(nums):\n        result = []\n        for i in range (len(nums)) :\n            square_root = int(math.sqrt(nums[i]))\n            for prime_num in range(2, square_root + 1) :\n                if (nums[i] % prime_num == 0) :\n                    result.append(prime_num)\n                    while (nums[i] % prime_num == 0) :\n                        nums[i] = nums[i] // prime_num\n            if (nums[i] >= 2) :\n                result.append(nums[i])\n        result = set(result)\n        return len(result)", "entry_point": "distinctPrimeFactors", "test_list": ["assert distinctPrimeFactors([2,4,3,7,10,6])==4", "assert distinctPrimeFactors([2,4,8,16])==1"]}
{"Contest id": "326/2520", "text_name": "Count the Digits That Divide a Number", "text": "Given an integer num, return the number of digits in num that divide num.\nAn integer val divides nums if nums % val == 0.", "canonical_solution": "def countDigits(num):\n        return sum(1 if num % int(d) == 0 else 0 for d in str(num))", "entry_point": "countDigits", "test_list": ["assert countDigits(7)==1", "assert countDigits(121)==2", "assert countDigits(1248)==4"]}
{"Contest id": "325/2518", "text_name": "Number of Great Partitions", "text": "You are given an array nums consisting of positive integers and an integer k.\nPartition the array into two ordered groups such that each element is in exactly one group. A partition is called great if the sum of elements of each group is greater than or equal to k.\nReturn the number of distinct great partitions. Since the answer may be too large, return it modulo 109 + 7.\nTwo partitions are considered distinct if some element nums[i] is in different groups in the two partitions.", "canonical_solution": "def countPartitions(A,k):\n        if sum(A) < k * 2: return 0\n        mod = 10**9 + 7\n        dp = [1] + [0] * (k - 1)\n        for a in A:\n            for i in range(k - 1 - a, -1, -1):\n                dp[i + a] += dp[i]\n        return (pow(2, len(A), mod) - sum(dp) * 2) % mod", "entry_point": "countPartitions", "test_list": ["assert countPartitions([1,2,3,4],4)==6", "assert countPartitions([3,3,3],4)==0", "assert countPartitions([6,6],2)==2"]}
{"Contest id": "325/2517", "text_name": "Maximum Tastiness of Candy Basket", "text": "You are given an array of positive integers price where price[i] denotes the price of the ith candy and a positive integer k.\nThe store sells baskets of k distinct candies. The tastiness of a candy basket is the smallest absolute difference of the prices of any two candies in the basket.\nReturn the maximum tastiness of a candy basket.", "canonical_solution": "def maximumTastiness(price, k):\n        if k == 0:\n            return 0\n        price.sort()\n        def isValid(num):\n            n = len(price)\n            cnt = 1\n            diff = price[0] + num\n            for i in range(1,n):\n                if price[i] >= diff:\n                    diff = price[i] + num\n                    cnt += 1\n                else:\n                    continue\n            return cnt\n        low,high = 0,max(price) - min(price)\n        ans = -1\n        while low <= high:\n            mid = (low + high) >> 1\n            if isValid(mid) >= k:\n                ans = mid\n                low = mid + 1\n            else:\n                high = mid - 1\n        return ans", "entry_point": "maximumTastiness", "test_list": ["assert maximumTastiness([13,5,1,8,21,2],3)==8", "assert maximumTastiness([1,3,1],2)==2", "assert maximumTastiness([7,7,7,7],2)==0"]}
{"Contest id": "325/2516", "text_name": "Take K of Each Character From Left and Right", "text": "You are given a string s consisting of the characters 'a', 'b', and 'c' and a non-negative integer k. Each minute, you may take either the leftmost character of s, or the rightmost character of s.\nReturn the minimum number of minutes needed for you to take at least k of each character, or return -1 if it is not possible to take k of each character.", "canonical_solution": "def takeCharacters(s, k):\n        ra = s.count('a') - k\n        rb = s.count('b') - k\n        rc = s.count('c') - k\n        if any(i < 0 for i in [ra, rb, rc]):\n            return -1\n        hm = defaultdict(int)\n        length = left = res = 0\n        for right in s:\n            hm[right] += 1\n            length += 1\n            while hm['a'] > ra or hm['b'] > rb or hm['c'] > rc:\n                hm[s[left]] -= 1\n                length -= 1\n                left += 1\n            res = max(res, length)\n        return len(s) - res", "entry_point": "takeCharacters", "test_list": ["assert takeCharacters(\"aabaaaacaabc\",2)==8", "assert takeCharacters(\"a\",1)==-1"]}
{"Contest id": "325/2515", "text_name": "Shortest Distance to Target String in a Circular Array", "text": "You are given a 0-indexed circular string array words and a string target. A circular array means that the array's end connects to the array's beginning.\nFormally, the next element of words[i] is words[(i + 1) % n] and the previous element of words[i] is words[(i - 1 + n) % n], where n is the length of words.\nStarting from startIndex, you can move to either the next word or the previous word with 1 step at a time.\nReturn the shortest distance needed to reach the string target. If the string target does not exist in words, return -1.", "canonical_solution": "def closetTarget(words, target, startIndex):\n        n = len(words)\n        moveright = 0\n        flag = False\n        for i in range(startIndex,len(words)+startIndex):\n            if words[(i+1)%n] == target:\n                flag = True\n                moveright += 1\n                break\n            else:\n                moveright += 1\n        if flag == False:\n            return -1\n        moveleft = 0\n        pointer = startIndex\n        while True:\n            if words[pointer] == target:\n                break\n            else:\n                pointer = (pointer - 1 + n) % n\n                moveleft += 1\n        return min(moveleft,moveright)", "entry_point": "closetTarget", "test_list": ["assert closetTarget([\"hello\",\"i\",\"am\",\"leetcode\",\"hello\"],\"hello\",1)==1", "assert closetTarget([\"a\",\"b\",\"leetcode\"],\"leetcode\",0)==1", "assert closetTarget([\"i\",\"eat\",\"leetcode\"],\"ate\",0)==-1"]}
{"Contest id": "Bi94/2514", "text_name": "Count Anagrams", "text": "You are given a string s containing one or more words. Every consecutive pair of words is separated by a single space ' '.\nA string t is an anagram of string s if the ith word of t is a permutation of the ith word of s.\nFor example, \"acb dfe\" is an anagram of \"abc def\", but \"def cab\" and \"adc bef\" are not.\nReturn the number of distinct anagrams of s. Since the answer may be very large, return it modulo 10^9 + 7.", "canonical_solution": "def countAnagrams(s):\n        from collections import Counter\n        import math\n        res = 1\n        for w in s.split(\" \"):\n            cnt, prem = Counter(w), math.factorial(len(w))\n            for rep in cnt.values():\n                prem = prem // math.factorial(rep)\n            res = res * prem % 1000000007\n        return res", "entry_point": "countAnagrams", "test_list": ["assert countAnagrams(\"too hot\")==18", "assert countAnagrams(\"aa\")==1"]}
{"Contest id": "Bi94/2513", "text_name": "Minimize the Maximum of Two Arrays", "text": "We have two arrays arr1 and arr2 which are initially empty. You need to add positive integers to them such that they satisfy all the following conditions:\narr1 contains uniqueCnt1 distinct positive integers, each of which is not divisible by divisor1.\narr2 contains uniqueCnt2 distinct positive integers, each of which is not divisible by divisor2.\nNo integer is present in both arr1 and arr2.\nGiven divisor1, divisor2, uniqueCnt1, and uniqueCnt2, return the minimum possible maximum integer that can be present in either array.", "canonical_solution": "def minimizeSet(divisor1, divisor2, uniqueCnt1, uniqueCnt2):\n        lcm = math.lcm(divisor1, divisor2)\n        def isok(num):\n            div1 = num - num // divisor1\n            if div1 < uniqueCnt1: \n                return False\n            div2 = num - num // divisor2 \n            if div2 < uniqueCnt2: \n                return False\n            union = num - num // lcm\n            if union < (uniqueCnt1 + uniqueCnt2):\n                return False\n            return True\n        l = 0\n        r = 10**15\n        while l < r: \n            mid = (l+r)//2\n            if isok(mid):\n                r = mid\n            else:\n                l = mid + 1\n        return l", "entry_point": "minimizeSet", "test_list": ["assert minimizeSet(2,7,1,3)==4", "assert minimizeSet(3,5,2,1)==3", "assert minimizeSet(2,4,8,2)==15"]}
{"Contest id": "Bi94/2512", "text_name": "Reward Top K Students", "text": "You are given two string arrays positive_feedback and negative_feedback, containing the words denoting positive and negative feedback, respectively. Note that no word is both positive and negative.\nInitially every student has 0 points. Each positive word in a feedback report increases the points of a student by 3, whereas each negative word decreases the points by 1.\nYou are given n feedback reports, represented by a 0-indexed string array report and a 0-indexed integer array student_id, where student_id[i] represents the ID of the student who has received the feedback report report[i]. The ID of each student is unique.\nGiven an integer k, return the top k students after ranking them in non-increasing order by their points. In case more than one student has the same points, the one with the lower ID ranks higher.", "canonical_solution": "def topStudents(positive_feedback, negative_feedback, report, student_id, k):\n        import collections\n        ans=collections.defaultdict(int)\n        positive_feedback_d=collections.defaultdict(int)\n        negative_feedback_d=collections.defaultdict(int)\n        for i in positive_feedback:\n            positive_feedback_d[i]+=1\n        for i in negative_feedback:\n            negative_feedback_d[i]+=1\n        for i in range(len(report)):\n            for j in report[i].split(\" \"):\n                if positive_feedback_d[j]>=1:\n                    ans[student_id[i]]+=3\n                elif negative_feedback_d[j]>=1:\n                    ans[student_id[i]]-=1\n                else:\n                    continue\n        temp=[]\n        sorted_d = (sorted(ans, key=lambda x: (-ans[x], x)))\n        i=0\n        for j in sorted_d:\n            temp.append(j)\n            i+=1\n            if i>=k:\n                break\n        return(temp)", "entry_point": "topStudents", "test_list": ["assert topStudents([\"smart\",\"brilliant\",\"studious\"],[\"not\"],[\"this student is studious\",\"the student is smart\"],[1,2],2)==[1,2]", "assert topStudents([\"smart\",\"brilliant\",\"studious\"],[\"not\"],[\"this student is not studious\",\"the student is smart\"],[1,2],2)==[2,1]"]}
{"Contest id": "Bi94/2511", "text_name": "Maximum Enemy Forts That Can Be Captured", "text": "You are given a 0-indexed integer array forts of length n representing the positions of several forts. forts[i] can be -1, 0, or 1 where:\n-1 represents there is no fort at the ith position.\n0 indicates there is an enemy fort at the ith position.\n1 indicates the fort at the ith the position is under your command.\nNow you have decided to move your army from one of your forts at position i to an empty position j such that:\n0 <= i, j <= n - 1\nThe army travels over enemy forts only. Formally, for all k where min(i,j) < k < max(i,j), forts[k] == 0.\nWhile moving the army, all the enemy forts that come in the way are captured.\nReturn the maximum number of enemy forts that can be captured. In case it is impossible to move your army, or you do not have any fort under your command, return 0.", "canonical_solution": "def captureForts(forts):\n        def solve(arr):\n            max_ = 0\n            count, flag = 0, False\n            for num in arr:\n                if num == 1: \n                    count, flag = 0, True\n                elif num == -1: \n                    max_, count, flag = max(max_, count), 0, False\n                else: \n                    if flag: count += 1\n            return max_\n        return max(solve(forts), solve(forts[::-1]))", "entry_point": "captureForts", "test_list": ["assert captureForts([1,0,0,-1,0,0,0,0,1])==4", "assert captureForts([0,0,1,-1])==0"]}
{"Contest id": "324/2509", "text_name": "Cycle Length Queries in a Tree", "text": "You are given an integer n. There is a complete binary tree with 2n - 1 nodes. The root of that tree is the node with the value 1, and every node with a value val in the range [1, 2n - 1 - 1] has two children where:\nThe left node has the value 2 * val, and\nThe right node has the value 2 * val + 1.\nYou are also given a 2D integer array queries of length m, where queries[i] = [ai, bi]. For each query, solve the following problem:\nAdd an edge between the nodes with values ai and bi.\nFind the length of the cycle in the graph.\nRemove the added edge between nodes with values ai and bi.\nNote that:\nA cycle is a path that starts and ends at the same node, and each edge in the path is visited only once.\nThe length of a cycle is the number of edges visited in the cycle.\nThere could be multiple edges between two nodes in the tree after adding the edge of the query.\nReturn an array answer of length m where answer[i] is the answer to the ith query.", "canonical_solution": "def cycleLengthQueries(n, queries):\n        res = []\n        for x,y in queries:\n            res.append(1)\n            while x != y:\n                x, y = min(x, y), max(x, y) // 2\n                res[-1] += 1\n        return res", "entry_point": "cycleLengthQueries", "test_list": ["assert cycleLengthQueries(3,[[5,3],[4,7],[2,3]])==[4,5,3]", "assert cycleLengthQueries(2,[[1,2]])==[2]"]}
{"Contest id": "324/2508", "text_name": "Add Edges to Make Degrees of All Nodes Even", "text": "There is an undirected graph consisting of n nodes numbered from 1 to n. You are given the integer n and a 2D array edges where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi. The graph can be disconnected.\nYou can add at most two additional edges (possibly none) to this graph so that there are no repeated edges and no self-loops.\nReturn true if it is possible to make the degree of each node in the graph even, otherwise return false.\nThe degree of a node is the number of edges connected to it.", "canonical_solution": "def isPossible(n, edges):\n        import collections\n        def areConnected(u,v): return u in N[v]\n        N = collections.defaultdict(set)        \n        for u,v in edges: _,_ = N[u].add(v), N[v].add(u)\n        O = [u for u in N if len(N[u]) % 2 == 1]\n        if len(O) == 0: return True\n        if len(O) > 4: return False\n        if len(O) == 2:\n            u,v = O\n            if not areConnected(u,v): return True\n            return any(not areConnected(u,w) and not areConnected(v,w) for w in range(1,n+1))            \n        if len(O) == 4: \n            u,v,w,x = O\n            if not areConnected(u,v) and not areConnected(w,x): return True\n            if not areConnected(u,w) and not areConnected(v,x): return True\n            if not areConnected(u,x) and not areConnected(v,w): return True\n            return False\n        return False", "entry_point": "isPossible", "test_list": ["assert isPossible(5,[[1,2],[2,3],[3,4],[4,2],[1,4],[2,5]])==True", "assert isPossible(4,[[1,2],[3,4]])==True", "assert isPossible(4,[[1,2],[1,3],[1,4]])==False"]}
{"Contest id": "324/2507", "text_name": "Smallest Value After Replacing With Sum of Prime Factors", "text": "You are given a positive integer n.\nContinuously replace n with the sum of its prime factors.\nNote that if a prime factor divides n multiple times, it should be included in the sum as many times as it divides n.\nReturn the smallest value n will take on.", "canonical_solution": "def smallestValue(n):\n        def factorization(n):\n                factors_sum = 0\n                i = 2\n                while n > 1:\n                    while n % i == 0:\n                        n //= i\n                        factors_sum +=i\n                    i += 1\n                return factors_sum\n        while n != (n:=factorization(n)) :pass\n        return n", "entry_point": "smallestValue", "test_list": ["assert smallestValue(15)==5", "assert smallestValue(3)==3"]}
{"Contest id": "324/2506", "text_name": "Count Pairs Of Similar Strings", "text": "You are given a 0-indexed string array words.\nTwo strings are similar if they consist of the same characters.\nFor example, \"abca\" and \"cba\" are similar since both consist of characters 'a', 'b', and 'c'.\nHowever, \"abacba\" and \"bcfd\" are not similar since they do not consist of the same characters.\nReturn the number of pairs (i, j) such that 0 <= i < j <= word.length - 1 and the two strings words[i] and words[j] are similar.", "canonical_solution": "def similarPairs(words):\n        wordMap = {}\n        for word in words:\n            curr = sorted(set(word))\n            curr = ''.join(curr)\n            if curr in wordMap:\n                wordMap[curr]+=1\n            else:\n                wordMap[curr]=1\n        pairs = 0\n        for word in wordMap:\n            count = wordMap[word]\n            pairs += (count* (count-1))//2\n        return pairs", "entry_point": "similarPairs", "test_list": ["assert similarPairs([\"aba\",\"aabb\",\"abcd\",\"bac\",\"aabc\"])==2", "assert similarPairs([\"aabb\",\"ab\",\"ba\"])==3", "assert similarPairs([\"nba\",\"cba\",\"dba\"])==0"]}
{"Contest id": "323/2503", "text_name": "Maximum Number of Points From Grid Queries", "text": "You are given an m x n integer matrix grid and an array queries of size k.\nFind an array answer of size k such that for each integer queries[i] you start in the top left cell of the matrix and repeat the following process:\nIf queries[i] is strictly greater than the value of the current cell that you are in, then you get one point if it is your first time visiting this cell, and you can move to any adjacent cell in all 4 directions: up, down, left, and right.\nOtherwise, you do not get any points, and you end this process.\nAfter the process, answer[i] is the maximum number of points you can get. Note that for each query you are allowed to visit the same cell multiple times.\nReturn the resulting array answer.", "canonical_solution": "def maxPoints(grid, queries):\n    import bisect\n    import heapq\n    m = len(grid)\n    n = len(grid[0])\n    heap = [(grid[0][0], 0, 0)]\n    v = {(0, 0)}\n    order = []\n    while len(heap) > 0:\n            curr, i, j = heapq.heappop(heap)\n            order.append(curr)\n            for x, y in [(i - 1, j), (i, j - 1), (i + 1, j), (i, j + 1)]:\n                    if 0 <= x < m and 0 <= y < n and (x, y) not in v:\n                            v.add((x, y))\n                            heapq.heappush(heap, (grid[x][y], x, y))\n    maxYet = -1\n    for i in range(len(order)):\n            maxYet = max(maxYet, order[i])\n            order[i] = maxYet\n    res = []\n    for q in queries:\n            res.append(bisect.bisect_left(order, q))\n    return res", "entry_point": "maxPoints", "test_list": ["assert maxPoints([[1,2,3],[2,5,7],[3,5,1]],[5,6,2])==[5,8,1]", "assert maxPoints([[5,2,1],[1,1,2]],[3])==[0]"]}
{"Contest id": "323/2501", "text_name": "Longest Square Streak in an Array", "text": "You are given an integer array nums. A subsequence of nums is called a square streak if:\nThe length of the subsequence is at least 2, and\nafter sorting the subsequence, each element (except the first element) is the square of the previous number.\nReturn the length of the longest square streak in nums, or return -1 if there is no square streak.\nA subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.", "canonical_solution": "def longestSquareStreak(nums):\n        uniq = set(nums)\n        res = 0\n        for i in nums:\n            temp = i\n            t = 0\n            while temp * temp in uniq:\n                temp *= temp\n                t += 1          \n            res = max(res, t)\n        return res + 1 if res else -1", "entry_point": "longestSquareStreak", "test_list": ["assert longestSquareStreak([4,3,6,16,8,2])==3", "assert longestSquareStreak([2,3,5,6,7])==-1"]}
{"Contest id": "323/2500", "text_name": "Delete Greatest Value in Each Row", "text": "You are given an m x n matrix grid consisting of positive integers.\nPerform the following operation until grid becomes empty:\nDelete the element with the greatest value from each row. If multiple such elements exist, delete any of them.\nAdd the maximum of deleted elements to the answer.\nNote that the number of columns decreases by one after each operation.\nReturn the answer after performing the operations described above.", "canonical_solution": "def deleteGreatestValue(grid):\n        i = 0\n        output = 0\n        current_max = 0\n        while True:\n            if len(grid[i]) == 0:\n                break\n            grid[i] = sorted(grid[i])\n            current_max = max(current_max,grid[i][-1])\n            grid[i].pop(-1)\n            i+=1\n            if i == len(grid):\n                output += current_max\n                current_max = 0\n                i = 0\n        return output", "entry_point": "deleteGreatestValue", "test_list": ["assert deleteGreatestValue([[1,2,4],[3,3,1]])==8", "assert deleteGreatestValue([[10]])==10"]}
{"Contest id": "Bi93/2499", "text_name": "Minimum Total Cost to Make Arrays Unequal", "text": "You are given two 0-indexed integer arrays nums1 and nums2, of equal length n.\nIn one operation, you can swap the values of any two indices of nums1. The cost of this operation is the sum of the indices.\nFind the minimum total cost of performing the given operation any number of times such that nums1[i] != nums2[i] for all 0 <= i <= n - 1 after performing all the operations.\nReturn the minimum total cost such that nums1 and nums2 satisfy the above condition. In case it is not possible, return -1.", "canonical_solution": "def minimumTotalCost(nums1, nums2):\n    from collections import Counter\n    import  collections\n    d = Counter(nums2)\n    n = len(nums1)\n    h = n//2\n    for i,j in d.items():\n        if j>h:\n            return -1\n    d = collections.defaultdict(int)\n    ans = 0\n    cnt =0\n    for i in range(n):\n        if nums1[i]==nums2[i]:\n            ans+=i\n            cnt+=1\n            d[nums1[i]]+=1\n    val =0\n    mx =0\n    for i,j in d.items():\n        if j>mx:\n            mx =j\n            val = i\n    if mx+mx>cnt:\n        for i in range(n):\n            if nums1[i]!=nums2[i] and nums1[i]!=val and nums2[i]!=val and mx+mx>cnt:\n                ans+=i\n                cnt+=1\n    return ans", "entry_point": "minimumTotalCost", "test_list": ["assert minimumTotalCost([1,2,3,4,5],[1,2,3,4,5])==10", "assert minimumTotalCost([2,2,2,1,3],[1,2,2,3,3])==10", "assert minimumTotalCost([1,2,2],[1,2,2])==-1"]}
{"Contest id": "Bi93/2498", "text_name": "Frog Jump II", "text": "You are given a 0-indexed integer array stones sorted in strictly increasing order representing the positions of stones in a river.\nA frog, initially on the first stone, wants to travel to the last stone and then return to the first stone. However, it can jump to any stone at most once.\nThe length of a jump is the absolute difference between the position of the stone the frog is currently on and the position of the stone to which the frog jumps.\nMore formally, if the frog is at stones[i] and is jumping to stones[j], the length of the jump is |stones[i] - stones[j]|.\nThe cost of a path is the maximum length of a jump among all jumps in the path.\nReturn the minimum cost of a path for the frog.", "canonical_solution": "def maxJump(A):\n        res = A[1] - A[0];\n        for i in range(2, len(A)):\n            res = max(res, A[i] - A[i - 2])\n        return res", "entry_point": "maxJump", "test_list": ["assert maxJump([0,2,5,6,7])==5", "assert maxJump([0,3,9])==9"]}
{"Contest id": "Bi93/2496", "text_name": "Maximum Value of a String in an Array", "text": "The value of an alphanumeric string can be defined as:\nThe numeric representation of the string in base 10, if it comprises of digits only.\nThe length of the string, otherwise.\nGiven an array strs of alphanumeric strings, return the maximum value of any string in strs.", "canonical_solution": "def maximumValue(strs):\n        def sol(strs, index, max_):\n            if index >= len(strs): return max_\n            if strs[index].isdigit():\n                return sol(strs, index + 1, max(max_, int(strs[index])))\n            return sol(strs, index + 1, max(max_, len(strs[index])))\n        return sol(strs, 0, 0)", "entry_point": "maximumValue", "test_list": ["assert maximumValue([\"alic3\",\"bob\",\"3\",\"4\",\"00000\"])==5", "assert maximumValue([\"1\",\"01\",\"001\",\"0001\"])==1"]}
{"Contest id": "322/2493", "text_name": "Divide Nodes Into the Maximum Number of Groups", "text": "You are given a positive integer n representing the number of nodes in an undirected graph. The nodes are labeled from 1 to n.\nYou are also given a 2D integer array edges, where edges[i] = [ai, bi] indicates that there is a bidirectional edge between nodes ai and bi. Notice that the given graph may be disconnected.\nDivide the nodes of the graph into m groups (1-indexed) such that:\nEach node in the graph belongs to exactly one group.\nFor every pair of nodes in the graph that are connected by an edge [ai, bi], if ai belongs to the group with index x, and bi belongs to the group with index y, then |y - x| = 1.\nReturn the maximum number of groups (i.e., maximum m) into which you can divide the nodes. Return -1 if it is impossible to group the nodes with the given conditions.", "canonical_solution": "def magnificentSets(n,e):\n        ajc = defaultdict(list)\n        for i , j in e:\n            ajc[i].append(j)\n            ajc[j].append(i)\n        def st(i):\n            rt , cur , used , vi = 1 , [i] , {i} , [0] * (n+1)\n            vi[i] = 1\n            while cur:\n                nxt = set()\n                for v in cur:\n                    for u in ajc[v]:\n                        if vi[u] == rt:\n                            return -1 , -1\n                        elif vi[u] == 0:\n                            used.add(u)\n                            nxt.add(u)\n                            vi[u] = rt +1\n                cur = nxt\n                if not cur: break\n                rt += 1\n            return min(used) , rt\n        ans = {}\n        for j in range(1 , n+1):\n            rep , rt = st(j)\n            if rep == -1:\n                return -1\n            ans[rep] = max(ans.get(rep , 0) , rt) \n        return sum(ans.values())", "entry_point": "magnificentSets", "test_list": ["assert magnificentSets(6,[[1,2],[1,4],[1,5],[2,6],[2,3],[4,6]])==4", "assert magnificentSets(3,[[1,2],[2,3],[3,1]])==-1"]}
{"Contest id": "322/2492", "text_name": "Minimum Score of a Path Between Two Cities", "text": "You are given a positive integer n representing n cities numbered from 1 to n. You are also given a 2D array roads where roads[i] = [ai, bi, distancei] indicates that there is a bidirectional road between cities ai and bi with a distance equal to distancei. The cities graph is not necessarily connected.\nThe score of a path between two cities is defined as the minimum distance of a road in this path.\nReturn the minimum possible score of a path between cities 1 and n.\nNote:\nA path is a sequence of roads between two cities.\nIt is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\nThe test cases are generated such that there is at least one path between 1 and n.", "canonical_solution": "def minScore(n, roads):\n    import queue\n    from sys import maxsize\n    ans = maxsize\n    gr = [[] for _ in range(n+1)]\n    for edge in roads:\n        gr[edge[0]].append((edge[1], edge[2]))\n        gr[edge[1]].append((edge[0], edge[2]))\n    vis = [0] * (n+1)\n    q = queue.Queue()\n    q.put(1)\n    vis[1] = 1\n    while not q.empty():\n        node = q.get()\n        for v, dis in gr[node]:\n            ans = min(ans, dis)\n            if vis[v] == 0:\n                vis[v] = 1\n                q.put(v)\n    return ans", "entry_point": "minScore", "test_list": ["assert minScore(4,[[1,2,9],[2,3,6],[2,4,5],[1,4,7]])==5", "assert minScore(4,[[1,2,2],[1,3,4],[3,4,7]])==2"]}
{"Contest id": "322/2491", "text_name": "Divide Players Into Teams of Equal Skill", "text": "You are given a positive integer array skill of even length n where skill[i] denotes the skill of the ith player. Divide the players into n / 2 teams of size 2 such that the total skill of each team is equal.\nThe chemistry of a team is equal to the product of the skills of the players on that team.\nReturn the sum of the chemistry of all the teams, or return -1 if there is no way to divide the players into teams such that the total skill of each team is equal.", "canonical_solution": "def dividePlayers(skill):\n        skill.sort()\n        ans, sum_ = 0, 0\n        ptr1, ptr2 = 0, len(skill) - 1\n        for i in range(len(skill) // 2):\n            if i == 0:\n                sum_ = skill[ptr1] + skill[ptr2]\n                ans += (skill[ptr1] * skill[ptr2])\n            else:\n                if (skill[ptr1] + skill[ptr2]) != sum_: return -1\n                ans += (skill[ptr1] * skill[ptr2])\n            ptr1 += 1\n            ptr2 -= 1\n        return ans", "entry_point": "dividePlayers", "test_list": ["assert dividePlayers([3,2,5,1,3,4])==22", "assert dividePlayers([3,4])==12", "assert dividePlayers([1,1,2,3])==-1"]}
{"Contest id": "322/2490", "text_name": "Circular Sentence", "text": "A sentence is a list of words that are separated by a single space with no leading or trailing spaces.\nFor example, \"Hello World\", \"HELLO\", \"hello world hello world\" are all sentences.\nWords consist of only uppercase and lowercase English letters. Uppercase and lowercase English letters are considered different.\nA sentence is circular if:\nThe last character of a word is equal to the first character of the next word.\nThe last character of the last word is equal to the first character of the first word.\nFor example, \"leetcode exercises sound delightful\", \"eetcode\", \"leetcode eats soul\" are all circular sentences. However, \"Leetcode is cool\", \"happy Leetcode\", \"Leetcode\" and \"I like Leetcode\" are not circular sentences.\nGiven a string sentence, return true if it is circular. Otherwise, return false.", "canonical_solution": "def isCircularSentence(s):\n        arr, word = [], ''\n        for ch in s:\n            if ch == ' ':\n                arr.append(word)\n                word = ''\n            else: word += ch\n        arr.append(word)\n        if arr[0][0] != arr[-1][-1]:\n            return False\n        last = arr[0][-1]   \n        for i in range(1, len(arr)):\n            if arr[i][0] == last:\n                last = arr[i][-1]\n            else:\n                return False\n        return True", "entry_point": "isCircularSentence", "test_list": ["assert isCircularSentence(\"leetcode exercises sound delightful\")==True", "assert isCircularSentence(\"eetcode\")==True", "assert isCircularSentence(\"Leetcode is cool\")==False"]}
{"Contest id": "321/2488", "text_name": "Count Subarrays With Median K", "text": "You are given an array nums of size n consisting of distinct integers from 1 to n and a positive integer k.\nReturn the number of non-empty subarrays in nums that have a median equal to k.\nNote:\nThe median of an array is the middle element after sorting the array in ascending order. If the array is of even length, the median is the left middle element.\nFor example, the median of [2,3,1,4] is 2, and the median of [8,4,3,5,1] is 4.\nA subarray is a contiguous part of an array.", "canonical_solution": "def countSubarrays(nums, k):\n        d, iMed = defaultdict(int), nums.index(k)\n        ans, diff, d[0] = 0, 0, 1\n        for i, n in enumerate(nums):\n            diff+= (n>k) - (n<k)\n            if i < iMed: d[diff]+= 1\n            else: ans += (d[diff] + d[diff-1])\n        return ans", "entry_point": "countSubarrays", "test_list": ["assert countSubarrays([3,2,1,4,5],4)==3", "assert countSubarrays([2,3,1],3)==1"]}
{"Contest id": "321/2486", "text_name": "Append Characters to String to Make Subsequence", "text": "You are given two strings s and t consisting of only lowercase English letters.\nReturn the minimum number of characters that need to be appended to the end of s so that t becomes a subsequence of s.\nA subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.", "canonical_solution": "def appendCharacters(s, t):\n        it = iter(s)\n        for i,c in enumerate(t):\n            if c not in it:\n                return len(t) - i\n        return 0", "entry_point": "appendCharacters", "test_list": ["assert appendCharacters(\"coaching\",\"coding\")==4", "assert appendCharacters(\"abcde\",\"a\")==0", "assert appendCharacters(\"z\",\"abcde\")==5"]}
{"Contest id": "321/2485", "text_name": "Find the Pivot Integer", "text": "Given a positive integer n, find the pivot integer x such that:\nThe sum of all elements between 1 and x inclusively equals the sum of all elements between x and n inclusively.\nReturn the pivot integer x. If no such integer exists, return -1. It is guaranteed that there will be at most one pivot index for the given input.", "canonical_solution": "def pivotInteger(n):\n    from math import sqrt\n    temp = (n * n + n) // 2\n    sq = int(sqrt(temp))\n    if sq * sq == temp:\n        return sq\n    return -1", "entry_point": "pivotInteger", "test_list": ["assert pivotInteger(8)==6", "assert pivotInteger(1)==1", "assert pivotInteger(4)==-1"]}
{"Contest id": "Bi92/2484", "text_name": "Count Palindromic Subsequences", "text": "Given a string of digits s, return the number of palindromic subsequences of s having length 5. Since the answer may be very large, return it modulo 109 + 7.\nNote:\nA string is palindromic if it reads the same forward and backward.\nA subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.", "canonical_solution": "def countPalindromes(s):\n        res=0\n        for i in range(10):\n            for j in range(10):\n                pattern=str(i)+str(j)+\"|\"+str(j)+str(i)\n                dp=[0]*6\n                dp[-1]=1\n                for x in range(len(s)):\n                    for y in range(5):\n                        if s[x]==pattern[y] or y==2:\n                            dp[y]+=dp[y+1]\n                res=(res+dp[0])%(10**9+7)\n        return res ", "entry_point": "countPalindromes", "test_list": ["assert countPalindromes(\"103301\")==2", "assert countPalindromes(\"0000000\")==21", "assert countPalindromes(\"9999900000\")==2"]}
{"Contest id": "Bi92/2483", "text_name": "Minimum Penalty for a Shop", "text": "You are given the customer visit log of a shop represented by a 0-indexed string customers consisting only of characters 'N' and 'Y':\nif the ith character is 'Y', it means that customers come at the ith hour\nwhereas 'N' indicates that no customers come at the ith hour.\nIf the shop closes at the jth hour (0 <= j <= n), the penalty is calculated as follows:\nFor every hour when the shop is open and no customers come, the penalty increases by 1.\nFor every hour when the shop is closed and customers come, the penalty increases by 1.\nReturn the earliest hour at which the shop must be closed to incur a minimum penalty.\nNote that if a shop closes at the jth hour, it means the shop is closed at the hour j.", "canonical_solution": "def bestClosingTime(customers):\n        max_score = 0\n        score = 0\n        right_time = -1\n        for i in range(len(customers)):\n            score += 1 if customers[i] == 'Y' else -1\n            if score > max_score:\n                max_score = score\n                right_time = i\n        return right_time + 1", "entry_point": "bestClosingTime", "test_list": ["assert bestClosingTime(\"YYNY\")==2", "assert bestClosingTime(\"NNNNN\")==0", "assert bestClosingTime(\"YYYY\")==4"]}
{"Contest id": "Bi92/2482", "text_name": "Difference Between Ones and Zeros in Row and Column", "text": "You are given a 0-indexed m x n binary matrix grid.\nA 0-indexed m x n difference matrix diff is created with the following procedure:\nLet the number of ones in the ith row be onesRowi.\nLet the number of ones in the jth column be onesColj.\nLet the number of zeros in the ith row be zerosRowi.\nLet the number of zeros in the jth column be zerosColj.\ndiff[i][j] = onesRowi + onesColj - zerosRowi - zerosColj\nReturn the difference matrix diff.", "canonical_solution": "def onesMinusZeros(grid):\n        m, n = len(grid), len(grid[0])\n        row_ones = [0] * m\n        col_ones = [0] * n\n        for i in range(m):\n            for j in range(n):\n                row_ones[i] += grid[i][j]\n                col_ones[j] += grid[i][j]\n        for i in range(m):\n            for j in range(n):\n                grid[i][j] = 2 * (row_ones[i] + col_ones[j]) - m - n\n        return grid", "entry_point": "onesMinusZeros", "test_list": ["assert onesMinusZeros([[0,1,1],[1,0,1],[0,0,1]])==[[0,0,4],[0,0,4],[-2,-2,2]]", "assert onesMinusZeros([[1,1,1],[1,1,1]])==[[5,5,5],[5,5,5]]"]}
{"Contest id": "320/2478", "text_name": "Number of Beautiful Partitions", "text": "You are given a string s that consists of the digits '1' to '9' and two integers k and minLength.\nA partition of s is called beautiful if:\ns is partitioned into k non-intersecting substrings.\nEach substring has a length of at least minLength.\nEach substring starts with a prime digit and ends with a non-prime digit. Prime digits are '2', '3', '5', and '7', and the rest of the digits are non-prime.\nReturn the number of beautiful partitions of s. Since the answer may be very large, return it modulo 109 + 7.\nA substring is a contiguous sequence of characters within a string.", "canonical_solution": "def beautifulPartitions(s, k, minLength):\n        M = 10 ** 9 + 7\n        n = len(s)\n        primes = \"2357\"\n        isPrime = False\n        isComp = False\n        for c in s:\n            if c in primes:\n                isPrime = True\n            else:\n                isComp = True\n        if not isPrime or not isComp:\n            return 0\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        dp[n][0] = 1\n        primesum = [[0] for _ in range(k + 1)]\n        primesum[0][0] = 1\n        for i in range(n - 1, -1, -1):\n            if s[i] in primes:\n                for l in range(1, k + 1):\n                    if minLength <= len(primesum[l - 1]):\n                        dp[i][l] += primesum[l - 1][-minLength]\n            for l in range(k + 1):\n                val = 0\n                if s[i] in primes and (i == 0 or s[i - 1] not in primes):\n                    val = dp[i][l]\n                primesum[l].append(primesum[l][-1] + val)\n        return dp[0][k] % M", "entry_point": "beautifulPartitions", "test_list": ["assert beautifulPartitions(\"23542185131\",3,2)==3", "assert beautifulPartitions(\"23542185131\",3,3)==1", "assert beautifulPartitions(\"3312958\",3,1)==1"]}
{"Contest id": "320/2477", "text_name": "Minimum Fuel Cost to Report to the Capital", "text": "There is a tree (i.e., a connected, undirected graph with no cycles) structure country network consisting of n cities numbered from 0 to n - 1 and exactly n - 1 roads. The capital city is city 0. You are given a 2D integer array roads where roads[i] = [ai, bi] denotes that there exists a bidirectional road connecting cities ai and bi.\nThere is a meeting for the representatives of each city. The meeting is in the capital city.\nThere is a car in each city. You are given an integer seats that indicates the number of seats in each car.\nA representative can use the car in their city to travel or change the car and ride with another representative. The cost of traveling between two cities is one liter of fuel.\nReturn the minimum number of liters of fuel to reach the capital city.", "canonical_solution": "def minimumFuelCost(roads, seats):\n    import math\n    ans = 0\n    graph = [[] for _ in range(len(roads) + 1)]\n    for u, v in roads:\n        graph[u].append(v)\n        graph[v].append(u)\n    def dfs(u,prev):\n        nonlocal ans\n        people = 1\n        for v in graph[u]:\n            if v == prev:\n                continue\n            people += dfs(v, u)\n        if u > 0:\n            ans += int(math.ceil(people / seats))\n        return people\n    dfs(0, -1)\n    return ans", "entry_point": "minimumFuelCost", "test_list": ["assert minimumFuelCost([[0,1],[0,2],[0,3]],5)==3", "assert minimumFuelCost([[3,1],[3,2],[1,0],[0,4],[0,5],[4,6]],2)==7", "assert minimumFuelCost([],1)==0"]}
{"Contest id": "320/2475", "text_name": "Number of Unequal Triplets in Array", "text": "You are given a 0-indexed array of positive integers nums. Find the number of triplets (i, j, k) that meet the following conditions:\n0 <= i < j < k < nums.length\nnums[i], nums[j], and nums[k] are pairwise distinct.\nIn other words, nums[i] != nums[j], nums[i] != nums[k], and nums[j] != nums[k].\nReturn the number of triplets that meet the conditions.", "canonical_solution": "def unequalTriplets(A):\n    from collections import Counter\n    trips = pairs = 0\n    count = Counter()\n    for i,a in enumerate(A):\n        trips += pairs - count[a] * (i - count[a])\n        pairs += i - count[a]\n        count[a] += 1\n    return trips\nunequalTriplets([4,4,2,4,3])", "entry_point": "unequalTriplets", "test_list": ["assert unequalTriplets([4,4,2,4,3])==3", "assert unequalTriplets([1,1,1,1,1])==0"]}
{"Contest id": "319/2472", "text_name": "Maximum Number of Non-overlapping Palindrome Substrings", "text": "You are given a string s and a positive integer k.\nSelect a set of non-overlapping substrings from the string s that satisfy the following conditions:\nThe length of each substring is at least k.\nEach substring is a palindrome.\nReturn the maximum number of substrings in an optimal selection.\nA substring is a contiguous sequence of characters within a string.", "canonical_solution": "def maxPalindromes(s, k):\n        n = len(s)\n        def valid(i, j):\n            if j > len(s):\n                return False\n            if s[i : j] == s[i : j][::-1]:\n                return True\n            return False\n        maxSubstrings = 0\n        start = 0\n        while start < n:\n            if valid(start, start + k):\n                maxSubstrings += 1\n                start += k\n            elif valid(start, start + k + 1):\n                maxSubstrings += 1\n                start += k + 1\n            else:\n                start += 1\n        return maxSubstrings", "entry_point": "maxPalindromes", "test_list": ["assert maxPalindromes(\"abaccdbbd\",3)==2", "assert maxPalindromes(\"adbcda\",2)==0"]}
{"Contest id": "319/2470", "text_name": "Number of Subarrays With LCM Equal to K", "text": "Given an integer array nums and an integer k, return the number of subarrays of nums where the least common multiple of the subarray's elements is k.\nA subarray is a contiguous non-empty sequence of elements within an array.\nThe least common multiple of an array is the smallest positive integer that is divisible by all the array elements.", "canonical_solution": "def subarrayLCM(nums, k):\n        def gcd(a,b):\n            return math.gcd(a,b)\n        def lcm(n1,n2):\n            return (n1*n2)//gcd(n1,n2)\n        n=len(nums)\n        ans=0\n        for i in range(n):\n            lcmi=nums[i]\n            for j in range(i,n):\n                lcmi=lcm(lcmi,nums[j])\n                if(lcmi==k):\n                    ans+=1\n        return ans", "entry_point": "subarrayLCM", "test_list": ["assert subarrayLCM([3,6,2,7,1],6)==4", "assert subarrayLCM([3],2)==0"]}
{"Contest id": "319/2469", "text_name": "Convert the Temperature", "text": "You are given a non-negative floating point number rounded to two decimal places celsius, that denotes the temperature in Celsius.\nYou should convert Celsius into Kelvin and Fahrenheit and return it as an array ans = [kelvin, fahrenheit].\nReturn the array ans. Answers within 10-5 of the actual answer will be accepted.", "canonical_solution": "def convertTemperature(celsius):\n        return [(celsius + 273.15),(celsius * 1.80 + 32.00)]", "entry_point": "convertTemperature", "test_list": ["assert convertTemperature(36.50)==[309.65000,97.70000]", "assert convertTemperature(122.11)==[395.26000,251.79800]"]}
{"Contest id": "Bi91/2468", "text_name": "Split Message Based on Limit", "text": "You are given a string, message, and a positive integer, limit.\nYou must split message into one or more parts based on limit. Each resulting part should have the suffix \"<a/b>\", where \"b\" is to be replaced with the total number of parts and \"a\" is to be replaced with the index of the part, starting from 1 and going up to b. Additionally, the length of each resulting part (including its suffix) should be equal to limit, except for the last part whose length can be at most limit.\nThe resulting parts should be formed such that when their suffixes are removed and they are all concatenated in order, they should be equal to message. Also, the result should contain as few parts as possible.\nReturn the parts message would be split into as an array of strings. If it is impossible to split message as required, return an empty array.", "canonical_solution": "def splitMessage(s, limit):\n        cur = k = i = 0\n        while 3 + len(str(k)) * 2 < limit and cur + len(s) + (3 + len(str(k))) * k > limit * k:\n            k += 1\n            cur += len(str(k))\n        res = []\n        if 3 + len(str(k)) * 2 < limit:\n            for j in range(1, k + 1):\n                l = limit - (len(str(j)) + 3 + len(str(k)))\n                res.append('%s<%s/%s>' % (s[i:i + l], j, k))\n                i += l\n        return res", "entry_point": "splitMessage", "test_list": ["assert splitMessage(\"this is really a very awesome message\",9) == [\"thi<1/14>\",\"s i<2/14>\",\"s r<3/14>\",\"eal<4/14>\",\"ly <5/14>\",\"a v<6/14>\",\"ery<7/14>\",\" aw<8/14>\",\"eso<9/14>\",\"me<10/14>\",\" m<11/14>\",\"es<12/14>\",\"sa<13/14>\",\"ge<14/14>\"]", "assert splitMessage(\"short message\", 15) == [\"short mess<1/2>\",\"age<2/2>\"]"]}
{"Contest id": "Bi91/2466", "text_name": "Count Ways To Build Good Strings", "text": "Given the integers zero, one, low, and high, we can construct a string by starting with an empty string, and then at each step perform either of the following:\nAppend the character '0' zero times.\nAppend the character '1' one times.\nThis can be performed any number of times.\nA good string is a string constructed by the above process having a length between low and high (inclusive).\nReturn the number of different good strings that can be constructed satisfying these properties. Since the answer can be large, return it modulo 109 + 7.", "canonical_solution": "def countGoodStrings(low, high, zero, one):\n        dp = [0] * (high+1)\n        ans, mod = 0, 10**9+7\n        dp[0] = 1\n        for i in range(1, high+1):\n            dp[i] = ((dp[i-zero] if i-zero>=0 else 0) + (dp[i-one] if i-one>=0 else 0)) % mod\n            if i >= low:\n                ans = (ans + dp[i]) % mod\n        return ans", "entry_point": "countGoodStrings", "test_list": ["assert countGoodStrings(low = 3, high = 3, zero = 1, one = 1) == 8", "assert countGoodStrings(low = 2, high = 3, zero = 1, one = 2) == 5"]}
{"Contest id": "Bi91/2465", "text_name": "Number of Distinct Averages", "text": "You are given a 0-indexed integer array nums of even length.\nAs long as nums is not empty, you must repetitively:\nFind the minimum number in nums and remove it.\nFind the maximum number in nums and remove it.\nCalculate the average of the two removed numbers.\nThe average of two numbers a and b is (a + b) / 2.\nFor example, the average of 2 and 3 is (2 + 3) / 2 = 2.5.\nReturn the number of distinct averages calculated using the above process.\nNote that when there is a tie for a minimum or maximum number, any can be removed.", "canonical_solution": "def distinctAverages(nums):\n        n = len(nums)\n        nums.sort()\n        r = n-1\n        res = set()\n        for l in range(n//2) :\n            avg = (nums[l]+nums[r])/2\n            res.add(avg)\n            r -= 1\n        return len(res)", "entry_point": "distinctAverages", "test_list": ["assert distinctAverages([4,1,4,0,3,5]) == 2", "assert distinctAverages([1,100]) == 1"]}
{"Contest id": "318/2463", "text_name": "Minimum Total Distance Traveled", "text": "There are some robots and factories on the X-axis. You are given an integer array robot where robot[i] is the position of the ith robot. You are also given a 2D integer array factory where factory[j] = [positionj, limitj] indicates that positionj is the position of the jth factory and that the jth factory can repair at most limitj robots.\nThe positions of each robot are unique. The positions of each factory are also unique. Note that a robot can be in the same position as a factory initially.\nAll the robots are initially broken; they keep moving in one direction. The direction could be the negative or the positive direction of the X-axis. When a robot reaches a factory that did not reach its limit, the factory repairs the robot, and it stops moving.\nAt any moment, you can set the initial direction of moving for some robot. Your target is to minimize the total distance traveled by all the robots.\nReturn the minimum total distance traveled by all the robots. The test cases are generated such that all the robots can be repaired.\nNote that\nAll robots move at the same speed.\nIf two robots move in the same direction, they will never collide.\nIf two robots move in opposite directions and they meet at some point, they do not collide. They cross each other.\nIf a robot passes by a factory that reached its limits, it crosses it as if it does not exist.\nIf the robot moved from a position x to a position y, the distance it moved is |y - x|.\n", "canonical_solution": "def minimumTotalDistance(R, F):\n        R.sort()\n        F.sort()\n        dp = [0] + [float('inf')] * len(R)\n        for j, (f, l) in enumerate(F):\n            for _ in range(l):\n                for i in range(len(R), 0, -1):\n                    dp[i] = min(dp[i], dp[i-1] + abs(R[i-1]-f))\n        return dp[-1]", "entry_point": "minimumTotalDistance", "test_list": ["assert minimumTotalDistance([0,4,6],[[2,2],[6,2]]) == 4", "assert minimumTotalDistance([1,-1],[[-2,1],[2,1]]) == 2"]}
{"Contest id": "318/2462", "text_name": "Total Cost to Hire K Workers", "text": "You are given a 0-indexed integer array costs where costs[i] is the cost of hiring the ith worker.\nYou are also given two integers k and candidates. We want to hire exactly k workers according to the following rules:\nYou will run k sessions and hire exactly one worker in each session.\nIn each hiring session, choose the worker with the lowest cost from either the first candidates workers or the last candidates workers. Break the tie by the smallest index.\nFor example, if costs = [3,2,7,7,1,2] and candidates = 2, then in the first hiring session, we will choose the 4th worker because they have the lowest cost [3,2,7,7,1,2].\nIn the second hiring session, we will choose 1st worker because they have the same lowest cost as 4th worker but they have the smallest index [3,2,7,7,2]. Please note that the indexing may be changed in the process.\nIf there are fewer than candidates workers remaining, choose the worker with the lowest cost among them. Break the tie by the smallest index.\nA worker can only be chosen once.\nReturn the total cost to hire exactly k workers.", "canonical_solution": "def totalCost(costs, k, candidates):\n        import heapq\n        q=costs[:candidates]\n        r=costs[max(candidates,len(costs)-candidates):]\n        heapq.heapify(q)\n        heapq.heapify(r)\n        res=0\n        i=candidates\n        j=len(costs)-candidates-1\n        for _  in range(k):\n            if not r or q and q[0]<=r[0]:\n                res+=heapq.heappop(q)\n                if i<=j:\n                    heapq.heappush(q,costs[i])\n                    i+=1\n            else:\n                res+=heapq.heappop(r)\n                if i<=j:\n                    heapq.heappush(r,costs[j])\n                    j-=1       \n        return res", "entry_point": "totalCost", "test_list": ["assert totalCost(costs = [17,12,10,2,7,2,11,20,8], k = 3, candidates = 4) == 11", "assert totalCost(costs = [1,2,4,1], k = 3, candidates = 3) == 4"]}
{"Contest id": "318/2461", "text_name": "Maximum Sum of Distinct Subarrays With Length K", "text": "You are given an integer array nums and an integer k. Find the maximum subarray sum of all the subarrays of nums that meet the following conditions:\nThe length of the subarray is k, and\nAll the elements of the subarray are distinct.\nReturn the maximum subarray sum of all the subarrays that meet the conditions. If no subarray meets the conditions, return 0.\nA subarray is a contiguous non-empty sequence of elements within an array.\n", "canonical_solution": "def maximumSubarraySum(nums, k):\n        prefixS = [ nums[0] ]\n        for i in range( 1, len(nums) ):\n            prefixS.append( prefixS[-1] + nums[i] )       \n        best = 0            \n        start = 0           \n        summation = 0      \n        lastIndexOf = defaultdict( lambda : -1)\n        for end, number in enumerate(nums):                       \n            if lastIndexOf[number] >= start:\n                summation = prefixS[end] - prefixS[ lastIndexOf[number] ]\n                start = lastIndexOf[number] + 1                \n            elif start + k == end:\n                summation = prefixS[end] - prefixS[start]\n                start += 1                \n            else:\n                summation += nums[end]           \n            if (end - start + 1) == k:\n                best = max(best, summation)\n            lastIndexOf[ number ] = end           \n        return best", "entry_point": "maximumSubarraySum", "test_list": ["assert maximumSubarraySum(nums = [1,5,4,2,9,9,9], k = 3) == 15", "assert maximumSubarraySum(nums = [4,4,4], k = 3) == 0"]}
{"Contest id": "318/2460", "text_name": "Apply Operations to an Array", "text": "You are given a 0-indexed array nums of size n consisting of non-negative integers.\nYou need to apply n - 1 operations to this array where, in the ith operation (0-indexed), you will apply the following on the ith element of nums:\nIf nums[i] == nums[i + 1], then multiply nums[i] by 2 and set nums[i + 1] to 0. Otherwise, you skip this operation.\nAfter performing all the operations, shift all the 0's to the end of the array.\nFor example, the array [1,0,2,0,0,1] after shifting all its 0's to the end, is [1,2,1,0,0,0].\nReturn the resulting array.\nNote that the operations are applied sequentially, not all at once.", "canonical_solution": "def applyOperations(nums):\n        for i in range(len(nums)-1):\n            if nums[i]==nums[i+1]:\n                nums[i]*=2\n                nums[i+1]=0                \n        temp = []\n        zeros = []\n        a=nums\n        for i in range(len(a)):\n            if a[i] !=0:\n                temp.append(a[i])\n            else:\n                zeros.append(a[i])\n        return (temp+zeros)", "entry_point": "applyOperations", "test_list": ["assert applyOperations([1,2,2,1,1,0]) == [1,4,2,0,0,0]", "assert applyOperations([0,1]) == [1,0]"]}
{"Contest id": "317/2457", "text_name": "Minimum Addition to Make Integer Beautiful", "text": "You are given two positive integers n and target.\nAn integer is considered beautiful if the sum of its digits is less than or equal to target.\nReturn the minimum non-negative integer x such that n + x is beautiful. The input will be generated such that it is always possible to make n beautiful.", "canonical_solution": "def makeIntegerBeautiful(n, target):\n        n0 = n\n        i = 0\n        while sum(map(int, str(n))) > target:\n            n = n // 10 + 1\n            i += 1\n        return n * (10 ** i) - n0", "entry_point": "makeIntegerBeautiful", "test_list": ["assert makeIntegerBeautiful(16,6)==4", "assert makeIntegerBeautiful(467,6)==33", "assert makeIntegerBeautiful(1,1)==0"]}
{"Contest id": "317/2456", "text_name": "Most Popular Video Creator", "text": "You are given two string arrays creators and ids, and an integer array views, all of length n. The ith video on a platform was created by creator[i], has an id of ids[i], and has views[i] views.\nThe popularity of a creator is the sum of the number of views on all of the creator's videos. Find the creator with the highest popularity and the id of their most viewed video.\nIf multiple creators have the highest popularity, find all of them.\nIf multiple videos have the highest view count for a creator, find the lexicographically smallest id.\nReturn a 2D array of strings answer where answer[i] = [creatori, idi] means that creatori has the highest popularity and idi is the id of their most popular video. The answer can be returned in any order.", "canonical_solution": "def mostPopularCreator(creators, ids, views):\n        memo = {}\n        overall_max_popular_video_count = -1\n        for i in range(len(creators)):\n            if creators[i] in memo:\n                memo[creators[i]][0] += views[i]\n                if memo[creators[i]][2] < views[i]:\n                    memo[creators[i]][1] = ids[i]\n                    memo[creators[i]][2] = views[i]\n                elif memo[creators[i]][2] == views[i]:\n                    memo[creators[i]][1] = min(memo[creators[i]][1],ids[i])\n            else:\n                memo[creators[i]] = [views[i],ids[i],views[i]]\n            overall_max_popular_video_count = max(memo[creators[i]][0],overall_max_popular_video_count)     \n        result = []\n        for i in memo:\n            if memo[i][0] == overall_max_popular_video_count:\n                result.append([i,memo[i][1]])\n        return result", "entry_point": "mostPopularCreator", "test_list": ["assert mostPopularCreator([\"alice\",\"bob\",\"alice\",\"chris\"],[\"one\",\"two\",\"three\",\"four\"],[5,10,5,4])==[[\"alice\",\"one\"],[\"bob\",\"two\"]]", "assert mostPopularCreator([\"alice\",\"alice\",\"alice\"],  [\"a\",\"b\",\"c\"], [1,2,2])==[[\"alice\",\"b\"]]"]}
{"Contest id": "317/2455", "text_name": "Average Value of Even Numbers That Are Divisible by Three", "text": "Given an integer array nums of positive integers, return the average value of all even integers that are divisible by 3.\nNote that the average of n elements is the sum of the n elements divided by n and rounded down to the nearest integer.", "canonical_solution": "def averageValue(nums):\n    nums = [n for n in nums if not n%6]\n    return sum(nums)//len(nums) if nums else 0", "entry_point": "averageValue", "test_list": ["assert averageValue([1,3,6,10,12,15])==9", "assert averageValue([1,2,4,7,10])==0"]}
{"Contest id": "Bi90/2454", "text_name": "Next Greater Element IV", "text": "You are given a 0-indexed array of non-negative integers nums. For each integer in nums, you must find its respective second greater integer.\nThe second greater integer of nums[i] is nums[j] such that:\nj > i\nnums[j] > nums[i]\nThere exists exactly one index k such that nums[k] > nums[i] and i < k < j.\nIf there is no such nums[j], the second greater integer is considered to be -1.\nFor example, in the array [1, 2, 4, 3], the second greater integer of 1 is 4, 2 is 3, and that of 3 and 4 is -1.\nReturn an integer array answer, where answer[i] is the second greater integer of nums[i].", "canonical_solution": "def secondGreaterElement(nums):\n    res, s1, s2 = [-1] * len(nums), [], []\n    for i,a in enumerate(nums):\n        while s2 and nums[s2[-1]] < a:\n            res[s2.pop()] = a\n        tmp = []\n        while s1 and nums[s1[-1]] < a:\n            tmp.append(s1.pop())\n        s2 += tmp[::-1]\n        s1.append(i)\n    return res", "entry_point": "secondGreaterElement", "test_list": ["assert secondGreaterElement([2,4,0,9,6])==[9,6,6,-1,-1]", "assert secondGreaterElement([3,3])==[-1,-1]"]}
{"Contest id": "Bi90/2453", "text_name": "Destroy Sequential Targets", "text": "You are given a 0-indexed array nums consisting of positive integers, representing targets on a number line. You are also given an integer space.\nYou have a machine which can destroy targets. Seeding the machine with some nums[i] allows it to destroy all targets with values that can be represented as nums[i] + c * space, where c is any non-negative integer. You want to destroy the maximum number of targets in nums.\nReturn the minimum value of nums[i] you can seed the machine with to destroy the maximum number of targets.", "canonical_solution": "def destroyTargets(nums, space):\n    from collections import Counter\n    count = Counter(a % space for a in nums)\n    maxc = max(count.values())\n    return min(a for a in nums if count[a % space] == maxc)", "entry_point": "destroyTargets", "test_list": ["assert destroyTargets([3,7,8,1,1,5],2)==1", "assert destroyTargets([1,3,5,2,4,6],2)==1", "assert destroyTargets([6,2,5],100)==2"]}
{"Contest id": "Bi90/2452", "text_name": "Words Within Two Edits of Dictionary", "text": "You are given two string arrays, queries and dictionary. All words in each array comprise of lowercase English letters and have the same length.\nIn one edit you can take a word from queries, and change any letter in it to any other letter. Find all words from queries that, after a maximum of two edits, equal some word from dictionary.\nReturn a list of all words from queries, that match with some word from dictionary after a maximum of two edits. Return the words in the same order they appear in queries.", "canonical_solution": "def twoEditWords(queries, dictionary):\n    from collections import Counter\n    lst=[]\n    val=Counter(queries)\n    for i in queries:\n        for j in dictionary:\n            cnt=len(i)\n            idx1=0\n            while idx1<len(i):\n                if i[idx1]==j[idx1]:\n                    cnt-=1\n                idx1+=1\n            if cnt<=2 and val[i]!=0:\n                val[i]-=1\n                lst.append(i)\n                break\n    return lst", "entry_point": "twoEditWords", "test_list": ["assert twoEditWords([\"word\",\"note\",\"ants\",\"wood\"],[\"wood\",\"joke\",\"moat\"])==[\"word\",\"note\",\"wood\"]", "assert twoEditWords([\"yes\"],[\"not\"])==[]"]}
{"Contest id": "Bi90/2451", "text_name": "Odd String Difference", "text": "You are given an array of equal-length strings words. Assume that the length of each string is n.\nEach string words[i] can be converted into a difference integer array difference[i] of length n - 1 where difference[i][j] = words[i][j+1] - words[i][j] where 0 <= j <= n - 2. Note that the difference between two letters is the difference between their positions in the alphabet i.e. the position of 'a' is 0, 'b' is 1, and 'z' is 25.\nFor example, for the string \"acb\", the difference integer array is [2 - 0, 1 - 2] = [2, -1].\nAll the strings in words have the same difference integer array, except one. You should find that string.\nReturn the string in words that has different difference integer array.", "canonical_solution": "def oddString(words):\n    from collections import defaultdict\n    hashmap = defaultdict(list)\n    for w in words:\n        difference = []\n        for i in range(1,len(w)):\n            difference.append(ord(w[i])-ord(w[i-1]))\n        hashmap[tuple(difference)].append(w)\n    for k,a in hashmap.items():\n        if len(a) == 1:\n            return a[0]", "entry_point": "oddString", "test_list": ["assert oddString([\"adc\",\"wzy\",\"abc\"])==\"abc\"", "assert oddString([\"aaa\",\"bob\",\"ccc\",\"ddd\"])==\"bob\""]}
{"Contest id": "316/2449", "text_name": "Minimum Number of Operations to Make Arrays Similar", "text": "You are given two positive integer arrays nums and target, of the same length.\nIn one operation, you can choose any two distinct indices i and j where 0 <= i, j < nums.length and:\nset nums[i] = nums[i] + 2 and\nset nums[j] = nums[j] - 2.\nTwo arrays are considered to be similar if the frequency of each element is the same.\nReturn the minimum number of operations required to make nums similar to target. The test cases are generated such that nums can always be similar to target.", "canonical_solution": "def makeSimilar(nums, target):\n    nums.sort(key = lambda a: (a & 1, a))\n    target.sort(key = lambda a: (a & 1, a))\n    return sum(abs(a - b) for a,b in zip(nums, target)) // 4", "entry_point": "makeSimilar", "test_list": ["assert makeSimilar([8,12,6],[2,14,10])==2", "assert makeSimilar([1,2,5],[4,1,3])==1", "assert makeSimilar([1,1,1,1,1],[1,1,1,1,1])==0"]}
{"Contest id": "316/2448", "text_name": "Minimum Cost to Make Array Equal", "text": "You are given two 0-indexed arrays nums and cost consisting each of n positive integers.\nYou can do the following operation any number of times:\nIncrease or decrease any element of the array nums by 1.\nThe cost of doing one operation on the ith element is cost[i].\nReturn the minimum total cost such that all the elements of the array nums become equal.", "canonical_solution": "def minCost(nums, cost):\n    def f(x):\n        return sum(abs(a - x) * c for a,c in zip(nums, cost))\n    l, r = min(nums), max(nums)\n    res = f(l)\n    while l < r:\n        x = (l + r) // 2\n        y1, y2 = f(x), f(x + 1)\n        res = min(y1, y2)\n        if y1 < y2:\n            r = x\n        else:\n            l = x + 1\n    return res", "entry_point": "minCost", "test_list": ["assert minCost([1,3,5,2],[2,3,1,14])==8", "assert minCost([2,2,2,2,2],[4,2,8,1,3])==0"]}
{"Contest id": "316/2447", "text_name": "Number of Subarrays With GCD Equal to K", "text": "Given an integer array nums and an integer k, return the number of subarrays of nums where the greatest common divisor of the subarray's elements is k.\nA subarray is a contiguous non-empty sequence of elements within an array.\nThe greatest common divisor of an array is the largest integer that evenly divides all the array elements.", "canonical_solution": "def subarrayGCD(nums, k):\n    def gcd(a, b):\n        while a and b:\n            a, b = b, a % b\n        return a or b\n    cnt = 0\n    n = len(nums)\n    for i in range(n):\n        tmp_gcd = 0 \n        for j in range(i,n):\n            tmp_gcd = gcd(tmp_gcd, nums[j])\n            if tmp_gcd == k:\n                cnt += 1\n            elif tmp_gcd < k:\n                break\n    return cnt", "entry_point": "subarrayGCD", "test_list": ["assert subarrayGCD([9,3,1,2,6,3],3)==4", "assert subarrayGCD([4],7)==0"]}
{"Contest id": "316/2446", "text_name": "Determine if Two Events Have Conflict", "text": "You are given two arrays of strings that represent two inclusive events that happened on the same day, event1 and event2, where:\nevent1 = [startTime1, endTime1] and\nevent2 = [startTime2, endTime2].\nEvent times are valid 24 hours format in the form of HH:MM.\nA conflict happens when two events have some non-empty intersection (i.e., some moment is common to both events).\nReturn true if there is a conflict between two events. Otherwise, return false.", "canonical_solution": "def haveConflict(event1, event2):\n    return event1[0] <= event2[1] and event2[0] <= event1[1]", "entry_point": "haveConflict", "test_list": ["assert haveConflict([\"01:15\",\"02:00\"],[\"02:00\",\"03:00\"])==True", "assert haveConflict([\"01:00\",\"02:00\"],[\"01:20\",\"03:00\"])==True", "assert haveConflict([\"10:00\",\"11:00\"], [\"14:00\",\"15:00\"])==False"]}
{"Contest id": "315/2444", "text_name": "Count Subarrays With Fixed Bounds", "text": "You are given an integer array nums and two integers minK and maxK.\nA fixed-bound subarray of nums is a subarray that satisfies the following conditions:\nThe minimum value in the subarray is equal to minK.\nThe maximum value in the subarray is equal to maxK.\nReturn the number of fixed-bound subarrays.\nA subarray is a contiguous part of an array.", "canonical_solution": "def countSubarrays(nums, minK, maxK):\n    res = 0\n    jmin = jmax = jbad = -1\n    for i,a in enumerate(nums):\n        if not minK <= a <= maxK: jbad = i\n        if a == minK: jmin = i\n        if a == maxK: jmax = i\n        res += max(0, min(jmin, jmax) - jbad)\n    return res", "entry_point": "countSubarrays", "test_list": ["assert countSubarrays([1,3,5,2,7,5],1,5)==2", "assert countSubarrays([1,1,1,1],1,1)==10"]}
{"Contest id": "315/2443", "text_name": "Sum of Number and Its Reverse", "text": "Given a non-negative integer num, return true if num can be expressed as the sum of any non-negative integer and its reverse, or false otherwise.", "canonical_solution": "def sumOfNumberAndReverse(num):\n    return any(n + int(str(n)[::-1]) == num for n in range(num//2,num+1))", "entry_point": "sumOfNumberAndReverse", "test_list": ["assert sumOfNumberAndReverse(443)==True", "assert sumOfNumberAndReverse(63)==False", "assert sumOfNumberAndReverse(181)==True"]}
{"Contest id": "315/2442", "text_name": "Count Number of Distinct Integers After Reverse Operations", "text": "You are given an array nums consisting of positive integers.\nYou have to take each integer in the array, reverse its digits, and add it to the end of the array. You should apply this operation to the original integers in nums.\nReturn the number of distinct integers in the final array.", "canonical_solution": "def countDistinctIntegers(nums):\n    new_array = []\n    for item in nums:\n        new_array.append(int(str(item)[::-1]))\n    nums.extend(new_array) \n    return len(set(nums)) ", "entry_point": "countDistinctIntegers", "test_list": ["assert countDistinctIntegers([1,13,10,12,31])==6", "assert countDistinctIntegers([2,2,2])==1"]}
{"Contest id": "315/2441", "text_name": "Largest Positive Integer That Exists With Its Negative", "text": "Given an integer array nums that does not contain any zeros, find the largest positive integer k such that -k also exists in the array.\nReturn the positive integer k. If there is no such integer, return -1.", "canonical_solution": "def findMaxK(nums):\n    nums.sort()\n    i, j = 0, len(nums)-1\n    while i < j:\n        if nums[i] == - nums[j]:\n            return nums[j]\n        if abs(nums[i]) > abs(nums[j]):\n            i += 1\n        else:\n            j -= 1\n    return -1", "entry_point": "findMaxK", "test_list": ["assert findMaxK([-1,2,-3,3])==3", "assert findMaxK([-1,10,6,7,-7,1])==7", "assert findMaxK([-10,8,6,7,-2,-3])==-1"]}
{"Contest id": "Bi89/2440", "text_name": "Create Components With Same Value", "text": "There is an undirected tree with n nodes labeled from 0 to n - 1.\nYou are given a 0-indexed integer array nums of length n where nums[i] represents the value of the ith node. You are also given a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nYou are allowed to delete some edges, splitting the tree into multiple connected components. Let the value of a component be the sum of all nums[i] for which node i is in the component.\nReturn the maximum number of edges you can delete, such that every connected component in the tree has the same value.", "canonical_solution": "def componentValue(nums, edges):\n    from collections import defaultdict\n    def dfs(a, b):\n        tally = nums[a]\n        for c in graph[a]: \n            if c != b:\n                tally += dfs(c, a)\n        return tally if tally != div else 0\n    graph = defaultdict(list)\n    n, sm, mx, mn = len(nums), sum(nums), max(nums), min(nums)\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    for div in range(mx, sm//mn):\n        if not(sm%div or dfs(0, n-1)):\n            return sm//div-1\n    return 0", "entry_point": "componentValue", "test_list": ["assert componentValue([6,2,2,2,6], [[0,1],[1,2],[1,3],[3,4]] )==2", "assert componentValue([2],[])==0"]}
{"Contest id": "Bi89/2439", "text_name": "Minimize Maximum of Array", "text": "You are given a 0-indexed array nums comprising of n non-negative integers.\nIn one operation, you must:\nChoose an integer i such that 1 <= i < n and nums[i] > 0.\nDecrease nums[i] by 1.\nIncrease nums[i - 1] by 1.\nReturn the minimum possible value of the maximum integer of nums after performing any number of operations.", "canonical_solution": "def minimizeArrayValue(nums):\n    from itertools import accumulate\n    return max((a + i) // (i + 1) for i,a in enumerate(accumulate(nums)))", "entry_point": "minimizeArrayValue", "test_list": ["assert minimizeArrayValue([3,7,1,6])==5", "assert minimizeArrayValue([10,1])==10"]}
{"Contest id": "Bi89/2438", "text_name": "Range Product Queries of Powers", "text": "Given a positive integer n, there exists a 0-indexed array called powers, composed of the minimum number of powers of 2 that sum to n. The array is sorted in non-decreasing order, and there is only one way to form the array.\nYou are also given a 0-indexed 2D integer array queries, where queries[i] = [lefti, righti]. Each queries[i] represents a query where you have to find the product of all powers[j] with lefti <= j <= righti.\nReturn an array answers, equal in length to queries, where answers[i] is the answer to the ith query. Since the answer to the ith query may be too large, each answers[i] should be returned modulo 10^9 + 7.", "canonical_solution": "def productQueries(n, queries):\n    powers_mul = [1]\n    for i in range(30): \n        if n & 1<<i:                \n            powers_mul.append((1<<i) * powers_mul[-1])\n    answers = []\n    for left, right in queries:\n        answers.append((powers_mul[right+1] // powers_mul[left]) % 1_000_000_007)\n    return answers", "entry_point": "productQueries", "test_list": ["assert productQueries(15,[[0,1],[2,2],[0,3]])==[2,4,64]", "assert productQueries(2,[[0,0]])==[2]"]}
{"Contest id": "Bi89/2437", "text_name": "Number of Valid Clock Times", "text": "You are given a string of length 5 called time, representing the current time on a digital clock in the format \"hh:mm\". The earliest possible time is \"00:00\" and the latest possible time is \"23:59\".\nIn the string time, the digits represented by the ? symbol are unknown, and must be replaced with a digit from 0 to 9.\nReturn an integer answer, the number of valid clock times that can be created by replacing every ? with a digit from 0 to 9.", "canonical_solution": "def countTime(time):\n    import re\n    pattern = time.replace('?', '.')\n    return sum(\n        re.fullmatch(pattern, f'{hour:02}:{minute:02}') is not None\n        for hour in range(24)\n        for minute in range(60)\n    )", "entry_point": "countTime", "test_list": ["assert countTime(\"?5:00\")==2", "assert countTime(\"0?:0?\")==100", "assert countTime(\"??:??\")==1440"]}
{"Contest id": "314/2435", "text_name": "Paths in Matrix Whose Sum Is Divisible by K", "text": "You are given a 0-indexed m x n integer matrix grid and an integer k. You are currently at position (0, 0) and you want to reach position (m - 1, n - 1) moving only down or right.\nReturn the number of paths where the sum of the elements on the path is divisible by k. Since the answer may be very large, return it modulo 10^9 + 7.", "canonical_solution": "def numberOfPaths(grid, k):\n    from collections import Counter\n    n, m, mod = len(grid), len(grid[0]), 10**9 + 7\n    dp = [Counter() for j in range(m + 1)]\n    dp[0][0] = 1\n    for i, r in enumerate(grid):\n        for j, a in enumerate(r):\n            dp[j] = Counter({(a + b) % k: c % mod for b, c in (dp[j] + dp[j-1]).items()})\n    return dp[m - 1][0]", "entry_point": "numberOfPaths", "test_list": ["assert numberOfPaths([[5,2,4],[3,0,5],[0,7,2]],3)==2", "assert numberOfPaths([[0,0]],5)==1", "assert numberOfPaths([[7,3,4,9],[2,3,6,2],[2,3,7,0]],1)==10"]}
{"Contest id": "314/2434", "text_name": "Using a Robot to Print the Lexicographically Smallest String", "text": "You are given a string s and a robot that currently holds an empty string t. Apply one of the following operations until s and t are both empty:\nRemove the first character of a string s and give it to the robot. The robot will append this character to the string t.\nRemove the last character of a string t and give it to the robot. The robot will write this character on paper.\nReturn the lexicographically smallest string that can be written on the paper.", "canonical_solution": "def robotWithString(s):\n    n = len(s)\n    min_suffix, t, ans = [s[-1]] * n, [], []\n    for i in range(n - 2, -1, -1):\n        min_suffix[i] = min(s[i], min_suffix[i + 1])\n    for i, char in enumerate(s):\n        t.append(char)\n        while i + 1 < n and t and min_suffix[i + 1] >= t[-1]:\n            ans += t.pop()\n    ans += t[::-1]\n    return ''.join(ans)", "entry_point": "robotWithString", "test_list": ["assert robotWithString(\"zza\")==\"azz\"", "assert robotWithString(\"bac\")==\"abc\"", "assert robotWithString(\"bdda\")==\"addb\""]}
{"Contest id": "314/2433", "text_name": "Find The Original Array of Prefix Xor", "text": "You are given an integer array pref of size n. Find and return the array arr of size n that satisfies:\npref[i] = arr[0] ^ arr[1] ^ ... ^ arr[i].\nNote that ^ denotes the bitwise-xor operation.\nIt can be proven that the answer is unique.", "canonical_solution": "def findArray(pref):\n    for i in range(len(pref) - 1, 0, -1):\n        pref[i] ^= pref[i - 1]\n    return pref", "entry_point": "findArray", "test_list": ["assert findArray([5,2,0,3,1])==[5,7,2,3,2]", "assert findArray([13])==[13]"]}
{"Contest id": "314/2432", "text_name": "The Employee That Worked on the Longest Task", "text": "There are n employees, each with a unique id from 0 to n - 1.\nYou are given a 2D integer array logs where logs[i] = [idi, leaveTimei] where:\nidi is the id of the employee that worked on the ith task, and\nleaveTimei is the time at which the employee finished the ith task. All the values leaveTimei are unique.\nNote that the ith task starts the moment right after the (i - 1)th task ends, and the 0th task starts at time 0.\nReturn the id of the employee that worked the task with the longest time. If there is a tie between two or more employees, return the smallest id among them.", "canonical_solution": "def hardestWorker(n, logs):\n    time , i_d = logs[0][1] , logs[0][0]  \n    for i in range(1,len(logs)):\n        gap= logs[i][1] - logs[i-1][1]\n        if gap > time or gap == time and i_d > logs[i][0]:\n            time , i_d = gap , logs[i][0]\n    return i_d", "entry_point": "hardestWorker", "test_list": ["assert hardestWorker(10,[[0,3],[2,5],[0,9],[1,15]])==1", "assert hardestWorker(26,[[1,1],[3,7],[2,12],[7,17]])==3", "assert hardestWorker(2,[[0,10],[1,20]])==0"]}
{"Contest id": "313/2430", "text_name": "Maximum Deletions on a String", "text": "You are given a string s consisting of only lowercase English letters. In one operation, you can:\nDelete the entire string s, or\nDelete the first i letters of s if the first i letters of s are equal to the following i letters in s, for any i in the range 1 <= i <= s.length / 2.\nFor example, if s = \"ababc\", then in one operation, you could delete the first two letters of s to get \"abc\", since the first two letters of s and the following two letters of s are both equal to \"ab\".\nReturn the maximum number of operations needed to delete all of s.", "canonical_solution": "def deleteString(s):\n    n = len(s)\n    if (len(set(s)) == 1): return n\n    lcs = [[0] * (n + 1) for i in range(n + 1)]\n    dp = [1] * n\n    for i in range(n-1, -1, -1):\n        for j in range(i + 1, n):\n            if s[i] == s[j]:\n                lcs[i][j] = lcs[i + 1][j + 1] + 1\n            if lcs[i][j] >= j - i:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return dp[0]", "entry_point": "deleteString", "test_list": ["assert deleteString(\"abcabcdabc\")==2", "assert deleteString(\"aaabaab\")==4", "assert deleteString(\"aaaaa\")==5"]}
{"Contest id": "313/2429", "text_name": "Minimize XOR", "text": "Given two positive integers num1 and num2, find the positive integer x such that:\nx has the same number of set bits as num2, and\nThe value x XOR num1 is minimal.\nNote that XOR is the bitwise XOR operation.\nReturn the integer x. The test cases are generated such that x is uniquely determined.\nThe number of set bits of an integer is the number of 1's in its binary representation.", "canonical_solution": "def minimizeXor(num1, num2):\n    c = 0\n    for i in range(32):\n        if num2 & (1<<i):\n            c+=1\n    num = 0\n    for i in range(31,-1,-1):\n        if (num1 & (1<<i)) and c>0:\n            num+=pow(2,i)\n            c-=1\n    s = str(bin(num)[2:])\n    s = \"0\"*(32-len(s))+s\n    i = 31\n    while(c>0 and i>0):\n        if (s[i]==\"0\"):\n            s = s[:i]+\"1\"+s[i+1:]\n            c-=1\n        else:\n            i-=1\n    return int(s,2)", "entry_point": "minimizeXor", "test_list": ["assert minimizeXor(3,5)==3", "assert minimizeXor(1,12)==3"]}
{"Contest id": "313/2427", "text_name": "Number of Common Factors", "text": "Given two positive integers a and b, return the number of common factors of a and b.\nAn integer x is a common factor of a and b if x divides both a and b.", "canonical_solution": "def commonFactors(a, b):\n    return sum(not(a%i or b%i) for i in range(1,min(a,b)+1))", "entry_point": "commonFactors", "test_list": ["assert commonFactors(12,6)==4", "assert commonFactors(25,30)==2"]}
{"Contest id": "Bi88/2426", "text_name": "Number of Pairs Satisfying Inequality", "text": "You are given two 0-indexed integer arrays nums1 and nums2, each of size n, and an integer diff. Find the number of pairs (i, j) such that:\n0 <= i < j <= n - 1 and\nnums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff.\nReturn the number of pairs that satisfy the conditions.", "canonical_solution": "def numberOfPairs(nums1, nums2, diff):\n        import bisect\n        n = len(nums1)\n        d = []\n        for i in range(n):\n            d.append(nums1[i] - nums2[i])\n        res = 0\n        order = []\n        for i in range(n - 1, -1, -1):\n            res += len(order) - bisect.bisect_left(order, d[i] - diff)\n            bisect.insort(order, d[i])\n        return res", "entry_point": "numberOfPairs", "test_list": ["assert numberOfPairs([3,2,5], [2,2,1],1)==3", "assert numberOfPairs([3,-1],[-2,2], -1)==0"]}
{"Contest id": "Bi88/2425", "text_name": "Bitwise XOR of All Pairings", "text": "You are given two 0-indexed arrays, nums1 and nums2, consisting of non-negative integers. There exists another array, nums3, which contains the bitwise XOR of all pairings of integers between nums1 and nums2 (every integer in nums1 is paired with every integer in nums2 exactly once).\nReturn the bitwise XOR of all integers in nums3.", "canonical_solution": "def xorAllNums(nums1, nums2):\n    from functools import reduce\n    def xor(a, b):\n        return a ^ b\n    return (len(nums1) % 2 * reduce(xor, nums2)) ^ (len(nums2) % 2 * reduce(xor, nums1))", "entry_point": "xorAllNums", "test_list": ["assert xorAllNums([2,1,3],[10,2,5,0])==13", "assert xorAllNums([1,2], [3,4])==0"]}
{"Contest id": "Bi88/2423", "text_name": "Remove Letter To Equalize Frequency", "text": "You are given a 0-indexed string word, consisting of lowercase English letters. You need to select one index and remove the letter at that index from word so that the frequency of every letter present in word is equal.\nReturn true if it is possible to remove one letter so that the frequency of all letters in word are equal, and false otherwise.\nNote:\nThe frequency of a letter x is the number of times it occurs in the string.\nYou must remove exactly one letter and cannot choose to do nothing.", "canonical_solution": "def equalFrequency(word):\n    from collections import Counter\n    counter = Counter(word)\n    for c in word:\n        counter[c] -= 1\n        if counter[c] == 0:\n            counter.pop(c)\n        if len(set(counter.values())) == 1:\n            return True\n        counter[c] += 1\n    return False", "entry_point": "equalFrequency", "test_list": ["assert equalFrequency(\"abcc\")==True", "assert equalFrequency(\"aazz\")==False"]}
{"Contest id": "312/2421", "text_name": "Number of Good Paths", "text": "There is a tree (i.e. a connected, undirected graph with no cycles) consisting of n nodes numbered from 0 to n - 1 and exactly n - 1 edges.\nYou are given a 0-indexed integer array vals of length n where vals[i] denotes the value of the ith node. You are also given a 2D integer array edges where edges[i] = [ai, bi] denotes that there exists an undirected edge connecting nodes ai and bi.\nA good path is a simple path that satisfies the following conditions:\nThe starting node and the ending node have the same value.\nAll nodes between the starting node and the ending node have values less than or equal to the starting node (i.e. the starting node's value should be the maximum value along the path).\nReturn the number of distinct good paths.\nNote that a path and its reverse are counted as the same path. For example, 0 -> 1 is considered to be the same as 1 -> 0. A single node is also considered as a valid path.", "canonical_solution": "def numberOfGoodPaths(vals, edges):\n    from collections import Counter\n    res = n = len(vals)\n    f = list(range(n))\n    count = [Counter({vals[i]: 1}) for i in range(n)]\n    edges = sorted([max(vals[i], vals[j]),i,j] for i,j in edges)\n    def find(x):\n        if f[x] != x:\n            f[x] = find(f[x])\n        return f[x]\n    for v,i,j in edges:\n        fi, fj = find(i), find(j)\n        cj, ci = count[fi][v], count[fj][v]\n        res += ci * cj\n        f[fj] = fi\n        count[fi] = Counter({v: ci + cj})\n    return res", "entry_point": "numberOfGoodPaths", "test_list": ["assert numberOfGoodPaths([1,3,2,1,3],[[0,1],[0,2],[2,3],[2,4]])==6", "assert numberOfGoodPaths([1,1,2,2,3],[[0,1],[1,2],[2,3],[2,4]])==7", "assert numberOfGoodPaths([1], [])==1"]}
{"Contest id": "312/2420", "text_name": "Find All Good Indices", "text": "You are given a 0-indexed integer array nums of size n and a positive integer k.\nWe call an index i in the range k <= i < n - k good if the following conditions are satisfied:\nThe k elements that are just before the index i are in non-increasing order.\nThe k elements that are just after the index i are in non-decreasing order.\nReturn an array of all good indices sorted in increasing order.", "canonical_solution": "def goodIndices(nums, k):\n    n, ans= len(nums) ,[]\n    dp1 , dp2= [1]*(n+1), [1]*(n+1)\n    for i in range(1,n):\n        if nums[i-1]>=nums[i]:  dp1[i]= dp1[i-1]+1\n    for i in range(n-2,-1,-1):\n        if nums[i]<=nums[i+1]:  dp2[i]= dp2[i+1]+1\n    for i in range(k,n-k):\n        if dp1[i-1]>=k and dp2[i+1]>=k: ans+= [i]\n    return ans", "entry_point": "goodIndices", "test_list": ["assert goodIndices([2,1,1,1,3,4,1],2)==[2,3]", "assert goodIndices([2,1,1,2],2)==[]"]}
{"Contest id": "312/2419", "text_name": "Longest Subarray With Maximum Bitwise AND", "text": "You are given an integer array nums of size n.\nConsider a non-empty subarray from nums that has the maximum possible bitwise AND.\nIn other words, let k be the maximum value of the bitwise AND of any subarray of nums. Then, only subarrays with a bitwise AND equal to k should be considered.\nReturn the length of the longest such subarray.\nThe bitwise AND of an array is the bitwise AND of all the numbers in it.\nA subarray is a contiguous sequence of elements within an array.", "canonical_solution": "def longestSubarray(nums):\n    val = max(nums)\n    i = j = res = 0\n    while j < len(nums):\n        if nums[j] == val:\n            while j < len(nums) and nums[j] == val: j += 1\n            res = max(res, j - i)\n        i = j = j + 1\n    return res", "entry_point": "longestSubarray", "test_list": ["assert longestSubarray([1,2,3,3,2,2])==2", "assert longestSubarray([1,2,3,4])==1"]}
{"Contest id": "312/2418", "text_name": "Sort the People", "text": "You are given an array of strings names, and an array heights that consists of distinct positive integers. Both arrays are of length n.\nFor each index i, names[i] and heights[i] denote the name and height of the ith person.\nReturn names sorted in descending order by the people's heights.", "canonical_solution": "def sortPeople(names, heights):\n    height_dict = dict(zip(heights,names)) \n    names.clear()\n    for key in sorted(height_dict.keys(),reverse=True):\n        names.append(height_dict[key])\n    return names", "entry_point": "sortPeople", "test_list": ["assert sortPeople([\"Mary\",\"John\",\"Emma\"],[180,165,170])==[\"Mary\",\"Emma\",\"John\"]", "assert sortPeople([\"Alice\",\"Bob\",\"Bob\"],[155,185,150])==[\"Bob\",\"Alice\",\"Bob\"]"]}
{"Contest id": "311/2416", "text_name": "Sum of Prefix Scores of Strings", "text": "You are given an array words of size n consisting of non-empty strings.\nWe define the score of a string word as the number of strings words[i] such that word is a prefix of words[i].\nFor example, if words = [\"a\", \"ab\", \"abc\", \"cab\"], then the score of \"ab\" is 2, since \"ab\" is a prefix of both \"ab\" and \"abc\".\nReturn an array answer of size n where answer[i] is the sum of scores of every non-empty prefix of words[i].\nNote that a string is considered as a prefix of itself.", "canonical_solution": "def sumPrefixScores(words):\n    d = dict()\n    for i in words:\n        s=\"\"\n        for j in range(len(i)):\n            s+=i[j]\n            if s in d:\n                d[s]+=1\n            else:\n                d[s]=1\n    l=[]\n    for i in words:\n        c = 0\n        s=\"\"\n        for j in range(len(i)):\n            s+=i[j]\n            c+=d[s]\n        l.append(c)\n    return l", "entry_point": "sumPrefixScores", "test_list": ["assert sumPrefixScores([\"abc\",\"ab\",\"bc\",\"b\"])==[5,4,3,2]", "assert sumPrefixScores([\"abcd\"])==[4]"]}
{"Contest id": "311/2414", "text_name": "Length of the Longest Alphabetical Continuous Substring", "text": "An alphabetical continuous string is a string consisting of consecutive letters in the alphabet. In other words, it is any substring of the string \"abcdefghijklmnopqrstuvwxyz\".\nFor example, \"abc\" is an alphabetical continuous string, while \"acb\" and \"za\" are not.\nGiven a string s consisting of lowercase letters only, return the length of the longest alphabetical continuous substring.", "canonical_solution": "def longestContinuousSubstring(s):\n    cur = 1\n    res = 1\n    for i in range(1,len(s)):\n        if ord(s[i])-ord(s[i-1])==1:\n            cur = cur+1\n            res = max(cur,res)\n        else:\n            cur = 1\n    return res", "entry_point": "longestContinuousSubstring", "test_list": ["assert longestContinuousSubstring(\"abacaba\")==2", "assert longestContinuousSubstring(\"abcde\")==5"]}
{"Contest id": "311/2413", "text_name": "Smallest Even Multiple", "text": "Given a positive integer n, return the smallest positive integer that is a multiple of both 2 and n.", "canonical_solution": "def smallestEvenMultiple(n):\n        return n << (n & 1)", "entry_point": "smallestEvenMultiple", "test_list": ["assert smallestEvenMultiple(5)==10", "assert smallestEvenMultiple(6)==6"]}
{"Contest id": "Bi87/2412", "text_name": "Minimum Money Required Before Transactions", "text": "You are given a 0-indexed 2D integer array transactions, where transactions[i] = [costi, cashbacki].\nThe array describes transactions, where each transaction must be completed exactly once in some order. At any given moment, you have a certain amount of money. In order to complete transaction i, money >= costi must hold true. After performing a transaction, money becomes money - costi + cashbacki.\nReturn the minimum amount of money required before any transaction so that all of the transactions can be completed regardless of the order of the transactions.", "canonical_solution": "def minimumMoney(transactions):\n    res = v = 0\n    for i,j in transactions:\n        res += max(0, i - j)\n        v = max(v, min(i, j))\n    return res + v", "entry_point": "minimumMoney", "test_list": ["assert minimumMoney([[2,1],[5,0],[4,2]])==10", "assert minimumMoney([[3,0],[0,3]])==3"]}
{"Contest id": "Bi87/2411", "text_name": "Smallest Subarrays With Maximum Bitwise OR", "text": "You are given a 0-indexed array nums of length n, consisting of non-negative integers. For each index i from 0 to n - 1, you must determine the size of the minimum sized non-empty subarray of nums starting at i (inclusive) that has the maximum possible bitwise OR.\nIn other words, let Bij be the bitwise OR of the subarray nums[i...j]. You need to find the smallest subarray starting at i, such that bitwise OR of this subarray is equal to max(Bik) where i <= k <= n - 1.\nThe bitwise OR of an array is the bitwise OR of all the numbers in it.\nReturn an integer array answer of size n where answer[i] is the length of the minimum sized subarray starting at i with maximum bitwise OR.\nA subarray is a contiguous non-empty sequence of elements within an array.", "canonical_solution": "def smallestSubarrays(nums):\n    last = [0] * 32\n    n = len(nums)\n    res = [0] * n\n    for i in range(n - 1, -1, -1):\n        for j in range(32):\n            if nums[i] & (1 << j):\n                last[j] = i\n        res[i] = max(1, max(last) - i + 1)\n    return res", "entry_point": "smallestSubarrays", "test_list": ["assert smallestSubarrays([1,0,2,1,3])==[3,3,2,2,1]", "assert smallestSubarrays([1,2])==[2,1]"]}
{"Contest id": "Bi87/2410", "text_name": "Maximum Matching of Players With Trainers", "text": "You are given a 0-indexed integer array players, where players[i] represents the ability of the ith player. You are also given a 0-indexed integer array trainers, where trainers[j] represents the training capacity of the jth trainer.\nThe ith player can match with the jth trainer if the player's ability is less than or equal to the trainer's training capacity. Additionally, the ith player can be matched with at most one trainer, and the jth trainer can be matched with at most one player.\nReturn the maximum number of matchings between players and trainers that satisfy these conditions.", "canonical_solution": "def matchPlayersAndTrainers(players, trainers):\n    players, trainers = sorted(players), sorted(trainers)\n    i, j, matchings = len(players) - 1, len(trainers) - 1, 0\n    while i >= 0 and j >= 0:\n        if players[i] > trainers[j]:\n                i -= 1\n        else:\n            matchings, i, j = matchings + 1, i - 1, j - 1\n    return matchings", "entry_point": "matchPlayersAndTrainers", "test_list": ["assert matchPlayersAndTrainers([4,7,9],[8,2,5,8])==2", "assert matchPlayersAndTrainers([1,1,1],[10])==1"]}
{"Contest id": "Bi87/2409", "text_name": "Count Days Spent Together", "text": "Alice and Bob are traveling to Rome for separate business meetings.\nYou are given 4 strings arriveAlice, leaveAlice, arriveBob, and leaveBob. Alice will be in the city from the dates arriveAlice to leaveAlice (inclusive), while Bob will be in the city from the dates arriveBob to leaveBob (inclusive). Each will be a 5-character string in the format \"MM-DD\", corresponding to the month and day of the date.\nReturn the total number of days that Alice and Bob are in Rome together.\nYou can assume that all dates occur in the same calendar year, which is not a leap year. Note that the number of days per month can be represented as: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31].", "canonical_solution": "def countDaysTogether(arriveAlice, leaveAlice, arriveBob, leaveBob):\n    def getDate(date):\n        monthList = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n        month = int(date[:2])\n        days = int(date[3:])\n        return sum(monthList[: month - 1]) + days\n    return max(0,getDate(min(leaveAlice, leaveBob)) -getDate(max(arriveAlice, arriveBob)) + 1)", "entry_point": "countDaysTogether", "test_list": ["assert countDaysTogether(\"08-15\",\"08-18\",\"08-16\",\"08-19\")==3", "assert countDaysTogether(\"10-01\",\"10-31\",\"11-01\",\"12-31\")==0"]}
{"Contest id": "310/2407", "text_name": "Longest Increasing Subsequence II", "text": "You are given an integer array nums and an integer k.\nFind the longest subsequence of nums that meets the following requirements:\nThe subsequence is strictly increasing and\nThe difference between adjacent elements in the subsequence is at most k.\nReturn the length of the longest subsequence that meets the requirements.\nA subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.", "canonical_solution": "def lengthOfLIS(nums, k):\n    from collections import defaultdict\n    from bisect import insort, bisect_left\n    import bisect\n    dp_tracker = defaultdict(list)\n    n = len(nums)\n    dp = [1]*n\n    max_till_now = 1\n    for i in range(n):\n        temp_ans = 1\n        max_ans = 0\n        for j in range(max_till_now, 0, -1):\n            ind = bisect_left(dp_tracker[j], nums[i])\n            if ind != 0:\n                if k >= (nums[i] - dp_tracker[j][ind-1]) > 0:\n                    max_ans = j\n                    break\n        dp[i] = temp_ans + max_ans\n        bisect.insort(dp_tracker[dp[i]], nums[i])\n        max_till_now = max(max_till_now, dp[i])\n    return max(dp)", "entry_point": "lengthOfLIS", "test_list": ["assert lengthOfLIS([4,2,1,4,3,4,5,8,15],3)==5", "assert lengthOfLIS([7,4,5,1,8,12,4,7],5)==4", "assert lengthOfLIS([1,5],1)==1"]}
{"Contest id": "310/2406", "text_name": "Divide Intervals Into Minimum Number of Groups", "text": "You are given a 2D integer array intervals where intervals[i] = [lefti, righti] represents the inclusive interval [lefti, righti].\nYou have to divide the intervals into one or more groups such that each interval is in exactly one group, and no two intervals that are in the same group intersect each other.\nReturn the minimum number of groups you need to make.\nTwo intervals intersect if there is at least one common number between them. For example, the intervals [1, 5] and [5, 8] intersect.", "canonical_solution": "def minGroups(intervals):\n    A = []\n    for a,b in intervals:\n        A.append([a, 1])\n        A.append([b + 1, -1])\n    res = cur = 0\n    for a, diff in sorted(A):\n        cur += diff\n        res = max(res, cur)\n    return res", "entry_point": "minGroups", "test_list": ["assert minGroups([[5,10],[6,8],[1,5],[2,3],[1,10]])==3", "assert minGroups([[1,3],[5,6],[8,10],[11,13]])==1"]}
{"Contest id": "310/2405", "text_name": "Optimal Partition of String", "text": "Given a string s, partition the string into one or more substrings such that the characters in each substring are unique. That is, no letter appears in a single substring more than once.\nReturn the minimum number of substrings in such a partition.\nNote that each character should belong to exactly one substring in a partition.", "canonical_solution": "def partitionString(s):\n    idx = 0\n    count = 0\n    mp = {} \n    while idx < len(s):\n        if s[idx] in mp: \n            count += 1\n            mp.clear()\n        mp[s[idx]] = True\n        idx += 1 \n    return count + 1 ", "entry_point": "partitionString", "test_list": ["assert partitionString(\"abacaba\")==4", "assert partitionString(\"ssssss\")==6"]}
{"Contest id": "310/2404", "text_name": "Most Frequent Even Element", "text": "Given an integer array nums, return the most frequent even element.If there is a tie, return the smallest one. If there is no such element, return -1.", "canonical_solution": "def mostFrequentEven(nums):\n    mp={}\n    val,freq =10**6,0\n    for i in nums:\n        if i%2==0:\n            if i in mp: mp[i]+=1\n            else: mp[i]=1\n            if mp[i]>freq or mp[i]==freq and i<val:\n                val, freq =i , mp[i]\n    return -1 if freq==0 else val", "entry_point": "mostFrequentEven", "test_list": ["assert mostFrequentEven([0,1,2,2,4,4,1])==2", "assert mostFrequentEven([4,4,4,9,2,4])==4", "assert mostFrequentEven([29,47,21,41,13,37,25,7])==-1"]}
{"Contest id": "309/2402", "text_name": "Meeting Rooms III", "text": "You are given an integer n. There are n rooms numbered from 0 to n - 1.\nYou are given a 2D integer array meetings where meetings[i] = [starti, endi] means that a meeting will be held during the half-closed time interval [starti, endi). All the values of starti are unique.\nMeetings are allocated to rooms in the following manner:\nEach meeting will take place in the unused room with the lowest number.\nIf there are no available rooms, the meeting will be delayed until a room becomes free. The delayed meeting should have the same duration as the original meeting.\nWhen a room becomes unused, meetings that have an earlier original start time should be given the room.\nReturn the number of the room that held the most meetings. If there are multiple rooms, return the room with the lowest number.\nA half-closed interval [a, b) is the interval between a and b including a and not including b.", "canonical_solution": "def mostBooked(n, meetings):\n    from heapq import heapify,heappop,heappush\n    ready = [r for r in range(n)]\n    rooms = []\n    heapify(ready)\n    res = [0] * n\n    for s,e in sorted(meetings):\n        while rooms and rooms[0][0] <= s:\n            t,r = heappop(rooms)\n            heappush(ready, r)\n        if ready:\n            r = heappop(ready)\n            heappush(rooms, [e, r])\n        else:\n            t,r = heappop(rooms)\n            heappush(rooms, [t + e - s, r])\n        res[r] += 1\n    return res.index(max(res))", "entry_point": "mostBooked", "test_list": ["assert mostBooked(2,[[0,10],[1,5],[2,7],[3,4]])==0", "assert mostBooked(3,[[1,20],[2,10],[3,5],[4,9],[6,8]])==1"]}
{"Contest id": "309/2401", "text_name": "Longest Nice Subarray", "text": "You are given an array nums consisting of positive integers.\nWe call a subarray of nums nice if the bitwise AND of every pair of elements that are in different positions in the subarray is equal to 0.\nReturn the length of the longest nice subarray.\nA subarray is a contiguous part of an array.\nNote that subarrays of length 1 are always considered nice.", "canonical_solution": "def longestNiceSubarray(nums):\n    res = AND = i = 0\n    for j in range(len(nums)):\n        while AND & nums[j]:\n            AND ^= nums[i]\n            i += 1\n        AND |= nums[j]\n        res = max(res, j - i + 1)\n    return res", "entry_point": "longestNiceSubarray", "test_list": ["assert longestNiceSubarray([1,3,8,48,10])==3", "assert longestNiceSubarray([3,1,5,11,13])==1"]}
{"Contest id": "309/2400", "text_name": "Number of Ways to Reach a Position After Exactly k Steps", "text": "You are given two positive integers startPos and endPos. Initially, you are standing at position startPos on an infinite number line. With one step, you can move either one position to the left, or one position to the right.\nGiven a positive integer k, return the number of different ways to reach the position endPos starting from startPos, such that you perform exactly k steps. Since the answer may be very large, return it modulo 10^9 + 7.\nTwo ways are considered different if the order of the steps made is not exactly the same.\nNote that the number line includes negative integers.", "canonical_solution": "def numberOfWays(startPos, endPos, k):\n    from math import comb\n    if (startPos - endPos - k) % 2: return 0\n    return comb(k, (endPos - startPos + k) // 2) % (10 ** 9 + 7)", "entry_point": "numberOfWays", "test_list": ["assert numberOfWays(1,2,3)==3", "assert numberOfWays(2,5,10)==0"]}
{"Contest id": "309/2399", "text_name": "Check Distances Between Same Letters", "text": "You are given a 0-indexed string s consisting of only lowercase English letters, where each letter in s appears exactly twice. You are also given a 0-indexed integer array distance of length 26.\nEach letter in the alphabet is numbered from 0 to 25 (i.e. 'a' -> 0, 'b' -> 1, 'c' -> 2, ... , 'z' -> 25).\nIn a well-spaced string, the number of letters between the two occurrences of the ith letter is distance[i]. If the ith letter does not appear in s, then distance[i] can be ignored.\nReturn true if s is a well-spaced string, otherwise return false.", "canonical_solution": "def checkDistances(s, distance):\n    from collections import defaultdict\n    d = defaultdict(list)\n    for i, ch in enumerate(s):\n        d[ch].append(i)\n    return all(b-a-1 == distance[ord(ch)-97] for ch, (a,b) in d.items())", "entry_point": "", "test_list": ["assert checkDistances(\"abaccb\",[1,3,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0])==True", "assert checkDistances(\"aa\",[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0])==False"]}
{"Contest id": "Bi86/2398", "text_name": "Maximum Number of Robots Within Budget", "text": "You have n robots. You are given two 0-indexed integer arrays, chargeTimes and runningCosts, both of length n. The ith robot costs chargeTimes[i] units to charge and costs runningCosts[i] units to run. You are also given an integer budget.\nThe total cost of running k chosen robots is equal to max(chargeTimes) + k * sum(runningCosts), where max(chargeTimes) is the largest charge cost among the k robots and sum(runningCosts) is the sum of running costs among the k robots.\nReturn the maximum number of consecutive robots you can run such that the total cost does not exceed budget.", "canonical_solution": "def maximumRobots(chargeTimes, runningCosts, budget):\n        from collections import deque\n        maxQ = deque()\n        maxCons = current = p1 = 0\n        getBudget = lambda: chargeTimes[maxQ[0]]  + ((p2 - p1 + 1) * current) if(maxQ) else 0\n        \n        for p2, (charge, running) in enumerate(zip(chargeTimes, runningCosts)):\n            current += running\n            while(maxQ and chargeTimes[maxQ[-1]] < charge):\n                maxQ.pop()\n            maxQ.append(p2)\n            \n            while(getBudget() > budget):\n                current -= runningCosts[p1]\n                p1 += 1\n                while(maxQ and maxQ[0] < p1):\n                    maxQ.popleft()\n            \n            maxCons = max(maxCons, p2 - p1 + 1)\n        return maxCons", "entry_point": "maximumRobots", "test_list": ["assert maximumRobots([3,6,1,3,4],[2,1,3,4,5],25)==3", "assert maximumRobots([11,12,19],[10,8,7],19)==0"]}
{"Contest id": "Bi86/2397", "text_name": "Maximum Rows Covered by Columns", "text": "You are given a 0-indexed m x n binary matrix matrix and an integer numSelect, which denotes the number of distinct columns you must select from matrix.\nLet us consider s = {c1, c2, ...., cnumSelect} as the set of columns selected by you. A row row is covered by s if:\nFor each cell matrix[row][col] (0 <= col <= n - 1) where matrix[row][col] == 1, col is present in s or,\nNo cell in row has a value of 1.\nYou need to choose numSelect columns such that the number of rows that are covered is maximized.\nReturn the maximum number of rows that can be covered by a set of numSelect columns.", "canonical_solution": "def maximumRows(matrix, numSelect):\n        import math\n        from itertools import combinations\n        m, n, ans = len(matrix), len(matrix[0]), -math.inf\n        for comb in combinations((num for num in range(n)),n-numSelect):\n            ct = len(set(r for r in range(m) for c in comb if matrix[r][c] == 1))\n            ans = max(ans,m-ct)\n        return ans", "entry_point": "maximumRows", "test_list": ["assert maximumRows([[0,0,0],[1,0,1],[0,1,1],[0,0,1]],2)==3", "assert maximumRows([[1],[0]],1)==2"]}
{"Contest id": "Bi86/2396", "text_name": "Strictly Palindromic Number", "text": "An integer n is strictly palindromic if, for every base b between 2 and n - 2 (inclusive), the string representation of the integer n in base b is palindromic.\nGiven an integer n, return true if n is strictly palindromic and false otherwise.\nA string is palindromic if it reads the same forward and backward.", "canonical_solution": "def isStrictlyPalindromic(n):\n        return False", "entry_point": "isStrictlyPalindromic", "test_list": ["assert isStrictlyPalindromic(9)==False", "assert isStrictlyPalindromic(4)==False"]}
{"Contest id": "Bi86/2395", "text_name": "Find Subarrays With Equal Sum", "text": "Given a 0-indexed integer array nums, determine whether there exist two subarrays of length 2 with equal sum. Note that the two subarrays must begin at different indices.\nReturn true if these subarrays exist, and false otherwise.\nA subarray is a contiguous non-empty sequence of elements within an array.", "canonical_solution": "def findSubarrays(nums):\n    seen = set()\n    for i in range(len(nums)-1):\n        s = nums[i] + nums[i+1]\n        if s in seen:\n            return True\n        seen.add(s)\n    return False", "entry_point": "findSubarrays", "test_list": ["assert findSubarrays([4,2,4])==True", "assert findSubarrays([1,2,3,4,5])==False", "assert findSubarrays([0,0,0])==True"]}
{"Contest id": "308/2392", "text_name": "Build a Matrix With Conditions", "text": "You are given a positive integer k. You are also given:\na 2D integer array rowConditions of size n where rowConditions[i] = [abovei, belowi], and\na 2D integer array colConditions of size m where colConditions[i] = [lefti, righti].\nThe two arrays contain integers from 1 to k.\nYou have to build a k x k matrix that contains each of the numbers from 1 to k exactly once. The remaining cells should have the value 0.\nThe matrix should also satisfy the following conditions:\nThe number abovei should appear in a row that is strictly above the row at which the number belowi appears for all i from 0 to n - 1.\nThe number lefti should appear in a column that is strictly left of the column at which the number righti appears for all i from 0 to m - 1.\nReturn any matrix that satisfies the conditions. If no answer exists, return an empty matrix.", "canonical_solution": "def buildMatrix(k, rowCond, colCond):\n        import collections\n        def topoSort(k, cond):\n            nei = collections.defaultdict(list)\n            for s, e in cond:\n                nei[e].append(s)\n            \n            def helper(i):\n                if i in visited and visited[i] == -1:\n                    return False\n                if i in visited and visited[i] == 1:\n                    return True\n                visited[i] = -1\n                for n in nei[i]:\n                    if not helper(n):\n                        return False \n                res.append(i)\n                visited[i] = 1\n                return True\n            \n            res = []\n            visited = {}\n            for i in range(1, k + 1):\n                if not helper(i):\n                    return []\n            return res\n    \n        rowOrder = topoSort(k, rowCond)\n        if rowOrder == []:\n            return []\n        colOrder = topoSort(k, colCond)\n        if colOrder == []:\n            return []\n        colMap = {}\n        for i in range(len(colOrder)):\n            colMap[colOrder[i]] = i\n        \n        res = [[0 for j in range(k)] for i in range(k)]\n        for i in range(len(rowOrder)):\n            res[i][colMap[rowOrder[i]]] = rowOrder[i]\n        return res", "entry_point": "buildMatrix", "test_list": ["assert buildMatrix(3,[[1,2],[3,2]],[[2,1],[3,2]])==[[3,0,0],[0,0,1],[0,2,0]]", "assert buildMatrix(3,[[1,2],[2,3],[3,1],[2,3]],[[2,1]])==[]"]}
{"Contest id": "308/2391", "text_name": "Minimum Amount of Time to Collect Garbage", "text": "You are given a 0-indexed array of strings garbage where garbage[i] represents the assortment of garbage at the ith house. garbage[i] consists only of the characters 'M', 'P' and 'G' representing one unit of metal, paper and glass garbage respectively. Picking up one unit of any type of garbage takes 1 minute.\nYou are also given a 0-indexed integer array travel where travel[i] is the number of minutes needed to go from house i to house i + 1.\nThere are three garbage trucks in the city, each responsible for picking up one type of garbage. Each garbage truck starts at house 0 and must visit each house in order; however, they do not need to visit every house.\nOnly one garbage truck may be used at any given moment. While one truck is driving or picking up garbage, the other two trucks cannot do anything.\nReturn the minimum number of minutes needed to pick up all the garbage.", "canonical_solution": "def garbageCollection(garbage, travel):\n    total_minutes = 0\n    current_travel_time = 0\n    total_minutes += len(garbage[0])\n    last_garbage_indices = [-1, -1, -1]\n    for house_index in range(1, len(garbage)):\n        total_minutes += len(garbage[house_index])\n        if \"M\" in garbage[house_index]:\n            last_garbage_indices[0] = house_index - 1\n        if \"P\" in garbage[house_index]:\n            last_garbage_indices[1] = house_index - 1\n        if \"G\" in garbage[house_index]:\n            last_garbage_indices[2] = house_index - 1\n    for travel_index in range(len(travel)):\n        current_travel_time += travel[travel_index]\n        for truck_index in range(3):\n            if last_garbage_indices[truck_index] == travel_index:\n                total_minutes += current_travel_time\n    return total_minutes", "entry_point": "garbageCollection", "test_list": ["assert garbageCollection([\"G\",\"P\",\"GP\",\"GG\"],[2,4,3])==21", "assert garbageCollection([\"MMM\",\"PGM\",\"GP\"],[3,10])==37"]}
{"Contest id": "308/2390", "text_name": "Removing Stars From a String", "text": "You are given a string s, which contains stars *.\nIn one operation, you can:\nChoose a star in s.\nRemove the closest non-star character to its left, as well as remove the star itself.\nReturn the string after all stars have been removed.\nNote:\nThe input will be generated such that the operation is always possible.\nIt can be shown that the resulting string will always be unique.", "canonical_solution": "def removeStars(s):\n    stack = []\n    for c in s:\n        if c == '*' and stack:\n            stack.pop()\n        else:\n            stack.append(c)\n    return ''.join(stack)", "entry_point": "removeStars", "test_list": ["assert removeStars(\"leet**cod*e\")==\"lecoe\"", "assert removeStars(\"erase*****\")==\"\""]}
{"Contest id": "308/2389", "text_name": "Longest Subsequence With Limited Sum", "text": "You are given an integer array nums of length n, and an integer array queries of length m.\nReturn an array answer of length m where answer[i] is the maximum size of a subsequence that you can take from nums such that the sum of its elements is less than or equal to queries[i].\nA subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.", "canonical_solution": "def answerQueries(nums, queries):\n    from itertools import accumulate\n    from bisect import bisect_right\n    nums = list(accumulate(sorted(nums)))\n    return [bisect_right(nums, q) for q in queries]", "entry_point": "answerQueries", "test_list": ["assert answerQueries([4,5,2,1],[3,10,21])==[2,3,4]", "assert answerQueries([2,3,4,5],[1])==[0]"]}
{"Contest id": "307/2386", "text_name": "Find the K-Sum of an Array", "text": "You are given an integer array nums and a positive integer k. You can choose any subsequence of the array and sum all of its elements together.\nWe define the K-Sum of the array as the kth largest subsequence sum that can be obtained (not necessarily distinct).\nReturn the K-Sum of the array.\nA subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.\nNote that the empty subsequence is considered to have a sum of 0.", "canonical_solution": "def kSum(nums, k):\n    import heapq\n    maxSum = sum([max(0, num) for num in nums])\n    absNums = sorted([abs(num) for num in nums])\n    maxHeap = [(-maxSum + absNums[0], 0)]\n    ans = [maxSum]\n    while len(ans) < k:\n        nextSum, i = heapq.heappop(maxHeap)\n        heapq.heappush(ans, -nextSum)\n        if i + 1 < len(absNums):\n            heapq.heappush(maxHeap, (nextSum - absNums[i] + absNums[i + 1], i + 1))\n            heapq.heappush(maxHeap, (nextSum + absNums[i + 1], i + 1))\n    return ans[0]", "entry_point": "kSum", "test_list": ["assert kSum([2,4,-2],5)==2", "assert kSum([1,-2,3,4,-10,12],16)==10"]}
{"Contest id": "307/2384", "text_name": "Largest Palindromic Number", "text": "You are given a string num consisting of digits only.\nReturn the largest palindromic integer (in the form of a string) that can be formed using digits taken from num. It should not contain leading zeroes.\nNotes:\nYou do not need to use all the digits of num, but you must use at least one digit.\nThe digits can be reordered.", "canonical_solution": "def largestPalindromic(num):\n        from collections import Counter\n        c = Counter(num)\n        if len(c)==1 and c['0']>=1:\n            return \"0\"\n        m = -1  \n        res1 = ''\n        res2 = ''\n        for i in range(9,-1,-1):\n            while c[str(i)]:\n                if not res1 and i==0:   \n                    break \n                if c[str(i)]>=2:\n                    res1 += str(i)\n                    res2 = str(i) + res2\n                    c[str(i)]-=2\n                if c[str(i)] == 1:\n                    m = max(m,i)  \n                    c[str(i)]-=1\n                if c[str(i)]==0:\n                    del c[str(i)]\n        return res1+res2 if m==-1 else res1 + str(m) + res2\nlargestPalindromic(\"444947137\")", "entry_point": "largestPalindromic", "test_list": ["assert largestPalindromic(\"444947137\")==\"7449447\"", "assert largestPalindromic(\"00009\")==\"9\""]}
{"Contest id": "307/2383", "text_name": "Minimum Hours of Training to Win a Competition", "text": "You are entering a competition, and are given two positive integers initialEnergy and initialExperience denoting your initial energy and initial experience respectively.\nYou are also given two 0-indexed integer arrays energy and experience, both of length n.\nYou will face n opponents in order. The energy and experience of the ith opponent is denoted by energy[i] and experience[i] respectively. When you face an opponent, you need to have both strictly greater experience and energy to defeat them and move to the next opponent if available.\nDefeating the ith opponent increases your experience by experience[i], but decreases your energy by energy[i].\nBefore starting the competition, you can train for some number of hours. After each hour of training, you can either choose to increase your initial experience by one, or increase your initial energy by one.\nReturn the minimum number of training hours required to defeat all n opponents.", "canonical_solution": "def minNumberOfHours(initialEnergy, initialExperience, energy, experience):\n        traning = 0\n        totalEnergy = sum(energy)\n        if initialEnergy <= totalEnergy:\n            traning += (totalEnergy - initialEnergy + 1)\n        for opponentExperience in experience:\n            if initialExperience <= opponentExperience:\n                traning += (opponentExperience - initialExperience + 1)\n                initialExperience = opponentExperience + 1\n            initialExperience += opponentExperience            \n        return traning", "entry_point": "minNumberOfHours", "test_list": ["assert minNumberOfHours(5,3,[1,4,3,2],[2,6,3,1])==8", "assert minNumberOfHours(2,4,[1],[3])==0"]}
{"Contest id": "Bi85/2382", "text_name": "Maximum Segment Sum After Removals", "text": "You are given two 0-indexed integer arrays nums and removeQueries, both of length n. For the ith query, the element in nums at the index removeQueries[i] is removed, splitting nums into different segments.\nA segment is a contiguous sequence of positive integers in nums. A segment sum is the sum of every element in a segment.\nReturn an integer array answer, of length n, where answer[i] is the maximum segment sum after applying the ith removal.\nNote: The same index will not be removed more than once.", "canonical_solution": "def maximumSegmentSum(nums, removeQueries):\n        def findParent(i):\n            cur=i\n            while parent[cur]!=cur:\n                cur=parent[cur]\n            parent[i]=cur\n            return cur       \n        def union(u,v):\n            uParent=findParent(u)\n            vParent=findParent(v)\n            if rank[uParent]<rank[vParent]:\n                parent[uParent]=vParent\n                segmentSum[vParent]+=segmentSum[uParent]\n            elif rank[uParent]>rank[vParent]:\n                parent[vParent]=uParent\n                segmentSum[uParent]+=segmentSum[vParent]\n            else:\n                parent[vParent]=uParent\n                rank[uParent]+=1\n                segmentSum[uParent]+=segmentSum[vParent]                \n        n=len(nums)\n        parent=[i for i in range(n)]\n        segmentSum=[0]*n\n        rank=[0]*n\n        ans=[0]*n\n        maxSegmentSum=0\n        for j in range(n-1,-1,-1):\n            idx=removeQueries[j]\n            segmentSum[idx]=nums[idx]\n            if idx>0 and segmentSum[idx-1]>0:\n                union(idx,idx-1)\n            if idx<n-1 and segmentSum[idx+1]>0:\n                union(idx,idx+1)\n            ans[j]=maxSegmentSum\n            maxSegmentSum=max(maxSegmentSum,segmentSum[findParent(idx)])\n        return ans", "entry_point": "maximumSegmentSum", "test_list": ["assert maximumSegmentSum([1,2,5,6,1],[0,3,2,4,1])==[14,7,2,2,0]", "assert maximumSegmentSum([3,2,11,1],[3,2,1,0])==[16,5,3,0]"]}
{"Contest id": "Bi85/2381", "text_name": "Shifting Letters II", "text": "You are given a string s of lowercase English letters and a 2D integer array shifts where shifts[i] = [starti, endi, directioni]. For every i, shift the characters in s from the index starti to the index endi (inclusive) forward if directioni = 1, or shift the characters backward if directioni = 0.\nShifting a character forward means replacing it with the next letter in the alphabet (wrapping around so that 'z' becomes 'a'). Similarly, shifting a character backward means replacing it with the previous letter in the alphabet (wrapping around so that 'a' becomes 'z').\nReturn the final string after all such shifts to s are applied.", "canonical_solution": "def shiftingLetters(s, shifts):\n        import collections\n        import string\n        from collections import Counter\n        n = len(s)\n        d = collections.Counter()\n        for st, e, right in shifts:\n            d[st] += 1 if right else -1        \n            if e+1 < n:                         \n                d[e+1] += -1 if right else 1\n        prefix = [0]                           \n        ans = ''\n        for i in range(n):                     \n            cur = prefix[-1] + d[i]\n            prefix.append(cur)\n            ans += string.ascii_lowercase[(ord(s[i]) - ord('a') + cur) % 26]\n        return ans", "entry_point": "shiftingLetters", "test_list": ["assert shiftingLetters(\"abc\",[[0,1,0],[1,2,1],[0,2,1]])==\"ace\"", "assert shiftingLetters(\"dztz\",[[0,0,0],[1,1,1]])==\"catz\""]}
{"Contest id": "Bi85/2380", "text_name": "Time Needed to Rearrange a Binary String", "text": "You are given a binary string s. In one second, all occurrences of \"01\" are simultaneously replaced with \"10\". This process repeats until no occurrences of \"01\" exist.\nReturn the number of seconds needed to complete this process.", "canonical_solution": "def secondsToRemoveOccurrences(s):\n        ans=0\n        while '01' in s:\n            ans+=1\n            s=s.replace('01','10')\n        return ans", "entry_point": "secondsToRemoveOccurrences", "test_list": ["assert secondsToRemoveOccurrences(\"0110101\")==4", "assert secondsToRemoveOccurrences(\"11100\")==0"]}
{"Contest id": "Bi85/2379", "text_name": "Minimum Recolors to Get K Consecutive Black Blocks", "text": "You are given a 0-indexed string blocks of length n, where blocks[i] is either 'W' or 'B', representing the color of the ith block. The characters 'W' and 'B' denote the colors white and black, respectively.\nYou are also given an integer k, which is the desired number of consecutive black blocks.\nIn one operation, you can recolor a white block such that it becomes a black block.\nReturn the minimum number of operations needed such that there is at least one occurrence of k consecutive black blocks.", "canonical_solution": "def minimumRecolors(blocks, k):\n        n, minOps, flips, count, i = len(blocks), 1e9, 0, 0, 0\n        for j in range (n):\n            if blocks[j] == 'W':\n                flips += 1\n                count += 1\n            elif blocks[j] == 'B':\n                count += 1\n            if count == k:\n                minOps = min(minOps, flips)\n                if blocks[i] == 'W':\n                    flips -= 1\n                    count -= 1\n                else: count -= 1\n                i += 1\n        return minOps", "entry_point": "minimumRecolors", "test_list": ["assert minimumRecolors(\"WBBWWBBWBW\",7)==3", "assert minimumRecolors(\"WBWBBBW\",2)==0"]}
{"Contest id": "306/2376", "text_name": "Count Special Integers", "text": "We call a positive integer special if all of its digits are distinct.\nGiven a positive integer n, return the number of special integers that belong to the interval [1, n].", "canonical_solution": "def countSpecialNumbers(n):\n        dp = [[[[-1 for i in range(2)] for i in range(2)] for i in range(1<<10)] for i in range(10)]\n        def fun(i,leading_zeros,tight,memo):\n            if i==len(str(n)):\n                if leading_zeros==1:\n                    return 0\n                return 1\n            if dp[i][memo][tight][leading_zeros]!=-1:\n                return dp[i][memo][tight][leading_zeros]\n            end = 9\n            if tight==1:\n                end = int(str(n)[i])\n            ans = 0\n            for j in range(end+1):\n                if j==0:\n                    if leading_zeros==1:\n                        ans+=fun(i+1,1,tight&(j==end),memo)\n                    else:\n                        if memo&(1<<j)==0:\n                            ans+=fun(i+1,0,tight&(j==end),memo|(1<<j))\n                else:\n                    if memo&(1<<j)==0:\n                        ans+=fun(i+1,0,tight&(j==end),memo|(1<<j))\n            dp[i][memo][tight][leading_zeros] = ans\n            return ans\n        return fun(0,1,1,0)", "entry_point": "countSpecialNumbers", "test_list": ["assert countSpecialNumbers(20)==19", "assert countSpecialNumbers(5)==5", "assert countSpecialNumbers(135)==110"]}
{"Contest id": "306/2375", "text_name": "Construct Smallest Number From DI String", "text": "You are given a 0-indexed string pattern of length n consisting of the characters 'I' meaning increasing and 'D' meaning decreasing.\nA 0-indexed string num of length n + 1 is created using the following conditions:\nnum consists of the digits '1' to '9', where each digit is used at most once.\nIf pattern[i] == 'I', then num[i] < num[i + 1].\nIf pattern[i] == 'D', then num[i] > num[i + 1].\nReturn the lexicographically smallest possible string num that meets the conditions.", "canonical_solution": "def smallestNumber(pattern):\n        ans = []\n        dec_count = 0\n        for i in range(len(pattern)):\n            if pattern[i] == \"I\":\n                for j in range(i, i-dec_count-1,-1):\n                    ans.append(str(j+1))\n                dec_count = 0\n            elif pattern[i] == \"D\":\n                dec_count += 1\n        for j in range(len(pattern), len(pattern)-dec_count-1,-1):\n            ans.append(str(j+1))\n        return \"\".join(ans)", "entry_point": "smallestNumber", "test_list": ["assert smallestNumber(\"IIIDIDDD\")==\"123549876\"", "assert smallestNumber(\"DDD\")==\"4321\""]}
{"Contest id": "306/2374", "text_name": "Node With Highest Edge Score", "text": "You are given a directed graph with n nodes labeled from 0 to n - 1, where each node has exactly one outgoing edge.\nThe graph is represented by a given 0-indexed integer array edges of length n, where edges[i] indicates that there is a directed edge from node i to node edges[i].\nThe edge score of a node i is defined as the sum of the labels of all the nodes that have an edge pointing to i.\nReturn the node with the highest edge score. If multiple nodes have the same edge score, return the node with the smallest index.", "canonical_solution": "def edgeScore(edges):\n        n = len(edges)\n        edge_score = {i:0 for i in range(n)}  \n        for start, end in enumerate(edges):\n            edge_score[end] += start           \n        maximum = max(edge_score.values())\n        candidates = [node for node, score in edge_score.items() if score == maximum]\n        candidates.sort()\n        return candidates[0]", "entry_point": "edgeScore", "test_list": ["assert edgeScore([1,0,0,0,0,7,7,5])==7", "assert edgeScore([2,0,0,2])==0"]}
{"Contest id": "306/2373", "text_name": "Largest Local Values in a Matrix", "text": "You are given an n x n integer matrix grid.\nGenerate an integer matrix maxLocal of size (n - 2) x (n - 2) such that:\nmaxLocal[i][j] is equal to the largest value of the 3 x 3 matrix in grid centered around row i + 1 and column j + 1.\nIn other words, we want to find the largest value in every contiguous 3 x 3 matrix in grid.\nReturn the generated matrix.", "canonical_solution": "def largestLocal(grid):\n        l=len(grid)-2\n        ans=[]\n        for i in range(l):\n            ans.append([0]*l)\n        for i in range(l):\n            for j in range(l):\n                ans[i][j] = max(grid[i][j],grid[i][j+1],grid[i][j+2],\n                      grid[i+1][j],grid[i+1][j+1],grid[i+1][j+2],\n                      grid[i+2][j],grid[i+2][j+1],grid[i+2][j+2])\n        return ans", "entry_point": "largestLocal", "test_list": ["assert largestLocal([[9,9,8,1],[5,6,2,6],[8,2,6,4],[6,2,2,2]])==[[9,9],[8,6]]", "assert largestLocal([[1,1,1,1,1],[1,1,1,1,1],[1,1,2,1,1],[1,1,1,1,1],[1,1,1,1,1]])==[[2,2,2],[2,2,2],[2,2,2]]"]}
{"Contest id": "305/2370", "text_name": "Longest Ideal Subsequence", "text": "You are given a string s consisting of lowercase letters and an integer k. We call a string t ideal if the following conditions are satisfied:\nt is a subsequence of the string s.\nThe absolute difference in the alphabet order of every two adjacent letters in t is less than or equal to k.\nReturn the length of the longest ideal string.\nA subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\nNote that the alphabet order is not cyclic. For example, the absolute difference in the alphabet order of 'a' and 'z' is 25, not 1.", "canonical_solution": "def longestIdealString(s, k):\n        dp = [0] * 128\n        for c in s:\n            i = ord(c)\n            dp[i] = max(dp[i - k : i + k + 1]) + 1\n        return max(dp)", "entry_point": "longestIdealString", "test_list": ["assert longestIdealString(\"acfgbd\",2)==4", "assert longestIdealString(\"abcd\",3)==4"]}
{"Contest id": "305/2369", "text_name": "Check if There is a Valid Partition For The Array", "text": "You are given a 0-indexed integer array nums. You have to partition the array into one or more contiguous subarrays.\nWe call a partition of the array valid if each of the obtained subarrays satisfies one of the following conditions:\nThe subarray consists of exactly 2, equal elements. For example, the subarray [2,2] is good.\nThe subarray consists of exactly 3, equal elements. For example, the subarray [4,4,4] is good.\nThe subarray consists of exactly 3 consecutive increasing elements, that is, the difference between adjacent elements is 1. For example, the subarray [3,4,5] is good, but the subarray [1,3,5] is not.\nReturn true if the array has at least one valid partition. Otherwise, return false.", "canonical_solution": "def validPartition(nums):\n        n = len(nums)\n        dp = [False] * (n + 1)\n        dp[0] = True        \n        if nums[1] == nums[0]:\n            dp[2] = True       \n        for i in range(2, n):\n            if nums[i] == nums[i - 1]:\n                dp[i + 1] = dp[i + 1] or dp[i - 1]            \n            if nums[i] == nums[i - 1] and nums[i] == nums[i - 2]:\n                dp[i + 1] = dp[i + 1] or dp[i - 2]\n            if nums[i] == nums[i - 1] + 1 and nums[i] == nums[i - 2] + 2:\n                dp[i + 1] = dp[i + 1] or dp[i - 2]\n        return dp[n]", "entry_point": "validPartition", "test_list": ["assert validPartition([4,4,4,5,6])==True", "assert validPartition([1,1,1,2])==False"]}
{"Contest id": "305/2367", "text_name": "Number of Arithmetic Triplets", "text": "You are given a 0-indexed, strictly increasing integer array nums and a positive integer diff. A triplet (i, j, k) is an arithmetic triplet if the following conditions are met:\ni < j < k,\nnums[j] - nums[i] == diff, and\nnums[k] - nums[j] == diff.\nReturn the number of unique arithmetic triplets.", "canonical_solution": "def arithmeticTriplets(nums, diff):\n        ans = 0\n        n = len(nums)\n        for i in range(n):\n            if nums[i] + diff in nums and nums[i] + 2 * diff in nums:\n                ans += 1\n        return ans", "entry_point": "arithmeticTriplets", "test_list": ["assert arithmeticTriplets([0,1,4,6,7,10],3)==2", "assert arithmeticTriplets([4,5,6,7,8,9],2)==2"]}
{"Contest id": "Bi84/2366", "text_name": "Minimum Replacements to Sort the Array", "text": "You are given a 0-indexed integer array nums. In one operation you can replace any element of the array with any two elements that sum to it.\nFor example, consider nums = [5,6,7]. In one operation, we can replace nums[1] with 2 and 4 and convert nums to [5,2,4,7].\nReturn the minimum number of operations to make an array that is sorted in non-decreasing order.", "canonical_solution": "def minimumReplacement(A):\n        x = A[-1]\n        res = 0\n        for a in reversed(A):\n            k = (a + x - 1) // x\n            x = a // k\n            res += k - 1\n        return res", "entry_point": "minimumReplacement", "test_list": ["assert minimumReplacement([3,9,3])==2", "assert minimumReplacement([1,2,3,4,5])==0"]}
{"Contest id": "Bi84/2365", "text_name": "Task Scheduler II", "text": "You are given a 0-indexed array of positive integers tasks, representing tasks that need to be completed in order, where tasks[i] represents the type of the ith task.\nYou are also given a positive integer space, which represents the minimum number of days that must pass after the completion of a task before another task of the same type can be performed.\nEach day, until all tasks have been completed, you must either:\nComplete the next task from tasks, or\nTake a break.\nReturn the minimum number of days needed to complete all tasks.", "canonical_solution": "def taskSchedulerII(A,space):\n        last = defaultdict(lambda: - len(A) - 10)\n        res = 0\n        for a in A:\n            last[a] = res = max(res, last[a] + space) + 1\n        return res", "entry_point": "taskSchedulerII", "test_list": ["assert taskSchedulerII([1,2,1,2,3,1],3)==9", "assert taskSchedulerII([5,8,8,5],2)==6"]}
{"Contest id": "Bi84/2364", "text_name": "Count Number of Bad Pairs", "text": "You are given a 0-indexed integer array nums. A pair of indices (i, j) is a bad pair if i < j and j - i != nums[j] - nums[i].\nReturn the total number of bad pairs in nums.", "canonical_solution": "def countBadPairs(nums):\n        count=0\n        n=len(nums)\n        d={}\n        for i in range(n):\n            if nums[i]-i in d:\n                count+=d[nums[i]-i]\n                d[nums[i]-i]+=1\n            else:\n                d[nums[i]-i]=1\n        return (n*(n-1)//2) - count", "entry_point": "countBadPairs", "test_list": ["assert countBadPairs([4,1,3,3])==5", "assert countBadPairs([1,2,3,4,5])==0"]}
{"Contest id": "Bi84/2363", "text_name": "Merge Similar Items", "text": "You are given two 2D integer arrays, items1 and items2, representing two sets of items. Each array items has the following properties:\nitems[i] = [valuei, weighti] where valuei represents the value and weighti represents the weight of the ith item.\nThe value of each item in items is unique.\nReturn a 2D integer array ret where ret[i] = [valuei, weighti], with weighti being the sum of weights of all items with value valuei.\nNote: ret should be returned in ascending order by value.", "canonical_solution": "def mergeSimilarItems(items1, items2):\n        hashset = {}\n        for i in range(len(items1)):\n            if items1[i][0] in hashset:\n                hashset[items1[i][0]] += items1[i][1]\n            else:\n                hashset[items1[i][0]] = items1[i][1]\n\n        for i in range(len(items2)):\n            if items2[i][0] in hashset:\n                hashset[items2[i][0]] += items2[i][1]\n            else:\n                hashset[items2[i][0]] = items2[i][1]       \n        ans = []\n        for i in sorted(hashset):\n            ans.append([i, hashset[i]])       \n        return ans", "entry_point": "mergeSimilarItems", "test_list": ["assert mergeSimilarItems([[1,1],[4,5],[3,8]],[[3,1],[1,5]])==[[1,6],[3,9],[4,5]]", "assert mergeSimilarItems([[1,1],[3,2],[2,3]],[[2,1],[3,2],[1,3]])==[[1,4],[2,4],[3,4]]", "assert mergeSimilarItems([[1,3],[2,2]],[[7,1],[2,2],[1,4]])==[[1,7],[2,4],[7,1]]"]}
{"Contest id": "304/2360", "text_name": "Longest Cycle in a Graph", "text": "You are given a directed graph of n nodes numbered from 0 to n - 1, where each node has at most one outgoing edge.\nThe graph is represented with a given 0-indexed array edges of size n, indicating that there is a directed edge from node i to node edges[i]. If there is no outgoing edge from node i, then edges[i] == -1.\nReturn the length of the longest cycle in the graph. If no cycle exists, return -1.\nA cycle is a path that starts and ends at the same node.", "canonical_solution": "def longestCycle(edges):\n        from collections import Counter\n        n = len(edges)\n        indeg = Counter(edges)\n        stack = [node for node in range(n) if indeg[node] == 0]\n        inCycle = {node for node in range(n)}\n        while stack:\n            cur = stack.pop()\n            inCycle.remove(cur)\n            nei = edges[cur]\n            if nei == -1:\n                continue\n            indeg[nei] -= 1\n            if indeg[nei] == 0:\n                stack.append(nei)\n        def dfs(s):\n            stack = [s]\n            seen.add(s)\n            res = 0\n            while stack:\n                res += 1\n                cur = stack.pop()\n\n                nei = edges[cur]\n                if nei not in seen:\n                    seen.add(nei)\n                    stack.append(nei)\n            return res\n        seen = set()\n        res = 0\n        for i in inCycle:\n            if i not in seen:\n                res = max(res, dfs(i))\n        return res if res else -1", "entry_point": "longestCycle", "test_list": ["assert longestCycle([3,3,4,2,3])==3", "assert longestCycle([2,-1,3,1])==-1"]}
{"Contest id": "304/2359", "text_name": "Find Closest Node to Given Two Nodes", "text": "You are given a directed graph of n nodes numbered from 0 to n - 1, where each node has at most one outgoing edge.\nThe graph is represented with a given 0-indexed array edges of size n, indicating that there is a directed edge from node i to node edges[i]. If there is no outgoing edge from i, then edges[i] == -1.\nYou are also given two integers node1 and node2.\nReturn the index of the node that can be reached from both node1 and node2, such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized. If there are multiple answers, return the node with the smallest index, and if no possible answer exists, return -1.\nNote that edges may contain cycles.", "canonical_solution": "def closestMeetingNode(edges, node1, node2):\n        visited1 = set()\n        visited2 = set()\n        ans = set()        \n        while node1 != -1 or node2 != -1:\n            if node1 != -1 and ((node1 in visited2) or node1 == node2):\n                ans.add(node1)\n            if node2 != -1 and ((node2 in visited1) or node1 == node2):\n                ans.add(node2)\n            if ans:\n                return min(ans)\n            if node1 != -1 and node1 not in visited1:\n                visited1.add(node1)\n                node1 = edges[node1]\n            else:\n                node1 = -1\n            if node2 != -1 and node2 not in visited2:\n                visited2.add(node2)\n                node2 = edges[node2]\n            else:\n                node2 = -1\n        return -1", "entry_point": "closestMeetingNode", "test_list": ["assert closestMeetingNode([2,2,3,-1],0,1)==2", "assert closestMeetingNode([1,2,-1],0,2)==2"]}
{"Contest id": "304/2358", "text_name": "Maximum Number of Groups Entering a Competition", "text": "You are given a positive integer array grades which represents the grades of students in a university. You would like to enter all these students into a competition in ordered non-empty groups, such that the ordering meets the following conditions:\nThe sum of the grades of students in the ith group is less than the sum of the grades of students in the (i + 1)th group, for all groups (except the last).\nThe total number of students in the ith group is less than the total number of students in the (i + 1)th group, for all groups (except the last).\nReturn the maximum number of groups that can be formed.", "canonical_solution": "def maximumGroups(grades):\n     from math import sqrt\n     return  int(-.5+sqrt(.25+2*len(grades)))", "entry_point": "maximumGroups", "test_list": ["assert maximumGroups([10,6,12,7,3,5])==3", "assert maximumGroups([8,8])==1"]}
{"Contest id": "304/2357", "text_name": "Make Array Zero by Subtracting Equal Amounts", "text": "You are given a non-negative integer array nums. In one operation, you must:\nChoose a positive integer x such that x is less than or equal to the smallest non-zero element in nums.\nSubtract x from every positive element in nums.\nReturn the minimum number of operations to make every element in nums equal to 0.", "canonical_solution": "def minimumOperations(nums):\n        c,n=0,len(nums)\n        def smallestNonZero():\n            x=101\n            for i in nums:\n                if i==0:\n                    continue\n                if i<x:\n                    x=i\n            return x\n        while sum(nums)!=0:\n            c+=1\n            x=smallestNonZero()\n            for i in range(n):\n                if nums[i]==0:\n                    continue\n                nums[i]-=x\n        return c", "entry_point": "minimumOperations", "test_list": ["assert minimumOperations([1,5,0,3,5])==3", "assert minimumOperations([0])==0"]}
{"Contest id": "303/2354", "text_name": "Number of Excellent Pairs", "text": "You are given a 0-indexed positive integer array nums and a positive integer k.\nA pair of numbers (num1, num2) is called excellent if the following conditions are satisfied:\nBoth the numbers num1 and num2 exist in the array nums.\nThe sum of the number of set bits in num1 OR num2 and num1 AND num2 is greater than or equal to k, where OR is the bitwise OR operation and AND is the bitwise AND operation.\nReturn the number of distinct excellent pairs.\nTwo pairs (a, b) and (c, d) are considered distinct if either a != c or b != d. For example, (1, 2) and (2, 1) are distinct.\nNote that a pair (num1, num2) such that num1 == num2 can also be excellent if you have at least one occurrence of num1 in the array.", "canonical_solution": "def countExcellentPairs(nums, k):\n        A  = sorted([bin(n).count('1') for n in set(nums)])\n        res = 0\n        p1, p2 = 0, len(A) - 1\n        while p1 < p2:\n            if A[p1] + A[p2] >= k:\n                res += (p2 - p1) * 2 \n                p2 -= 1\n            else:\n                p1 += 1        \n        for n in A:\n            if 2 * n >= k:\n                res += 1\n        return res", "entry_point": "countExcellentPairs", "test_list": ["assert countExcellentPairs([1,2,3,1],3)==5", "assert countExcellentPairs([5,1,1],10)==0"]}
{"Contest id": "303/2352", "text_name": "Equal Row and Column Pairs", "text": "Given a 0-indexed n x n integer matrix grid, return the number of pairs (ri, cj) such that row ri and column cj are equal.\nA row and column pair is considered equal if they contain the same elements in the same order (i.e., an equal array).", "canonical_solution": "def equalPairs(grid):\n        from collections import Counter\n        tpse = Counter(zip(*grid))                \n        grid = Counter(map(tuple,grid))            \n        return  sum(tpse[t]*grid[t] for t in tpse)  ", "entry_point": "equalPairs", "test_list": ["assert equalPairs([[3,2,1],[1,7,6],[2,7,7]])==1", "assert equalPairs([[3,1,2,2],[1,4,4,5],[2,4,2,2],[2,4,2,2]])==3"]}
{"Contest id": "303/2351", "text_name": "First Letter to Appear Twice", "text": "Given a string s consisting of lowercase English letters, return the first letter to appear twice.\nNote:\nA letter a appears twice before another letter b if the second occurrence of a is before the second occurrence of b.\ns will contain at least one letter that appears twice.", "canonical_solution": "def repeatedCharacter(s):\n        from collections import defaultdict\n        occurences = defaultdict(int)\n        for char in s:\n            occurences[char] += 1\n            if occurences[char] == 2:\n                return char", "entry_point": "repeatedCharacter", "test_list": ["assert repeatedCharacter(\"abccbaacz\")==\"c\"", "assert repeatedCharacter(\"abcdd\")==\"d\""]}
{"Contest id": "Bi83/2350", "text_name": "Shortest Impossible Sequence of Rolls", "text": "You are given an integer array rolls of length n and an integer k. You roll a k sided dice numbered from 1 to k, n times, where the result of the ith roll is rolls[i].\nReturn the length of the shortest sequence of rolls that cannot be taken from rolls.\nA sequence of rolls of length len is the result of rolling a k sided dice len times.\nNote that the sequence taken does not have to be consecutive as long as it is in order.", "canonical_solution": "def shortestSequence(rolls, k):\n        res = 1\n        s = set()\n        for a in rolls:\n            s.add(a)\n            if len(s) == k:\n                res += 1\n                s.clear()\n        return res", "entry_point": "shortestSequence", "test_list": ["assert shortestSequence([4,2,1,2,3,3,2,4,1],4)==3", "assert shortestSequence([1,1,2,2],2)==2", "assert shortestSequence([1,1,3,2,2,2,3,3],4)==1"]}
{"Contest id": "Bi83/2348", "text_name": "Number of Zero-Filled Subarrays", "text": "Given an integer array nums, return the number of subarrays filled with 0.\nA subarray is a contiguous non-empty sequence of elements within an array.", "canonical_solution": "def zeroFilledSubarray(nums):\n        total_zero_subarrays = current_zero_subarrays = 0                \n        for num in nums:\n            if num == 0:\n                current_zero_subarrays += 1\n                total_zero_subarrays += current_zero_subarrays\n            else:\n                current_zero_subarrays = 0                \n        return total_zero_subarrays", "entry_point": "zeroFilledSubarray", "test_list": ["assert zeroFilledSubarray([1,3,0,0,2,0,0,4])==6", "assert zeroFilledSubarray([0,0,0,2,0,0])==9", "assert zeroFilledSubarray([2,10,2019])==0"]}
{"Contest id": "Bi83/2347", "text_name": "Best Poker Hand", "text": "You are given an integer array ranks and a character array suits. You have 5 cards where the ith card has a rank of ranks[i] and a suit of suits[i].\nThe following are the types of poker hands you can make from best to worst:\n\"Flush\": Five cards of the same suit.\n\"Three of a Kind\": Three cards of the same rank.\n\"Pair\": Two cards of the same rank.\n\"High Card\": Any single card.\nReturn a string representing the best type of poker hand you can make with the given cards.\nNote that the return values are case-sensitive.", "canonical_solution": "def bestHand(ranks, suits):\n    from collections import Counter\n    max_rank_cnt = max(Counter(ranks).values())\n    max_suit_cnt = max(Counter(suits).values())\n    return {\n        max_rank_cnt == 2: 'Pair',\n        max_rank_cnt >= 3: 'Three of a Kind',\n        max_suit_cnt == 5: 'Flush',\n    }.get(True, 'High Card')\n        ", "entry_point": "bestHand", "test_list": ["assert bestHand([13,2,3,1,9],[\"a\",\"a\",\"a\",\"a\",\"a\"])==\"Flush\"", "assert bestHand([4,4,2,4,4],[\"d\",\"a\",\"a\",\"b\",\"c\"])==\"Three of a Kind\"", "assert bestHand([10,10,2,12,9], [\"a\",\"b\",\"c\",\"a\",\"d\"])==\"Pair\""]}
{"Contest id": "302/2343", "text_name": "Query Kth Smallest Trimmed Number", "text": "You are given a 0-indexed array of strings nums, where each string is of equal length and consists of only digits.\nYou are also given a 0-indexed 2D integer array queries where queries[i] = [ki, trimi]. For each queries[i], you need to:\nTrim each number in nums to its rightmost trimi digits.\nDetermine the index of the kith smallest trimmed number in nums. If two trimmed numbers are equal, the number with the lower index is considered to be smaller.\nReset each number in nums to its original length.\nReturn an array answer of the same length as queries, where answer[i] is the answer to the ith query.\nNote:\nTo trim to the rightmost x digits means to keep removing the leftmost digit, until only x digits remain.\nStrings in nums may contain leading zeros.", "canonical_solution": "def smallestTrimmedNumbers(nums, queries):\n        from collections import defaultdict\n        sl = len(nums[0])\n        len_to_sorted = defaultdict(list)\n        ans = [0] * len(queries)       \n        for i, (k_smallest, trim_len) in enumerate(queries):\n            if trim_len not in len_to_sorted:\n                # have to trim\n                for ni, num in enumerate(nums):\n                    len_to_sorted[trim_len].append( (int(num[sl - trim_len:]), ni) )                    \n                len_to_sorted[trim_len] = sorted(len_to_sorted[trim_len])\n            ans[i] = len_to_sorted[trim_len][k_smallest -1][1]           \n        return ans", "entry_point": "smallestTrimmedNumbers", "test_list": ["assert smallestTrimmedNumbers([\"102\",\"473\",\"251\",\"814\"],[[1,1],[2,3],[4,2],[1,2]])==[2,2,1,0]", "assert smallestTrimmedNumbers([\"24\",\"37\",\"96\",\"04\"],[[2,1],[2,2]])==[3,0]"]}
{"Contest id": "302/2342", "text_name": "Max Sum of a Pair With Equal Sum of Digits", "text": "You are given a 0-indexed array nums consisting of positive integers. You can choose two indices i and j, such that i != j, and the sum of digits of the number nums[i] is equal to that of nums[j].\nReturn the maximum value of nums[i] + nums[j] that you can obtain over all possible indices i and j that satisfy the conditions.", "canonical_solution": "def maximumSum(nums):\n        dict_map = {}        \n        res = -1\n        for num in nums:\n            temp = num\n            new_num = 0\n            while temp:\n                new_num += temp % 10\n                temp = temp // 10\n            if new_num in dict_map:\n                new_res = num + dict_map[new_num]\n                res = max(res, new_res)\n                dict_map[new_num] = max(num, dict_map[new_num])\n            else:\n                dict_map[new_num] = num\n        return res", "entry_point": "maximumSum", "test_list": ["assert maximumSum([18,43,36,13,7])==54", "assert maximumSum([10,12,19,14])==-1"]}
{"Contest id": "302/2341", "text_name": "Maximum Number of Pairs in Array", "text": "You are given a 0-indexed integer array nums. In one operation, you may do the following:\nChoose two integers in nums that are equal.\nRemove both integers from nums, forming a pair.\nThe operation is done on nums as many times as possible.\nReturn a 0-indexed integer array answer of size 2 where answer[0] is the number of pairs that are formed and answer[1] is the number of leftover integers in nums after doing the operation as many times as possible.", "canonical_solution": "def numberOfPairs(nums):\n        output = []  \n        pair = 0\n        unique = list(set(nums)) \n        for i in range(len(unique)):\n            count = nums.count(unique[i]) \n            if count % 2 !=0:\n                output.append(unique[i]) \n            pair += (count)//2 \n        return [pair,len(output)] ", "entry_point": "numberOfPairs", "test_list": ["assert numberOfPairs([1,3,2,1,3,2,2])==[3,1]", "assert numberOfPairs([1,1])==[1,0]", "assert numberOfPairs([0])==[0,1]"]}
{"Contest id": "301/2338", "text_name": "Count the Number of Ideal Arrays", "text": "You are given two integers n and maxValue, which are used to describe an ideal array.\nA 0-indexed integer array arr of length n is considered ideal if the following conditions hold:\nEvery arr[i] is a value from 1 to maxValue, for 0 <= i < n.\nEvery arr[i] is divisible by arr[i - 1], for 0 < i < n.\nReturn the number of distinct ideal arrays of length n. Since the answer may be very large, return it modulo 109 + 7.", "canonical_solution": "def idealArrays(n, m):\n        mod, ans, comb = 10**9 + 7, m, 1\n        dp = [0] + [1] * m       \n        for i in range(1, min(n, 14)):\n            for j in range(m, 0, -1):\n                if dp[j] == 0: continue\n                for k in range(j << 1, m + 1, j):\n                    dp[k] += dp[j]\n                dp[j] = 0\n            comb = (comb * (n-i)) // i\n            ans = (ans + sum(dp) * comb) % mod\n        return ans", "entry_point": "idealArrays", "test_list": ["assert idealArrays(n = 2, m= 5) == 10", "assert idealArrays(n = 5, m= 3) == 11"]}
{"Contest id": "301/2337", "text_name": "Move Pieces to Obtain a String", "text": "You are given two strings start and target, both of length n. Each string consists only of the characters 'L', 'R', and '_' where:\nThe characters 'L' and 'R' represent pieces, where a piece 'L' can move to the left only if there is a blank space directly to its left, and a piece 'R' can move to the right only if there is a blank space directly to its right.\nThe character '_' represents a blank space that can be occupied by any of the 'L' or 'R' pieces.\nReturn true if it is possible to obtain the string target by moving the pieces of the string start any number of times. Otherwise, return false.", "canonical_solution": "def canChange(start, target):\n        lcnt, rcnt = 0, 0\n        for c1, c2 in zip(start, target):\n            if c1 == 'L': lcnt += 1\n            if c2 == 'L': lcnt -= 1\n            if c1 == 'R': rcnt += 1\n            if c2 == 'R': rcnt -= 1\n        if lcnt or rcnt: return False\n        \n        s_ptr = 0\n        for t_ptr in range(len(target)):\n            if target[t_ptr] == '_':\n                continue\n            else:\n                while s_ptr < len(start) and start[s_ptr] == '_':\n                    s_ptr += 1\n                if (target[t_ptr] != start[s_ptr] or\n                    target[t_ptr] == 'L' and s_ptr < t_ptr or\n                    target[t_ptr] == 'R' and s_ptr > t_ptr):\n                    return False\n                s_ptr += 1\n        return True", "entry_point": "canChange", "test_list": ["assert canChange(start = \"_L__R__R_\", target = \"L______RR\") == True", "assert canChange(start = \"R_L_\", target = \"__LR\") == False", "assert canChange(start = \"_R\", target = \"R_\") == False"]}
{"Contest id": "301/2335", "text_name": "Minimum Amount of Time to Fill Cups", "text": "You have a water dispenser that can dispense cold, warm, and hot water. Every second, you can either fill up 2 cups with different types of water, or 1 cup of any type of water.\nYou are given a 0-indexed integer array amount of length 3 where amount[0], amount[1], and amount[2] denote the number of cold, warm, and hot water cups you need to fill respectively. Return the minimum number of seconds needed to fill up all the cups.", "canonical_solution": "def fillCups(A):\n        return max(max(A), (sum(A) + 1) // 2)", "entry_point": "fillCups", "test_list": ["assert fillCups([1,4,2]) == 4", "assert fillCups([5,4,4]) == 7", "assert fillCups([5,0,0]) == 5"]}
{"Contest id": "Bi82/2334", "text_name": "Subarray With Elements Greater Than Varying Threshold", "text": "You are given an integer array nums and an integer threshold.\nFind any subarray of nums of length k such that every element in the subarray is greater than threshold / k.\nReturn the size of any such subarray. If there is no such subarray, return -1.\nA subarray is a contiguous non-empty sequence of elements within an array.", "canonical_solution": "def validSubarraySize(nums, threshold):\n        nums = [0] + nums + [0]\n        stack = [0]\n        for i in range(1,len(nums)):\n            while nums[i] < nums[stack[-1]]:\n                tmp = nums[stack.pop()]\n                if tmp > threshold / (i - stack[-1] - 1):\n                    return i - stack[-1] - 1\n            stack.append(i)\n        return -1", "entry_point": "validSubarraySize", "test_list": ["assert validSubarraySize(nums = [1,3,4,3,1], threshold = 6) == 3", "assert validSubarraySize(nums = [6,5,6,5,8], threshold = 7) == 1"]}
{"Contest id": "Bi82/2333", "text_name": "Minimum Sum of Squared Difference", "text": "You are given two positive 0-indexed integer arrays nums1 and nums2, both of length n.\nThe sum of squared difference of arrays nums1 and nums2 is defined as the sum of (nums1[i] - nums2[i])2 for each 0 <= i < n.\nYou are also given two positive integers k1 and k2. You can modify any of the elements of nums1 by +1 or -1 at most k1 times. Similarly, you can modify any of the elements of nums2 by +1 or -1 at most k2 times.\nReturn the minimum sum of squared difference after modifying array nums1 at most k1 times and modifying array nums2 at most k2 times.\nNote: You are allowed to modify the array elements to become negative integers.", "canonical_solution": "def minSumSquareDiff(nums1, nums2, k1, k2):\n        from heapq import heapify, heappush, heappop\n        heap = [ -abs(x-y) for x, y in zip(nums1, nums2)]\n        s = -sum(heap)\n        if k1+k2 >= s: return 0\n        delta = k1 + k2\n        heapify(heap)\n        n = len(nums1)\n        while delta > 0:\n            d = -heappop(heap)\n            gap = max(delta//n, 1) if heap else delta\n            d -= gap\n            heappush(heap, -d)\n            delta -= gap\n        return sum(pow(e,2) for e in heap)", "entry_point": "minSumSquareDiff", "test_list": ["assert minSumSquareDiff(nums1 = [1,2,3,4], nums2 = [2,10,20,19], k1 = 0, k2 = 0) == 579", "assert minSumSquareDiff(nums1 = [1,4,10,12], nums2 = [5,8,6,9], k1 = 1, k2 = 1) == 43"]}
{"Contest id": "Bi82/2332", "text_name": "The Latest Time to Catch a Bus", "text": "You are given a 0-indexed integer array buses of length n, where buses[i] represents the departure time of the ith bus. You are also given a 0-indexed integer array passengers of length m, where passengers[j] represents the arrival time of the jth passenger. All bus departure times are unique. All passenger arrival times are unique.\nYou are given an integer capacity, which represents the maximum number of passengers that can get on each bus.\nWhen a passenger arrives, they will wait in line for the next available bus. You can get on a bus that departs at x minutes if you arrive at y minutes where y <= x, and the bus is not full. Passengers with the earliest arrival times get on the bus first.\nMore formally when a bus arrives, either:\nIf capacity or fewer passengers are waiting for a bus, they will all get on the bus, or\nThe capacity passengers with the earliest arrival times will get on the bus.\nReturn the latest time you may arrive at the bus station to catch a bus. You cannot arrive at the same time as another passenger.\nNote: The arrays buses and passengers are not necessarily sorted.", "canonical_solution": "def latestTimeCatchTheBus(buses, passengers, capacity):\n        passengers.sort()\n        cur = 0\n\n        for time in sorted(buses):\n            cap = capacity\n            while cur < len(passengers) and passengers[cur] <= time and cap > 0:\n                cur += 1\n                cap -= 1\n\n        best = time if cap > 0 else passengers[cur - 1]\n\n        passengers = set(passengers)\n        while best in passengers:\n            best -= 1\n        return best", "entry_point": "latestTimeCatchTheBus", "test_list": ["assert latestTimeCatchTheBus(buses = [10,20], passengers = [2,17,18,19], capacity = 2) == 16", "assert latestTimeCatchTheBus(buses = [20,30,10], passengers = [19,13,26,4,25,11,21], capacity = 2) == 20"]}
{"Contest id": "300/2328", "text_name": "Number of Increasing Paths in a Grid", "text": "You are given an m x n integer matrix grid, where you can move from a cell to any adjacent cell in all 4 directions.\nReturn the number of strictly increasing paths in the grid such that you can start from any cell and end at any cell. Since the answer may be very large, return it modulo 109 + 7.\nTwo paths are considered different if they do not have exactly the same sequence of visited cells.", "canonical_solution": "def countPaths(A):\n        m, n, mod = len(A), len(A[0]), 10 ** 9 + 7\n        dp = [[1] * n for i in range(m)]\n        for a, i, j in sorted([A[i][j], i, j] for i in range(m) for j in range(n)):\n            for x, y in [[i, j + 1], [i, j - 1], [i + 1, j], [i - 1, j]]:\n                if 0 <= x < m and 0 <= y < n and A[x][y] < A[i][j]:\n                    dp[i][j] += dp[x][y] % mod\n        return sum(map(sum, dp)) % mod", "entry_point": "countPaths", "test_list": ["assert countPaths([[1,1],[3,4]]) == 8", "assert countPaths([[1],[2]]) == 3"]}
{"Contest id": "300/2327", "text_name": "Number of People Aware of a Secret", "text": "On day 1, one person discovers a secret.\nYou are given an integer delay, which means that each person will share the secret with a new person every day, starting from delay days after discovering the secret. You are also given an integer forget, which means that each person will forget the secret forget days after discovering it. A person cannot share the secret on the same day they forgot it, or on any day afterwards.\nGiven an integer n, return the number of people who know the secret at the end of day n. Since the answer may be very large, return it modulo 109 + 7.", "canonical_solution": "def peopleAwareOfSecret(n, delay, forget):\n        dp = [1] + [0] * forget\n        mod = 10 ** 9 + 7\n        share = 0\n        for i in range(1, n):\n            dp[i % forget] = share = (share + dp[(i - delay) % forget] - dp[i % forget]) % mod\n        return sum(dp) % mod", "entry_point": "peopleAwareOfSecret", "test_list": ["assert peopleAwareOfSecret(n = 6, delay = 2, forget = 4) == 5", "assert peopleAwareOfSecret(n = 4, delay = 1, forget = 3) == 6"]}
{"Contest id": "300/2325", "text_name": "Decode the Message", "text": "You are given the strings key and message, which represent a cipher key and a secret message, respectively. The steps to decode message are as follows:\nUse the first appearance of all 26 lowercase English letters in key as the order of the substitution table.\nAlign the substitution table with the regular English alphabet.\nEach letter in message is then substituted using the table.\nSpaces ' ' are transformed to themselves.\nFor example, given key = \"happy boy\" (actual key would have at least one instance of each letter in the alphabet), we have the partial substitution table of ('h' -> 'a', 'a' -> 'b', 'p' -> 'c', 'y' -> 'd', 'b' -> 'e', 'o' -> 'f').\nReturn the decoded message.", "canonical_solution": "def decodeMessage(key, message):\n        mapping = {' ': ' '}\n        i = 0\n        res = ''\n        letters = 'abcdefghijklmnopqrstuvwxyz'\n        \n        for char in key:\n            if char not in mapping:\n                mapping[char] = letters[i]\n                i += 1\n        \n        for char in message:\n            res += mapping[char]\n                \n        return res", "entry_point": "decodeMessage", "test_list": ["assert decodeMessage(key = \"the quick brown fox jumps over the lazy dog\", message = \"vkbs bs t suepuv\") == \"this is a secret\"", "assert decodeMessage(key = \"eljuxhpwnyrdgtqkviszcfmabo\", message = \"zwx hnfx lqantp mnoeius ycgk vcnjrdb\") == \"the five boxing wizards jump quickly\""]}
{"Contest id": "299/2321", "text_name": "Maximum Score Of Spliced Array", "text": "You are given two 0-indexed integer arrays nums1 and nums2, both of length n.\nYou can choose two integers left and right where 0 <= left <= right < n and swap the subarray nums1[left...right] with the subarray nums2[left...right].\nFor example, if nums1 = [1,2,3,4,5] and nums2 = [11,12,13,14,15] and you choose left = 1 and right = 2, nums1 becomes [1,12,13,4,5] and nums2 becomes [11,2,3,14,15].\nYou may choose to apply the mentioned operation once or not do anything.\nThe score of the arrays is the maximum of sum(nums1) and sum(nums2), where sum(arr) is the sum of all the elements in the array arr.\nReturn the maximum possible score.\nA subarray is a contiguous sequence of elements within an array. arr[left...right] denotes the subarray that contains the elements of nums between indices left and right (inclusive).", "canonical_solution": "def maximumsSplicedArray(a, b):\n\n        n = len(a)\n\n        def C(a, b):\n\n            x, y, z = 0, 0, 0\n\n            for i in range(n):\n\n                x = max(a[i] + x, b[i] + y)\n                y = max(a[i] + z, b[i] + y)\n                z = a[i] + z\n\n            return max(x, y, z)\n\n        return max(C(a, b), C(b, a))", "entry_point": "maximumsSplicedArray", "test_list": ["assert maximumsSplicedArray([60,60,60], [10,90,10]) == 210", "assert maximumsSplicedArray([20,40,20,70,30], [50,20,50,40,20]) == 220", "assert maximumsSplicedArray([7,11,13], [1,1,1]) == 31"]}
{"Contest id": "299/2320", "text_name": "Count Number of Ways to Place Houses", "text": "There is a street with n * 2 plots, where there are n plots on each side of the street. The plots on each side are numbered from 1 to n. On each plot, a house can be placed.\nReturn the number of ways houses can be placed such that no two houses are adjacent to each other on the same side of the street. Since the answer may be very large, return it modulo 109 + 7.\nNote that if a house is placed on the ith plot on one side of the street, a house can also be placed on the ith plot on the other side of the street.", "canonical_solution": "def countHousePlacements(n):\n        a, b, mod = 1, 1, 10**9 + 7\n        for i in range(n):\n            a, b = b, (a + b) % mod\n        return b * b % mod", "entry_point": "countHousePlacements", "test_list": ["assert countHousePlacements(n = 1) == 4", "assert countHousePlacements(n = 2) == 9"]}
{"Contest id": "299/2319", "text_name": "Check if Matrix Is X-Matrix", "text": "A square matrix is said to be an X-Matrix if both of the following conditions hold:\nAll the elements in the diagonals of the matrix are non-zero.\nAll other elements are 0.\nGiven a 2D integer array grid of size n x n representing a square matrix, return true if grid is an X-Matrix. Otherwise, return false.", "canonical_solution": "def checkXMatrix(grid):\n        n = len(grid)\n        for i in range(n):\n            for j in range(n):\n                if i==j or (i+j) ==n-1:\n                    if grid[i][j] == 0:\n                        return False\n                elif grid[i][j] != 0: \n                    return False\n        return True", "entry_point": "checkXMatrix", "test_list": ["assert checkXMatrix(grid = [[2,0,0,1],[0,3,1,0],[0,5,2,0],[4,0,0,2]]) == True", "assert checkXMatrix(grid = [[5,7,0],[0,3,1],[0,5,0]]) == False"]}
{"Contest id": "Bi81/2318", "text_name": "Number of Distinct Roll Sequences", "text": "You are given an integer n. You roll a fair 6-sided dice n times. Determine the total number of distinct sequences of rolls possible such that the following conditions are satisfied:\nThe greatest common divisor of any adjacent values in the sequence is equal to 1.\nThere is at least a gap of 2 rolls between equal valued rolls. More formally, if the value of the ith roll is equal to the value of the jth roll, then abs(i - j) > 2.\nReturn the total number of distinct sequences possible. Since the answer may be very large, return it modulo 109 + 7.\nTwo sequences are considered distinct if at least one element is different.", "canonical_solution": "def distinctSequences(n):\n        l1 = [5, 3, 4, 3, 5, 2]\n        l2 = [12, 11, 12, 11, 12, 8]       \n        if n==1:\n            return 6\n        if n==2:\n            return sum(l1)       \n        mod = 10**9+7\n        for i in range(n-3):           \n            temp = [0]*6            \n            temp[0] = (sum(l2[1:]) - 4*l1[0] )%mod           \n            temp[1] = (l2[0]+l2[2]+l2[4] - 2*l1[1])%mod          \n            temp[2] = (l2[0]+l2[1]+l2[3]+l2[4] - 3*l1[2] )%mod           \n            temp[3] = (l2[0]+l2[2]+l2[4] - 2*l1[3])%mod           \n            temp[4] = (sum(l2[:4])+l2[5] - 4*l1[4])%mod           \n            temp[5] = (l2[0]+l2[4] - 1*l1[5] )%mod           \n            l1, l2 = l2, temp\n        return sum(l2)%mod", "entry_point": "distinctSequences", "test_list": ["assert distinctSequences(n = 4) == 184", "assert distinctSequences(n = 2) == 22"]}
{"Contest id": "Bi81/2317", "text_name": "Maximum XOR After Operations", "text": "You are given a 0-indexed integer array nums. In one operation, select any non-negative integer x and an index i, then update nums[i] to be equal to nums[i] AND (nums[i] XOR x).\nNote that AND is the bitwise AND operation and XOR is the bitwise XOR operation.\nReturn the maximum possible bitwise XOR of all elements of nums after applying the operation any number of times.", "canonical_solution": "def maximumXOR(nums):\n        res=0\n        for i in nums:\n            res |= i\n        return res", "entry_point": "maximumXOR", "test_list": ["assert maximumXOR(nums = [3,2,4,6]) == 7", "assert maximumXOR(nums = [1,2,3,9,2]) == 11"]}
{"Contest id": "Bi81/2316", "text_name": "Count Unreachable Pairs of Nodes in an Undirected Graph", "text": "You are given an integer n. There is an undirected graph with n nodes, numbered from 0 to n - 1. You are given a 2D integer array edges where edges[i] = [ai, bi] denotes that there exists an undirected edge connecting nodes ai and bi.\nReturn the number of pairs of different nodes that are unreachable from each other.", "canonical_solution": "def countPairs(n, edges):\n        from collections import deque\n        graph = {i: set() for i in range(n)}\n        for a, b in edges:\n            graph[a].add(b)\n            graph[b].add(a)\n        cmps, used = [], set()\n        for eg in graph:\n            if eg in used:\n                continue\n            q, counter = deque([eg]), 0\n            used.add(eg)\n            while q:\n                pp = q.popleft()\n                counter += 1\n                for nn in graph[pp]:\n                    if nn not in used:\n                        q.append(nn)\n                        used.add(nn)\n            cmps.append(counter)\n        prefix = [cmps[0]] + [0]*(len(cmps) - 1)\n        for i in range(1, len(cmps)):\n            prefix[i] = prefix[i - 1] + cmps[i]\n        ans = 0\n        for i in range(len(cmps)):\n            ans += (n - prefix[i])*cmps[i]\n        return ans", "entry_point": "countPairs", "test_list": ["assert countPairs(n = 3, edges = [[0,1],[0,2],[1,2]]) == 0", "assert countPairs(n = 7, edges = [[0,2],[0,5],[2,4],[1,6],[5,4]]) == 14"]}
{"Contest id": "Bi81/2315", "text_name": "Count Asterisks", "text": "You are given a string s, where every two consecutive vertical bars '|' are grouped into a pair. In other words, the 1st and 2nd '|' make a pair, the 3rd and 4th '|' make a pair, and so forth.\nReturn the number of '*' in s, excluding the '*' between each pair of '|'.\nNote that each '|' will belong to exactly one pair.", "canonical_solution": "def countAsterisks(s):\n        lst=[] \n        for i in s: \n            if '|' not in lst: \n                lst.append(i) \n            elif '|' in lst and i=='|': \n                lst.pop() \n        return lst.count('*')", "entry_point": "countAsterisks", "test_list": ["assert countAsterisks(s = \"l|*e*et|c**o|*de|\") == 2", "assert countAsterisks(s = \"iamprogrammer\") == 0", "assert countAsterisks(s = \"yo|uar|e**|b|e***au|tifu|l\") == 5"]}
{"Contest id": "298/2312", "text_name": " Selling Pieces of Wood", "text": " You are given two integers m and n that represent the height and width of a rectangular piece of wood. You are also given a 2D integer array prices, where prices[i] = [hi, wi, pricei] indicates you can sell a rectangular piece of wood of height hi and width wi for pricei dollars.\nTo cut a piece of wood, you must make a vertical or horizontal cut across the entire height or width of the piece to split it into two smaller pieces. After cutting a piece of wood into some number of smaller pieces, you can sell pieces according to prices. You may sell multiple pieces of the same shape, and you do not have to sell all the shapes. The grain of the wood makes a difference, so you cannot rotate a piece to swap its height and width.\nReturn the maximum money you can earn after cutting an m x n piece of wood.\nNote that you can cut the piece of wood as many times as you want.", "canonical_solution": "def sellingWood(m, n, prices):\n        dp = [[0] * (n + 1) for i in range(m+1)]\n        for w, h, p in prices:\n            dp[w][h] = p\n        for w in range(1, m + 1):\n            for h in range(1, n + 1):\n                for a in range(1, w // 2 + 1):\n                    dp[w][h] = max(dp[w][h], dp[a][h] + dp[w - a][h])\n                for a in range(1, h // 2 + 1):\n                    dp[w][h] = max(dp[w][h], dp[w][a] + dp[w][h - a])\n        return dp[m][n]", "entry_point": "sellingWood", "test_list": ["assert sellingWood(m = 3, n = 5, prices = [[1,4,2],[2,2,7],[2,1,3]]) == 19", "assert sellingWood(m = 4, n = 6, prices = [[3,2,10],[1,4,2],[4,1,3]]) == 32"]}
{"Contest id": "298/2311", "text_name": "Longest Binary Subsequence Less Than or Equal to K", "text": "You are given a binary string s and a positive integer k.\nReturn the length of the longest subsequence of s that makes up a binary number less than or equal to k.\nNote:\nThe subsequence can contain leading zeroes.\nThe empty string is considered to be equal to 0.\nA subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.", "canonical_solution": "def longestSubsequence(s, k):\n        dp = [0]\n        for v in map(int, s):\n            if dp[-1] * 2 + v <= k:\n                dp.append(dp[-1] * 2 + v)\n            for i in range(len(dp) - 1, 0, -1):\n                dp[i] = min(dp[i], dp[i - 1] * 2 + v)\n        return len(dp) - 1", "entry_point": "longestSubsequence", "test_list": ["assert longestSubsequence(s = \"1001010\", k = 5) == 5", "assert longestSubsequence(s = \"00101001\", k = 1) == 6"]}
{"Contest id": "298/2310", "text_name": "Sum of Numbers With Units Digit K", "text": "Given two integers num and k, consider a set of positive integers with the following properties:\nThe units digit of each integer is k.\nThe sum of the integers is num.\nReturn the minimum possible size of such a set, or -1 if no such set exists.\nNote:\nThe set can contain multiple instances of the same integer, and the sum of an empty set is considered 0.\nThe units digit of a number is the rightmost digit of the number.", "canonical_solution": "def minimumNumbers(num, k):\n        if num == 0: return 0\n        for i in range(1, 11):\n            if k * i % 10 == num % 10 and i * k <= num:\n                return i\n        return -1", "entry_point": "minimumNumbers", "test_list": ["assert minimumNumbers(num = 58, k = 9) == 2", "assert minimumNumbers(num = 37, k = 2) == -1", "assert minimumNumbers(num = 0, k = 7) == 0"]}
{"Contest id": "298/2309", "text_name": "Greatest English Letter in Upper and Lower Case", "text": "Given a string of English letters s, return the greatest English letter which occurs as both a lowercase and uppercase letter in s. The returned letter should be in uppercase. If no such letter exists, return an empty string.\nAn English letter b is greater than another letter a if b appears after a in the English alphabet.", "canonical_solution": "def greatestLetter(s):\n        s = set(s)\n        upper, lower = ord('Z'), ord('z')\n        for i in range(26):\n            if chr(upper - i) in s and chr(lower - i) in s:\n                return chr(upper - i)\n        return ''", "entry_point": "greatestLetter", "test_list": ["assert greatestLetter(s = \"lEeTcOdE\") == \"E\"", "assert greatestLetter(s = \"arRAzFif\") == \"R\"", "assert greatestLetter(s = \"AbCdEfGhIjK\") == \"\""]}
{"Contest id": "297/2306", "text_name": "Naming a Company", "text": "You are given an array of strings ideas that represents a list of names to be used in the process of naming a company. The process of naming a company is as follows:\nChoose 2 distinct names from ideas, call them ideaA and ideaB.\nSwap the first letters of ideaA and ideaB with each other.\nIf both of the new names are not found in the original ideas, then the name ideaA ideaB (the concatenation of ideaA and ideaB, separated by a space) is a valid company name.\nOtherwise, it is not a valid name.\nReturn the number of distinct valid names for the company.", "canonical_solution": "def distinctNames(ideas):\n    ans = 0\n    suffixes = [set() for _ in range(26)]\n\n    for idea in ideas:\n      suffixes[ord(idea[0]) - ord('a')].add(idea[1:])\n\n    for i in range(25):\n      for j in range(i + 1, 26):\n        count = len(suffixes[i] & suffixes[j])\n        ans += 2 * (len(suffixes[i]) - count) * (len(suffixes[j]) - count)\n\n    return ans", "entry_point": "distinctNames", "test_list": ["assert distinctNames(ideas = [\"coffee\",\"donuts\",\"time\",\"toffee\"]) == 6", "assert distinctNames(ideas = [\"lack\",\"back\"]) == 0"]}
{"Contest id": "297/2305", "text_name": "Fair Distribution of Cookies", "text": "You are given an integer array cookies, where cookies[i] denotes the number of cookies in the ith bag. You are also given an integer k that denotes the number of children to distribute all the bags of cookies to. All the cookies in the same bag must go to the same child and cannot be split up.\nThe unfairness of a distribution is defined as the maximum total cookies obtained by a single child in the distribution.\nReturn the minimum unfairness of all distributions.", "canonical_solution": "def distributeCookies(cookies, k):\n        size = len(cookies)     \n        dp = [[0] * (1 << size) for _ in range(k)]\n        sum_ = [0] * (1 << size)\n        inf = int(1e9)\n        for i in range(1, 1 << size):\n            for j, c in enumerate(cookies):\n                if i >> j & 1: sum_[i] += c\n        dp[0] = sum_\n        for i in range(1, k):\n            for j in range(1 << size):\n                dp[i][j] = inf\n                sub = j\n                while sub:\n                    max_cost = max(dp[i-1][j^sub], sum_[sub])\n                    dp[i][j] = min(dp[i][j], max_cost)\n                    sub = (sub - 1) & j\n        return dp[k-1][-1]    ", "entry_point": "distributeCookies", "test_list": ["assert distributeCookies(cookies = [8,15,10,20,8], k = 2) == 31", "assert distributeCookies(cookies = [6,1,3,2,2,4,1,2], k = 3) == 7"]}
{"Contest id": "297/2304", "text_name": "Minimum Path Cost in a Grid", "text": "You are given a 0-indexed m x n integer matrix grid consisting of distinct integers from 0 to m * n - 1. You can move in this matrix from a cell to any other cell in the next row. That is, if you are in cell (x, y) such that x < m - 1, you can move to any of the cells (x + 1, 0), (x + 1, 1), ..., (x + 1, n - 1). Note that it is not possible to move from cells in the last row.\nEach possible move has a cost given by a 0-indexed 2D array moveCost of size (m * n) x n, where moveCost[i][j] is the cost of moving from a cell with value i to a cell in column j of the next row. The cost of moving from cells in the last row of grid can be ignored.\nThe cost of a path in grid is the sum of all values of cells visited plus the sum of costs of all the moves made. Return the minimum cost of a path that starts from any cell in the first row and ends at any cell in the last row.", "canonical_solution": "def minPathCost(grid, moveCost):\n        max_row, max_col = len(grid), len(grid[0])\n        dp = [[-1] * max_col for _ in range(max_row)] \n\n        def recursion(row, col):\n            if row == max_row - 1:\n                return grid[row][col]\n            if dp[row][col] == -1:\n                current = grid[row][col] \n                res = float('inf')\n                for c in range(max_col):\n                    val = moveCost[current][c] + recursion(row + 1, c) \n                    res = min(res, val)\n                dp[row][col] = res + current \n            return dp[row][col]\n\n        for c in range(max_col):\n            recursion(0, c)\n        return min(dp[0])", "entry_point": "minPathCost", "test_list": ["assert minPathCost(grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]) == 17", "assert minPathCost(grid = [[5,1,2],[4,0,3]], moveCost = [[12,10,15],[20,23,8],[21,7,1],[8,1,13],[9,10,25],[5,3,2]]) == 6"]}
{"Contest id": "297/2303", "text_name": "Calculate Amount Paid in Taxes", "text": "You are given a 0-indexed 2D integer array brackets where brackets[i] = [upperi, percenti] means that the ith tax bracket has an upper bound of upperi and is taxed at a rate of percenti. The brackets are sorted by upper bound (i.e. upperi-1 < upperi for 0 < i < brackets.length).\nTax is calculated as follows:\nThe first upper0 dollars earned are taxed at a rate of percent0.\nThe next upper1 - upper0 dollars earned are taxed at a rate of percent1.\nThe next upper2 - upper1 dollars earned are taxed at a rate of percent2.\nAnd so on.\nYou are given an integer income representing the amount of money you earned. Return the amount of money that you have to pay in taxes. Answers within 10-5 of the actual answer will be accepted.\n ", "canonical_solution": "def calculateTax(brackets, income):\n        taxtot=0\n        if(brackets[0][0]<income):\n            taxtot+=brackets[0][0]*(brackets[0][1])\n            income-=brackets[0][0]\n        else:\n            taxtot+=income*(brackets[0][1])\n            return taxtot/100\n        i=1\n        while(income>0 and i<len(brackets)):\n            if(income>(brackets[i][0]-brackets[i-1][0])):\n                taxtot+=(brackets[i][0]-brackets[i-1][0])*brackets[i][1]\n                income-=brackets[i][0]-brackets[i-1][0]\n            else:\n                taxtot+=income*brackets[i][1]\n                income=0\n            i+=1\n        return taxtot/100", "entry_point": "calculateTax", "test_list": ["assert calculateTax(brackets = [[3,50],[7,10],[12,25]], income = 10) == 2.65000", "assert calculateTax(brackets = [[1,0],[4,25],[5,50]], income = 2) == 0.25000", "assert calculateTax(brackets = [[2,50]], income = 0) == 0.00000"]}
{"Contest id": "Bi80/2302", "text_name": "Count Subarrays With Score Less Than K", "text": "The score of an array is defined as the product of its sum and its length.\nFor example, the score of [1, 2, 3, 4, 5] is (1 + 2 + 3 + 4 + 5) * 5 = 75.\nGiven a positive integer array nums and an integer k, return the number of non-empty subarrays of nums whose score is strictly less than k.\nA subarray is a contiguous sequence of elements within an array.", "canonical_solution": "def countSubarrays(A, k):\n        res = cur = i = 0\n        for j in range(len(A)):\n            cur += A[j]\n            while cur * (j - i + 1) >= k:\n                cur -= A[i]\n                i += 1\n            res += j - i + 1\n        return res", "entry_point": "countSubarrays", "test_list": ["assert countSubarrays([2,1,4,3,5], 10) == 6", "assert countSubarrays([1,1,1], 5) == 5"]}
{"Contest id": "Bi80/2301", "text_name": "Match Substring After Replacement", "text": "You are given two strings s and sub. You are also given a 2D character array mappings where mappings[i] = [oldi, newi] indicates that you may perform the following operation any number of times:\nReplace a character oldi of sub with newi.\nEach character in sub cannot be replaced more than once.\nReturn true if it is possible to make sub a substring of s by replacing zero or more characters according to mappings. Otherwise, return false.\nA substring is a contiguous non-empty sequence of characters within a string.", "canonical_solution": "def matchReplacement(s, sub, mappings):\n        from collections import defaultdict\n        regexp = []\n        m = defaultdict(lambda: set())\n        for f, t in mappings:\n            m[f].add(t)\n        def search(i, j):\n            len_s = len(s)\n            len_sub = len(sub)\n            while j < len(sub):\n                lenlefts = len_s - i\n                lenleftsub = len_sub - j\n                if lenlefts < lenleftsub:\n                    return False\n                elif (s[i] == sub[j]) or (s[i] in m[sub[j]]):\n                    i+=1\n                    j+=1\n                    continue\n                else:\n                    return False\n            return True\n        for i in range(len(s)):\n            if search(i, 0):\n                return True\n        return False", "entry_point": "matchReplacement", "test_list": ["assert matchReplacement(s = \"fool3e7bar\", sub = \"leet\", mappings = [[\"e\",\"3\"],[\"t\",\"7\"],[\"t\",\"8\"]]) == True", "assert matchReplacement(s = \"fooleetbar\", sub = \"f00l\", mappings = [[\"o\",\"0\"]]) == False", "assert matchReplacement(s = \"Fool33tbaR\", sub = \"leetd\", mappings = [[\"e\",\"3\"],[\"t\",\"7\"],[\"t\",\"8\"],[\"d\",\"b\"],[\"p\",\"b\"]]) == True"]}
{"Contest id": "Bi80/2300", "text_name": "Successful Pairs of Spells and Potions", "text": "You are given two positive integer arrays spells and potions, of length n and m respectively, where spells[i] represents the strength of the ith spell and potions[j] represents the strength of the jth potion.\nYou are also given an integer success. A spell and potion pair is considered successful if the product of their strengths is at least success.\nReturn an integer array pairs of length n where pairs[i] is the number of potions that will form a successful pair with the ith spell.", "canonical_solution": "def successfulPairs(spells, potions, success):\n        n = len(spells)\n        m = len(potions)\n        pairs = [0] * n\n        potions.sort()\n        for i in range(n):\n            spell = spells[i]\n            left = 0\n            right = m - 1\n            while left <= right:\n                mid = left + (right - left) // 2\n                product = spell * potions[mid]\n                if product >= success:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            pairs[i] = m - left\n        return pairs", "entry_point": "successfulPairs", "test_list": ["assert successfulPairs(spells = [5,1,3], potions = [1,2,3,4,5], success = 7) == [4,0,3]", "assert successfulPairs(spells = [3,1,2], potions = [8,5,8], success = 16) == [2,0,2]"]}
{"Contest id": "Bi80/2299", "text_name": "Strong Password Checker II", "text": "A password is said to be strong if it satisfies all the following criteria:\nIt has at least 8 characters.\nIt contains at least one lowercase letter.\nIt contains at least one uppercase letter.\nIt contains at least one digit.\nIt contains at least one special character. The special characters are the characters in the following string: \"!@#$%^&*()-+\".\nIt does not contain 2 of the same character in adjacent positions (i.e., \"aab\" violates this condition, but \"aba\" does not).\nGiven a string password, return true if it is a strong password. Otherwise, return false.\n ", "canonical_solution": "def strongPasswordCheckerII(password):\n        if len(password) < 8:\n            return False\n        lowercase, uppercase, digit, special = False, False, False, False\n        special_char = \"!@#$%^&*()-+\"\n        for i in range(len(password)):\n            if i != len(password)-1 and password[i] == password[i+1]: \n                return False\n            if not lowercase: \n                lowercase = password[i].islower()\n            if not uppercase:\n                uppercase = password[i].isupper()\n            if not digit:\n                digit = password[i].isdigit()\n            if not special:\n                special = password[i] in special_char\n        return lowercase and uppercase and digit and special", "entry_point": "strongPasswordCheckerII", "test_list": ["assert strongPasswordCheckerII(password = \"IloveLe3tcode!\") == True", "assert strongPasswordCheckerII(password = \"Me+You--IsMyDream\") == False", "assert strongPasswordCheckerII(password = \"1aB!\") == False"]}
{"Contest id": "296/2295", "text_name": "Replace Elements in an Array", "text": "You are given a 0-indexed array nums that consists of n distinct positive integers. Apply m operations to this array, where in the ith operation you replace the number operations[i][0] with operations[i][1].\nIt is guaranteed that in the ith operation:\noperations[i][0] exists in nums.\noperations[i][1] does not exist in nums.\nReturn the array obtained after applying all the operations.", "canonical_solution": "def arrayChange(nums, operations):\n            replacements = {}\n            for x, y in reversed(operations):\n                replacements[x] = replacements.get(y, y)\n            for idx, val in enumerate(nums):\n                if val in replacements:\n                    nums[idx] = replacements[val]\n            return nums", "entry_point": "arrayChange", "test_list": ["assert arrayChange(nums = [1,2,4,6], operations = [[1,3],[4,7],[6,1]]) == [3,2,7,1]", "assert arrayChange(nums = [1,2], operations = [[1,3],[2,1],[3,2]]) == [2,1]"]}
{"Contest id": "296/2294", "text_name": "Partition Array Such That Maximum Difference Is K", "text": "You are given an integer array nums and an integer k. You may partition nums into one or more subsequences such that each element in nums appears in exactly one of the subsequences.\nReturn the minimum number of subsequences needed such that the difference between the maximum and minimum values in each subsequence is at most k.\nA subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.", "canonical_solution": "def partitionArray(A, k):\n        A.sort()\n        res = 1\n        mn = mx = A[0]\n        for a in A:\n            mn = min(mn, a)\n            mx = max(mx, a)\n            if mx - mn > k:\n                res += 1\n                mn = mx = a\n        return res", "entry_point": "partitionArray", "test_list": ["assert partitionArray([3,6,1,2,5], 2) == 2", "assert partitionArray([1,2,3], 1) == 2", "assert partitionArray([2,2,4,5], 0) == 3"]}
{"Contest id": "296/2293", "text_name": "Min Max Game", "text": "You are given a 0-indexed integer array nums whose length is a power of 2.\nApply the following algorithm on nums:\nLet n be the length of nums. If n == 1, end the process. Otherwise, create a new 0-indexed integer array newNums of length n / 2.\nFor every even index i where 0 <= i < n / 2, assign the value of newNums[i] as min(nums[2 * i], nums[2 * i + 1]).\nFor every odd index i where 0 <= i < n / 2, assign the value of newNums[i] as max(nums[2 * i], nums[2 * i + 1]).\nReplace the array nums with newNums.\nRepeat the entire process starting from step 1.\nReturn the last number that remains in nums after applying the algorithm.\n ", "canonical_solution": "def minMaxGame(nums):\n        l=nums\n        while len(l)>1:\n            is_min=True     \n            tmp=[]\n            for i in range(0, len(l), 2):\n                if is_min:\n                    tmp.append(min(l[i:i+2]))\n                else:\n                    tmp.append(max(l[i:i+2]))\n                is_min=not is_min            \n            l=tmp            \n        return l[0]", "entry_point": " minMaxGame", "test_list": ["assert  minMaxGame(nums = [1,3,5,2,4,8,2,2]) == 1", "assert  minMaxGame(nums = [3]) == 3"]}
{"Contest id": "295/2290", "text_name": "Minimum Obstacle Removal to Reach Corner", "text": "You are given a 0-indexed 2D integer array grid of size m x n. Each cell has one of two values:\n0 represents an empty cell,\n1 represents an obstacle that may be removed.\nYou can move up, down, left, or right from and to an empty cell.\nReturn the minimum number of obstacles to remove so you can move from the upper left corner (0, 0) to the lower right corner (m - 1, n - 1).", "canonical_solution": "def minimumObstacles(grid):\n        from collections import deque\n        R, C = len(grid), len(grid[0])\n        d = [(1,0),(-1,0),(0,1),(0,-1)]\n        distances = [[-1] * C for _ in range(R)]\n        q = deque([(0, 0, 0)])\n        while q:\n            for _ in range(len(q)):\n                dist, r, c = q.popleft()\n                \n                for dr, dc in d:\n                    rr, cc = r + dr, c + dc\n                    if 0 <= rr < R and 0 <= cc < C and distances[rr][cc] == -1:\n                        \n                        if grid[rr][cc] == 1:\n                            distances[rr][cc] = dist + 1\n                            q.append((dist + 1, rr, cc))\n                            \n                        else:\n                            distances[rr][cc] = dist\n                            q.appendleft((dist, rr, cc))\n                            \n        return distances[R - 1][C - 1]", "entry_point": "minimumObstacles", "test_list": ["assert minimumObstacles(grid = [[0,1,1],[1,1,0],[1,1,0]]) == 2", "assert minimumObstacles(grid = [[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]]) == 0"]}
{"Contest id": "295/2289", "text_name": "Steps to Make Array Non-decreasing", "text": "You are given a 0-indexed integer array nums. In one step, remove all elements nums[i] where nums[i - 1] > nums[i] for all 0 < i < nums.length.\nReturn the number of steps performed until nums becomes a non-decreasing array.", "canonical_solution": "def totalSteps(nums):\n        st = []\n        ans = 0\n        for i in nums:\n            t = 0\n            while st and st[-1][0] <= i:\n                t = max(t, st.pop()[1])\n            x = 0 \n            if st: \n                x = t+1 \n            st.append([i, x])\n            ans = max(ans, x)\n        return ans", "entry_point": "totalStep", "test_list": ["assert totalSteps([5,3,4,4,7,3,6,11,8,5,11]) == 3", "assert totalSteps([4,5,7,7,13]) == 0"]}
{"Contest id": "295/2288", "text_name": "Apply Discount to Prices", "text": "A sentence is a string of single-space separated words where each word can contain digits, lowercase letters, and the dollar sign '$'. A word represents a price if it is a sequence of digits preceded by a dollar sign.\nFor example, \"$100\", \"$23\", and \"$6\" represent prices while \"100\", \"$\", and \"$1e5\" do not.\nYou are given a string sentence representing a sentence and an integer discount. For each word representing a price, apply a discount of discount% on the price and update the word in the sentence. All updated prices should be represented with exactly two decimal places.\nReturn a string representing the modified sentence.\nNote that all prices will contain at most 10 digits.", "canonical_solution": "def discountPrices(sentence, discount):\n        s = sentence.split()\n        m = discount / 100 \n        for i,word in enumerate(s):\n            if word[0] == \"$\" and word[1:].isdigit():\n                num = int(word[1:]) * (1-m)\n                w = \"$\" + \"{:.2f}\".format(num)\n                s[i] = w\n        \n        return \" \".join(s)", "entry_point": "discountPrices", "test_list": ["assert discountPrices(sentence = \"there are $1 $2 and 5$ candies in the shop\", discount = 50) == \"there are $0.50 $1.00 and 5$ candies in the shop\"", "assert discountPrices(sentence = \"1 2 $3 4 $5 $6 7 8$ $9 $10$\", discount = 100) == \"1 2 $0.00 4 $0.00 $0.00 7 8$ $0.00 $10$\""]}
{"Contest id": "295/2287", "text_name": "Rearrange Characters to Make Target String", "text": "You are given two 0-indexed strings s and target. You can take some letters from s and rearrange them to form new strings.\nReturn the maximum number of copies of target that can be formed by taking letters from s and rearranging them.", "canonical_solution": "def rearrangeCharacters(s, target):\n        from collections import Counter\n        counter_s = Counter(s)        \n        return min(counter_s[c] // count for c,count in Counter(target).items())", "entry_point": "rearrangeCharacters", "test_list": [""]}
{"Contest id": "Bi79/2285", "text_name": "Maximum Total Importance of Roads", "text": "You are given an integer n denoting the number of cities in a country. The cities are numbered from 0 to n - 1.\nYou are also given a 2D integer array roads where roads[i] = [ai, bi] denotes that there exists a bidirectional road connecting cities ai and bi.\nYou need to assign each city with an integer value from 1 to n, where each value can only be used once. The importance of a road is then defined as the sum of the values of the two cities it connects.\nReturn the maximum total importance of all roads possible after assigning the values optimally.", "canonical_solution": "def maximumImportance(n, roads):\n        Arr = [0] * n \n        for A,B in roads:\n            Arr[A] += 1\n            Arr[B] += 1\n        Arr.sort()\n        summ = 0\n        for i in range(len(Arr)):\n            summ += Arr[i] * (i+1)\n        \n        return summ", "entry_point": "maximumImportance", "test_list": ["assert maximumImportance(n = 5, roads = [[0,1],[1,2],[2,3],[0,2],[1,3],[2,4]]) == 43", "assert maximumImportance(n = 5, roads = [[0,3],[2,4],[1,3]]) == 20"]}
{"Contest id": "Bi79/2284", "text_name": "Sender With Largest Word Count", "text": "You have a chat log of n messages. You are given two string arrays messages and senders where messages[i] is a message sent by senders[i].\nA message is list of words that are separated by a single space with no leading or trailing spaces. The word count of a sender is the total number of words sent by the sender. Note that a sender may send more than one message.\nReturn the sender with the largest word count. If there is more than one sender with the largest word count, return the one with the lexicographically largest name.\nNote:\nUppercase letters come before lowercase letters in lexicographical order.\n\"Alice\" and \"alice\" are distinct.", "canonical_solution": "def largestWordCount(messages, senders):\n        d={}\n        l=[]\n        for i in range(len(messages)):\n            if senders[i] not in d:\n                d[senders[i]]=len(messages[i].split())\n            else:\n                d[senders[i]]+=len(messages[i].split())\n        x=max(d.values())\n        for k,v in d.items():\n            if v==x :\n                l.append(k)\n        if len(l)==1:\n            return l[0]\n        else:\n            l=sorted(l)[::-1] \n            return l[0]", "entry_point": "largestWordCount", "test_list": ["assert largestWordCount(messages = [\"Hello userTwooo\",\"Hi userThree\",\"Wonderful day Alice\",\"Nice day userThree\"], senders = [\"Alice\",\"userTwo\",\"userThree\",\"Alice\"]) == \"Alice\"", "assert largestWordCount(messages = [\"How is leetcode for everyone\",\"Leetcode is useful for practice\"], senders = [\"Bob\",\"Charlie\"]) == \"Charlie\""]}
{"Contest id": "Bi79/2283", "text_name": "Check if Number Has Equal Digit Count and Digit Value", "text": "You are given a 0-indexed string num of length n consisting of digits.\nReturn true if for every index i in the range 0 <= i < n, the digit i occurs num[i] times in num, otherwise return false.", "canonical_solution": "def digitCount(num):\n        from collections import Counter\n        d = Counter(num)\n        for i in range(len(num)):\n            if int(num[i])!=d.get(str(i), 0):\n                return False\n        return True", "entry_point": "digitCount", "test_list": ["assert digitCount(num = \"1210\") == True", "assert digitCount(num = \"030\") == False"]}
{"Contest id": "294/2281", "text_name": "Sum of Total Strength of Wizards", "text": "As the ruler of a kingdom, you have an army of wizards at your command.\nYou are given a 0-indexed integer array strength, where strength[i] denotes the strength of the ith wizard. For a contiguous group of wizards (i.e. the wizards' strengths form a subarray of strength), the total strength is defined as the product of the following two values:\nThe strength of the weakest wizard in the group.\nThe total of all the individual strengths of the wizards in the group.\nReturn the sum of the total strengths of all contiguous groups of wizards. Since the answer may be very large, return it modulo 109 + 7.\nA subarray is a contiguous non-empty sequence of elements within an array.", "canonical_solution": "def totalStrength(A):\n        res, ac, mod, stack, acc = 0, 0, 10 ** 9 + 7, [-1], [0]\n        A += [0]\n        for r, a in enumerate(A):\n            ac += a\n            acc.append(ac + acc[-1])\n            while stack and A[stack[-1]] > a:\n                i = stack.pop()\n                l = stack[-1]\n                lacc = acc[i] - acc[max(l, 0)]\n                racc = acc[r] - acc[i]\n                ln, rn = i - l, r - i\n                res += A[i] * (racc * ln - lacc * rn) % mod\n            stack.append(r)\n        return res % mod", "entry_point": "totalStrength", "test_list": ["assert totalStrength([1,3,1,2]) == 44", "assert totalStrength([5,4,6]) == 213"]}
{"Contest id": "294/2280", "text_name": "Minimum Lines to Represent a Line Chart", "text": "You are given a 2D integer array stockPrices where stockPrices[i] = [dayi, pricei] indicates the price of the stock on day dayi is pricei. A line chart is created from the array by plotting the points on an XY plane with the X-axis representing the day and the Y-axis representing the price and connecting adjacent points. One such example is shown below:", "canonical_solution": "def minimumLines(A):\n        n = len(A)\n        res = n - 1\n        A.sort()\n        for i in range(1, n - 1):\n            a, b, c = A[i-1], A[i], A[i+1]\n            if (b[0] - a[0]) * (c[1] - b[1]) == (c[0] - b[0]) * (b[1] - a[1]):\n                res -= 1\n        return res", "entry_point": "minimumLines", "test_list": ["assert minimumLines([[1,7],[2,6],[3,5],[4,4],[5,4],[6,3],[7,2],[8,1]]) == 3", "assert minimumLines([[3,4],[1,2],[7,8],[2,3]]) == 1"]}
{"Contest id": "294/2279", "text_name": "Maximum Bags With Full Capacity of Rocks", "text": "You have n bags numbered from 0 to n - 1. You are given two 0-indexed integer arrays capacity and rocks. The ith bag can hold a maximum of capacity[i] rocks and currently contains rocks[i] rocks. You are also given an integer additionalRocks, the number of additional rocks you can place in any of the bags.\nReturn the maximum number of bags that could have full capacity after placing the additional rocks in some bags.", "canonical_solution": "def maximumBags(capacity, rocks, x):\n        count = sorted(c - r for c,r in zip(capacity, rocks))[::-1]\n        while count and x and count[-1] <= x:\n            x -= count.pop()\n        return len(rocks) - len(count)", "entry_point": "maximumBags", "test_list": ["assert maximumBags([2,3,4,5], [1,2,4,4], 2) == 3", "assert maximumBags([10,2,2], [2,2,0], 100) == 3"]}
{"Contest id": "294/2278", "text_name": "Percentage of Letter in String", "text": "Given a string s and a character letter, return the percentage of characters in s that equal letter rounded down to the nearest whole percent.", "canonical_solution": "def percentageLetter(s, letter):\n        return (s.count(letter)*100)//len(s)", "entry_point": "percentageLetter", "test_list": ["assert percentageLetter(s = \"foobar\", letter = \"o\") == 33", "assert percentageLetter(s = \"jjjj\", letter = \"k\") == 0"]}
{"Contest id": "293/2275", "text_name": "Largest Combination With Bitwise AND Greater Than Zero", "text": "The bitwise AND of an array nums is the bitwise AND of all integers in nums.\nFor example, for nums = [1, 5, 3], the bitwise AND is equal to 1 & 5 & 3 = 1.\nAlso, for nums = [7], the bitwise AND is 7.\nYou are given an array of positive integers candidates. Evaluate the bitwise AND of every combination of numbers of candidates. Each number in candidates may only be used once in each combination.\nReturn the size of the largest combination of candidates with a bitwise AND greater than 0.", "canonical_solution": "def largestCombination(A):\n        return max(sum(1 << i & a > 0 for a in A) for i in range(30))", "entry_point": "largestCombination", "test_list": ["assert largestCombination([16,17,71,62,12,24,14]) == 4", "assert largestCombination([8,8]) == 2"]}
{"Contest id": "293/2274", "text_name": "Maximum Consecutive Floors Without Special Floors", "text": "Alice manages a company and has rented some floors of a building as office space. Alice has decided some of these floors should be special floors, used for relaxation only.\nYou are given two integers bottom and top, which denote that Alice has rented all the floors from bottom to top (inclusive). You are also given the integer array special, where special[i] denotes a special floor that Alice has designated for relaxation.\nReturn the maximum number of consecutive floors without a special floor.", "canonical_solution": "def maxConsecutive(bottom, top, A):\n        A.sort()\n        res = max(top - A[-1], A[0] - bottom)\n        for i in range(1, len(A)):\n            res = max(res, A[i] - A[i - 1] - 1)\n        return res", "entry_point": "maxConsecutive", "test_list": ["assert maxConsecutive(2, 9, [4,6]) == 3", "assert maxConsecutive(6, 8,  [7,6,8]) == 0"]}
{"Contest id": "293/2273", "text_name": "Find Resultant Array After Removing Anagrams", "text": "You are given a 0-indexed string array words, where words[i] consists of lowercase English letters.\nIn one operation, select any index i such that 0 < i < words.length and words[i - 1] and words[i] are anagrams, and delete words[i] from words. Keep performing this operation as long as you can select an index that satisfies the conditions.\nReturn words after performing all operations. It can be shown that selecting the indices for each operation in any arbitrary order will lead to the same result.\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase using all the original letters exactly once. For example, \"dacb\" is an anagram of \"abdc\".", "canonical_solution": "def removeAnagrams(words):\n        def get_counts(x):\n            count = [0] * 26 \n            for c in x:\n                count[ord(c) - ord('a')] += 1\n            return count\n        \n        \n        if not words:\n            return []\n        \n        \n        i = 0\n        while i < len(words) - 1:\n            if get_counts(words[i]) == get_counts(words[i + 1]):\n                words.remove(words[i + 1])\n                continue\n            i += 1\n        return words", "entry_point": "removeAnagrams", "test_list": ["assert removeAnagrams(words = [\"abba\",\"baba\",\"bbaa\",\"cd\",\"cd\"]) == [\"abba\",\"cd\"]", "assert removeAnagrams(words = [\"a\",\"b\",\"c\",\"d\",\"e\"]) == [\"a\",\"b\",\"c\",\"d\",\"e\"]"]}
{"Contest id": "Bi78/2272", "text_name": " Substring With Largest Variance", "text": "The variance of a string is defined as the largest difference between the number of occurrences of any 2 characters present in the string. Note the two characters may or may not be the same.\nGiven a string s consisting of lowercase English letters only, return the largest variance possible among all substrings of s.\nA substring is a contiguous sequence of characters within a string.\n ", "canonical_solution": "def largestVariance(s):\n        counter=[0]*26\n        for ch in s:\n            counter[ord(ch)-ord('a')]+=1\n        global_max=0\n        for i in range(26):\n            for j in range(26):\n                if i==j or counter[i]==0 or counter[j]==0:\n                    continue\n                \n                major= chr(ord('a')+i)\n                minor= chr(ord('a')+j)\n                majorCount=0\n                minorCount=0\n\n                restMinor= counter[j]\n\n                for ch in s:\n                    if ch==major:\n                        majorCount+=1\n\n                    if ch==minor:\n                        minorCount+=1\n                        restMinor-=1\n\n                    if minorCount>0:\n                        global_max=max(global_max, majorCount-minorCount)\n                    \n                    if majorCount<minorCount and restMinor>0:\n                        majorCount=0\n                        minorCount=0\n\n        return global_max", "entry_point": "largestVariance", "test_list": ["assert largestVariance(s = \"aababbb\") == 3", "assert largestVariance(s = \"abcde\") == 0"]}
{"Contest id": "Bi78/2271", "text_name": "Maximum White Tiles Covered by a Carpet", "text": "You are given a 2D integer array tiles where tiles[i] = [li, ri] represents that every tile j in the range li <= j <= ri is colored white.\nYou are also given an integer carpetLen, the length of a single carpet that can be placed anywhere.\nReturn the maximum number of white tiles that can be covered by the carpet.", "canonical_solution": "def maximumWhiteTiles(tiles, carpetLen):\n        tiles.sort()\n        j = cover = res = 0\n        for i in range(len(tiles)):\n            while j<len(tiles) and tiles[j][1]-tiles[i][0] + 1 <= carpetLen:\n                cover += tiles[j][1]-tiles[j][0] + 1\n                j += 1\n            if j<len(tiles) and tiles[j][0]-tiles[i][0] + 1 <= carpetLen:\n                res = max(res, cover + carpetLen-(tiles[j][0]-tiles[i][0]))\n            else:\n                res = max(res, cover)\n            if i!=j:\n                cover -= tiles[i][1]-tiles[i][0]+1\n            j = max(j, i+1)\n        return res", "entry_point": "maximumWhiteTiles", "test_list": ["assert maximumWhiteTiles(tiles = [[1,5],[10,11],[12,18],[20,25],[30,32]], carpetLen = 10) == 9", "assert maximumWhiteTiles(tiles = [[10,11],[1,1]], carpetLen = 2) == 2"]}
{"Contest id": "Bi78/2270", "text_name": "Number of Ways to Split Array", "text": "You are given a 0-indexed integer array nums of length n.\nnums contains a valid split at index i if the following are true:\nThe sum of the first i + 1 elements is greater than or equal to the sum of the last n - i - 1 elements.\nThere is at least one element to the right of i. That is, 0 <= i < n - 1.\nReturn the number of valid splits in nums.", "canonical_solution": "def waysToSplitArray(nums):\n        count = 0\n        left_sum, right_sum = 0, sum(nums)\n        for i in range(len(nums) - 1):\n            left_sum += nums[i]\n            right_sum -= nums[i]\n            if left_sum >= right_sum:\n                count += 1\n        return count", "entry_point": "waysToSplitArray", "test_list": ["assert waysToSplitArray(nums = [10,4,-8,7]) == 2", "assert waysToSplitArray(nums = [2,3,1,0]) == 2"]}
{"Contest id": "Bi78/2269", "text_name": "Find the K-Beauty of a Number", "text": "The k-beauty of an integer num is defined as the number of substrings of num when it is read as a string that meet the following conditions:\nIt has a length of k.\nIt is a divisor of num.\nGiven integers num and k, return the k-beauty of num.\nNote:\nLeading zeros are allowed.\n0 is not a divisor of any value.\nA substring is a contiguous sequence of characters in a string.", "canonical_solution": "def divisorSubstrings(num, k):\n    l = 0\n    r = k\n\n    num = str(num)\n    count = 0\n    while r <= len(num):            \n        n = int(num[l: r])\n\n        if not n:\n            l += 1\n            r += 1\n            continue\n\n        if int(num) % n == 0:\n            count += 1   \n            \n        l += 1\n        r += 1\n\n    return count", "entry_point": "divisorSubstrings", "test_list": ["assert divisorSubstrings(num = 240, k = 2) == 2", "assert divisorSubstrings(num = 430043, k = 2) == 2"]}
{"Contest id": "292/2267", "text_name": "Check if There Is a Valid Parentheses String Path", "text": "A parentheses string is a non-empty string consisting only of '(' and ')'. It is valid if any of the following conditions is true:\nIt is ().\nIt can be written as AB (A concatenated with B), where A and B are valid parentheses strings.\nIt can be written as (A), where A is a valid parentheses string.\nYou are given an m x n matrix of parentheses grid. A valid parentheses string path in the grid is a path satisfying all of the following conditions:\nThe path starts from the upper left cell (0, 0).\nThe path ends at the bottom-right cell (m - 1, n - 1).\nThe path only ever moves down or right.\nThe resulting parentheses string formed by the path is valid.\nReturn true if there exists a valid parentheses string path in the grid. Otherwise, return false.", "canonical_solution": "def hasValidPath(A):\n        m, n = len(A), len(A[0])\n        dp = defaultdict(set)\n        dp[0, -1] = dp[-1, 0] = {0}\n        for i in range(m):\n            for j in range(n):\n                d = 1 if A[i][j] == '(' else -1\n                dp[i,j] |= {a + d for a in dp[i-1,j] | dp[i,j-1] if a + d >= 0}\n        return 0 in dp[m - 1, n - 1]", "entry_point": "hasValidPath", "test_list": ["assert hasValidPath([[\"(\",\"(\",\"(\"],[\")\",\"(\",\")\"],[\"(\",\"(\",\")\"],[\"(\",\"(\",\")\"]]) == True", "assert hasValidPath([[\")\",\")\"],[\"(\",\"(\"]]) == False"]}
{"Contest id": "292/2266", "text_name": "Count Number of Texts", "text": "Alice is texting Bob using her phone. The mapping of digits to letters is shown in the figure below.\nIn order to add a letter, Alice has to press the key of the corresponding digit i times, where i is the position of the letter in the key.\nFor example, to add the letter 's', Alice has to press '7' four times. Similarly, to add the letter 'k', Alice has to press '5' twice.\nNote that the digits '0' and '1' do not map to any letters, so Alice does not use them.\nHowever, due to an error in transmission, Bob did not receive Alice's text message but received a string of pressed keys instead.\nFor example, when Alice sent the message \"bob\", Bob received the string \"2266622\".\nGiven a string pressedKeys representing the string received by Bob, return the total number of possible text messages Alice could have sent.\nSince the answer may be very large, return it modulo 109 + 7.", "canonical_solution": "def countTexts(pressedKeys):\n        dp = [1] + [0]*len(pressedKeys)\n        mod = 10**9 + 7\n        for i, n in enumerate(pressedKeys):\n            dp[i+1] = dp[i]\n            if i >= 1 and pressedKeys[i-1] == n:\n                dp[i+1] += dp[i-1]\n                dp[i+1] %= mod\n                if i >= 2 and pressedKeys[i-2] == n:\n                    dp[i+1] += dp[i-2]\n                    dp[i+1] %= mod\n                    if i >= 3 and pressedKeys[i-3] == n and (n == \"7\" or n == \"9\"):\n                        dp[i+1] += dp[i-3]\n                        dp[i+1] %= mod\n        return dp[-1]", "entry_point": "countTexts", "test_list": ["assert countTexts(pressedKeys = \"22233\") == 8", "assert countTexts(pressedKeys = \"222222222222222222222222222222222222\") == 82876089"]}
{"Contest id": "292/2264", "text_name": "Largest 3-Same-Digit Number in String", "text": "You are given a string num representing a large integer. An integer is good if it meets the following conditions:\nIt is a substring of num with length 3.\nIt consists of only one unique digit.\nReturn the maximum good integer as a string or an empty string \"\" if no such integer exists.\nNote:\nA substring is a contiguous sequence of characters within a string.\nThere may be leading zeroes in num or a good integer.", "canonical_solution": "def largestGoodInteger(num):\n        result = -1\n        for i in range(len(num) - 2):\n            if num[i] == num[i + 1] == num[i + 2]:\n                result = max(result, int(num[i]))\n        return \"\" if result == -1 else str(result) * 3", "entry_point": "largestGoodInteger", "test_list": ["assert largestGoodInteger(num = \"6777133339\") == \"777\"", "assert largestGoodInteger(num = \"2300019\") == \"000\"", "assert largestGoodInteger(num = \"42352338\") == \"\""]}
{"Contest id": "291/2262", "text_name": "Total Appeal of A String", "text": "The appeal of a string is the number of distinct characters found in the string.\nFor example, the appeal of \"abbca\" is 3 because it has 3 distinct characters: 'a', 'b', and 'c'.\nGiven a string s, return the total appeal of all of its substrings.\nA substring is a contiguous sequence of characters within a string.", "canonical_solution": "def appealSum(s):\n        last = {}\n        res = 0\n        for i,c in enumerate(s):\n            last[c] = i + 1\n            res += sum(last.values())\n        return res", "entry_point": "appealSum", "test_list": ["assert appealSum(s = \"abbca\") == 28", "assert appealSum(s = \"code\") == 20"]}
{"Contest id": "291/2261", "text_name": "K Divisible Elements Subarrays", "text": "Given an integer array nums and two integers k and p, return the number of distinct subarrays, which have at most k elements that are divisible by p.\nTwo arrays nums1 and nums2 are said to be distinct if:\nThey are of different lengths, or\nThere exists at least one index i where nums1[i] != nums2[i].\nA subarray is defined as a non-empty contiguous sequence of elements in an array.", "canonical_solution": "def countDistinct(nums, k, p):\n        n = len(nums)                        \n        sub_arrays = set()\n\n        for start in range(n):\n            cnt = 0\n            temp = ''\n            for i in range(start, n):\n                if nums[i]%p == 0:\n                    cnt+=1                 \n                temp+=str(nums[i]) + ','          \n                if cnt>k:\n                    break\n                sub_arrays.add(temp)                                    \n                \n        return len(sub_arrays)", "entry_point": "countDistinct", "test_list": ["assert countDistinct(nums = [2,3,3,2,2], k = 2, p = 2) == 11", "assert countDistinct(nums = [1,2,3,4], k = 4, p = 1) == 10"]}
{"Contest id": "291/2260", "text_name": "Minimum Consecutive Cards to Pick Up", "text": "You are given an integer array cards where cards[i] represents the value of the ith card. A pair of cards are matching if the cards have the same value.\nReturn the minimum number of consecutive cards you have to pick up to have a pair of matching cards among the picked cards. If it is impossible to have matching cards, return -1.", "canonical_solution": "def minimumCardPickup(cards):\n        ans = math.inf\n        n = len(cards)\n        pos = defaultdict(lambda: -1)\n        for i in range(n):\n            if pos[cards[i]] != -1:\n                ans = min(i - pos[cards[i]] + 1, ans)\n            pos[cards[i]] = i\n        return ans if ans != math.inf else -1", "entry_point": "minimumCardPickup", "test_list": ["assert minimumCardPickup(cards = [3,4,2,3,4,7]) == 4", "assert minimumCardPickup(cards = [1,0,5,3]) == -1"]}
{"Contest id": "291/2259", "text_name": "Remove Digit From Number to Maximize Result", "text": "You are given a string number representing a positive integer and a character digit.\nReturn the resulting string after removing exactly one occurrence of digit from number such that the value of the resulting string in decimal form is maximized. The test cases are generated such that digit occurs at least once in number.", "canonical_solution": "def removeDigit(number, digit):\n        \n        last_index = 0\n\n        for num in range(1, len(number)):\n\n            if number[num-1] == digit:\n                if int(number[num]) > int(number[num-1]):\n                    return number[:num-1] + number[num:]\n                else:\n                    last_index = num - 1\n\n        if number[-1] == digit:\n            last_index = len(number) - 1\n\n        return number[:last_index] + number[last_index + 1:]", "entry_point": "removeDigit", "test_list": ["assert removeDigit(number = \"123\", digit = \"3\") == \"12\"", "assert removeDigit(number = \"1231\", digit = \"1\") == \"231\"", "assert removeDigit(number = \"551\", digit = \"5\") == \"51\""]}
{"Contest id": "Bi77/2258", "text_name": "Escape the Spreading Fire", "text": "You are given a 0-indexed 2D integer array grid of size m x n which represents a field. Each cell has one of three values:\n0 represents grass,\n1 represents fire,\n2 represents a wall that you and fire cannot pass through.\nYou are situated in the top-left cell, (0, 0), and you want to travel to the safehouse at the bottom-right cell, (m - 1, n - 1). Every minute, you may move to an adjacent grass cell. After your move, every fire cell will spread to all adjacent cells that are not walls.\nReturn the maximum number of minutes that you can stay in your initial position before moving while still safely reaching the safehouse. If this is impossible, return -1. If you can always reach the safehouse regardless of the minutes stayed, return 109.\nNote that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.\nA cell is adjacent to another cell if the former is directly north, east, south, or west of the latter (i.e., their sides are touching).", "canonical_solution": "def maximumMinutes(grid):\n        from collections import deque\n        m, n = len(grid), len(grid[0])\n        fire = [[float('inf') for _ in range(n)] for _ in range(m)]\n        def bfsFire():\n            q = deque()\n            for i in range(m):\n                for j in range(n):\n                    if grid[i][j] == 1:\n                        q.append((i, j))\n            dist = 0\n            while q:\n                size = len(q)\n                for _ in range(size):\n                    i, j = q.popleft()\n                    if fire[i][j] != float('inf'):\n                        continue\n                    fire[i][j] = dist\n                    if i < m - 1 and grid[i + 1][j] == 0 and fire[i + 1][j] == float('inf'): q.append((i + 1, j))\n                    if i > 0 and grid[i - 1][j] == 0 and fire[i - 1][j] == float('inf'): q.append((i - 1, j))\n                    if j < n - 1 and grid[i][j + 1] == 0 and fire[i][j + 1] == float('inf'): q.append((i, j + 1))\n                    if j > 0 and grid[i][j - 1] == 0 and fire[i][j - 1] == float('inf'): q.append((i, j - 1))\n                dist += 1\n        def bfsCanReach(time):\n            q = deque()\n            q.append((0, 0))\n            curGrid = [[grid[i][j] for j in range(n)] for i in range(m)]\n            while q:\n                size = len(q)\n                for _ in range(size):\n                    i, j = q.popleft()\n                    if i == m - 1 and j == n - 1 and time <= fire[i][j]:\n                        return True\n                    if fire[i][j] <= time or curGrid[i][j] == \"#\":\n                        continue\n                    curGrid[i][j] = \"#\"\n                    if i < m - 1 and curGrid[i + 1][j] == 0: q.append((i + 1, j))\n                    if i > 0 and curGrid[i - 1][j] == 0: q.append((i - 1, j))\n                    if j < n - 1 and curGrid[i][j + 1] == 0: q.append((i, j + 1))\n                    if j > 0 and curGrid[i][j - 1] == 0: q.append((i, j - 1))\n                time += 1\n            return False\n        bfsFire()\n        canReachHouse = bfsCanReach(0)\n        if not canReachHouse:\n            return -1\n        if canReachHouse and fire[m - 1][n - 1] == float('inf'):\n            return 10 ** 9\n        left, right = 0, 10 ** 9\n        while left < right:\n            mid = (left + right + 1) // 2\n            if bfsCanReach(mid):\n                left = mid\n            else:\n                right = mid - 1\n        return left", "entry_point": "maximumMinutes", "test_list": ["assert maximumMinutes(grid = [[0,2,0,0,0,0,0],[0,0,0,2,2,1,0],[0,2,0,0,1,2,0],[0,0,2,2,2,0,2],[0,0,0,0,0,0,0]]) == 3", "assert maximumMinutes(grid  = [[0,0,0,0],[0,1,2,0],[0,2,0,0]]) == -1", "assert maximumMinutes(grid  = [[0,0,0],[2,2,0],[1,2,0]]) == 1000000000"]}
{"Contest id": "Bi77/2257", "text_name": "Count Unguarded Cells in the Grid", "text": "You are given two integers m and n representing a 0-indexed m x n grid. You are also given two 2D integer arrays guards and walls where guards[i] = [rowi, coli] and walls[j] = [rowj, colj] represent the positions of the ith guard and jth wall respectively.\nA guard can see every cell in the four cardinal directions (north, east, south, or west) starting from their position unless obstructed by a wall or another guard. A cell is guarded if there is at least one guard that can see it.\nReturn the number of unoccupied cells that are not guarded.", "canonical_solution": "def countUnguarded(m, n, guards, walls):\n        dp = [[0] * n for _ in range(m)]\n        for x, y in guards+walls:\n            dp[x][y] = 1\n               \n        directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n        \n        for x, y in guards:\n            for dx, dy in directions:\n                curr_x = x\n                curr_y = y\n                \n                while 0 <= curr_x+dx < m and 0 <= curr_y+dy < n and dp[curr_x+dx][curr_y+dy] != 1:\n                    curr_x += dx\n                    curr_y += dy\n                    dp[curr_x][curr_y] = 2\n                    \n        return sum(1 for i in range(m) for j in range(n) if dp[i][j] == 0)                    ", "entry_point": "countUnguarded", "test_list": ["assert countUnguarded(m = 4, n = 6, guards = [[0,0],[1,1],[2,3]], walls = [[0,1],[2,2],[1,4]]) == 7", "assert countUnguarded(m = 3, n = 3, guards = [[1,1]], walls = [[0,1],[1,0],[2,1],[1,2]]) == 4"]}
{"Contest id": "Bi77/2256", "text_name": "Minimum Average Difference", "text": "You are given a 0-indexed integer array nums of length n.\nThe average difference of the index i is the absolute difference between the average of the first i + 1 elements of nums and the average of the last n - i - 1 elements. Both averages should be rounded down to the nearest integer.\nReturn the index with the minimum average difference. If there are multiple such indices, return the smallest one.\nNote:\nThe absolute difference of two numbers is the absolute value of their difference.\nThe average of n elements is the sum of the n elements divided (integer division) by n.\nThe average of 0 elements is considered to be 0.", "canonical_solution": "def minimumAverageDifference(nums):\n    from collections import deque\n    import sys\n    n = len(nums)\n    if n == 1:\n        return 0\n\n    queue = deque(nums[1: ])\n\n    left_sum = sum(nums[0: 1])\n    right_sum = sum(queue)\n\n    left_length = 1\n    right_length = n - 1\n\n    i = 0\n\n    min_avg = sys.maxsize\n    min_avg_idx = None\n\n    while i < n:\n        left_avg = left_sum // left_length\n        if right_length:\n            right_avg = right_sum // right_length\n        else:\n            right_avg = 0\n\n        diff = abs(left_avg - right_avg)\n        if diff < min_avg:\n            min_avg = diff\n            min_avg_idx = i\n\n        if not queue:\n            break\n        element = queue.popleft()\n\n        left_sum = left_sum + element\n        right_sum = right_sum - element\n\n        left_length += 1\n        right_length -= 1\n\n        i += 1\n\n    return min_avg_idx", "entry_point": "minimumAverageDifference", "test_list": ["assert minimumAverageDifference(nums = [2,5,3,9,5,3]) == 3", "assert minimumAverageDifference(nums = [0]) == 0"]}
{"Contest id": "Bi77/2255", "text_name": "Count Prefixes of a Given String", "text": "You are given a string array words and a string s, where words[i] and s comprise only of lowercase English letters.\nReturn the number of strings in words that are a prefix of s.\nA prefix of a string is a substring that occurs at the beginning of the string. A substring is a contiguous sequence of characters within a string.", "canonical_solution": "def countPrefixes(words, s):\n        return sum(map(s.startswith, words))", "entry_point": "countPrefixes", "test_list": ["assert countPrefixes(words = [\"a\",\"b\",\"c\",\"ab\",\"bc\",\"abc\"], s = \"abc\") == 3", "assert countPrefixes(words = [\"a\",\"a\"], s = \"aa\") == 2"]}
{"Contest id": "290/2251", "text_name": "Number of Flowers in Full Bloom", "text": "You are given a 0-indexed 2D integer array flowers, where flowers[i] = [starti, endi] means the ith flower will be in full bloom from starti to endi (inclusive). You are also given a 0-indexed integer array people of size n, where people[i] is the time that the ith person will arrive to see the flowers.\nReturn an integer array answer of size n, where answer[i] is the number of flowers that are in full bloom when the ith person arrives", "canonical_solution": "def fullBloomFlowers(flowers, people):\n        sorted_arrival_times = sorted(people)\n        flowers.sort()\n        \n        bloom_counts = {}\n        bloom_end_times = [] \n\n        flower_idx = 0\n        for person_time in sorted_arrival_times:\n            while flower_idx < len(flowers) and flowers[flower_idx][0] <= person_time:\n                heapq.heappush(bloom_end_times, flowers[flower_idx][1])\n                flower_idx += 1\n\n            while bloom_end_times and bloom_end_times[0] < person_time:\n                heapq.heappop(bloom_end_times)\n\n            bloom_counts[person_time] = len(bloom_end_times)\n\n        flower_counts = [bloom_counts[arrival_time] for arrival_time in people]\n\n        return flower_counts", "entry_point": "fullBloomFlowers", "test_list": ["assert fullBloomFlowers(flowers = [[1,6],[3,7],[9,12],[4,13]], people = [2,3,7,11]) == [1,2,2,2]", "assert fullBloomFlowers(flowers = [[1,10],[3,3]], people = [3,3,2]) == [2,2,1]"]}
{"Contest id": "290/2250", "text_name": "Count Number of Rectangles Containing Each Point", "text": "You are given a 2D integer array rectangles where rectangles[i] = [li, hi] indicates that ith rectangle has a length of li and a height of hi. You are also given a 2D integer array points where points[j] = [xj, yj] is a point with coordinates (xj, yj).\nThe ith rectangle has its bottom-left corner point at the coordinates (0, 0) and its top-right corner point at (li, hi).\nReturn an integer array count of length points.length where count[j] is the number of rectangles that contain the jth point.\nThe ith rectangle contains the jth point if 0 <= xj <= li and 0 <= yj <= hi. Note that points that lie on the edges of a rectangle are also considered to be contained by that rectangle.", "canonical_solution": "def countRectangles(rectangles, points):\n        import bisect\n        maxH = 101 \n        hToL = [[] for _ in range(maxH)]\n        \n        for l, h in rectangles:\n            hToL[h].append(l)\n            \n        for h in range(1, maxH):\n            hToL[h].sort()\n        \n        res = []\n        for px, py in points:\n            count = 0\n            for h in range(py, maxH):\n                if len(hToL[h]) == 0:\n                    continue\n                idx = bisect.bisect_left(hToL[h], px) \n                count += len(hToL[h]) - idx\n            res.append(count)\n        return res", "entry_point": "countRectangles", "test_list": ["assert countRectangles(rectangles = [[1,2],[2,3],[2,5]], points = [[2,1],[1,4]]) == [2,1]", "assert countRectangles(rectangles = [[1,1],[2,2],[3,3]], points = [[1,3],[1,1]]) == [1,3]"]}
{"Contest id": "290/2249", "text_name": "Count Lattice Points Inside a Circle", "text": "Given a 2D integer array circles where circles[i] = [xi, yi, ri] represents the center (xi, yi) and radius ri of the ith circle drawn on a grid, return the number of lattice points that are present inside at least one circle.\nNote:\nA lattice point is a point with integer coordinates.\nPoints that lie on the circumference of a circle are also considered to be inside it.", "canonical_solution": "def countLatticePoints(circles):\n        intervals = [[] for _ in range(201)]\n        for x, y, r in circles:\n            for i in range(-r, r + 1):\n                d = math.floor(math.sqrt(r**2 - i**2))\n                intervals[x + i].append([y - d, 0])\n                intervals[x + i].append([y + d, 1])\n        res = 0\n\n        for l in intervals:\n            if l:\n                l.sort()\n                count = 0\n                for i, ind in l:\n                    if count == 0:\n                        s = i\n                    if ind == 0:\n                        count += 1\n                    else:\n                        count -= 1\n                        if count == 0:\n                            res += i - s + 1\n        return res", "entry_point": "countLatticePoints", "test_list": ["assert countLatticePoints(circles = [[2,2,1]]) == 5", "assert countLatticePoints(circles = [[2,2,2],[3,4,1]]) == 16"]}
{"Contest id": "290/2248", "text_name": "Intersection of Multiple Arrays", "text": "Given a 2D integer array nums where nums[i] is a non-empty array of distinct positive integers, return the list of integers that are present in each array of nums sorted in ascending order.", "canonical_solution": "def intersection(A):\n        from collections import Counter\n        return sorted([k for k,v in Counter([x for l in A for x in l]).items() if v==len(A)])\n        ", "entry_point": "intersection", "test_list": ["assert intersection([[3,1,2,4,5],[1,2,3,4],[3,4,5,6]]) == [3,4]", "assert intersection([[1,2,3],[4,5,6]]) == []"]}
{"Contest id": "289/2245", "text_name": "Maximum Trailing Zeros in a Cornered Path", "text": "You are given a 2D integer array grid of size m x n, where each cell contains a positive integer.\nA cornered path is defined as a set of adjacent cells with at most one turn. More specifically, the path should exclusively move either horizontally or vertically up to the turn (if there is one), without returning to a previously visited cell. After the turn, the path will then move exclusively in the alternate direction: move vertically if it moved horizontally, and vice versa, also without returning to a previously visited cell.\nThe product of a path is defined as the product of all the values in the path.\nReturn the maximum number of trailing zeros in the product of a cornered path found in grid.\nNote:\nHorizontal movement means moving in either the left or right direction.\nVertical movement means moving in either the up or down direction.", "canonical_solution": "def maxTrailingZeros(grid):\n        ans = 0\n        m, n = len(grid), len(grid[0])\n        prefixH = [[[0] * 2 for _ in range(n + 1)] for __ in range(m)]\n        prefixV = [[[0] * 2 for _ in range(n)] for __ in range(m + 1)]\n        for i in range(m):\n            for j in range(n):\n                temp= grid[i][j]\n                while temp % 2 == 0:\n                    prefixH[i][j + 1][0] += 1\n                    prefixV[i + 1][j][0] += 1\n                    temp //= 2\n                while temp % 5 == 0:\n                    prefixH[i][j + 1][1] += 1\n                    prefixV[i + 1][j][1] += 1\n                    temp //= 5\n                for k in range(2):\n                    prefixH[i][j + 1][k] += prefixH[i][j][k]\n                    prefixV[i + 1][j][k] += prefixV[i][j][k]\n        for i in range(m):\n            for j in range(n):\n                left = prefixH[i][j]\n                up = prefixV[i][j]\n                right, down, center = [0] * 2, [0] * 2, [0] * 2\n                for k in range(2):\n                    right[k] = prefixH[i][n][k] - prefixH[i][j + 1][k]\n                    down[k] = prefixV[m][j][k] - prefixV[i + 1][j][k]\n                    center[k] = prefixH[i][j + 1][k] - prefixH[i][j][k]\n                LU, LD, RU, RD = [0] * 2, [0] * 2, [0] * 2, [0] * 2\n                for k in range(2):\n                    LU[k] += left[k] + up[k] + center[k]\n                    LD[k] += left[k] + down[k] + center[k]\n                    RU[k] += right[k] + up[k] + center[k]\n                    RD[k] += right[k] + down[k] + center[k]\n                ans = max(ans,\n                          min(LU[0], LU[1]),\n                          min(LD[0], LD[1]),\n                          min(RU[0], RU[1]),\n                          min(RD[0], RD[1]))\n        return ans", "entry_point": "maxTrailingZeros", "test_list": ["assert maxTrailingZeros(grid = [[23,17,15,3,20],[8,1,20,27,11],[9,4,6,2,21],[40,9,1,10,6],[22,7,4,5,3]]) == 3", "assert maxTrailingZeros(grid = [[4,3,2],[7,6,1],[8,8,8]]) == 0"]}
{"Contest id": "289/2244", "text_name": "Minimum Rounds to Complete All Tasks", "text": "You are given a 0-indexed integer array tasks, where tasks[i] represents the difficulty level of a task. In each round, you can complete either 2 or 3 tasks of the same difficulty level.\nReturn the minimum rounds required to complete all the tasks, or -1 if it is not possible to complete all the tasks.", "canonical_solution": "def minimumRounds(tasks):\n        from collections import Counter\n        freq = Counter(tasks).values()\n        return -1 if 1 in freq else sum((a + 2) // 3 for a in freq)\n        ", "entry_point": "minimumRounds", "test_list": ["assert minimumRounds(tasks = [2,2,3,3,2,4,4,4,4,4]) == 4", "assert minimumRounds(tasks = [2,3,3]) == -1"]}
{"Contest id": "289/2243", "text_name": " Calculate Digit Sum of a String", "text": "You are given a string s consisting of digits and an integer k.\nA round can be completed if the length of s is greater than k. In one round, do the following:\nDivide s into consecutive groups of size k such that the first k characters are in the first group, the next k characters are in the second group, and so on. Note that the size of the last group can be smaller than k.\nReplace each group of s with a string representing the sum of all its digits. For example, \"346\" is replaced with \"13\" because 3 + 4 + 6 = 13.\nMerge consecutive groups together to form a new string. If the length of the string is greater than k, repeat from step 1.\nReturn s after all rounds have been completed.", "canonical_solution": "def digitSum(s, k):\n        while len(s) > k:\n            set_3 = [s[i:i+k] for i in range(0, len(s), k)]\n            s = ''\n            for e in set_3:\n                val = 0\n                for n in e:\n                    val += int(n)\n                s += str(val)\n        return s", "entry_point": "digitSum", "test_list": ["assert digitSum(s = \"11111222223\", k = 3) == \"135\"", "assert digitSum(s = \"00000000\", k = 3) == \"000\""]}
{"Contest id": "Bi76/2242", "text_name": "Maximum Score of a Node Sequence", "text": "There is an undirected graph with n nodes, numbered from 0 to n - 1.\nYou are given a 0-indexed integer array scores of length n where scores[i] denotes the score of node i. You are also given a 2D integer array edges where edges[i] = [ai, bi] denotes that there exists an undirected edge connecting nodes ai and bi.\nA node sequence is valid if it meets the following conditions:\nThere is an edge connecting every pair of adjacent nodes in the sequence.\nNo node appears more than once in the sequence.\nThe score of a node sequence is defined as the sum of the scores of the nodes in the sequence.\nReturn the maximum score of a valid node sequence with a length of 4. If no such sequence exists, return -1.", "canonical_solution": "def maximumScore(scores, edges):\n        from collections import defaultdict\n        G = defaultdict(list)\n        for v,w in edges:\n            G[v].append(w)\n            G[w].append(v)\n        res = float('-inf')\n        for v in G:\n            G[v].sort(key = lambda w:-scores[w])\n        for v in G:\n            G[v] = set(G[v][:3])\n        res = float('-inf')\n        for v, w in edges:\n            tmp = scores[v]+scores[w]\n            for x in G[v]-set([w]):\n                for y in G[w]-set([v]):\n                    if x!=y:\n                        res = max(res, tmp + scores[x]+scores[y])\n        return res if res != float('-inf') else -1", "entry_point": "maximumScore", "test_list": ["assert maximumScore([5,2,9,8,4], [[0,1],[1,2],[2,3],[0,2],[1,3],[2,4]]) == 24", "assert maximumScore( [9,20,6,4,11,12],  [[0,3],[5,3],[2,4],[1,3]]) == -1"]}
{"Contest id": "Bi76/2240", "text_name": "Number of Ways to Buy Pens and Pencils", "text": "You are given an integer total indicating the amount of money you have. You are also given two integers cost1 and cost2 indicating the price of a pen and pencil respectively. You can spend part or all of your money to buy multiple quantities (or none) of each kind of writing utensil.\nReturn the number of distinct ways you can buy some number of pens and pencils.", "canonical_solution": "def waysToBuyPensPencils(total, cost1, cost2):\n        ways = 0;\n        penscost = 0;\n        while penscost <= total:\n            remainingAmount = total - penscost;\n            pencils = remainingAmount//cost2 + 1;\n            ways += pencils;\n            penscost += cost1;\n        return ways", "entry_point": "waysToBuyPensPencils", "test_list": ["assert waysToBuyPensPencils(total = 20, cost1 = 10, cost2 = 5) == 9", "assert waysToBuyPensPencils(total = 5, cost1 = 10, cost2 = 10) == 1"]}
{"Contest id": "Bi76/2239", "text_name": "Find Closest Number to Zero", "text": "Given an integer array nums of size n, return the number with the value closest to 0 in nums. If there are multiple answers, return the number with the largest value.", "canonical_solution": "def findClosestNumber(A):\n        return max([-abs(a), a] for a in A)[1] ", "entry_point": "findClosestNumber", "test_list": ["assert findClosestNumber( [-4,-2,1,4,8]) == 1", "assert findClosestNumber( [2,-1,1]) == 1"]}
{"Contest id": "288/2234", "text_name": "Maximum Total Beauty of the Gardens", "text": "Alice is a caretaker of n gardens and she wants to plant flowers to maximize the total beauty of all her gardens.\nYou are given a 0-indexed integer array flowers of size n, where flowers[i] is the number of flowers already planted in the ith garden. Flowers that are already planted cannot be removed. You are then given another integer newFlowers, which is the maximum number of flowers that Alice can additionally plant. You are also given the integers target, full, and partial.\nA garden is considered complete if it has at least target flowers. The total beauty of the gardens is then determined as the sum of the following:\nThe number of complete gardens multiplied by full.\nThe minimum number of flowers in any of the incomplete gardens multiplied by partial. If there are no incomplete gardens, then this value will be 0.\nReturn the maximum total beauty that Alice can obtain after planting at most newFlowers flowers.", "canonical_solution": "def maximumBeauty(flowers, newFlowers, target, full, partial):\n        import bisect\n        n = len(flowers)\n        flowers.sort()\n        pre,lack = [0],[0]\n         \n        if flowers[0] >= target:\n            return n*full\n        \n        for i in flowers:\n            pre.append(pre[-1]+i)\n        \n        cnt = 0\n        for i in flowers[::-1]:\n            if i >= target:\n                cnt+=1\n            lack.append(lack[-1]+max(target-i,0))\n        \n        def fill(flower,f,k):\n            i = bisect.bisect_left(flowers,flower,lo=0,hi=k)\n            return pre[i] + f >= i*flower\n            \n        res = 0\n        for k in range(cnt,n):\n            if lack[k] < newFlowers:\n                left, right = flowers[0], target+1\n                while left < right:\n                    mid = (left+right)//2\n                    if not fill(mid,newFlowers-lack[k],n-k):\n                        right = mid\n                    else:\n                        left = mid + 1\n                left -= 1\n                \n                if left >= target:\n                    \n                    res = max(res,(target-1)*partial+k*full)\n                else:\n                    res = max(res,k*full+left*partial)\n        \n        if lack[-1] <= newFlowers:\n            res = max(res,n*full)\n        return res\n        ", "entry_point": "maximumBeauty", "test_list": ["assert maximumBeauty(flowers = [1,3,1,1], newFlowers = 7, target = 6, full = 12, partial = 1) == 14", "assert maximumBeauty(flowers = [2,4,5,3], newFlowers = 10, target = 5, full = 2, partial = 6) == 30"]}
{"Contest id": "288/2233", "text_name": "Maximum Product After K Increments", "text": "You are given an array of non-negative integers nums and an integer k. In one operation, you may choose any element from nums and increment it by 1.\nReturn the maximum product of nums after at most k operations. Since the answer may be very large, return it modulo 109 + 7. Note that you should maximize the product before taking the modulo. ", "canonical_solution": "def maximumProduct(nums, k):\n        import heapq\n        heap = []\n        for i in nums:\n            heapq.heappush (heap,i)\n            \n        while k :\n            current = heapq.heappop(heap)\n            heapq.heappush(heap, current+1)\n            k-=1\n            \n        result =1\n        \n        while len(heap)>0:\n            x= heapq.heappop(heap)\n            result =(result*x )% (10**9+7)\n            \n        return result", "entry_point": "maximumProduct", "test_list": ["assert maximumProduct(nums = [0,4], k = 5) == 20", "assert maximumProduct(nums = [6,3,3,2], k = 2) == 216"]}
{"Contest id": "288/2232", "text_name": "Minimize Result by Adding Parentheses to Expression", "text": "You are given a 0-indexed string expression of the form \"<num1>+<num2>\" where <num1> and <num2> represent positive integers.\nAdd a pair of parentheses to expression such that after the addition of parentheses, expression is a valid mathematical expression and evaluates to the smallest possible value. The left parenthesis must be added to the left of '+' and the right parenthesis must be added to the right of '+'.\nReturn expression after adding a pair of parentheses such that expression evaluates to the smallest possible value. If there are multiple answers that yield the same result, return any of them.\nThe input has been generated such that the original value of expression, and the value of expression after adding any pair of parentheses that meets the requirements fits within a signed 32-bit integer.", "canonical_solution": "def minimizeResult(expression):\n        left, right = expression.split('+')                             \n        value = lambda s:eval(s.replace('(','*(').replace(')',')*').strip('*'))                                                                \n        lft = [ left[0:i]+'('+ left[i:] for i in range(  len(left )  )] \n        rgt = [right[0:i]+')'+right[i:] for i in range(1,len(right)+1)] \n        return  min([l+'+'+r for l in lft for r in rgt], key = value)", "entry_point": "minimizeResult", "test_list": ["assert minimizeResult(expression = \"247+38\") == \"2(47+38)\"", "assert minimizeResult(expression = \"12+34\") == \"1(2+3)4\"", "assert minimizeResult(expression = \"999+999\") == \"(999+999)\""]}
{"Contest id": "288/2231", "text_name": "Largest Number After Digit Swaps by Parity", "text": "You are given a positive integer num. You may swap any two digits of num that have the same parity (i.e. both odd digits or both even digits).\nReturn the largest possible value of num after any number of swaps.", "canonical_solution": "def largestInteger(num):\n        n = len(str(num))\n        arr = [int(i) for i in str(num)]\n        odd, even = [], []\n        for i in arr:\n            if i % 2 == 0:\n                even.append(i)\n            else:\n                odd.append(i)\n        odd.sort()\n        even.sort()\n        res = 0\n        for i in range(n):\n            if arr[i] % 2 == 0:\n                res = res*10 + even.pop()\n            else:\n                res = res*10 + odd.pop()\n        return res", "entry_point": "largestInteger", "test_list": ["assert largestInteger(num = 1234) == 3412", "assert largestInteger(num = 65875) == 87655"]}
{"Contest id": "287/2226", "text_name": "Maximum Candies Allocated to K Children", "text": "You are given a 0-indexed integer array candies. Each element in the array denotes a pile of candies of size candies[i]. You can divide each pile into any number of sub piles, but you cannot merge two piles together.\nYou are also given an integer k. You should allocate piles of candies to k children such that each child gets the same number of candies. Each child can take at most one pile of candies and some piles of candies may go unused.\nReturn the maximum number of candies each child can get.", "canonical_solution": "def maximumCandies(candies, k):\n        def canSplit(candies, mid, k):\n            split = 0\n            for i in candies:\n                split += i//mid\n            if split >= k:\n                return True\n            else:\n                return False\n        end = sum(candies)//k\n        start = 1\n        ans = 0\n        while start <= end:\n            mid = (start + end)//2\n            if canSplit(candies, mid, k):\n                start = mid + 1\n                ans = mid\n            else:\n                end = mid - 1\n        return ans", "entry_point": "maximumCandies", "test_list": ["assert maximumCandies([5,8,6], 3) == 5", "assert maximumCandies([2,5], 11) == 0"]}
{"Contest id": "287/2225", "text_name": "Find Players With Zero or One Losses", "text": "You are given an integer array matches where matches[i] = [winneri, loseri] indicates that the player winneri defeated player loseri in a match.\nReturn a list answer of size 2 where:\nanswer[0] is a list of all players that have not lost any matches.\nanswer[1] is a list of all players that have lost exactly one match.\nThe values in the two lists should be returned in increasing order.\nNote:\nYou should only consider the players that have played at least one match.\nThe testcases will be generated such that no two matches will have the same outcome.", "canonical_solution": "def findWinners(matches):\n        zeroLoss, oneLoss, moreLoss = set(), set(), set()\n\n        for match in matches:\n            winner, loser = match[0], match[1]\n\n            # Add winner.\n            if winner not in oneLoss and winner not in moreLoss:\n                zeroLoss.add(winner)\n\n            # Add or move loser.\n            if loser in zeroLoss:\n                zeroLoss.remove(loser)\n                oneLoss.add(loser)\n            elif loser in oneLoss:\n                oneLoss.remove(loser)\n                moreLoss.add(loser)\n            elif loser in moreLoss:\n                continue\n            else:\n                oneLoss.add(loser)\n\n        answer = [sorted(list(zeroLoss)), sorted(list(oneLoss))]\n        return answer", "entry_point": "findWinners", "test_list": ["assert findWinners(matches = [[1,3],[2,3],[3,6],[5,6],[5,7],[4,5],[4,8],[4,9],[10,4],[10,9]]) == [[1,2,10],[4,5,7,8]]", "assert findWinners(matches = [[2,3],[1,3],[5,4],[6,4]]) == [[1,2,5,6],[]]"]}
{"Contest id": "287/2224", "text_name": "Minimum Number of Operations to Convert Time", "text": "You are given two strings current and correct representing two 24-hour times.\n24-hour times are formatted as \"HH:MM\", where HH is between 00 and 23, and MM is between 00 and 59. The earliest 24-hour time is 00:00, and the latest is 23:59.\nIn one operation you can increase the time current by 1, 5, 15, or 60 minutes. You can perform this operation any number of times.\nReturn the minimum number of operations needed to convert current to correct.", "canonical_solution": "def convertTime(current, correct):\n        current_time = 60 * int(current[0:2]) + int(current[3:5])\n        target_time = 60 * int(correct[0:2]) + int(correct[3:5])\n        diff = target_time - current_time\n        count = 0\n        for i in [60, 15, 5, 1]:\n            count += diff // i\n            diff %= i\n        return count", "entry_point": "convertTime", "test_list": ["assert convertTime(current = \"02:30\", correct = \"04:35\") == 3", "assert convertTime(current = \"11:00\", correct = \"11:01\") == 1"]}
{"Contest id": "Bi75/2223", "text_name": "Sum of Scores of Built Strings", "text": "You are building a string s of length n one character at a time, prepending each new character to the front of the string. The strings are labeled from 1 to n, where the string with length i is labeled si.\nFor example, for s = \"abaca\", s1 == \"a\", s2 == \"ca\", s3 == \"aca\", etc.\nThe score of si is the length of the longest common prefix between si and sn (Note that s == sn).\nGiven the final string s, return the sum of the score of every si.", "canonical_solution": "def sumScores(s):\n        n = len(s)\n        lps = [0] * n\n        dp = [1] * n\n        j = 0\n        i = 1\n        while i < n:\n            if s[i] == s[j]:\n                lps[i] = j + 1\n\n                dp[i] += dp[j]\n                \n                i += 1\n                j += 1\n            elif j:\n                j = lps[j - 1]\n            else:\n                i += 1\n        \n        return sum(dp)   ", "entry_point": "sumScores", "test_list": ["assert sumScores(s = \"babab\") == 9", "assert sumScores(s = \"azbazbzaz\") == 14"]}
{"Contest id": "Bi75/2222", "text_name": "Number of Ways to Select Buildings", "text": "You are given a 0-indexed binary string s which represents the types of buildings along a street where:\ns[i] = '0' denotes that the ith building is an office and\ns[i] = '1' denotes that the ith building is a restaurant.\nAs a city official, you would like to select 3 buildings for random inspection. However, to ensure variety, no two consecutive buildings out of the selected buildings can be of the same type.\nFor example, given s = \"001101\", we cannot select the 1st, 3rd, and 5th buildings as that would form \"011\" which is not allowed due to having two consecutive buildings of the same type.\nReturn the number of valid ways to select 3 buildings.", "canonical_solution": "def numberOfWays(s):\n        z, o, zo, oz, total = 0, 0, 0, 0, 0\n        for c in s:\n            if c == '1':\n                total += oz\n                zo += z\n                o += 1\n            elif c == '0':\n                total += zo\n                oz += o\n                z += 1\n        return total", "entry_point": "numberOfWays", "test_list": ["assert numberOfWays(s = \"001101\") == 6", "assert numberOfWays(s = \"11100\") == 0"]}
{"Contest id": "Bi75/2221", "text_name": "Find Triangular Sum of an Array", "text": "You are given a 0-indexed integer array nums, where nums[i] is a digit between 0 and 9 (inclusive).\nThe triangular sum of nums is the value of the only element present in nums after the following process terminates:\nLet nums comprise of n elements. If n == 1, end the process. Otherwise, create a new 0-indexed integer array newNums of length n - 1.\nFor each index i, where 0 <= i < n - 1, assign the value of newNums[i] as (nums[i] + nums[i+1]) % 10, where % denotes modulo operator.\nReplace the array nums with newNums.\nRepeat the entire process starting from step 1.\nReturn the triangular sum of nums.", "canonical_solution": "def triangularSum(nums):\n    n = len(nums)\n    while n > 0:\n      for i in range(n-1):\n        nums[i] = (nums[i] + nums[i+1]) % 10\n      n -= 1\n    return nums[0]", "entry_point": "triangularSum", "test_list": ["assert triangularSum(nums = [1,2,3,4,5]) == 8", "assert triangularSum(nums = [5]) == 5"]}
{"Contest id": "Bi75/2220", "text_name": "Minimum Bit Flips to Convert Number", "text": "A bit flip of a number x is choosing a bit in the binary representation of x and flipping it from either 0 to 1 or 1 to 0.\nFor example, for x = 7, the binary representation is 111 and we may choose any bit (including any leading zeros not shown) and flip it. We can flip the first bit from the right to get 110, flip the second bit from the right to get 101, flip the fifth bit from the right (a leading zero) to get 10111, etc.\nGiven two integers start and goal, return the minimum number of bit flips to convert start to goal.", "canonical_solution": "def minBitFlips(start, goal):\n        n = start ^ goal \n        count = 0\n        while n:\n            n = n & (n-1) \n            count += 1\n        return count", "entry_point": "minBitFlips", "test_list": ["assert minBitFlips(start = 10, goal = 7) == 3", "assert minBitFlips(start = 3, goal = 4) == 3"]}
{"Contest id": "286/2218", "text_name": "Maximum Value of K Coins From Piles", "text": "There are n piles of coins on a table. Each pile consists of a positive number of coins of assorted denominations.\nIn one move, you can choose any coin on top of any pile, remove it, and add it to your wallet.\nGiven a list piles, where piles[i] is a list of integers denoting the composition of the ith pile from top to bottom, and a positive integer k, return the maximum total value of coins you can have in your wallet if you choose exactly k coins optimally.", "canonical_solution": "def maxValueOfCoins(piles, k):\n        dp = [[0] * (k + 1) for _ in range(len(piles) + 1)]\n        for i in range(1, len(piles) + 1):\n            for j in range(1, k + 1):\n                cur = 0\n                for x in range(min(len(piles[i - 1]), j)):\n                    cur += piles[i - 1][x]\n                    dp[i][j] = max(dp[i][j], cur + dp[i - 1][j - x - 1])\n                dp[i][j] = max(dp[i][j], dp[i - 1][j])\n        return dp[len(piles)][k]  ", "entry_point": "maxValueOfCoins", "test_list": ["assert maxValueOfCoins(piles = [[1,100,3],[7,8,9]], k = 2) == 101", "assert maxValueOfCoins(piles = [[100],[100],[100],[100],[100],[100],[1,1,1,1,1,1,700]], k = 7) == 706"]}
{"Contest id": "286/2217", "text_name": "Find Palindrome With Fixed Length", "text": "Given an integer array queries and a positive integer intLength, return an array answer where answer[i] is either the queries[i]th smallest positive palindrome of length intLength or -1 if no such palindrome exists.\nA palindrome is a number that reads the same backwards and forwards. Palindromes cannot have leading zeros.", "canonical_solution": "def kthPalindrome(queries, intLength):\n        ogLength = intLength\n        isOdd = intLength & 1\n        if isOdd:\n            intLength += 1\n        k = intLength // 2\n        k = 10 ** (k - 1)\n        op = []\n        for q in queries:\n            pal = str(k + q - 1)\n            if isOdd:\n                pal += pal[::-1][1:]\n            else:\n                pal += pal[::-1]\n            if len(pal) == ogLength:\n                op.append(int(pal))\n            else:\n                op.append(-1)\n        return op", "entry_point": "kthPalindrome", "test_list": ["assert kthPalindrome([1,2,3,4,5,90],3) == [101,111,121,131,141,999]", "assert kthPalindrome([2,4,6],4) == [1111,1331,1551]"]}
{"Contest id": "286/2216", "text_name": "Minimum Deletions to Make Array Beautiful", "text": "You are given a 0-indexed integer array nums. The array nums is beautiful if:\nnums.length is even.\nnums[i] != nums[i + 1] for all i % 2 == 0.\nNote that an empty array is considered beautiful.\nYou can delete any number of elements from nums. When you delete an element, all the elements to the right of the deleted element will be shifted one unit to the left to fill the gap created and all the elements to the left of the deleted element will remain unchanged.\nReturn the minimum number of elements to delete from nums to make it beautiful.\n ", "canonical_solution": "def minDeletion(A):\n        res, pre = 0, -1\n        for a in A:\n            if a == pre:\n                res += 1\n            else:\n                pre = a if pre < 0 else -1\n        return res + (pre >= 0)", "entry_point": "minDeletion", "test_list": ["assert minDeletion([1,1,2,3,5]) == 1", "assert minDeletion([1,1,2,2,3,3]) == 2"]}
{"Contest id": "286/2215", "text_name": "Find the Difference of Two Arrays", "text": "Given two 0-indexed integer arrays nums1 and nums2, return a list answer of size 2 where:\nanswer[0] is a list of all distinct integers in nums1 which are not present in nums2.\nanswer[1] is a list of all distinct integers in nums2 which are not present in nums1.\nNote that the integers in the lists may be returned in any order.", "canonical_solution": "def findDifference(nums1, nums2):\n        n1=set(nums1)\n        n2=set(nums2)\n        r1=list(set(x for x in nums1 if x not in n2))\n        r2=list(set(x for x in nums2 if x not in n1))\n        return [r1,r2]", "entry_point": "findDifference", "test_list": ["assert findDifference(nums1 = [1,2,3], nums2 = [2,4,6]) == [[1,3],[4,6]]", "assert findDifference(nums1 = [1,2,3,3], nums2 = [1,1,2,2]) == [[3],[]]"]}
{"Contest id": "285/2212", "text_name": "Maximum Points in an Archery Competition", "text": "Alice and Bob are opponents in an archery competition. The competition has set the following rules:\nAlice first shoots numArrows arrows and then Bob shoots numArrows arrows.\nThe points are then calculated as follows:\nThe target has integer scoring sections ranging from 0 to 11 inclusive.\nFor each section of the target with score k (in between 0 to 11), say Alice and Bob have shot ak and bk arrows on that section respectively. If ak >= bk, then Alice takes k points. If ak < bk, then Bob takes k points.\nHowever, if ak == bk == 0, then nobody takes k points.\nFor example, if Alice and Bob both shot 2 arrows on the section with score 11, then Alice takes 11 points. On the other hand, if Alice shot 0 arrows on the section with score 11 and Bob shot 2 arrows on that same section, then Bob takes 11 points.\nYou are given the integer numArrows and an integer array aliceArrows of size 12, which represents the number of arrows Alice shot on each scoring section from 0 to 11. Now, Bob wants to maximize the total number of points he can obtain.\nReturn the array bobArrows which represents the number of arrows Bob shot on each scoring section from 0 to 11. The sum of the values in bobArrows should equal numArrows.\nIf there are multiple ways for Bob to earn the maximum total points, return any one of them.", "canonical_solution": "def maximumBobPoints(numArrows, aliceArrows):\n    currMax = 0\n    result = [[0]*12]\n\n    def maxscore(section, score, arrows, i):\n        nonlocal currMax\n        if arrows < 0:\n            return\n        if arrows == 0 or i == 0:\n            if score >= currMax:\n                currMax = score\n                if arrows > 0:\n                    result[0] = [arrows] + section[1:]\n                else:\n                    result[0] = section[:]\n            return\n        section[i] = aliceArrows[i]+1\n        maxscore(section, score+i, arrows-aliceArrows[i]-1, i-1)\n        section[i] = 0\n        maxscore(section, score, arrows, i-1)\n    \n    maxscore([0]*12, 0, numArrows, 11)\n    return result[0]", "entry_point": "maximumBobPoints", "test_list": ["assert maximumBobPoints(numArrows = 9, aliceArrows = [1,1,0,1,0,0,2,1,0,1,2,0]) == [0,0,0,0,1,1,0,0,1,2,3,1]", "assert maximumBobPoints(numArrows = 3, aliceArrows = [0,0,1,0,0,0,0,0,0,0,0,2]) == [0,0,0,0,0,0,0,0,1,1,1,0]"]}
{"Contest id": "285/2211", "text_name": "Count Collisions on a Road", "text": "There are n cars on an infinitely long road. The cars are numbered from 0 to n - 1 from left to right and each car is present at a unique point.\nYou are given a 0-indexed string directions of length n. directions[i] can be either 'L', 'R', or 'S' denoting whether the ith car is moving towards the left, towards the right, or staying at its current point respectively. Each moving car has the same speed.\nThe number of collisions can be calculated as follows:\nWhen two cars moving in opposite directions collide with each other, the number of collisions increases by 2.\nWhen a moving car collides with a stationary car, the number of collisions increases by 1.\nAfter a collision, the cars involved can no longer move and will stay at the point where they collided. Other than that, cars cannot change their state or direction of motion.\nReturn the total number of collisions that will happen on the road.", "canonical_solution": "def countCollisions(directions):       \n        res, n, i, carsFromRight = 0, len(directions), 0, 0\n        \n        while i < n and directions[i] == 'L':\n               i+=1\n        \n        while i<n:\n            if directions[i] == 'R':\n                carsFromRight+=1\n            else:\n                res += carsFromRight if directions[i] == 'S' else carsFromRight+1;\n                carsFromRight = 0\n            i+=1\n                \n        return res", "entry_point": "countCollisions", "test_list": ["assert countCollisions(directions = \"RLRSLL\") == 5", "assert countCollisions(directions = \"LLRR\") == 0"]}
{"Contest id": "285/2210", "text_name": "Count Hills and Valleys in an Array", "text": "You are given a 0-indexed integer array nums. An index i is part of a hill in nums if the closest non-equal neighbors of i are smaller than nums[i]. Similarly, an index i is part of a valley in nums if the closest non-equal neighbors of i are larger than nums[i]. Adjacent indices i and j are part of the same hill or valley if nums[i] == nums[j].\nNote that for an index to be part of a hill or valley, it must have a non-equal neighbor on both the left and right of the index.\nReturn the number of hills and valleys in nums.", "canonical_solution": "def countHillValley(nums):\n        hillValley = 0\n        for i in range(1, len(nums)-1):\n            if nums[i] == nums[i+1]:\n                nums[i] = nums[i-1]\n            if nums[i] > nums[i-1] and nums[i] > nums[i+1]:     #hill check\n                hillValley += 1\n            if nums[i] < nums[i-1] and nums[i] < nums[i+1]:     #valley check\n                hillValley += 1\n        return hillValley", "entry_point": "countHillValley", "test_list": ["assert countHillValley(nums = [2,4,1,1,6,5]) == 3", "assert countHillValley(nums = [6,6,5,5,4,1]) == 0"]}
{"Contest id": "Bi74/2209", "text_name": "Minimum White Tiles After Covering With Carpets", "text": "You are given a 0-indexed binary string floor, which represents the colors of tiles on a floor:\nfloor[i] = '0' denotes that the ith tile of the floor is colored black.\nOn the other hand, floor[i] = '1' denotes that the ith tile of the floor is colored white.\nYou are also given numCarpets and carpetLen. You have numCarpets black carpets, each of length carpetLen tiles. Cover the tiles with the given carpets such that the number of white tiles still visible is minimum. Carpets may overlap one another.\nReturn the minimum number of white tiles still visible.", "canonical_solution": "def minimumWhiteTiles(floor, numCarpets, carpetLen):\n        n = len(floor)\n        if carpetLen*numCarpets >= n:\n            return 0\n        floorlist = []\n        for i in floor:\n            if i == '1':\n                floorlist.append(1)\n            else:\n                floorlist.append(0)\n        dp=[[0] * n for i in range(numCarpets)]        \n        for i in range(carpetLen, n):\n            dp[0][i] = min(floorlist[i] + dp[0][i-1], sum(floorlist[:i - carpetLen + 1]))\n        for j in range(1, numCarpets):\n            for i in range(carpetLen * j, n):\n                dp[j][i] = min(floorlist[i] + dp[j][i - 1], dp[j - 1][i - carpetLen])\n        return dp[-1][-1]", "entry_point": "minimumWhiteTiles", "test_list": ["assert minimumWhiteTiles( \"10110101\",  2,  2) == 2", "assert minimumWhiteTiles(\"11111\",  2,  3) == 0"]}
{"Contest id": "Bi74/2208", "text_name": "Minimum Operations to Halve Array Sum", "text": "You are given an array nums of positive integers. In one operation, you can choose any number from nums and reduce it to exactly half the number. (Note that you may choose this reduced number in future operations.)\nReturn the minimum number of operations to reduce the sum of nums by at least half.", "canonical_solution": "def halveArray(nums):\n        import heapq\n        if len(nums)==1:return 1       \n        count = 0\n        total = sum(nums)\n        half = float(total)/2\n        for i,val in enumerate(nums):\n            nums[i]=-val       \n        heapq.heapify(nums)        \n        while total > half:\n            halved = float(nums[0])/2\n            total+=halved\n            count+=1\n            heapq.heapreplace(nums,halved)                       \n        return count", "entry_point": "halveArray", "test_list": ["assert halveArray([5,19,8,1]) == 3", "assert halveArray([3,8,20]) == 3"]}
{"Contest id": "Bi74/2207", "text_name": "Maximize Number of Subsequences in a String", "text": "You are given a 0-indexed string text and another 0-indexed string pattern of length 2, both of which consist of only lowercase English letters.\nYou can add either pattern[0] or pattern[1] anywhere in text exactly once. Note that the character can be added even at the beginning or at the end of text.\nReturn the maximum number of times pattern can occur as a subsequence of the modified text.\nA subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.", "canonical_solution": "def maximumSubsequenceCount(text, pattern):\n        res = cnt1 = cnt2 = 0\n        for c in text:\n            if c == pattern[1]:\n                res += cnt1\n                cnt2 += 1\n            if c == pattern[0]:\n                cnt1 += 1\n        return res + max(cnt1, cnt2)", "entry_point": "maximumSubsequenceCount", "test_list": ["assert maximumSubsequenceCount(text = \"abdcdbc\", pattern = \"ac\") == 4", "assert maximumSubsequenceCount(text = \"aabb\", pattern = \"ab\") == 6"]}
{"Contest id": "Bi74/2206", "text_name": "Divide Array Into Equal Pairs", "text": "You are given an integer array nums consisting of 2 * n integers.\nYou need to divide nums into n pairs such that:\nEach element belongs to exactly one pair.\nThe elements present in a pair are equal.\nReturn true if nums can be divided into n pairs, otherwise return false.", "canonical_solution": "def divideArray(nums):\n        from collections import Counter\n        return all(i % 2 == 0 for i in Counter(nums).values())", "entry_point": "divideArray", "test_list": ["assert divideArray(nums = [3,2,3,2,2,2]) == True", "assert divideArray(nums = [1,2,3,4]) == False"]}
{"Contest id": "284/2203", "text_name": "Minimum Weighted Subgraph With the Required Paths", "text": "You are given an integer n denoting the number of nodes of a weighted directed graph. The nodes are numbered from 0 to n - 1.\nYou are also given a 2D integer array edges where edges[i] = [fromi, toi, weighti] denotes that there exists a directed edge from fromi to toi with weight weighti.\nLastly, you are given three distinct integers src1, src2, and dest denoting three distinct nodes of the graph.\nReturn the minimum weight of a subgraph of the graph such that it is possible to reach dest from both src1 and src2 via a set of edges of this subgraph. In case such a subgraph does not exist, return -1.\nA subgraph is a graph whose vertices and edges are subsets of the original graph. The weight of a subgraph is the sum of weights of its constituent edges.", "canonical_solution": "def minimumWeight(n, edges, src1, src2, dest):\n        from math import inf\n        forward, backward = dict(), dict()\n        for start, end, weight in edges:\n            if start in forward:\n                if end in forward[start]:\n                    forward[start][end] = min(weight, forward[start][end])\n                else:\n                    forward[start][end] = weight\n            else:\n                forward[start] = {end: weight}\n            if end in backward:\n                if start in backward[end]:\n                    backward[end][start] = min(weight, backward[end][start])\n                else:\n                    backward[end][start] = weight\n            else:\n                backward[end] = {start: weight}\n\n        def travel(origin: int, relations: dict, costs: list) -> None:\n            level = {origin}\n            costs[origin] = 0\n            while level:\n                new_level = set()\n                for node in level:\n                    if node in relations:\n                        for next_node, w in relations[node].items():\n                            if w + costs[node] < costs[next_node]:\n                                new_level.add(next_node)\n                                costs[next_node] = w + costs[node]\n                level = new_level\n\n        from_src1 = [inf] * n\n        from_src2 = [inf] * n\n        from_dest = [inf] * n\n\n        travel(src1, forward, from_src1)\n        travel(src2, forward, from_src2)\n        travel(dest, backward, from_dest)\n\n        combined_cost = min(sum(tpl)\n                            for tpl in zip(from_src1, from_src2, from_dest))\n\n        return combined_cost if combined_cost < inf else -1", "entry_point": "minimumWeight", "test_list": ["assert minimumWeight(n = 6, edges = [[0,2,2],[0,5,6],[1,0,3],[1,4,5],[2,1,1],[2,3,3],[2,3,4],[3,4,2],[4,5,1]], src1 = 0, src2 = 1, dest = 5) == 9", "assert minimumWeight(n = 3, edges = [[0,1,1],[2,1,1]], src1 = 0, src2 = 1, dest = 2) == -1"]}
{"Contest id": "284/2201", "text_name": "Count Artifacts That Can Be Extracted", "text": "There is an n x n 0-indexed grid with some artifacts buried in it. You are given the integer n and a 0-indexed 2D integer array artifacts describing the positions of the rectangular artifacts where artifacts[i] = [r1i, c1i, r2i, c2i] denotes that the ith artifact is buried in the subgrid where:\n(r1i, c1i) is the coordinate of the top-left cell of the ith artifact and\n(r2i, c2i) is the coordinate of the bottom-right cell of the ith artifact.\nYou will excavate some cells of the grid and remove all the mud from them. If the cell has a part of an artifact buried underneath, it will be uncovered. If all the parts of an artifact are uncovered, you can extract it.\nGiven a 0-indexed 2D integer array dig where dig[i] = [ri, ci] indicates that you will excavate the cell (ri, ci), return the number of artifacts that you can extract.\nThe test cases are generated such that:\nNo two artifacts overlap.\nEach artifact only covers at most 4 cells.\nThe entries of dig are unique.", "canonical_solution": "def digArtifacts(n, artifacts, dig):\n\n        dig = set((r,c) for r,c in dig)\n\n        count =0\n        for r1,c1, r2,c2 in artifacts:\n            positions = set()\n            for r in range(r1, r2+1):\n                for c in range(c1, c2+1):\n                    positions.add((r,c))\n\n            if all([pos in dig for pos in positions]):\n                count+=1\n\n        return count", "entry_point": "digArtifacts", "test_list": ["assert digArtifacts(n = 2, artifacts = [[0,0,0,0],[0,1,1,1]], dig = [[0,0],[0,1]]) == 1", "assert digArtifacts(n = 2, artifacts = [[0,0,0,0],[0,1,1,1]], dig = [[0,0],[0,1],[1,1]]) == 2"]}
{"Contest id": "284/2201", "text_name": "Maximize the Topmost Element After K Moves", "text": "You are given a 0-indexed integer array nums representing the contents of a pile, where nums[0] is the topmost element of the pile.\nIn one move, you can perform either of the following:\nIf the pile is not empty, remove the topmost element of the pile.\nIf there are one or more removed elements, add any one of them back onto the pile. This element becomes the new topmost element.\nYou are also given an integer k, which denotes the total number of moves to be made.\nReturn the maximum value of the topmost element of the pile possible after exactly k moves. In case it is not possible to obtain a non-empty pile after k moves, return -1.", "canonical_solution": "def maximumTop(nums, k):\n        if len(nums) == 1:\n            if k%2 != 0:\n                return -1\n            return nums[0]\n        \n        if k == 0:\n            return nums[0]\n        if k == len(nums):\n            return max(nums[:-1])\n        if k > len(nums):\n            return max(nums)\n        if k == 1:\n            return nums[1]\n        m = max(nums[:k-1])\n        m = max(m, nums[k])\n        return m", "entry_point": "maximumTop", "test_list": ["assert maximumTop(nums = [5,2,2,4,0,6], k = 4) == 5", "assert maximumTop(nums = [2], k = 1) == -1"]}
{"Contest id": "284/2200", "text_name": "Find All K-Distant Indices in an Array", "text": "You are given a 0-indexed integer array nums and two integers key and k. A k-distant index is an index i of nums for which there exists at least one index j such that |i - j| <= k and nums[j] == key.\nReturn a list of all k-distant indices sorted in increasing order.", "canonical_solution": "def findKDistantIndices(nums, key, k):\n        ind_j = []\n        for ind, elem in enumerate(nums):\n            if elem == key:\n                ind_j.append(ind)\n        res = []\n        for i in range(len(nums)):\n            for j in ind_j:\n                if abs(i - j) <= k:\n                    res.append(i)\n                    break\n        return sorted(res)", "entry_point": "findKDistantIndices", "test_list": ["assert findKDistantIndices(nums = [3,4,9,1,3,9,5], key = 9, k = 1) == [1,2,3,4,5,6]", "assert findKDistantIndices(nums = [2,2,2,2,2], key = 2, k = 2) == [0,1,2,3,4]"]}
{"Contest id": "283/2197", "text_name": "Replace Non-Coprime Numbers in Array", "text": "You are given an array of integers nums. Perform the following steps:\nFind any two adjacent numbers in nums that are non-coprime.\nIf no such numbers are found, stop the process.\nOtherwise, delete the two numbers and replace them with their LCM (Least Common Multiple).\nRepeat this process as long as you keep finding two adjacent non-coprime numbers.\nReturn the final modified array. It can be shown that replacing adjacent non-coprime numbers in any arbitrary order will lead to the same result.\nThe test cases are generated such that the values in the final array are less than or equal to 108.\nTwo values x and y are non-coprime if GCD(x, y) > 1 where GCD(x, y) is the Greatest Common Divisor of x and y.", "canonical_solution": "def replaceNonCoprimes(A):\n        res = []\n        for a in A:\n            while True:\n                x = math.gcd(res[-1] if res else 1, a)\n                if x == 1: break\n                a *= res.pop() // x\n            res.append(a)\n        return res", "entry_point": "replaceNonCoprimes", "test_list": ["assert replaceNonCoprimes( [6,4,3,2,7,6,2]) == [12,7,6]", "assert replaceNonCoprimes( [2,2,1,1,3,3,3]) == [2,1,1,3]"]}
{"Contest id": "283/2195", "text_name": "Append K Integers With Minimal Sum", "text": "You are given an integer array nums and an integer k. Append k unique positive integers that do not appear in nums to nums such that the resulting total sum is minimum.\nReturn the sum of the k integers appended to nums.", "canonical_solution": "def minimalKSum(nums, k):\n        nums.sort()\n        res = 0\n        nums.insert(0, 0)\n        nums.append(2000000001)\n        n = len(nums)\n        for i in range(n-1):\n            start = nums[i]\n            end = nums[i+1]\n            if start == end:\n                continue\n            a = start + 1\n            n = min(end - start - 1, k)\n            v = (n*(2*a + n - 1))//2\n            res += v\n            k -= n\n        return res", "entry_point": "minimalKSum", "test_list": ["assert minimalKSum(nums = [1,4,25,10,25], k = 2) == 5", "assert minimalKSum(nums = [5,6], k = 6) == 25"]}
{"Contest id": "283/2194", "text_name": "Cells in a Range on an Excel Sheet", "text": "A cell (r, c) of an excel sheet is represented as a string \"<col><row>\" where:\n<col> denotes the column number c of the cell. It is represented by alphabetical letters.\nFor example, the 1st column is denoted by 'A', the 2nd by 'B', the 3rd by 'C', and so on.\n<row> is the row number r of the cell. The rth row is represented by the integer r.\nYou are given a string s in the format \"<col1><row1>:<col2><row2>\", where <col1> represents the column c1, <row1> represents the row r1, <col2> represents the column c2, and <row2> represents the row r2, such that r1 <= r2 and c1 <= c2.\nReturn the list of cells (x, y) such that r1 <= x <= r2 and c1 <= y <= c2. The cells should be represented as strings in the format mentioned above and be sorted in non-decreasing order first by columns and then by rows.", "canonical_solution": "def cellsInRange(s):\n        return [chr(c) + chr(r) for c in range(ord(s[0]), ord(s[3]) + 1) for r in range(ord(s[1]), ord(s[4]) + 1)]", "entry_point": "cellsInRange", "test_list": ["assert cellsInRange(s = \"K1:L2\") == [\"K1\",\"K2\",\"L1\",\"L2\"]", "assert cellsInRange(s = \"A1:F1\") == [\"A1\",\"B1\",\"C1\",\"D1\",\"E1\",\"F1\"]"]}
{"Contest id": "Bi73/2193", "text_name": "Minimum Number of Moves to Make Palindrome", "text": "You are given a string s consisting only of lowercase English letters.\nIn one move, you can select any two adjacent characters of s and swap them.\nReturn the minimum number of moves needed to make s a palindrome.\nNote that the input will be generated such that s can always be converted to a palindrome.", "canonical_solution": "def minMovesToMakePalindrome(s):\n        count, length_of_s = 0, len(s)\n        if length_of_s <= 2:\n            return count\n        for i in reversed(range(length_of_s)):\n            if s[i] != s[0]:\n                continue\n            if i == 0:\n                count += len(s)/2 + minMovesToMakePalindrome(s[1:])  \n            else:\n                count += len(s)-1-i + minMovesToMakePalindrome(s[1:i]+s[i+1:])\n            break\n        return count", "entry_point": "minMovesToMakePalindrome", "test_list": ["assert minMovesToMakePalindrome(s = \"aabb\") == 2", "assert minMovesToMakePalindrome(s = \"letelt\") == 2"]}
{"Contest id": "Bi73/2192", "text_name": "All Ancestors of a Node in a Directed Acyclic Graph", "text": "You are given a positive integer n representing the number of nodes of a Directed Acyclic Graph (DAG). The nodes are numbered from 0 to n - 1 (inclusive).\nYou are also given a 2D integer array edges, where edges[i] = [fromi, toi] denotes that there is a unidirectional edge from fromi to toi in the graph.\nReturn a list answer, where answer[i] is the list of ancestors of the ith node, sorted in ascending order.\nA node u is an ancestor of another node v if u can reach v via a set of edges.", "canonical_solution": "def getAncestors(n, edges):\n    direct_child = defaultdict(list)\n    ans = [[] for _ in range(n)]\n    for x, y in edges:\n        direct_child[x].append(y)\n\n    def dfs(x, curr):\n        for ch in direct_child[curr]:\n            if ans[ch] and ans[ch][-1] == x: continue\n            ans[ch].append(x)\n            dfs(x, ch) \n\n    for i in range(n): dfs(i, i)\n    return ans", "entry_point": "getAncestors", "test_list": ["assert getAncestors( 8,  [[0,3],[0,4],[1,3],[2,4],[2,7],[3,5],[3,6],[3,7],[4,6]]) == [[],[],[],[0,1],[0,2],[0,1,3],[0,1,2,3,4],[0,1,2,3]]", "assert getAncestors( 5,  [[0,1],[0,2],[0,3],[0,4],[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]) == [[],[0],[0,1],[0,1,2],[0,1,2,3]]"]}
{"Contest id": "Bi73/2191", "text_name": "Sort the Jumbled Numbers", "text": "You are given a 0-indexed integer array mapping which represents the mapping rule of a shuffled decimal system. mapping[i] = j means digit i should be mapped to digit j in this system.\nThe mapped value of an integer is the new integer obtained by replacing each occurrence of digit i in the integer with mapping[i] for all 0 <= i <= 9.\nYou are also given another integer array nums. Return the array nums sorted in non-decreasing order based on the mapped values of its elements.\nNotes:\nElements with the same mapped values should appear in the same relative order as in the input.\nThe elements of nums should only be sorted based on their mapped values and not be replaced by them.", "canonical_solution": "def sortJumbled(mapping, nums):\n        \n        def convert(num):\n            if num == 0: \n                return mapping[0]\n            mapped, multiplier = 0, 1\n            while num:\n                mapped += multiplier * mapping[num%10]\n                multiplier *= 10\n                num = num // 10\n            return mapped\n        \n        return sorted(nums, key=convert)", "entry_point": "sortJumbled", "test_list": ["assert sortJumbled(mapping = [8,9,4,0,2,1,3,5,7,6], nums = [991,338,38]) == [338,38,991]", "assert sortJumbled(mapping = [0,1,2,3,4,5,6,7,8,9], nums = [789,456,123]) == [123,456,789]"]}
{"Contest id": "Bi73/2190", "text_name": "Most Frequent Number Following Key In an Array", "text": "You are given a 0-indexed integer array nums. You are also given an integer key, which is present in nums.\nFor every unique integer target in nums, count the number of times target immediately follows an occurrence of key in nums. In other words, count the number of indices i such that:\n0 <= i <= nums.length - 2,\nnums[i] == key and,\nnums[i + 1] == target.\nReturn the target with the maximum count. The test cases will be generated such that the target with maximum count is unique.", "canonical_solution": "def mostFrequent(nums, key):\n        cnt=0\n        res=[]\n        res1=0\n        a=0\n        for i in range(len(nums)-1):\n            if(nums[i]==key):\n                res.append(nums[i+1])\n        for i in res:\n            if(a<res.count(i)):\n                cnt=i\n            a=max(a,res.count(i))\n        return cnt", "entry_point": "mostFrequent", "test_list": ["assert mostFrequent(nums = [1,100,200,1,100], key = 1) == 100", "assert mostFrequent(nums = [2,2,2,2,3], key = 2) == 2"]}
{"Contest id": "282/2188", "text_name": "Minimum Time to Finish the Race", "text": "You are given a 0-indexed 2D integer array tires where tires[i] = [fi, ri] indicates that the ith tire can finish its xth successive lap in fi * ri(x-1) seconds.\nFor example, if fi = 3 and ri = 2, then the tire would finish its 1st lap in 3 seconds, its 2nd lap in 3 * 2 = 6 seconds, its 3rd lap in 3 * 22 = 12 seconds, etc.\nYou are also given an integer changeTime and an integer numLaps.\nThe race consists of numLaps laps and you may start the race with any tire. You have an unlimited supply of each tire and after every lap, you may change to any given tire (including the current tire type) if you wait changeTime seconds.\nReturn the minimum time to finish the race.", "canonical_solution": "def minimumFinishTime(tires, changeTime, numLaps):\n    minimum = []\n    total = [0] * len(tires)\n    while True:\n        for t in range(len(tires)):\n            total[t] += tires[t][0]\n            tires[t][0] *= tires[t][1]\n        minimum.append(min(total))\n        if minimum[-1] > changeTime + minimum[0]: break\n\n    dp = [float('inf')] * numLaps\n    for l in range(numLaps):\n        for pre in range(len(minimum)):\n            if l - pre - 1 < 0:\n                dp[l] = min(dp[l], minimum[pre])\n                break\n            dp[l] = min(dp[l], minimum[pre] + dp[l - pre - 1] + changeTime)\n    return dp[-1]", "entry_point": "minimumFinishTime", "test_list": ["assert minimumFinishTime(tires = [[2,3],[3,4]], changeTime = 5, numLaps = 4) == 21", "assert minimumFinishTime(tires = [[1,10],[2,2],[3,4]], changeTime = 6, numLaps = 5) == 25"]}
{"Contest id": "282/2187", "text_name": "Minimum Time to Complete Trips", "text": "You are given an array time where time[i] denotes the time taken by the ith bus to complete one trip.\nEach bus can make multiple trips successively; that is, the next trip can start immediately after completing the current trip. Also, each bus operates independently; that is, the trips of one bus do not influence the trips of any other bus.\nYou are also given an integer totalTrips, which denotes the number of trips all buses should make in total. Return the minimum time required for all buses to complete at least totalTrips trips.", "canonical_solution": "def minimumTime(time, totalTrips):\n        l, r = 0, time[0] * totalTrips\n        while l < r:\n            m = (l + r) // 2\n            if sum(m // t for t in time) < totalTrips:\n                l = m + 1\n            else:\n                r = m\n        return l", "entry_point": "minimumTime", "test_list": ["assert minimumTime(time = [1,2,3], totalTrips = 5) == 3", "assert minimumTime(time = [2], totalTrips = 1) == 2"]}
{"Contest id": "282/2186", "text_name": "Minimum Number of Steps to Make Two Strings Anagram II", "text": "You are given two strings s and t. In one step, you can append any character to either s or t.\nReturn the minimum number of steps to make s and t anagrams of each other.\nAn anagram of a string is a string that contains the same characters with a different (or the same) ordering.", "canonical_solution": "def minSteps(s, t):\n        from collections import Counter\n        a=Counter(s)\n        b=Counter(t)\n        c=(a-b)+(b-a)\n        \n        count=0\n        for i in c:\n            count+=c[i]\n        return count", "entry_point": "minSteps", "test_list": ["assert minSteps(s = \"leetcode\", t = \"coats\") == 7", "assert minSteps(s = \"night\", t = \"thing\") == 0"]}
{"Contest id": "282/2185", "text_name": "Counting Words With a Given Prefix", "text": "You are given an array of strings words and a string pref.\nReturn the number of strings in words that contain pref as a prefix.\nA prefix of a string s is any leading contiguous substring of s.", "canonical_solution": "def prefixCount(words, pref):\n    return sum([word.startswith(pref) for word in words])", "entry_point": "prefixCount", "test_list": ["assert prefixCount(words = [\"pay\",\"attention\",\"practice\",\"attend\"], pref = \"at\") == 2", "assert prefixCount(words = [\"leetcode\",\"win\",\"loops\",\"success\"], pref = \"code\") == 0"]}
{"Contest id": "281/2183", "text_name": "Count Array Pairs Divisible by K", "text": "Given a 0-indexed integer array nums of length n and an integer k, return the number of pairs (i, j) such that:\n0 <= i < j <= n - 1 and\nnums[i] * nums[j] is divisible by k.", "canonical_solution": "def coutPairs(A, k):\n        from collections import Counter\n        import math\n        cnt = Counter(math.gcd(a, k) for a in A)\n        res = 0\n        for a in cnt:\n            for b in cnt:\n                if a <= b and a * b % k == 0:\n                    res += cnt[a] * cnt[b] if a < b else cnt[a] * (cnt[a] - 1) // 2\n        return res", "entry_point": "countPairs", "test_list": ["assert coutPairs([1,2,3,4,5], 2) == 7", "assert coutPairs( [1,2,3,4], 5) == 0"]}
{"Contest id": "281/2182", "text_name": "Construct String With Repeat Limit", "text": "You are given a string s and an integer repeatLimit. Construct a new string repeatLimitedString using the characters of s such that no letter appears more than repeatLimit times in a row. You do not have to use all characters from s.\nReturn the lexicographically largest repeatLimitedString possible.\nA string a is lexicographically larger than a string b if in the first position where a and b differ, string a has a letter that appears later in the alphabet than the corresponding letter in b. If the first min(a.length, b.length) characters do not differ, then the longer string is the lexicographically larger one.", "canonical_solution": "def repeatLimitedString(s, repeatLimit):\n        from collections import Counter\n        table = Counter(s)\n        char_set = ['0', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's',\n                    't', 'u', 'v', 'w', 'x', 'y', 'z']\n        sorted_table = []\n        for i in range(26,-1,-1):\n            if char_set[i] in table:\n                sorted_table.append((char_set[i],table[char_set[i]]))\n\n        result = \"\"\n        n = len(sorted_table)\n        for i in range(n):\n            char, curr_freq = sorted_table[i]\n            index_to_take_from = i + 1\n            while curr_freq > repeatLimit:\n                result += char*repeatLimit\n                curr_freq -= repeatLimit\n                while index_to_take_from < n:\n                    ch_avail, freq_avail = sorted_table[index_to_take_from]\n                    if freq_avail == 0:\n                        index_to_take_from += 1\n                    else:\n                        result += ch_avail\n                        sorted_table[index_to_take_from] = (ch_avail,freq_avail-1)\n                        break\n                else:\n                    break\n            else:\n                result += char*curr_freq\n        return result", "entry_point": "repeatLimitedString", "test_list": ["assert repeatLimitedString(s = \"cczazcc\", repeatLimit = 3) == \"zzcccac\"", "assert repeatLimitedString(s = \"aababab\", repeatLimit = 2) == \"bbabaa\""]}
{"Contest id": "281/2180", "text_name": "Count Integers With Even Digit Sum", "text": "Given a positive integer num, return the number of positive integers less than or equal to num whose digit sums are even.\nThe digit sum of a positive integer is the sum of all its digits.", "canonical_solution": "def countEven(num):\n        return num // 2 if sum([int(k) for k in str(num)]) % 2 == 0 else (num - 1) // 2", "entry_point": "countEven", "test_list": ["assert countEven(num = 4) == 2", "assert countEven(num = 30) == 14"]}
{"Contest id": "Bi72/2179", "text_name": "Count Good Triplets in an Array", "text": "You are given two 0-indexed arrays nums1 and nums2 of length n, both of which are permutations of [0, 1, ..., n - 1].\nA good triplet is a set of 3 distinct values which are present in increasing order by position both in nums1 and nums2. In other words, if we consider pos1v as the index of the value v in nums1 and pos2v as the index of the value v in nums2, then a good triplet will be a set (x, y, z) where 0 <= x, y, z <= n - 1, such that pos1x < pos1y < pos1z and pos2x < pos2y < pos2z.\nReturn the total number of good triplets.", "canonical_solution": "def goodTriplets(nums1, nums2):\n        import bisect\n        n = len(nums1)\n        res = 0\n        m2 = [0] * n\n        q = []\n        for i in range(n):\n            m2[nums2[i]] = i           \n        for p1 in range(n):\n            p2 = m2[nums1[p1]] #\n            idx = bisect.bisect(q, p2) \n            q.insert(idx, p2)\n            before = idx\n            after = n-1 - p1 - p2 + before \n            res += before * after           \n        return res", "entry_point": "goodTriplets", "test_list": ["assert goodTriplets(nums1 = [2,0,1,3], nums2 = [0,1,2,3]) == 1", "assert goodTriplets(nums1 = [4,0,1,3,2], nums2 = [4,1,0,2,3]) == 4"]}
{"Contest id": "Bi72/2178", "text_name": "Maximum Split of Positive Even Integers", "text": "You are given an integer finalSum. Split it into a sum of a maximum number of unique positive even integers.\nFor example, given finalSum = 12, the following splits are valid (unique positive even integers summing up to finalSum): (12), (2 + 10), (2 + 4 + 6), and (4 + 8). Among them, (2 + 4 + 6) contains the maximum number of integers. Note that finalSum cannot be split into (2 + 2 + 4 + 4) as all the numbers should be unique.\nReturn a list of integers that represent a valid split containing a maximum number of integers. If no valid split exists for finalSum, return an empty list. You may return the integers in any order.", "canonical_solution": "def maximumEvenSplit(finalSum):\n        arr = []\n        if finalSum % 2 == 0: \n            a, i = finalSum \n            while i <= a: \n                arr.append(2*i) \n                a -= i \n                i += 1 \n            s = sum(arr)\n            arr[-1] += finalSum - s \n        return arr", "entry_point": "maximumEvenSplit", "test_list": ["assert maximumEvenSplit(finalSum = 12) == [2,4,6]", "assert maximumEvenSplit(finalSum = 7) == []", "assert maximumEvenSplit(finalSum = 28) == [6,8,2,12]"]}
{"Contest id": "Bi72/2177", "text_name": "Find Three Consecutive Integers That Sum to a Given Number", "text": "Given an integer num, return three consecutive integers (as a sorted array) that sum to num. If num cannot be expressed as the sum of three consecutive integers, return an empty array.", "canonical_solution": "def sumOfThree(num):\n        val=num//3\n        while val>=0 and 3*val==num:\n            return [val-1,val,val+1]\n        return []", "entry_point": "sumOfThree", "test_list": ["assert sumOfThree(num = 33) == [10,11,12]", "assert sumOfThree(num = 4) == []"]}
{"Contest id": "Bi72/2176", "text_name": "Count Equal and Divisible Pairs in an Array", "text": "Given a 0-indexed integer array nums of length n and an integer k, return the number of pairs (i, j) where 0 <= i < j < n, such that nums[i] == nums[j] and (i * j) is divisible by k.", "canonical_solution": "def countPairs(nums, k):\n        n=len(nums)\n        c=0\n        for i in range(0,n):\n            for j in range(i+1,n):\n                if nums[i]==nums[j] and ((i*j)%k==0):\n                    c+=1\n        return c   ", "entry_point": "countPairs", "test_list": ["assert countPairs(nums = [3,1,2,2,2,1,3], k = 2) == 4", "assert countPairs(nums = [1,2,3,4], k = 1) == 0"]}
{"Contest id": "280/2172", "text_name": "Maximum AND Sum of Array", "text": "You are given an integer array nums of length n and an integer numSlots such that 2 * numSlots >= n. There are numSlots slots numbered from 1 to numSlots.\nYou have to place all n integers into the slots such that each slot contains at most two numbers. The AND sum of a given placement is the sum of the bitwise AND of every number with its respective slot number.\nFor example, the AND sum of placing the numbers [1, 3] into slot 1 and [4, 6] into slot 2 is equal to (1 AND 1) + (3 AND 1) + (4 AND 2) + (6 AND 2) = 1 + 1 + 0 + 2 = 4.\nReturn the maximum possible AND sum of nums given numSlots slots.", "canonical_solution": "def maximumANDSum(A, ns):\n        from functools import lru_cache \n        @lru_cache(None)\n        def dp(i, mask):\n            res = 0\n            if i == len(A): return 0\n            for slot in range(1, ns + 1):\n                b = 3 ** (slot - 1)\n                if mask // b % 3 > 0:\n                    res = max(res, (A[i] & slot) + dp(i + 1, mask - b))\n            return res\n        \n        return dp(0, 3 ** ns - 1)", "entry_point": "maximumANDSum", "test_list": ["assert maximumANDSum([1,2,3,4,5,6], 3) == 9", "assert maximumANDSum([1,3,10,4,7,1],  9) == 24"]}
{"Contest id": "280/2171", "text_name": "Removing Minimum Number of Magic Beans", "text": "You are given an array of positive integers beans, where each integer represents the number of magic beans found in a particular magic bag.\nRemove any number of beans (possibly none) from each bag such that the number of beans in each remaining non-empty bag (still containing at least one bean) is equal. Once a bean has been removed from a bag, you are not allowed to return it to any of the bags.\nReturn the minimum number of magic beans that you have to remove.", "canonical_solution": "def minimumRemoval(beans):\n    beans.sort()\n    s = sum(beans)\n    l = len(beans)\n    res = float('inf')\n\n    for i in range(len(beans)):\n        res = min(res, s - l * beans[i])\n        l -= 1\n        \n    return res", "entry_point": "minimumRemoval", "test_list": ["assert minimumRemoval(beans = [4,1,6,5]) == 4", "assert minimumRemoval(beans = [2,10,3,2]) == 7"]}
{"Contest id": "280/2170", "text_name": "Minimum Operations to Make the Array Alternating", "text": "You are given a 0-indexed array nums consisting of n positive integers.\nThe array nums is called alternating if:\nnums[i - 2] == nums[i], where 2 <= i <= n - 1.\nnums[i - 1] != nums[i], where 1 <= i <= n - 1.\nIn one operation, you can choose an index i and change nums[i] into any positive integer.\nReturn the minimum number of operations required to make the array alternating.", "canonical_solution": "def minimumOperations(nums):\n        n = len(nums)\n        odd, even = defaultdict(int), defaultdict(int)\n        for i in range(n):\n            if i % 2 == 0:\n                even[nums[i]] += 1\n            else:\n                odd[nums[i]] += 1\n        topEven, secondEven = (None, 0), (None, 0)\n        for num in even:\n            if even[num] > topEven[1]:\n                topEven, secondEven = (num, even[num]), topEven\n            elif even[num] > secondEven[1]:\n                secondEven = (num, even[num])\n        topOdd, secondOdd = (None, 0), (None, 0)\n        for num in odd:\n            if odd[num] > topOdd[1]:\n                topOdd, secondOdd = (num, odd[num]), topOdd\n            elif odd[num] > secondOdd[1]:\n                secondOdd = (num, odd[num])\n        if topOdd[0] != topEven[0]:\n            return n - topOdd[1] - topEven[1]\n        else:\n            return n - max(secondOdd[1] + topEven[1], secondEven[1] + topOdd[1])", "entry_point": "minimumOperations", "test_list": ["assert minimumOperations(nums = [3,1,3,2,4,3]) == 3", "assert minimumOperations(nums = [1,2,2,2,2]) == 2"]}
{"Contest id": "280/2169", "text_name": "Count Operations to Obtain Zero", "text": "You are given two non-negative integers num1 and num2.\nIn one operation, if num1 >= num2, you must subtract num2 from num1, otherwise subtract num1 from num2.\nFor example, if num1 = 5 and num2 = 4, subtract num2 from num1, thus obtaining num1 = 1 and num2 = 4. However, if num1 = 4 and num2 = 5, after one operation, num1 = 4 and num2 = 1.\nReturn the number of operations required to make either num1 = 0 or num2 = 0.\n ", "canonical_solution": "def countOperations(num1, num2):\n        count = 0\n        while num1 != 0 and num2 != 0:\n            if num1 >= num2:\n                num1 -= num2\n            else:\n                num2 -= num1\n            count +=1\n        return count", "entry_point": "countOperations", "test_list": ["assert countOperations(num1 = 2, num2 = 3) == 3", "assert countOperations(num1 = 10, num2 = 10) == 1"]}
{"Contest id": "279/2167", "text_name": "Minimum Time to Remove All Cars Containing Illegal Goods", "text": "You are given a 0-indexed binary string s which represents a sequence of train cars. s[i] = '0' denotes that the ith car does not contain illegal goods and s[i] = '1' denotes that the ith car does contain illegal goods.\nAs the train conductor, you would like to get rid of all the cars containing illegal goods. You can do any of the following three operations any number of times:\nRemove a train car from the left end (i.e., remove s[0]) which takes 1 unit of time.\nRemove a train car from the right end (i.e., remove s[s.length - 1]) which takes 1 unit of time.\nRemove a train car from anywhere in the sequence which takes 2 units of time.\nReturn the minimum time to remove all the cars containing illegal goods.\nNote that an empty sequence of cars is considered to have no cars containing illegal goods.", "canonical_solution": "def minimumTime(s):\n        left, res, n = 0, len(s), len(s)\n        for i,c in enumerate(s):\n            left = min(left + (c == '1') * 2, i + 1)\n            res = min(res, left + n - 1 - i)\n        return res", "entry_point": "minimumTime", "test_list": ["assert minimumTime(s = \"1100101\") == 5", "assert minimumTime(s = \"0010\") == 2"]}
{"Contest id": "279/2165", "text_name": "Smallest Value of the Rearranged Number", "text": "You are given an integer num. Rearrange the digits of num such that its value is minimized and it does not contain any leading zeros.\nReturn the rearranged number with minimal value.\nNote that the sign of the number does not change after rearranging the digits.", "canonical_solution": "def smallestNumber(a):\n        s = sorted(str(abs(a)))\n        if a <= 0:\n            return -int(''.join(s[::-1]))\n        i = next(i for i,a in enumerate(s) if a > '0')\n        s[i], s[0] = s[0], s[i]\n        return int(''.join(s))", "entry_point": "smallestNumber", "test_list": ["assert smallestNumber(310) == 103", "assert smallestNumber(-7605) == -7650"]}
{"Contest id": "279/2164", "text_name": "Sort Even and Odd Indices Independently", "text": "You are given a 0-indexed integer array nums. Rearrange the values of nums according to the following rules:\nSort the values at odd indices of nums in non-increasing order.\nFor example, if nums = [4,1,2,3] before this step, it becomes [4,3,2,1] after. The values at odd indices 1 and 3 are sorted in non-increasing order.\nSort the values at even indices of nums in non-decreasing order.\nFor example, if nums = [4,1,2,3] before this step, it becomes [2,1,4,3] after. The values at even indices 0 and 2 are sorted in non-decreasing order.\nReturn the array formed after rearranging the values of nums.", "canonical_solution": "def sortEvenOdd(nums):\n        nums[::2], nums[1::2] = sorted(nums[::2]), sorted(nums[1::2], reverse=True)\n        return nums", "entry_point": "sortEvenOdd", "test_list": ["assert sortEvenOdd(nums = [4,1,2,3]) == [2,3,4,1]", "assert sortEvenOdd(nums = [2,1]) == [2,1]"]}
{"Contest id": "Bi71/2163", "text_name": "Minimum Difference in Sums After Removal of Elements", "text": "You are given a 0-indexed integer array nums consisting of 3 * n elements.\nYou are allowed to remove any subsequence of elements of size exactly n from nums. The remaining 2 * n elements will be divided into two equal parts:\nThe first n elements belonging to the first part and their sum is sumfirst.\nThe next n elements belonging to the second part and their sum is sumsecond.\nThe difference in sums of the two parts is denoted as sumfirst - sumsecond.\nFor example, if sumfirst = 3 and sumsecond = 2, their difference is 1.\nSimilarly, if sumfirst = 2 and sumsecond = 3, their difference is -1.\nReturn the minimum difference possible between the sums of the two parts after the removal of n elements.", "canonical_solution": "def minimumDifference(nums):\n    n = len(nums) // 3\n    first, second = list(), list()\n    sum_1, sum_2 = 0, 0\n\n    for i in range(n):\n        heapq.heappush(first, -nums[i])\n        sum_1 += nums[i]\n    for i in range(2 * n, 3 * n):\n        heapq.heappush(second, nums[i])\n        sum_2 += nums[i]\n\n    sum_first = [sum_1]\n    sum_second = [sum_2]\n\n    middle = nums[n : 2 * n]\n    for i in middle:\n        rep = heapq.heappushpop(first, -i)\n        sum_1 += i + rep\n        sum_first.append(sum_1)\n\n    for i in middle[::-1]:\n        rep = heapq.heappushpop(second, i)\n        sum_2 += i - rep\n        sum_second.append(sum_2)\n\n    return min(i - j for i, j in zip(sum_first, sum_second[::-1]))", "entry_point": "minimumDifference", "test_list": ["assert minimumDifference(nums = [3,1,2]) == -1", "assert minimumDifference(nums = [7,9,5,8,1,3]) == 1"]}
{"Contest id": "Bi71/2162", "text_name": "Minimum Cost to Set Cooking Time", "text": "A generic microwave supports cooking times for:\nat least 1 second.\nat most 99 minutes and 99 seconds.\nTo set the cooking time, you push at most four digits. The microwave normalizes what you push as four digits by prepending zeroes. It interprets the first two digits as the minutes and the last two digits as the seconds. It then adds them up as the cooking time. For example,\nYou push 9 5 4 (three digits). It is normalized as 0954 and interpreted as 9 minutes and 54 seconds.\nYou push 0 0 0 8 (four digits). It is interpreted as 0 minutes and 8 seconds.\nYou push 8 0 9 0. It is interpreted as 80 minutes and 90 seconds.\nYou push 8 1 3 0. It is interpreted as 81 minutes and 30 seconds.\nYou are given integers startAt, moveCost, pushCost, and targetSeconds. Initially, your finger is on the digit startAt. Moving the finger above any specific digit costs moveCost units of fatigue. Pushing the digit below the finger once costs pushCost units of fatigue.\nThere can be multiple ways to set the microwave to cook for targetSeconds seconds but you are interested in the way with the minimum cost.\nReturn the minimum cost to set targetSeconds seconds of cooking time.\nRemember that one minute consists of 60 seconds.", "canonical_solution": "def minCostSetTime(startAt, moveCost, pushCost, targetSeconds):\n        def count_cost(minutes, seconds):\n            time = f'{minutes // 10}{minutes % 10}{seconds // 10}{seconds % 10}'\n            time = time.lstrip('0')\n            t = [int(i) for i in time]\n            current = startAt\n            cost = 0\n            for i in t:\n                if i != current:\n                    current = i\n                    cost += moveCost\n                cost += pushCost\n            return cost\n        ans = float('inf')\n        for m in range(100):\n            for s in range(100):\n                if m * 60 + s == targetSeconds: \n                    ans = min(ans, count_cost(m, s))\n        return ans", "entry_point": "minCostSetTime", "test_list": ["assert minCostSetTime(startAt = 1, moveCost = 2, pushCost = 1, targetSeconds = 600) == 6", "assert minCostSetTime(startAt = 0, moveCost = 1, pushCost = 2, targetSeconds = 76) == 6"]}
{"Contest id": "Bi71/2161", "text_name": "Partition Array According to Given Pivot", "text": "You are given a 0-indexed integer array nums and an integer pivot. Rearrange nums such that the following conditions are satisfied:\nEvery element less than pivot appears before every element greater than pivot.\nEvery element equal to pivot appears in between the elements less than and greater than pivot.\nThe relative order of the elements less than pivot and the elements greater than pivot is maintained.\nMore formally, consider every pi, pj where pi is the new position of the ith element and pj is the new position of the jth element. For elements less than pivot, if i < j and nums[i] < pivot and nums[j] < pivot, then pi < pj. Similarly for elements greater than pivot, if i < j and nums[i] > pivot and nums[j] > pivot, then pi < pj.\nReturn nums after the rearrangement.", "canonical_solution": "def pivotArray(nums, p):\n        return [n for n in nums if n < p] + [n for n in nums if n == p] + [n for n in nums if n > p]", "entry_point": "pivotArray", "test_list": ["assert pivotArray([9,12,5,10,14,3,10],  10) == [9,5,3,10,10,12,14]", "assert pivotArray([-3,4,3,2], 2) == [-3,2,4,3]"]}
{"Contest id": "Bi71/2160", "text_name": "Minimum Sum of Four Digit Number After Splitting Digits", "text": "You are given a positive integer num consisting of exactly four digits. Split num into two new integers new1 and new2 by using the digits found in num. Leading zeros are allowed in new1 and new2, and all the digits found in num must be used.\nFor example, given num = 2932, you have the following digits: two 2's, one 9 and one 3. Some of the possible pairs [new1, new2] are [22, 93], [23, 92], [223, 9] and [2, 329].\nReturn the minimum possible sum of new1 and new2.", "canonical_solution": "def minimumSum(num):\n        num = sorted(str(num),reverse=True)\n        n = len(num)    \n        res = 0\n        even_iteration = False\n        position = 0\n        for i in range(n):\n            res += int(num[i])*(10**position)\n            if even_iteration:\n                position += 1\n                even_iteration = False\n            else:\n                even_iteration = True\n        return res", "entry_point": "minimumSum", "test_list": ["assert minimumSum(num = 2932) == 52", "assert minimumSum(num = 4009) == 13"]}
{"Contest id": "278/2157", "text_name": "Groups of Strings", "text": "You are given a 0-indexed array of strings words. Each string consists of lowercase English letters only. No letter occurs more than once in any string of words.\nTwo strings s1 and s2 are said to be connected if the set of letters of s2 can be obtained from the set of letters of s1 by any one of the following operations:\nAdding exactly one letter to the set of the letters of s1.\nDeleting exactly one letter from the set of the letters of s1.\nReplacing exactly one letter from the set of the letters of s1 with any letter, including itself.\nThe array words can be divided into one or more non-intersecting groups. A string belongs to a group if any one of the following is true:\nIt is connected to at least one other string of the group.\nIt is the only string present in the group.\nNote that the strings in words should be grouped in such a manner that a string belonging to a group cannot be connected to a string present in any other group. It can be proved that such an arrangement is always unique.\nReturn an array ans of size 2 where:\nans[0] is the maximum number of groups words can be divided into, and\nans[1] is the size of the largest group.", "canonical_solution": "def groupStrings(words):\n    import collections\n    n = len(words)\n    m = {}\n    f = []\n    def find(x):\n        if x != f[x]:\n            f[x] = find(f[x])\n        return f[x]\n    def connected(x):\n        for i in range(26):\n            yield x ^ (1 << i)\n            if (x & (1 << i)) > 0:\n                for j in range(26):\n                        if x & (1 << j) == 0:\n                            yield x ^ (1 << i) ^ (1 << j)\n    for i,w in enumerate(words):\n        x = sum(1 << (ord(c) - ord('a')) for c in w)\n        f.append(m.setdefault(x, i))\n        for y in connected(x):\n            if y in m:\n                i, j = find(m[x]), find(m[y])\n                if i != j:\n                    f[i] = j\n    count = collections.Counter(find(i) for i in range(n))\n    return [len(count), max(count.values())]", "entry_point": "groupStrings", "test_list": ["assert groupStrings(words = [\"a\",\"b\",\"ab\",\"cde\"]) == [2,3]", "assert groupStrings(words = [\"a\",\"ab\",\"abc\"]) == [1,3]"]}
{"Contest id": "278/2156", "text_name": "Find Substring With Given Hash Value", "text": "The hash of a 0-indexed string s of length k, given integers p and m, is computed using the following function:\nhash(s, p, m) = (val(s[0]) * p0 + val(s[1]) * p1 + ... + val(s[k-1]) * pk-1) mod m.\nWhere val(s[i]) represents the index of s[i] in the alphabet from val('a') = 1 to val('z') = 26.\nYou are given a string s and the integers power, modulo, k, and hashValue. Return sub, the first substring of s of length k such that hash(sub, power, modulo) == hashValue.\nThe test cases will be generated such that an answer always exists.\nA substring is a contiguous non-empty sequence of characters within a string.", "canonical_solution": "def subStrHash(s, p, m, k, hashValue):\n    def val(c):\n        return ord(c) - ord('a') + 1\n    res = n = len(s)\n    pk = pow(p,k,m)\n    cur = 0\n    for i in range(n - 1, -1, -1):\n        cur = (cur * p + val(s[i])) % m\n        if i + k < n:\n            cur = (cur - val(s[i + k]) * pk) % m\n        if cur == hashValue:\n            res = i\n    return s[res: res + k]", "entry_point": "subStrHash", "test_list": ["assert subStrHash(\"leetcode\",7,20,2,0)==\"ee\"", "assert subStrHash(\"fbxzaad\",31,100,3,32)==\"fbx\""]}
{"Contest id": "278/2155", "text_name": "All Divisions With the Highest Score of a Binary Array", "text": "You are given a 0-indexed binary array nums of length n. nums can be divided at index i (where 0 <= i <= n) into two arrays (possibly empty) numsleft and numsright:\nnumsleft has all the elements of nums between index 0 and i - 1 (inclusive), while numsright has all the elements of nums between index i and n - 1 (inclusive).\nIf i == 0, numsleft is empty, while numsright has all the elements of nums.\nIf i == n, numsleft has all the elements of nums, while numsright is empty.\nThe division score of an index i is the sum of the number of 0's in numsleft and the number of 1's in numsright.\nReturn all distinct indices that have the highest possible division score. You may return the answer in any order.", "canonical_solution": "def maxScoreIndices(nums):\n        zeroFromLeft = [0] * (len(nums) + 1)\n        oneFromRight = [0] * (len(nums) + 1)\n        for i in range(len(nums)):\n            if nums[i] == 0:\n                zeroFromLeft[i + 1] = zeroFromLeft[i] + 1\n            else:\n                zeroFromLeft[i + 1] = zeroFromLeft[i]\n                \n        for i in range(len(nums))[::-1]:\n            if nums[i] == 1:\n                oneFromRight[i] = oneFromRight[i + 1] + 1\n            else:\n                oneFromRight[i] = oneFromRight[i + 1]\n        \n        allSum = [0] * (len(nums) + 1)\n        currentMax = 0\n        res = []\n        for i in range(len(nums) + 1):\n            allSum[i] = oneFromRight[i] + zeroFromLeft[i]\n            if allSum[i] > currentMax:\n                res = []\n                currentMax = allSum[i]\n            if allSum[i] == currentMax:\n                res.append(i)\n        return res", "entry_point": "maxScoreIndices", "test_list": ["assert maxScoreIndices(nums = [0,0,1,0]) == [2,4]", "assert maxScoreIndices(nums = [0,0,0]) == [3]", "assert maxScoreIndices(nums = [1,1]) == [0]"]}
{"Contest id": "278/2154", "text_name": "Keep Multiplying Found Values by Two", "text": "You are given an array of integers nums. You are also given an integer original which is the first number that needs to be searched for in nums.\nYou then do the following steps:\nIf original is found in nums, multiply it by two (i.e., set original = 2 * original).\nOtherwise, stop the process.\nRepeat this process with the new number as long as you keep finding the number.\nReturn the final value of original.", "canonical_solution": "def findFinalValue(nums, original):\n        nums = set(nums)\n        while original in nums:\n            original *= 2\n        return original", "entry_point": "findFinalValue", "test_list": ["assert findFinalValue(nums = [5,3,6,1,12], original = 3) == 24", "assert findFinalValue(nums = [2,7,9], original = 4) == 4"]}
{"Contest id": "277/2151", "text_name": "Maximum Good People Based on Statements", "text": "There are two types of persons:\nThe good person: The person who always tells the truth.\nThe bad person: The person who might tell the truth and might lie.\nYou are given a 0-indexed 2D integer array statements of size n x n that represents the statements made by n people about each other. More specifically, statements[i][j] could be one of the following:\n0 which represents a statement made by person i that person j is a bad person.\n1 which represents a statement made by person i that person j is a good person.\n2 represents that no statement is made by person i about person j.\nAdditionally, no person ever makes a statement about themselves. Formally, we have that statements[i][i] = 2 for all 0 <= i < n.\nReturn the maximum number of people who can be good based on the statements made by the n people.", "canonical_solution": "def maximumGood(A):\n    n, ans = len(A), 0\n        \n    def check(perm):\n        for i in range(n):\n            if perm[i] == '0': continue\n            for j in range(n):\n                if A[i][j] == 2: continue\n                if (A[i][j] == 1 and perm[j] == '0') or (A[i][j] == 0 and perm[j] == '1'): \n                    return False\n        return True\n\n    for num in range(1 << n, 1 << (n + 1)):\n        permutation = bin(num)[3:]\n        if check(permutation): \n            ans = max(ans, permutation.count('1'))\n    return ans", "entry_point": "maximumGood", "test_list": ["assert maximumGood([[2,1,2],[1,2,2],[2,0,2]]) == 2", "assert maximumGood([[2,0],[0,2]]) == 1"]}
{"Contest id": "277/2150", "text_name": "Find All Lonely Numbers in the Array", "text": "You are given an integer array nums. A number x is lonely when it appears only once, and no adjacent numbers (i.e. x + 1 and x - 1) appear in the array.\nReturn all lonely numbers in nums. You may return the answer in any order.", "canonical_solution": "from collections import defaultdict\ndef findLonely(nums):\n        check = defaultdict(int)\n        for i in nums:\n            check[i] += 1\n        ans = []\n        for i in nums:\n            if ((i==0) or (i>=1 and check[i-1]==0)):\n                if check[i]==1 and check[i+1]==0:\n                    ans.append(i)\n        return ans", "entry_point": "findLonely", "test_list": ["assert findLonely(nums = [10,6,5,8]) == [10,8]", "assert findLonely(nums = [1,3,5,3]) == [1,5]"]}
{"Contest id": "277/2149", "text_name": "Rearrange Array Elements by Sign", "text": "You are given a 0-indexed integer array nums of even length consisting of an equal number of positive and negative integers.\nYou should rearrange the elements of nums such that the modified array follows the given conditions:\nEvery consecutive pair of integers have opposite signs.\nFor all integers with the same sign, the order in which they were present in nums is preserved.\nThe rearranged array begins with a positive integer.\nReturn the modified array after rearranging the elements to satisfy the aforementioned conditions.", "canonical_solution": "def rearrangeArray(nums):\n    a,b=list(filter(lambda x: x<0,nums)),list(filter(lambda x: x>0,nums))\n    result=[]\n    for i in range(len(a)):\n        result.append(b[i])\n        result.append(a[i])\n    return (result)", "entry_point": "rearrangeArray", "test_list": ["assert rearrangeArray(nums = [3,1,-2,-5,2,-4]) == [3,-2,1,-5,2,-4]", "assert rearrangeArray(nums = [-1,1]) == [1,-1]"]}
{"Contest id": "277/2148", "text_name": "Count Elements With Strictly Smaller and Greater Elements", "text": "Given an integer array nums, return the number of elements that have both a strictly smaller and a strictly greater element appear in nums.", "canonical_solution": "def countElements(nums):\n        M = max(nums)\n        m = min(nums)\n        return sum(1 for i in nums if m<i<M)", "entry_point": "countElements", "test_list": ["assert countElements(nums = [11,7,2,15]) == 2", "assert countElements(nums = [-3,3,3,90]) == 2"]}
{"Contest id": "Bi70/2147", "text_name": "Number of Ways to Divide a Long Corridor", "text": "Along a long library corridor, there is a line of seats and decorative plants. You are given a 0-indexed string corridor of length n consisting of letters 'S' and 'P' where each 'S' represents a seat and each 'P' represents a plant.\nOne room divider has already been installed to the left of index 0, and another to the right of index n - 1. Additional room dividers can be installed. For each position between indices i - 1 and i (1 <= i <= n - 1), at most one divider can be installed.\nDivide the corridor into non-overlapping sections, where each section has exactly two seats with any number of plants. There may be multiple ways to perform the division. Two ways are different if there is a position with a room divider installed in the first way but not in the second way.\nReturn the number of ways to divide the corridor. Since the answer may be very large, return it modulo 109 + 7. If there is no way, return 0.", "canonical_solution": "def numberOfWays(corridor):\n        seatsToLeft = 0        \n        consecutivePlants = 0\n        ans = 1           \n        for c in corridor:\n            if c == \"P\":\n                if seatsToLeft and seatsToLeft % 2 == 0:\n                    consecutivePlants += 1\n            else:\n                seatsToLeft += 1            \n                if seatsToLeft % 2 == 1 and consecutivePlants != 0:\n                    ans *= (consecutivePlants+1)\n                    consecutivePlants = 0              \n        return ans%(10**9+7) if (seatsToLeft and seatsToLeft%2 == 0) else 0", "entry_point": "numberOfWays", "test_list": ["assert numberOfWays(corridor = \"PPSPSP\") == 1", "assert numberOfWays(corridor = \"S\") == 0", "assert numberOfWays(corridor = \"SSPPSPS\") == 3"]}
{"Contest id": "Bi70/2146", "text_name": "K Highest Ranked Items Within a Price Range", "text": "You are given a 0-indexed 2D integer array grid of size m x n that represents a map of the items in a shop. The integers in the grid represent the following:\n0 represents a wall that you cannot pass through.\n1 represents an empty cell that you can freely move to and from.\nAll other positive integers represent the price of an item in that cell. You may also freely move to and from these item cells.\nIt takes 1 step to travel between adjacent grid cells.\nYou are also given integer arrays pricing and start where pricing = [low, high] and start = [row, col] indicates that you start at the position (row, col) and are interested only in items with a price in the range of [low, high] (inclusive). You are further given an integer k.\nYou are interested in the positions of the k highest-ranked items whose prices are within the given price range. The rank is determined by the first of these criteria that is different:\nDistance, defined as the length of the shortest path from the start (shorter distance has a higher rank).\nPrice (lower price has a higher rank, but it must be in the price range).\nThe row number (smaller row number has a higher rank).\nThe column number (smaller column number has a higher rank).\nReturn the k highest-ranked items within the price range sorted by their rank (highest to lowest). If there are fewer than k reachable items within the price range, return all of them.\n ", "canonical_solution": "import heapq\ndef highestRankedKItems(grid, pricing, start, k):\n        row, col = len(grid), len(grid[0])\n        q = [(0, grid[start[0]][start[1]], start[0], start[1])]\n        visit = set()\n        result = []\n        while q:\n            dis, price, x, y = heapq.heappop(q)\n            if (x, y) in visit:\n                continue\n            visit.add((x, y))\n            if price != 1 and price >= pricing[0] and price <= pricing[1]:\n                result.append([x, y])\n            if len(result) == k:\n                return result\n            for dx, dy in (0, 1), (0, -1), (1, 0), (-1, 0):\n                new_x, new_y = x + dx, y + dy\n                if 0 <= new_x < row and 0 <= new_y < col and (new_x, new_y) not in visit:\n                    temp = grid[new_x][new_y]\n                    if temp == 0:\n                        continue\n                    elif temp == 1:\n                        heapq.heappush(q, (dis + 1, 1, new_x, new_y))\n                    else:\n                        heapq.heappush(q, (dis + 1, temp, new_x, new_y))\n        \n        return result", "entry_point": "highestRankedKItems", "test_list": ["assert highestRankedKItems(grid = [[1,2,0,1],[1,3,0,1],[0,2,5,1]], pricing = [2,5], start = [0,0], k = 3) == [[0,1],[1,1],[2,1]]", "assert highestRankedKItems([[1,2,0,1],[1,3,3,1],[0,2,5,1]], pricing = [2,3], start = [2,3], k = 2) == [[2,1],[1,2]]", "assert highestRankedKItems(grid = [[1,1,1],[0,0,1],[2,3,4]], pricing = [2,3], start = [0,0], k = 3) == [[2,1],[2,0]]"]}
{"Contest id": "Bi70/2145", "text_name": "Count the Hidden Sequences", "text": "You are given a 0-indexed array of n integers differences, which describes the differences between each pair of consecutive integers of a hidden sequence of length (n + 1). More formally, call the hidden sequence hidden, then we have that differences[i] = hidden[i + 1] - hidden[i].\nYou are further given two integers lower and upper that describe the inclusive range of values [lower, upper] that the hidden sequence can contain.\nFor example, given differences = [1, -3, 4], lower = 1, upper = 6, the hidden sequence is a sequence of length 4 whose elements are in between 1 and 6 (inclusive).\n[3, 4, 1, 5] and [4, 5, 2, 6] are possible hidden sequences.\n[5, 6, 3, 7] is not possible since it contains an element greater than 6.\n[1, 2, 3, 4] is not possible since the differences are not correct.\nReturn the number of possible hidden sequences there are. If there are no possible sequences, return 0.", "canonical_solution": "from itertools import accumulate\ndef numberOfArrays(differences, lower, upper):\n           A = list(accumulate(differences, initial = 0))\n           return max(0, (upper - lower) - (max(A) - min(A)) + 1)", "entry_point": "numberOfArrays", "test_list": ["assert numberOfArrays(differences = [1,-3,4], lower = 1, upper = 6) == 2", "assert numberOfArrays(differences = [3,-4,5,1,-2], lower = -4, upper = 5) == 4", "assert numberOfArrays(differences = [4,-7,2], lower = 3, upper = 6) == 0"]}
{"Contest id": "Bi70/2144", "text_name": "Minimum Cost of Buying Candies With Discount", "text": "A shop is selling candies at a discount. For every two candies sold, the shop gives a third candy for free.\nThe customer can choose any candy to take away for free as long as the cost of the chosen candy is less than or equal to the minimum cost of the two candies bought.\nFor example, if there are 4 candies with costs 1, 2, 3, and 4, and the customer buys candies with costs 2 and 3, they can take the candy with cost 1 for free, but not the candy with cost 4.\nGiven a 0-indexed integer array cost, where cost[i] denotes the cost of the ith candy, return the minimum cost of buying all the candies.", "canonical_solution": "def minimumCost(cost):\n            return sum(a for i,a in enumerate(sorted(cost)) if (len(cost) - i) % 3)", "entry_point": "minimumCost", "test_list": ["assert minimumCost(cost = [1,2,3]) == 5", "assert minimumCost(cost = [6,5,7,9,2,2]) == 23", "assert minimumCost(cost = [5,5]) == 10"]}
{"Contest id": "276/2141", "text_name": "Maximum Running Time of N Computers", "text": "You have n computers. You are given the integer n and a 0-indexed integer array batteries where the ith battery can run a computer for batteries[i] minutes. You are interested in running all n computers simultaneously using the given batteries.\nInitially, you can insert at most one battery into each computer. After that and at any integer time moment, you can remove a battery from a computer and insert another battery any number of times. The inserted battery can be a totally new battery or a battery from another computer. You may assume that the removing and inserting processes take no time.\nNote that the batteries cannot be recharged.\nReturn the maximum number of minutes you can run all the n computers simultaneously.", "canonical_solution": "def maxRunTime(n, batteries):\n        left=0\n        right=sum(batteries)//n+1\n        def check(time):\n            return sum(min(time,b) for b in batteries)>=n*time\n\n        while left<=right:\n            mid=(left+right)//2\n            if check(mid):\n                left=mid+1\n\n            else:\n                right=mid-1\n\n        return right                    ", "entry_point": "maxRunTime", "test_list": ["assert maxRunTime(n = 2, batteries = [3,3,3]) == 4", "assert maxRunTime(n = 2, batteries = [1,1,1,1]) == 2"]}
{"Contest id": "276/2140", "text_name": "Solving Questions With Brainpower", "text": "You are given a 0-indexed 2D integer array questions where questions[i] = [pointsi, brainpoweri].\nThe array describes the questions of an exam, where you have to process the questions in order (i.e., starting from question 0) and make a decision whether to solve or skip each question. Solving question i will earn you pointsi points but you will be unable to solve each of the next brainpoweri questions. If you skip question i, you get to make the decision on the next question.\nFor example, given questions = [[3, 2], [4, 3], [4, 4], [2, 5]]:\nIf question 0 is solved, you will earn 3 points but you will be unable to solve questions 1 and 2.\nIf instead, question 0 is skipped and question 1 is solved, you will earn 4 points but you will be unable to solve questions 2 and 3.\nReturn the maximum points you can earn for the exam", "canonical_solution": "def mostPoints(questions):\n    def max_score(i: int) -> int:\n        return i < len(questions) and max(questions[i][0] + max_score(i + 1 + questions[i][1]), max_score(i + 1))\n    return max_score(0)", "entry_point": "mostPoints", "test_list": ["assert mostPoints(questions = [[3,2],[4,3],[4,4],[2,5]]) == 5", "assert mostPoints(questions = [[1,1],[2,2],[3,3],[4,4],[5,5]]) == 7"]}
{"Contest id": "276/2139", "text_name": "Minimum Moves to Reach Target Score", "text": "You are playing a game with integers. You start with the integer 1 and you want to reach the integer target.\nIn one move, you can either:\nIncrement the current integer by one (i.e., x = x + 1).\nDouble the current integer (i.e., x = 2 * x).\nYou can use the increment operation any number of times, however, you can only use the double operation at most maxDoubles times.\nGiven the two integers target and maxDoubles, return the minimum number of moves needed to reach target starting with 1.", "canonical_solution": "def minMoves(target, maxDoubles):\n        cnt=0\n        while target>1 and maxDoubles>0:\n            if target%2==0:\n                target=target//2\n                maxDoubles-=1\n            else:\n                target-=1\n            cnt+=1\n        if target>1:cnt+=target-1\n        return cnt", "entry_point": "minMoves", "test_list": ["assert minMoves(target = 5, maxDoubles = 0) == 4", "assert minMoves(target = 19, maxDoubles = 2) == 7", "assert minMoves(target = 10, maxDoubles = 4) == 4"]}
{"Contest id": "276/2138", "text_name": "Divide a String Into Groups of Size k", "text": "A string s can be partitioned into groups of size k using the following procedure:\nThe first group consists of the first k characters of the string, the second group consists of the next k characters of the string, and so on. Each character can be a part of exactly one group.\nFor the last group, if the string does not have k characters remaining, a character fill is used to complete the group.\nNote that the partition is done so that after removing the fill character from the last group (if it exists) and concatenating all the groups in order, the resultant string should be s.\nGiven the string s, the size of each group k and the character fill, return a string array denoting the composition of every group s has been divided into, using the above procedure.", "canonical_solution": "def divideString(s, k, fill):\n        l=[]\n        if len(s)%k!=0:\n            s+=fill*(k-len(s)%k)\n        for i in range(0,len(s),k):\n            l.append(s[i:i+k])\n        return l", "entry_point": "divideString", "test_list": ["assert divideString(s = \"abcdefghi\", k = 3, fill = \"x\") == [\"abc\",\"def\",\"ghi\"]", "assert divideString(s = \"abcdefghij\", k = 3, fill = \"x\") == [\"abc\",\"def\",\"ghi\",\"jxx\"]"]}
{"Contest id": "275/2136", "text_name": "Earliest Possible Day of Full Bloom", "text": "You have n flower seeds. Every seed must be planted first before it can begin to grow, then bloom. Planting a seed takes time and so does the growth of a seed. You are given two 0-indexed integer arrays plantTime and growTime, of length n each:\nplantTime[i] is the number of full days it takes you to plant the ith seed. Every day, you can work on planting exactly one seed. You do not have to work on planting the same seed on consecutive days, but the planting of a seed is not complete until you have worked plantTime[i] days on planting it in total.\ngrowTime[i] is the number of full days it takes the ith seed to grow after being completely planted. After the last day of its growth, the flower blooms and stays bloomed forever.\nFrom the beginning of day 0, you can plant the seeds in any order.\nReturn the earliest possible day where all seeds are blooming.", "canonical_solution": "def earliestFullBloom(plantTime, growTime):\n        comb=[(plantTime[i],growTime[i]) for i in range(len(plantTime))]\n        mx,passed_days=0,0\n        comb.sort(key=lambda x:(-x[1],x[0]))\n        for i in range(len(plantTime)):\n            mx=max(mx,(passed_days+comb[i][0]+comb[i][1]))\n            passed_days+=comb[i][0]\n        return mx", "entry_point": "earliestFullBloom", "test_list": ["assert earliestFullBloom(plantTime = [1,4,3], growTime = [2,3,1]) == 9", "assert earliestFullBloom(plantTime = [1,2,3,2], growTime = [2,1,2,1]) == 9", "assert earliestFullBloom(plantTime = [1], growTime = [1]) == 2"]}
{"Contest id": "275/2135", "text_name": "Count Words Obtained After Adding a Letter", "text": "You are given two 0-indexed arrays of strings startWords and targetWords. Each string consists of lowercase English letters only.\nFor each string in targetWords, check if it is possible to choose a string from startWords and perform a conversion operation on it to be equal to that from targetWords.\nThe conversion operation is described in the following two steps:\nAppend any lowercase letter that is not present in the string to its end.\nFor example, if the string is \"abc\", the letters 'd', 'e', or 'y' can be added to it, but not 'a'. If 'd' is added, the resulting string will be \"abcd\".\nRearrange the letters of the new string in any arbitrary order.\nFor example, \"abcd\" can be rearranged to \"acbd\", \"bacd\", \"cbda\", and so on. Note that it can also be rearranged to \"abcd\" itself.\nReturn the number of strings in targetWords that can be obtained by performing the operations on any string of startWords.\nNote that you will only be verifying if the string in targetWords can be obtained from a string in startWords by performing the operations. The strings in startWords do not actually change during this process.", "canonical_solution": "def wordCount(startWords, targetWords):\n        cnt = 0\n        for target in targetWords:\n            for start in startWords:\n                if len(target) - len(start) == 1 and len(set(list(target)) - set(list(start))) == 1:\n                    cnt += 1\n                    break\n        return cnt", "entry_point": "wordCount", "test_list": ["assert wordCount(startWords = [\"ant\",\"act\",\"tack\"], targetWords = [\"tack\",\"act\",\"acti\"]) == 2", "assert wordCount(startWords = [\"ab\",\"a\"], targetWords = [\"abc\",\"abcd\"]) == 1"]}
{"Contest id": "275/2134", "text_name": "Minimum Swaps to Group All 1's Together II", "text": "A swap is defined as taking two distinct positions in an array and swapping the values in them.\nA circular array is defined as an array where we consider the first element and the last element to be adjacent.\nGiven a binary circular array nums, return the minimum number of swaps required to group all 1's present in the array together at any location.", "canonical_solution": "def minSwaps(nums):\n    width = sum(num == 1 for num in nums)\n    nums += nums\n    res = width\n    curr_zeros = sum(num == 0 for num in nums[:width])     \n    for i in range(width, len(nums)):\n        curr_zeros -= (nums[i - width] == 0)\n        curr_zeros += (nums[i] == 0)\n        res = min(res, curr_zeros)\n    return res", "entry_point": "minSwaps", "test_list": ["assert minSwaps(nums = [0,1,0,1,1,0,0]) == 1", "assert minSwaps(nums = [0,1,1,1,0,0,1,1,0]) == 2", "assert minSwaps(nums = [1,1,0,0,1]) == 0"]}
{"Contest id": "275/2133", "text_name": "Check if Every Row and Column Contains All Numbers", "text": "An n x n matrix is valid if every row and every column contains all the integers from 1 to n (inclusive).\nGiven an n x n integer matrix matrix, return true if the matrix is valid. Otherwise, return false.", "canonical_solution": "def checkValid(matrix):\n        set_ = set(range(1,len(matrix)+1))\n        return all(set_ == set(x) for x in matrix+list(zip(*matrix)))", "entry_point": "checkValid", "test_list": ["assert checkValid(matrix = [[1,2,3],[3,1,2],[2,3,1]]) == True", "assert checkValid(matrix = [[1,1,1],[1,2,3],[1,2,3]]) == False"]}
{"Contest id": "Bi69/2132", "text_name": "Stamping the Grid", "text": "You are given an m x n binary matrix grid where each cell is either 0 (empty) or 1 (occupied).\nYou are then given stamps of size stampHeight x stampWidth. We want to fit the stamps such that they follow the given restrictions and requirements:\nCover all the empty cells.\nDo not cover any of the occupied cells.\nWe can put as many stamps as we want.\nStamps can overlap with each other.\nStamps are not allowed to be rotated.\nStamps must stay completely inside the grid.\nReturn true if it is possible to fit the stamps while following the given restrictions and requirements. Otherwise, return false.", "canonical_solution": "def possibleToStamp(M, h, w):\n        m, n = len(M), len(M[0])\n        A = [[0] * (n + 1) for _ in range(m + 1)]\n        good = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                A[i + 1][j + 1] = A[i + 1][j] + A[i][j + 1] - A[i][j] + (1 - M[i][j])\n                if i + 1 >= h and j + 1 >= w:\n                    x, y = i + 1 - h, j + 1 -w\n                    if A[i + 1][j + 1] - A[x][j + 1] - A[i + 1][y] + A[x][y] == w * h:\n                        good[i][j] += 1\n        B = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(m):\n            for j in range(n):\n                B[i + 1][j + 1] = B[i + 1][j] + B[i][j + 1] - B[i][j] + good[i][j]\n        for i in range(m):\n            for j in range(n):\n                x, y = min(i + h, m), min(j + w, n)\n                if M[i][j] == 0 and B[x][y] - B[i][y] - B[x][j] + B[i][j] == 0:\n                    return False\n        return True", "entry_point": "possibleToStamp", "test_list": ["assert possibleToStamp( [[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0]], 4, 3) == True", "assert possibleToStamp([[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]], 2, 2 ) == False"]}
{"Contest id": "Bi69/2131", "text_name": "Longest Palindrome by Concatenating Two Letter Words", "text": "You are given an array of strings words. Each element of words consists of two lowercase English letters.\nCreate the longest possible palindrome by selecting some elements from words and concatenating them in any order. Each element can be selected at most once.\nReturn the length of the longest palindrome that you can create. If it is impossible to create any palindrome, return 0.\nA palindrome is a string that reads the same forward and backward.", "canonical_solution": "def longestPalindrome(words):\n        dc=defaultdict(lambda:0)\n        for a in words:\n            dc[a]+=1\n        count=0\n        palindromswords=0\n        inmiddle=0\n        wds=set(words)\n        for a in wds:\n            if(a==a[::-1]):\n                if(dc[a]%2==1):\n                    inmiddle=1\n                palindromswords+=(dc[a]//2)*2\n            elif(dc[a[::-1]]>0):\n                count+=(2*(min(dc[a],dc[a[::-1]])))\n                dc[a]=0\n        return (palindromswords+count+inmiddle)*2", "entry_point": "longestPalindrome", "test_list": ["assert longestPalindrome(words = [\"lc\",\"cl\",\"gg\"]) == 6", "assert longestPalindrome(words = [\"ab\",\"ty\",\"yt\",\"lc\",\"cl\",\"ab\"]) == 8", "assert longestPalindrome(words = [\"cc\",\"ll\",\"xx\"]) == 2"]}
{"Contest id": "Bi69/2129", "text_name": "Capitalize the Title", "text": "You are given a string title consisting of one or more words separated by a single space, where each word consists of English letters. Capitalize the string by changing the capitalization of each word such that:\nIf the length of the word is 1 or 2 letters, change all letters to lowercase.\nOtherwise, change the first letter to uppercase and the remaining letters to lowercase.\nReturn the capitalized title.", "canonical_solution": "def capitalizeTitle(title):\n    return \" \".join([word.lower() if len(word) < 3 else word.title() for word in title.split()])", "entry_point": "capitalizeTitle", "test_list": ["assert capitalizeTitle(title = \"capiTalIze tHe titLe\") == \"Capitalize The Title\"", "assert capitalizeTitle(title = \"First leTTeR of EACH Word\") ==  \"First Letter of Each Word\"", "assert capitalizeTitle(title = \"i lOve leetcode\") == \"i Love Leetcode\""]}
{"Contest id": "274/2127", "text_name": "Maximum Employees to Be Invited to a Meeting", "text": "A company is organizing a meeting and has a list of n employees, waiting to be invited. They have arranged for a large circular table, capable of seating any number of employees.\nThe employees are numbered from 0 to n - 1. Each employee has a favorite person and they will attend the meeting only if they can sit next to their favorite person at the table. The favorite person of an employee is not themself.\nGiven a 0-indexed integer array favorite, where favorite[i] denotes the favorite person of the ith employee, return the maximum number of employees that can be invited to the meeting.", "canonical_solution": "def maximumInvitations(favorite):\n    import collections\n    pre = collections.defaultdict(list)\n    for i, j in enumerate(favorite):\n        pre[j].append(i)\n    seen, max_cycle_length, sequence_length = set(), 0, 0\n    for node in range(len(favorite)):  # for each island, there is one and only one cycle\n        if node in seen: continue\n        path = [node]\n        while favorite[path[-1]] not in seen:\n            seen.add(favorite[path[-1]])\n            path.append(favorite[path[-1]])\n        if favorite[path[-1]] not in path: continue\n        cycle_length = len(path) - path.index(favorite[path[-1]])\n        if cycle_length == 2: \n            max_sub_len = [0, 0]\n            cycle = path[-2:]\n            pre[cycle[0]].remove(cycle[1])\n            pre[cycle[1]].remove(cycle[0])\n            for k in [0, 1]: \n                dq = collections.deque([(cycle[k], 0)])\n                while dq:\n                    i, depth = dq.pop()  # DFS\n                    # i, depth = dq.popleft()  # BFS\n                    if i in pre:\n                        for j in pre[i]:\n                            dq.append((j, depth + 1))\n                            seen.add(j)\n                    else:\n                        max_sub_len[k] = max(max_sub_len[k], depth) \n            sequence_length += 2 + sum(max_sub_len)\n        else: \n            max_cycle_length = max(max_cycle_length, cycle_length)\n    return max(max_cycle_length, sequence_length)", "entry_point": "maximumInvitations", "test_list": ["assert maximumInvitations(favorite = [2,2,1,2]) == 3", "assert maximumInvitations(favorite = [1,2,0]) == 3"]}
{"Contest id": "274/2126", "text_name": "Destroying Asteroids", "text": "You are given an integer mass, which represents the original mass of a planet. You are further given an integer array asteroids, where asteroids[i] is the mass of the ith asteroid.\nYou can arrange for the planet to collide with the asteroids in any arbitrary order. If the mass of the planet is greater than or equal to the mass of the asteroid, the asteroid is destroyed and the planet gains the mass of the asteroid. Otherwise, the planet is destroyed.\nReturn true if all asteroids can be destroyed. Otherwise, return false.", "canonical_solution": "def asteroidsDestroyed(mass, asteroids):\n        asteroids.sort()\n        for asteroid in asteroids:\n            if mass >= asteroid:\n                mass += asteroid\n            else:\n                return False\n        return True", "entry_point": "asteroidsDestroyed", "test_list": ["assert asteroidsDestroyed(mass = 10, asteroids = [3,9,19,5,21]) == True", "assert asteroidsDestroyed(mass = 5, asteroids = [4,9,23,4]) == False"]}
{"Contest id": "274/2125", "text_name": "Number of Laser Beams in a Bank", "text": "Anti-theft security devices are activated inside a bank. You are given a 0-indexed binary string array bank representing the floor plan of the bank, which is an m x n 2D matrix. bank[i] represents the ith row, consisting of '0's and '1's. '0' means the cell is empty, while'1' means the cell has a security device.\nThere is one laser beam between any two security devices if both conditions are met:\nThe two devices are located on two different rows: r1 and r2, where r1 < r2.\nFor each row i where r1 < i < r2, there are no security devices in the ith row.\nLaser beams are independent, i.e., one beam does not interfere nor join with another.\nReturn the total number of laser beams in the bank.", "canonical_solution": "def numberOfBeams(bank):\n        if len(bank) < 2:\n            return 0\n        solution = 0\n        beacons_in_prev_row = 0\n        beacons_in_current_row = 0\n        for row in bank:\n            beacons_in_current_row = 0\n            for c in row:\n                if c == '1':\n                    beacons_in_current_row += 1\n            solution += beacons_in_current_row * beacons_in_prev_row\n            beacons_in_prev_row = beacons_in_current_row or beacons_in_prev_row\n        return solution", "entry_point": "numberOfBeams", "test_list": ["assert numberOfBeams(bank = [\"011001\",\"000000\",\"010100\",\"001000\"]) == 8", "assert numberOfBeams(bank = [\"000\",\"111\",\"000\"]) == 0"]}
{"Contest id": "274/2124", "text_name": "Check if All A's Appears Before All B's", "text": "Given a string s consisting of only the characters 'a' and 'b', return true if every 'a' appears before every 'b' in the string. Otherwise, return false.", "canonical_solution": "def checkString(s):\n    return (''.join(sorted(list(s))))==s\n    def checkString(s):\n        return \"ba\" not in s", "entry_point": "checkString", "test_list": ["assert checkString(s = \"aaabbb\") == True", "assert checkString(s = \"abab\") == False", "assert checkString(s = \"bbb\") == True"]}